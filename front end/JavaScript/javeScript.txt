JavaScript
  一.类型
    JS 语言的每一个值都属于某一种数据类型。JS 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合，运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JS 代码运行过程中产生的数据，都具有运行时类型。
      1.Undefined
      2.Null
      3.Boolean
      4.String
      5.Number
      6.Symbol
      7.Object
    有的编程规范要求用void 0代表undefined，为什么？
      Undefined表示未定义，它的类型只有一个值，就是undefined。任何变量在赋值前都是Undefined类型，值为undefined，一般情况下可以用undefined（就是名为undefined的这个全局变量）来表达这个值，或者void运算来把任意一个表达式变成undefined值。建议使用 void 0 或 void(0) 来获取undefined值。在实际编程时，一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。
      
    Undefined 和 Null
      Undefined 和 Null 有一定的表意区别，Null表示的是："定义了但是为空"。Null的类型也只有一个值，就是null，与undefined不同null是JS关键字，在任何程序中，都可以使用null关键字来获取null值。
 
    String
      字符串是否有最大长度？
        String用于表示文本数据，String 有最大长度是 2^53 - 1，String的意义并非字符串，而是字符串的UTF16编码，字符串的操作charAt、charCodeAt、length等方法针对的都是UTF16编码。所以字符串最大长度，是受字符串的编码长度影响
        JS 中的字符串是永远无法变更的，所以字符串具有值类型的特征
        JS 字符串把每个UTF16单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，应该格外小心。

    Number
      JS 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。
      JS 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JS 为了表达几个额外的语言场景（比如，不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：
        · NaN：NaN规定和参考双精度浮点数的表达方式，1位符号位+52位尾数位共53位，指数固定为 2^e–1 并去掉±∞两个值，NaN其实是 2^53-2 个特殊数字的合集（2^53-2 = 9007199254740990 ）所以，为什么NaN !== NaN，因为它不是一个值，而是一群值
        · Infinity，无穷大
        · -Infinity，负无穷大
      JS中有 +0 和 -0，在加法类运算中没有区别，但是在除法的场合需要特别留意，除以 -0 会得到 负无穷大,除以 +0 会得到 正无穷大，而区分 +0 或 -0 的方式是1/x是Infinity还是-Infinity
      根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，也就是 console.log(0.1 + 0.2 == 0.3)，这里输出的是 false，说明两边不相等，这是浮点运算的特点（number类型运算都要将其转化为二进制，将二进制运算，运算的结果再转化为十进制，因为number是64位双精度，小数部分只有52位，但0.1转化成为二进制是无限循环的，所以四舍五入了这里就发生了精度丢失，0.1的二进制和0.2的二进制相加需要保留有效数字，所以又发生了精度丢失，所以结果为0.30000000000000004）。浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。
      正确的比较方法是使用JS提供的最小精度值： console.log(Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON); 检查等式两侧的绝对值是否小于绝对精度，才是正确比较浮点数的方法。
      Number.EPSILON：ES6 在Number对象上面，新增一个极小的常量 Number.EPSILON。Number.EPSILON = 2.220446049250313e-16。根据规范，它表示 1 与大于 1 的最小浮点数之间的差。对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。Number.EPSILON实际上是 JS 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。引入一个这么小的量的目的，在于为浮点数计算，Number.EPSILON可以用来设置“能够接受的误差范围”。
    
    Symbol
      Symbol是ES6中引入的新类型，他是一切非字符串的对象key的集合，在ES6规范中，整个对象系统被用Symbol重塑。
      Symbol可以具有字符串类型的描述，但是即使描述相同，Symbol也不相等。
      创建Symbeol的方式是使用全局的Symbol函数。例如：var symbol = Symbol("my symbol");
      Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用。当需要对一个对象进行迭代时（比如开始用于一个for..of循环中），它的Symbol.iterator方法都会在不传参情况下被调用，返回的迭代器用于获取要迭代的值。

    Object
      Object 是JS中最复杂的类型，也是JS的核心机制之一，Object表示对象，在JS中对象的定义是“属性的集合”。属性分为 数据属性 和 访问器属性 ，两者都是key-value结构，key可以是字符串或Symbol类型。
      提到对象，必须提到一个概念：类，JS中的类仅仅是运行时对象的一个私有属性，JS中无法自定义类型
      JS中的几个基本类型，都在对象中有一个“亲戚”：1.String 2.Boolean 3.Number 4.Symbol
      在JS中，3 和 New Number(3) 是两个完全不同的值，3 是Number类型，New Number(3) 是对象类型
      Number、Boolean、String，三个构造器是两用的，当跟 New 搭配时，他们产生对象，当单独使用时，表示强制类型转换。Symbol比较特殊，直接用 New 调用它会抛出错误，但它依然是Symbol对象的构造器

      JS在语言设计上试图模糊基本类型与对象之间的关系，在日常代码中可以把对象的方法放在基本类型上使用，如：console.log("ab".charAt(0));
      甚至在原型上添加方法都可以应用于基本类型， “.”运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。
      
  二.类型转换
    JS是弱类型语言，所以类型转换发生的非常频繁，大部分我们熟悉的运算都会先进行类型转换。
      StringToNumber
        字符串到数字的类型转换，存在一个语法结构，类型转换支持二进制，八进制，十进制，十六进制，此外，JS支持的字符串语法还包括，正负号科学计数法，可以使用大写或小写的e来表示，如：Number("1e3") = 1 * 10^3 = 1000，Number(-1e-2) = -1 * 10^-2 = -0.01
        需要注意，parseInt 和 parseFloat并不使用这个转换，所以支持的语法跟Number不同。parseInt，在不传入第二个参数时，如果第一个参数是Number类型，会自动识别进制（不可靠），而且会遇到非数字直接返回非数字前面的数字，如果第一个参数是字符串，只能识别十六进制，也不支持科学计数法，所以需要传入第二个参数。parseFloat直接把原字符串作为十进制解析，它不会引入任何其他进制。多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。
      
      NumberToString
        在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串则是使用科学计数法表示的。是为了保证产生的字符串不会过长。具体算法，看JS语言标准。

      装箱转换
        每一种基本类型Number、String、Boolean、Symbol在对象中都有对应的类，所谓装箱转换就是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。
        全局的Symbol函数无法使用new来调用，但可以使用装箱机制来得到一个Symbol对象，可以利用函数的.call()方法来强迫装箱。
          var symbolObject = (function(){ return this; }).call(Symbol("a"));
          console.log(typeof symbolObject); //object
          console.log(symbolObject instanceof Symbol); //true
          console.log(symbolObject.constructor == Symbol); //true
        装箱机制会频繁产生临时对象，在对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换
        使用内置的Object函数，可以JS代码中显式的调用装箱能力
          var symbolObject = Object(Symbol("a"));
          console.log(typeof symbolObject); //object
          console.log(symbolObject instanceof Symbol); //true
          // 原型链 symbolObject.__proto__  =>  Symbol.__proto__ => Object
          console.log(symbolObject.constructor == Symbol); //true
        每一类装箱对象都有私有的Class属性，这些属性可以用Object.prototype.toString获取
          var symbolObject = Object(Symbol("0"));
          var symbolT      = Symbol("b");
          console.log(Object.prototype.toString.call(symbolObject)); // [Object Symbol]
          console.log(Object.prototype.toString.call(symbolT)); // [Object Symbol]
          console.log(typeof symbolObject); // Object
          console.log(typeof symbolT); // Symbol
        在JS中没有任何方法可以改变私有的Class属性，所以，Object.prototype.toString 可以准确识别对象对应的基本类型的方法，它比 instanceof 更准确，需要注意.call()会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型
        instanceof 运算符用来判断一个构造函数的prototype属性(或对象的__proto__)所指向的对象是否存在另外一个要检测对象的原型链上

      拆箱转换
        在JS标准中，规定了 toPrimitive 函数，它是对象类型到基本类型的转换（即拆箱转换）。对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则，通过拆箱转换，把对象先转为基本类型，再从基本类型转为对应的String或Number。所以，拆箱转换会先尝试调用 valueOf 和 toString 来获取拆箱后的基本类型，如果 typeOf 和 toString 都不存在或没有返回基本类型，则会报类型错误TypeError。

    规范类型
      1. List 和 Record： 用于描述函数传参过程。
      2. Set：主要用于解释字符集等。
      3. Completion Record：用于描述异常、跳出等语句执行过程。
      4. Reference：用于描述对象属性访问、delete 等。
      5. Property Descriptor：用于描述对象的属性。
      6. Lexical Environment 和 Environment Record：用于描述变量和作用域。
      7. Data Block：用于描述二进制数据。
    
  三.面向对象
    JS标准对于 基于对象 的定义：语言和宿主的基础设施由对象来提供，并且JS程序即是一系列互相通讯的对象的集合。
    1. JS对象的特征
      (1) 对象具有唯一标识性：即使两个完全相同的对象，也并非同一个对象
        一般而言，对象的唯一标识性，是用内存地址来体现的，对象具有唯一标识的内存地址，所以具有唯一的标识
      (2) 对象有状态：对象具有状态，同一个对象可能处于不同状态下
      (3) 对象有行为：即对象的状态可能因为它的行为产生变迁
        在JS中将状态和行为统一抽象为属性，JS中将函数设计成一种特殊对象，所以，JS中的状态和行为都能用属性来抽象。

      JS对象独有的特色：对象具有高度的动态性，因为JS赋予了使用者在运行时为对象添改状态和行为的能力。
      为了提高抽象能力：JS的属性被设计成比其他语言更复杂的形式，它提供了 数据属性 和 访问器属性（getter/setter） 两类。

    2.JS对象的两类属性
      对于JS，属性并非简单的名称和值，JS用一组特征（attribute）来描述属性（property）
      (1)数据属性
        特征
        1. value：就是属性的值
        2. writable：决定属性能否被赋值
        3. enumerable：决定for in能否枚举该属性
        4. configurable：决定该属性能否被删除或改变特征值

        我们通常用于定义属性的代码会产生数据属性，其中的writable、enumerable、configurable都默认为true。可以使用内置函数Object.getOwnPropertyDescriptor来查看。

      (2)访问器属性（getter/setter）
        特征
        1. getter：描述获取该属性值时调用的函数，并返回函数的结果，默认值为undefined
        2. setter：描述该属性被赋值时调用的函数，默认值为undefined
        3. enumerable：决定for in能否枚举该属性
        4. configurable：决定该属性能否被删除或者改变特征值
        
        访问器属性使得属性在读和写时执行代码，它允许使用者在写和读时得到完全不同的值，它可以视为函数的一种语法糖。
        使用Object.definePropetry，可以 改变特征值 或 定义访问器属性，但是不能同时指定 访问器属性和值或可写属性writable
        实际上JS对象的运行时是一个“具有高度动态性的属性集合”，属性以 字符串 或 Symbol 为 key，以 数据属性特征值 和 访问器属性特征值 为value。对象是一个属性的索引结构（索引结构是一种常见的数据结构，可以把它理解为一个能够以较快速度用key来查找value的字典），能够以Symbol为属性名是JS对象的一个特色
      
    3. JS的原形
      如果抛开JS用于模拟Java的复杂语法设施（如 new、Function Object、函数的prototype属性等），可以用两条概括：
        (1) 如果所有对象都有私有字段[[prototype]]（即__proto__），就是对象的原形
          注释：
            [[prototype]]是对象的私有属性，而prototype是只有函数才有的属性，[[prototype]]是JS的非标准但许多浏览器实现的属性，即__proto__，Object.[[prototype]] === Object.getPrototypeOf(someObject) === someObject.__proto__（Object.[[prototype]]浏览器不支持这样操作，Object.getPrototypeOf()是ES6的方法）
            所有的JS对象都有一个指向它的原形对象的内部链接[[prototype]]，但只有函数才有prototype这个属性
        (2) 读一个属性，如果对象没有，则会继续访问对象的原形，直到原形为空或找到为止
      
      ES6以来，JS提供了一系列的内置函数，以便更为直接的访问操纵原形
        ① Object.create：根据指定的原形创建新对象，原形可以是null
        ② Object.getPrototypeOf：获得一个对象的原形
        ③ Object.setPrototypeOf：设置一个对象的原形

      早期版本中的类与原型
        在早期版本的JS中，“类”的定义是一个私有属性[[class]]，语言标准为内置类型如：Number、String、Date等指定了[[class]]属性，以表示它们的类。唯一可以访问[[class]]属性的方式是 Object.prototype.toString
        从ES5开始，[[class]]私有属性被Symbol.toStringTag替代，Object.prototype.toString的意义从命名上不再跟class相关，甚至可以自定义。
        使用 Symbol.toStringTag 来自定义 Object.prototype.toString
          var o = { [Symbol.toStringTag] : "MY"} // 创建一个对象，给它唯一的属性Symbol.toStringTag
          console.log(o + "") // [object MY]     使用 + 来触发Object.prototype.toString的调用，发现这个属性最终对Object.prototype.toSting 的结果产生了影响
        
        new 运算接受一个构造器和一组调用参数，实际上做了3件事
          (1) 以构造器的prototype属性为原形，创建新对象
          (2) 将 this 和 调用参数 传给构造器，执行
          (3) 如果构造器返回的是对象，则返回，否则返回第一步创建的对象
        new 客观上提供了两种添加属性的方式，一：在构造器中添加属性，二：在构造器的prototype中添加属性

      ES6中的类
        ES6 中引入了 class 关键字，并且在标准中删除了所有[[class]]相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JS 的官方编程范式。在任何场景下都优先使用ES6的语法来定义类，使function回归原本的函数定义。
        在现有的类语法中，getter/setter 和 method 是兼容性最好的。
        我们通过 get/set 关键字来创建 getter/setter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。
        类的写法实际上也是由原型运行时来承载的，逻辑上 JS 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。
        类通过extends关键字提供了继承能力，使用 extends 关键字会自动设置了 constructor，并且会自动调用父类的构造函数。使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用函数来模拟对象。
      

  四.JS的对象
    1.对象的分类
      (1) 宿主对象（host Object）： 由 JS 宿主环境提供的对象，它们的行为完全由宿主环境决定
        在浏览器环境中，全局对象是window，window上又有很多属性，如：document，window上的属性，一部分来自JS语言，另一部分来自浏览器环境。JS标准中规定了全局对象属性，W3C的各种标准中规定了Window对象的其他属性。宿主对象也分 固有 和 用户可创建，比如：document.createElement就可以创建一些DOM对象

      (2) 内置对象（Buitt-in Object）：由 JS 语言提供的对象
        固有对象（intrinsic Object）：由标准规定，随着JS运行时创建而自动创建的对象实例。
          固有对象在JS代码执行前就被创建出来了，它们通常扮演着类似基础库的角色。ECMA标准提供了150+个固有对象，可以通过 https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects
          
        原生对象（Native Object）：可以由用户通过Array、RegExp等内置构造器或特殊语法创建的对象。
          JS中能够通过语言本身的构造器创建的对象称为原生对象。JS标准中提供了39个构造器。通过这些构造器，可以用 new 运算创建新的对象，所以把这些对象称为原生对象。这些构造器几乎所有的能力都无法用纯JS代码来实现，也无法用 class/extends 语法来继承。因为这些构造器创建的对象多数使用了私有字段，例如：Error: [[ErrorData]] Boolean: [[BooleanData]] Number[[NumberData]]，这些字段使得原型继承方法无法正
          常工作，所以，这些原生对象都是为了特定能力或性能，而设计出来的特权对象。

        普通对象（Ordinary Object）：由{}语法、Object构造器或 class 关键字定义类创建的对象，它能够被原形继承。

      用对象来模拟函数和构造器：函数对象和构造器对象
        在JS中，还有一个看待对象的不同视角，就是用对象来模拟函数和构造器。JS为这一类对象预留了私有字段机制，并规定了抽象的函数对象和构造器对象的概念。
          函数对象：  具有私有字段[[call]]的对象。      构造器函数：具有私有字段[[construct]]的对象
        JS 用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其他语言的函数一样被调用、传参。任何宿主只要提供了“具有私有字段[[call]]的对象”，就可以被 JS 函数调用语法支持。
            // [[call]]私有字段必须是一个引擎中定义的函数，需要接受 this 值和 调用参数，并且会产生域的切换。
        任何对象只要实现了[[call]]，它就是一个函数对象，可以作为函数去调用。如果它实现了[[construct]]，它就是一个构造器对象，可以作为构造器被调用。
        用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出的效果并不相同。对于宿主和内置对象来说，它们实现[[call]](作为函数被调用) 和 [[construct]](作为构造函数被调用)不总是一致的。例如：内置函数 Date 在作为构造器被调用时产生新的对象，作为函数时，则产生字符串。
        而在宿主环境中，提供的 Image 构造器，则根本不允许作为函数被调用。基本函数(String，Boolean，Number)，它们的构造器被当做函数调用时，则产生类型转换的效果。
        在 ES6 之后 => 语法创建的函数仅仅是函数，它们无法被当做构造器使用。
        使用 function 语法或者 Function 构造器创建的对象来说，[[call]]和[[construct]]行为总是类似的。
          function f(){ return 1; }  var v = f(); // 作为函数使用  var o = new f(); // 把f作为构造器调用
        它们[[construct]]的执行过程如下：
          1. 以 Object.prototype 作为原形创建一个新对象
          2. 以新对象为 this，执行函数的[[call]]
          3. 如果[[call]]的返回值是对象，那么返回这个对象，否则，返回第一步创建的新对象
        这样的规则造成了个现象，如果构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度可以实现“私有”。
          function cls(){this.a = 100; return { getValue: () => this.a }}
          var o = new cls;
          o.getValue(); // 100   a在外面永远无法访问到

      特殊行为的对象
        在固有对象和原生对象中，有一些对象的行为跟正常行为的对象有很大的区别。
        它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同
          1. Array：Array 的 length 属性根据最大的下标自动发生变化。
          2. Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。
          3. String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。
          4. Arguments：arguments 的非负整数型下标属性跟对应的变量联动。
          5. 模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import。
          6. 类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。
          7. bind 后的 function：跟原来的函数相关联。


  五.JS的执行
    (1) Promise、async/await
      1. 宏观和微观任务
        使用 JSC引擎 的术语，把宿主发起的任务称为宏观任务，把JS引擎发起的任务称为微观任务。
        JS引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为 事件循环。
        事件的循环原理，在底层的C/C++代码中，这个事件循环是一个跑在独立事件中的循环，用伪代码来表示：
          while(true) { r = wait(); execute(r); }
        整个循环都是反复的 “等待 - 执行”，每次的执行过程，都是一个宏观任务。在宏观任务中，JS的 Promise 还会产生异步代码，JS必须保证这些异步任务在同一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列。
        有了宏观任务和微观任务机制，我们就可以实现 JS 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等 宿主API，则会添加宏观任务。
      
      2. Promise
        Promise 是JS语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行io、等待或者其他异步操作的函数，不返回真实结果，而是返回一个“承诺”，函数的调用方可以选择在合适的时机，选择等待这个承诺实现(通过Promise的 then 方法的回调)。
        Promise有三个状态：
          1.pending[待定] 初始状态
          2.fulfilled[实现] 操作成功
          3.rejected[失败] 操作失败
        当Promise状态发生改变，就会触发then()里的响应函数处理后续步骤，Promise状态一旦改变，不会再变
          new Promise( function(resolve, reject){ resolve('成功'); }).then( res => { console.log(res)}, err => {console.log(err)} );
          resolve的作用：
            将 Promise对象的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
          reject的作用：
            将 Promise对象的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去
        Promise的then回调是一个异步的执行过程。
        如何分析异步执行的顺序：
          1. 首先分析有多少个宏任务
          2. 在每个宏任务中，分析有多少个微任务
          3. 根据调用顺序确定宏任务中微任务的执行顺序
          4. 根据宏任务的触发规则和调用次序，确定宏任务的执行顺序
          5. 确定整个顺序

      3. async/await
        async/await是ES6新加入的特性，它提供了for、if等代码结构来编写异步的方式。它的运行基础是 Promise。
        async 函数必定返回 Promise，所有返回 Promise 的函数都可以认为是异步函数。
        async 函数是一种特殊语法，特征是在 function 关键字前加上 async 关键字，就定义了 async 函数，可以在其中使用 await 来等待一个 Promise。
        async 函数是可以嵌套的。
        
    (2) JS的执行
      1.闭包
        闭包翻译自英文单词 closure，在计算机领域有三个完全不同的意义：
          编译原理：它是处理语法产生式的一个步骤
          计算几何：它表示包裹片面点集的凸多边形（翻译作凸包）
          编程语言：它表示一种函数
        闭包是一个绑定了执行环境的函数，闭包与普通函数的区别是，它携带了执行的环境
        JS中对应的闭包组成部分
          环境部分
            环境：函数的词法环境（执行上下文的一部分）
            标识符列表：函数中用到的未声明的变量
          表达式部分
            函数体
        JS 中的函完全符合闭包的定义，它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，他的表达式部分就是函数体。
        
      2.执行上下文：执行的基础设施
        JS函数的复杂性主要来自于它携带的“环境部分”，JS中与闭包“环境部分”相对应的术语是“词法环境”，但是JS中需要处理this、变量声明等等一系列复杂的语法，所以，在JS的设计中，词法环境只是 JS 执行上下文 的一部分。
        JS 标准把一段代码（包括函数），执行所需的所有信息定义为： "执行上下文"
        执行上下文 在ES2018中的定义：
          · lexical environment：  词法环境，当获取变量或者 this 值时使用。
          · variable environment： 变量环境，当声明变量时使用。
          · code evaluation state：用于恢复代码执行位置。
          · Funtion：执行的任务是函数时使用，表示正在被执行的函数。
          · ScriptOrModule：执行的任务是脚本或模块时使用，表示正在被执行的代码。
          · Realm：使用的基础库和内置对象实例。
          · Generator：仅生成器上下文有这个属性，表示当前生成器

        var b = {}; let c = 1; this.a = 2;
        想要正确的执行这段代码，需要知道：
          1. var 把 b 声明到哪里
          2. b 表示哪个变量
          3. b 的原型是哪个对象
          4. let 把 c 声明到哪里
          4. this 指向哪个对象
        这些信息需要执行上下文来给出，这段代码出现在不同的位置，关联到不同的上下文，同样的代码会产生不一样的行为。

      3.var的声明与赋值
        var 声明作用域函数执行的作用域，也就是，var会穿透for、if等语句。
        在只有 var，没有 let 的旧 JS 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的作用范围。
        由于语法规定了 function 开头的是函数声明，所以想要让函数变成函数表达式，必须加点东西。
        使用 void 关键字
          void function(){ var a; }();
        这有效的避免了语法问题，同时语义上 void 运算表示忽略后面表达式的值，变成undefined，IIFE不关心函数的返回值，所以语义也比较合理。
        void是运算符，其后跟一个表达式，无论 void 后的表达式是什么都会执行，void 操作符都会返回 undefined。
        void在JS中一般有3种作用：
          ① 返回 undefined
            undefined在JS中不是保留字，可以定义undefined这个变量，使用全局的undefined可能会被局部变量覆盖，所以使用 void 0来代替undefined。
          ② 执行无用操作
            如果有a链接，不希望点击的时候跳转，不写又会刷新，通常使用：<a href="javascript:void(0)">来执行空操作
          ③ void 执行后面的表达式，例如：var a = 1; void a++; // a = 2;

      4.let
        let是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确地梳理和规定。
        为了实现let，JS 在运行时引入了块级作用域。
        以下语句会使 let 使用产生作用域：
          · for
          · if
          · switch
          · try/catch/finally

      5.Realm
        在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm。
        在 ES2016 之前的版本中，标准中甚少提及{}的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。
        Realm 中包含一组完整的内置对象，而且是复制关系。
        对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。

      6.函数的种类
        (1) 普通函数：用 function 关键字定义的函数
          function foo(){ //code }
        (2) 箭头函数：用 => 运算符定义的函数
          const foo = () => { //code }
        (3) 方法：在 class 中定义的函数
          class C { foo() { //code } }
        (4) 生成器函数：使用 function* 定义的函数
          function* foo(){ //code }
        (5) 类：用 class 定义的类，也是函数
          class foo { construct() { //code } }
        (6) 异步函数：普通函数、箭头函数和生成器函数前加上 async 关键字
          async function foo(){}
          const function foo = async () => {}
          async function foo*() {}
        
      7.this 关键字
        行为
          this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。
          普通函数的this值由“调用它所使用的引用”决定，原因在于：获取函数的表达式时，它实际上返回的不是函数本身，而是一个Reference类型。
          Reference类型由两部分组成：一个对象和一个属性值
          当做一些算术运算（或其他运算时），Reference类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete等操作，都需要用到Reference类型中的对象。
          调用函数时使用的引用，决定了函数执行时刻的 this 值
          而箭头函数，不论什么引用来调用它，都不影响它的this值，它会继承外层函数调用的 this 绑定(无论 this 绑定到什么)
          生成器函数、异步生成器函数 和 异步普通函数跟普通函数 行为是一致的，异步箭头函数与箭头函数 行为是一致的。

        机制
          函数能够引用定义时的变量，函数也能记忆定义时的this，因此，函数内部必定有一个机制来保存这些信息。
          在 JS 标准中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]
          当一个函数执行时，会创建一条新的执行环境记录，记录外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]，这就是 切换上下文
          JS 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。当函数调用时，会入栈一个新的执行上下文，调用结束后，执行上下文被出栈。
          而 this 是一个更为复杂的机制，JS标准定义了 [[thisMode]] 私有属性，[[thisMode]]私有属性有三个取值
            · lexical：表示从上下文中找this，这对应了箭头函数
            · global： 表示当this为undefined时，取全局对象，这对应了普通函数
            · strict： 当严格模式时使用，this严格按照调用时传入的值，可能为 null 或 undefined
          方法的行为跟普通函数有差异，就是因为 class 设计成了默认按 strict 模式执行

          函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来记录新纪录的[[ThisBindingStatus]]私有属性
          代码执行遇到 this 时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有 this 的执行环境记录时获取 this 的值

        操作this的内置函数
          Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的 this 值。
            function foo(a, b, c){ console.log(this); console.log(a, b, c); }
            foo.call({}, 1, 2, 3);
            foo.apply({}, [4, 5, 6]);
          
          Function.prototype.bind 可以生成一个绑定过的新函数，这个新函数的 this 值被指定为bind()的第一个参数
            function foo(a, b, c){ console.log(this); console.log(a, b, c); }
            foo.bind({}, 1, 2, 3)();
          
          call、apply、bind 用于不接受this的函数类型，如：箭头函数、class 都不会报错，这时，它们无法实现改变 this 的能力，但可以实现传参。 

      8.语句
        语句是任何编程语言的基础结构，与JS对象一样 JS语句 有“看起来很像其他语言，但其实一点都不一样”的特点
        JS语句存在嵌套关系，所以执行过程主要在树形结构上进行，树形结构的每一个节点执行后产生Completion Record类型，根据语句结构和Completion Record，JS实现了各种分支和跳出逻辑。

        Completion类型
          JS语句执行的完成状态，可以用一个标准类型来表示：Completion Record 类型
          Completion Record 表示一个语句执行完之后的结果，它有三个字段:
            · [[type]]   表示完成的类型，有 break continue return throw 和 normal 几种类型
            · [[value]]  表示语句的返回值，如果语句没有，则是empty
            · [[target]] 表示语句的目标，通常是一个JS标签
          JS 正是依靠语句的 Completion Record 类型，方才可以在语句的复杂嵌套结构中，实现各种控制。

        普通语句
          在JS中，不带控制能力的语句称为 普通语句。有下面几种：
            · 声明类语句
              var声明
              const声明
              let声明
              函数声明
              类声明
            · 表达式语句
            · 空语句
            · debugger语句
          这些语句在执行时，从前到后顺序执行（先忽略var和函数声明的预处理机制），没有任何分支或重复执行逻辑。
          普通语句执行后，会得到[[type]]为normal的Completion Record，JS引擎遇到这样的Completion Record，会继续执行下一条语句。
          这些语句中只有表示式语句会产生[[value]]

        语句块
          语句块就是一组用大括号括起来的语句，它是一种语句的复合结构，可以嵌套。语句块内部语句的Completion Record的[[type]]如果不为normal，会打断语句块后续的语句执行。
          在语句块中插入一条return语句，产生了一个非normal记录，那么整个语句块会成为非normal。这个结构就保证了非normal的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。

        控制型语句
          控制型语句带if、switch关键字，它们会对不同类型的Completion Record产生反应。
          控制语句分为两部分：
            1. 对其内部造成影响，如：if、switch、while/for、try
            2. 对外部造成影响，如：return、break、continue、throw
          这两类的配合，会产生控制代码执行顺序和执行逻辑的效果。

        带标签的语句
          任何JS语句都是可以加标签的，在语句前加冒号即可：
            firstStatement: var a = 1;
          大部分时候，这个东西相当于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的target相配合，用于跳出多层循环。

      
    (3) JS文法
      文法是编译原理中对语言的写法的一种规定，一般来说，文法分为 词法 和 语法 两种。
      词法规定了语言的最小语义单位：token，可以翻译为“标记”或“词”。
      从字符到词是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或正则表达式来进行。
      
      1. JS词法
        JS源代码中的输入分类：
          · WhiteSpace     空白字符
          · LineTerminator 换行符
          · Comment        注释
          · Token          词
            IdentifierName  标识符名称，例如：变量名、关键字
            Punctuator      符号，使用的运算符和大括号等符号
            NumericLiteral  数字直接量，就是写的数字
            StringLiteral   字符串直接量，就是用单引号或双引号引起来的直接量
            Template        字符串模板，用反引号 ` 括起来的直接量 

        这个设计比较符合通用的编程语言设计方式，但JS有一些特殊的地方：
          1. 除法与正则表达式冲突问题。JS不但支持除法运算符“/”和“/=”，还支持用斜杠括起来的正则表达式“/abc/”。
             这时候，对于词法分析来说，其实是没有办法处理的，所以，JS的处理方案是定义两组词法，然后靠词法分析传一个标志给词法分析器，让它来决定使用哪一套词法。

          2. 字符串模板   
             `hello，${name}`
             理论上，“${}”内部可以放任何JS表达式代码，而这些代码是以“}”结尾的，也就是说，这部分词法不允许出现“}”运算符。
             是否允许“}”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，
               · InputElementDiv;
               · InputElementRegExp;
               · InputElementRegExpOrTemplateTail;
               · InputElementTemplateTail
          为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“}”从token中单独抽出来，用词上，也从Token改为CommonToken。

          对于一般语言的词法分析过程来说，都会丢弃除了Token之外的输入，但是对于JS来说，不太一样，换行符和注释还会影响词法分析过程，所以要实现JS的解释器，词法分析和语法分析非常麻烦，需要来回传递信息。

        空白符号 WhiteSpace
          JS可以支持18种空白符号，但在ASCII编码内，只有五种可用：
            · <HT>（或称<TAB>）是U+0009，是缩进TAB符，也就是字符串中写的\t
            · <VT>是U+000B，也就是垂直方向的TAB符\v，这个字符很少用
            · <FF>是U+000C，Form Feed分页符，字符串直接量中写作\f，现在很少有打印源程序的事情发生了，所以这个字符在JS源代码中很少用到
            · <SP>是U+0020，就是普通的空格
            · <NBSP>是U+00A0，非断行空格，它是SP的一个变体，在文字排版中，可以避免因为空格，在此处发生断行，其他方面与空格完全一样。HTML中，&nbsp;生成的就是它
            · <ZWNBSP>（旧称<BOM>）是U+FEFF，这是ES5新加入的空白符，是Unicode中的零宽非断行空格，在以UTF编码格式的文件中，常常在文件首插入一个额外的U+FEFF，解析UTF文件的程序可以根据U+FEFF的表示方式猜测文件采用哪种UTF编码方式。这个字符也叫做“bit order mark”

        换行符 LineTerminator
          JS中提供了4种换行符：
            · <LF>是U+000A，就是正常的换行符，是字符串中的\n
            · <CR>是U+000D，就是“回车”，在字符串中是\r，在一部分Windows风格的编辑器中，换行是两个字符\r\n
            · <LS>是U+2028，是Unicode中的行分隔符
            · <PS>是U+2029，是Unicode中的段落分隔符
          大部分的换行符在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响JS的两个重要语法特征：自动插入分号和“no line terminator”规则

        注释 Comment
          JS的注释分为单行注释和多行注释：
            /* MultiLineCommentChars */
            // SingleLineCommentChars
          多行注释中允许出现除了*之外的所有字符，而每一个*之后，不能出现正斜杠符/
          除了四种LineTerminator之外，任何字符都可以作为单行注释
          注意：多行注释是否包含换行符，会对 JS 语法产生影响，对于“no line terminator”规则来说，带换行符的多行注释和换行符是等效的

        标识符名称 IdentifierName
          IdentifierName可以以美元符"$"、下划线“_”、或者Unicode字母开始，除了开始字符以外，IdentifierName中还可以使用Unicode连接标记，字符以及连接符号。
          IdentifierName的任意字符可以使用JS的Unicode转义写法，在使用Unicode的转义写法时，没有任何字符限制。
          IdentifierName可以是Identifier、NullLiteral、BooleanLiteral或者keyword，在ObjectLiteral中，IdentifierName还可以被直接当做属性名称使用。
          仅当不是保留字的时候，IdentifierName会被解析为Identifier
          注意<ZWNJ>和<ZWJ>是ES5新加的两个格式控制字符，它们都是0宽
          在JS中，有33个关键字：
            await break try catch class const continue debugger default delete else export extends finally for function if import instanceof new return super switch case this throw typeof var void do while with yield
          除了上面的内容外，还有一个为未来使用而保留的关键字：
            enum
          在严格模式下，有一些额外的为未来使用而保留的关键字：
            implements package protected interface private public
          除了这些，NullLiteral（null）和BooleanLiteral（true false）也是保留字，不能用于Identifier

        符号 Punctuator
          因为除法和正则问题，/和/=两个运算符被拆分为DivPunctuator，因为字符串模板问题，} 也被独立拆分，所有符号为：
            { ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }

        数字直接量 NumericLiteral
          JS规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数、十六进制整数
          十进制的Number可以带小数，小数点前后都可以忽略，但不能同时忽略，例：.01  12.  2.1
          数字直接量还支持科学计数法，e后面的部分只允许使用整数，例：10.24E+2  10.24e-2  10.24e2
            0x开头为十六进制：oxFB     0o开头为八进制：0o79     0b开头为二进制：0b1000

        字符串直接量 StringLiteral
          JS中的StringLiteral支持单引号和双引号两种写法。
          单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是\和所有换行符。
          JS中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。
            1.单字符转义，即一个反斜杠\后面跟一个字符这种形式。

        正则表达式直接量 RegularExpressionLiteral
          正则表达式由Body和Flags两部分组成，例如：
            /RegularExpressionBody/ig
          其中Body部分至少有一个字符，第一个字符不能是*（因为/*跟多行注释有词法冲突）。
          正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。
          正则表达式并非机械的见到/就停止，在正则表达式[ ]中的/就会被认为是普通字符，例如：
            /[/]/.test("/"); // true
          除了 \、/ 和 [ 三个字符之外，JS表达式中的字符都是普通字符。
          用\和一个非换行符可以组成一个转义，[ ]中也支持转义。正则表达式中的flag在词法阶段不会限制字符。
          虽然只有ig几个是有效的，但是任何IdentifierPart（Identifier中合法的字符）序列在词法阶段都会被认为是合法的。

        字符串模板 Template
          在词法结构上，Template是个整体，其中的${}是并列关系。
          实际上，在JS词法中，包含${}的Template，是被拆开分析的。例如：
            `a${b}c${d}e`
            在JS中被认为是
            `a${   b   }c${   d   }e`
            它被拆成了五个部分：
              · `a${  这个被称为模板头
              · }c${  被称为模板中段
              · }e`   被称为模板尾
              · b和d都是普通标识符
            实际上，这里的词法分析过程已经与语法分析深度耦合了。
            模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数
              function f(){ console.log(arguments); }
              var a = "world"
              f`Hello ${a}!`; // [["Hello", "!"], world]
            模板字符串不需要关心大多数字符的转义，但是 ${ 和 ` 还是需要处理的。
            模板中的转义跟字符串几乎完全一样，都是使用 \。


      2. JS语法
        自动插入分号
          自动插入分号规则独立于所有语法产生式定义，规则：
            · 有换行符，且下一个符号是不符合语法的，那么就尝试插入分号
            · 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号
            · 源代码结束处，不能形成完整的脚本或模块结构，那么就自动插入分号

        no LineTerminator here 规则
          no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符
          自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟no LineTerminator here 规则强相关。
          JS语法中定义了以下 no LIneTerminator here 规则：
            · 带标签的 continue 语句，不能在 continue 后插入换行
            · 带标签的 break 语句，不能再break后插入换行
            · return 后不能插入换行
            · 后自增、后自减前不能插入换行
            · throw 和 Exception 之间不能插入换行
            · 凡是 async 关键字后面，都不能插入换行
            · 箭头函数的箭头前，都不能插入换行
            · yield之后，不能插入换行

          no LineTerminator here 规则的存在，多数情况下是为了保证自动插入分号行为是符合预期的，但是在JS设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要格外注意

        不写分号需要注意的情况
          · 以括号开头的语句
          · 以数组开头的语句
          · 以正则表达式开头的语句
          · 以 Template 开头的语句
          例子在：HTML演示文件/语法.html

    
    (4) JS语法
      JS有两种源文件：一. 脚本 二. 模块。这个区分是在ES6引入了模块机制开始的。
          脚本可以由浏览器或node引入执行的，而模块只能由JS代码用import引入执行
          从概念上，可以认为脚本具有主动性的JS代码，是控制宿主完成一定任务的代码；而模块是被动性的代码，是等待被调用的库
          浏览器支持用<script>引入模块，但必须给<script>标签添加type="module"。如果引入脚本，则不需要type
          脚本中可以包含语句，模块中可以包含3中内容：import声明、export声明和语句。