JavaScript
  一.类型
    JS 语言的每一个值都属于某一种数据类型。JS 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合，运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JS 代码运行过程中产生的数据，都具有运行时类型。
    1.Undefined
    2.Null
    3.Boolean
    4.String
    5.Number
    6.Symbol
    7.Object
    有的编程规范要求用void 0代表undefined，为什么？
      Undefined表示未定义，它的类型只有一个值，就是undefined。任何变量在赋值前都是Undefined类型，值为undefined，一般情况下可以用undefined（就是名为undefined的这个变量）来表达这个值，或者void运算来把任意一个表达式变成undefined值。建议使用 void 0或void(0)来获取undefined值。在实际编程时，一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。
      
    Undefined 和 Null
      Undefined 和 Null 有一定的表意区别，Null表示的是："定义了但是为空"。Null的类型也只有一个值，就是null，与undefined不同null是JS关键字，在任何程序中，都可以使用null关键字来获取null值。
 
    String
      字符串是否有最大长度？
        String用于表示文本数据，String 有最大长度是 2^53 - 1，String的意义并非字符串，而是字符串的UTF16编码，字符串的操作charAt、charCodeAt、length等方法针对的都是UTF16编码。所以字符串最大长度，都是受字符串的编码长度影响
        JS中的字符串是永远无法变更的，所以字符串具有值类型的特征
        JS 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，应该格外小心。

    Number
      JS 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。
      JS 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JS 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：
        · NaN：NaN规定和参考双精度浮点数的表达方式，1位符号位+52位尾数位共53位，指数固定为2^e – 1并去掉±∞两个值，那么NaN其实是 2^53-2 个特殊数字的合集（2^53-2 = 9007199254740990 ）所以，为什么NaN !== NaN了，它不是一个值，而是一群值
        · Infinity，无穷大
        · -Infinity，负无穷大
      JS中有+0 和 -0，在加法类运算中没有区别，但是在除法的场合需要特别留意，除以 -0 会得到 负无穷大,除以 0 会得到 正无穷大，而区分 +0 或 -0 的方式是1/x是Infinity还是-Infinity
      根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，也就是 console.log(0.1 + 0.2 == 0.3)，这里输出的是 false，说明两边不相等，这是浮点运算的特点（number类型运算都要将其转化为二进制，将二进制运算，运算的结果再转化为十进制，因为number是64位双精度，小数部分只有52位，但0.1转化成为二进制是无限循环的，所以四舍五入了这里就发生了精度丢失，0.1的二进制和0.2的二进制相加需要保留有效数字，所以又发生了精度丢失，所以结果为0.300000000000004）。浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。
      正确的比较方法是使用JS提供的最小精度值： console.log(Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON); 检查等式两侧的绝对值是否小于绝对精度，才是正确比较浮点数的方法。
      Number.EPSILON：ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。Number.EPSILON = 2.220446049250313e-16。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。Number.EPSILON实际上是 JS 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。引入一个这么小的量的目的，在于为浮点数计算，Number.EPSILON可以用来设置“能够接受的误差范围”。
    
    Symbol
      Symbol是ES6中引入的新类型，他是一切非字符串的对象key的集合，在ES6规范中，整个对象系统被用Symbol重塑。
      Symbol可以具有字符串类型的描述，但是即使描述相同，Symbol也不相等。
      创建Symbeol的方式是使用全局的Symbol函数。例如：var symbol = Symbol("my symbol");
      Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用。当需要对一个对象进行迭代时（比如开始用于一个for..of循环中），它的Symbol.iterator方法都会在不传参情况下被调用，返回的迭代器用于获取要迭代的值。

    Object
      Object 是JS中最复杂的类型，也是JS的核心机制之一，Object表示对象，在JS中对象的定义是“属性的集合”。属性分为 数据属性 和 访问器属性 ，两者都是key-value结构，key可以是字符串或Symbol类型。
      提到对象，必须提到一个概念：类，JS中的类仅仅是运行时对象的一个私有属性，JS中无法自定义类型
      JS中的几个基本类型，都在对象中有一个“亲戚”：1.String 2.Boolean 3.Number 4.Symbol
      在JS中，3 和 New Number(3) 是两个完全的值，3 是Number类型，New Number(3) 是对象类型
      Number、Boolean、String，三个构造器是两用的，当跟New 搭配时，他们产生对象，当单独使用时，表示强制类型转换。Symbol比较特殊，直接用New调用它会抛出错误，但它依然是Symbol对象的构造器

      JS在语言设计上试图模糊基本类型与对象之间的关系，在日常代码中可以把对象的方法放在基本类型上使用，如：console.log("ab".charAt(0));
      甚至在原型上添加方法都可以应用于基本类型， “.”运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。
      
  二.类型转换
    JS是弱类型语言，所以类型转换发生的非常频繁，大部分我们熟悉的运算都会先进行类型转换。
      StringToNumber
        字符串到数字的类型转换，存在一个语法结构，类型转换支持二进制，八进制，十进制，十六进制，此外，JS支持字符串语法还包括，正负号科学计数法，可以使用大写或小写的e来表示，如：Number(1e3) = 1 * 10^3 = 1000，-1e-2 = -1 * 10^-2 = -0.01
        需要注意，parseInt 和 parseFloat并不使用这个转换，所以支持的语法跟Number不同。parseInt，在不传入第二个参数时，只支持16进制前缀“0x”，而且会自动忽略非数字字符，也不支持科学计数法，所以需要传入第二个参数。parseFloat直接把原字符串作为十进制解析，它不会引入任何其他进制。多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。
      
      NumberToString
        在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。是为了保证产生字符串的不会过长。具体算法，去看JS语言标准。

      装箱转换
        每一种基本类型Number、String、Boolean、Symbol在对象中都有对应的类，所谓装箱转换就是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。
        全局的Symbol函数无法使用new来调用，但可以使用装箱机制来得到一个Symbol对象，可以利用函数的.call()方法来强迫装箱。
          var symbolObject = (function(){ return this; }).call(Symbol("a"));
          console.log(typeof symbolObject); //object
          console.log(symbolObject instanceof Symbol); //true
          console.log(symbolObject.constructor == Symbol); //true
        装箱机制会频繁产生临时对象，在对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换
        使用内置的Object函数，可以JS代码中显式的调用装箱能力
          var symbolObject = Object(Symbol("a"));
          console.log(typeof symbolObject); //object
          console.log(symbolObject instanceof Symbol); //true
          console.log(symbolObject.constructor == Symbol); //true
        每一类装箱对象都有私有的Class属性，这些属性可以用Object.prototype.toString获取，
          var symbolObject = Object(Symbol("0"));
          var symbolT      = Symbol("b");
          console.log(Object.prototype.toString.call(symbolObject)); // [Object Symbol]
          console.log(typeof symbolObject); // Object
          console.log(typeof symbolT); // Symbol
        在JS中没有任何方法可以改变私有的Class属性，所以，Object.prototype.toString 可以准确识别对象对应的基本类型的方法，它比 instanceof 更准确，需要注意.call()会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型

      拆箱转换
        在JS标准中，规定了toPrimitive 函数，它是对象类型到基本类型的转换（即拆箱转换）。对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则，通过拆箱转换，把对象先转为基本类型，再从基本类型转为对应的String或Number。拆箱转换会先尝试调用 valueOf 和 toString 来获取拆箱后的基本类型，如果 typeOf 和 toString 都不存在或没有返回基本类型，则会报类型错误TypeError。

    规范类型
      1. List 和 Record： 用于描述函数传参过程。
      2. Set：主要用于解释字符集等。
      3. Completion Record：用于描述异常、跳出等语句执行过程。
      4. Reference：用于描述对象属性访问、delete 等。
      5. Property Descriptor：用于描述对象的属性。
      6. Lexical Environment 和 Environment Record：用于描述变量和作用域。
      7. Data Block：用于描述二进制数据。
    
  三.什么是面向对象
    JS标准对于 基于对象 的定义：语言和宿主的基础设施由对象来提供，并且JS程序即是一系列互相通讯的对象的集合。
    