# CSS 选择器

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [CSS 选择器](#css-选择器)
  - [一. 概述](#一-概述)
    - [1.1 为什么 CSS 选择器很强](#11-为什么-css-选择器很强)
    - [1.2 CSS 选择器世界的一些基本概念](#12-css-选择器世界的一些基本概念)
      - [1.2.1 选择器、选择符、伪类和伪元素](#121-选择器-选择符-伪类和伪元素)
      - [1.2.2 CSS 选择器的作用域](#122-css-选择器的作用域)
      - [1.2.3 CSS 选择器的命名空间](#123-css-选择器的命名空间)
    - [1.3 无效 CSS 选择器特性与实际应用](#13-无效-css-选择器特性与实际应用)
  - [二. CSS 选择器的优先级](#二-css-选择器的优先级)
    - [2.1 CSS 优先级规则概览](#21-css-优先级规则概览)
    - [2.2 深入 CSS 选择器优先级](#22-深入-css-选择器优先级)
      - [2.2.1 CSS 选择器优先级的计算规则](#221-css-选择器优先级的计算规则)
  - [三. CSS 选择器的命名](#三-css-选择器的命名)
    - [3.1 CSS 选择器是否区分大小写](#31-css-选择器是否区分大小写)
    - [3.2CSS 选择器命名的合法性](#32css-选择器命名的合法性)

<!-- /code_chunk_output -->

## 一. 概述

CSS 选择器本身很简单，就是一些特定的选择符号，于是，很多开发者就认为 CSS 选择器的世界很简单，没什么好学的。实际上，CSS 选择器非常强大，它不
仅涉及视觉表现，而且与用户安全、用户体验有非常密切的联系。

### 1.1 为什么 CSS 选择器很强

CSS 选择器能够做的事情远比预想的多得多。CSS 是为样式服务的，它重表现，轻逻辑，如同人的思想一样，相互碰撞才能产生火花。尤其对于 CSS 选择器，它作为 CSS 世界的支柱，与 HTML 结构、浏览器行为、用户行为以及整个 CSS 世界相互依存、相互作用，这必然会产生很多碰撞，让 CSS 选择器变得非常强悍。同时，CSS 选择器本身也并非那么单纯。

### 1.2 CSS 选择器世界的一些基本概念

平常所说的 CSS 选择器实际上是一个统称，是很多基本概念的集合，有必要先了解一下这些基本概念。

#### 1.2.1 选择器、选择符、伪类和伪元素

CSS 选择器可以分为 4 类，即选择器、选择符、伪类和伪元素。

1. **选择器**
   这里的 “选择器” 指的就是平常使用的 CSS 声明块前面的标签、类名等。

2. **选择符**

   CSS 选择器中的选择符有 5 个，分别如下：

   ```css
   /* 后代关系 */
   .container img {
     object-fit: cover;
   }
   /*父子关系*/
   ol > li {
     margin: 5em 0;
   }
   /* 相邻兄弟关系 */
   button + button {
     margin-left: 10px;
   }
   /* 后续兄弟关系 */
   button ~ button {
     margin-left: 10px;
   }
   /*
    * 列选择符是规范中刚出现不久的新选择符，目前浏览器的兼容性还不足以让它在实际项目中得到应用
   */
   .col||td {
     background-color: skyblue;
   }
   ```

3. **伪类**

   伪类的特征是其前面会有一个冒号 `:`，通常与浏览器行为和用户行为相关联，可以看成是 CSS 世界的 JS。伪类和选择符相互配合可以实现非常多的纯 CSS 交互效果。

4. **伪元素**

   伪元素的特征是其前面会有两个冒号 `:`，常见的有 `::before`、`::after`、`::first-letter` 和 `::first-line` 等。

#### 1.2.2 CSS 选择器的作用域

以前 CSS 选择器只有一个全局作用域，也就是在网页任意地方的 CSS 都共用一个文档上下文。

如今 CSS 选择器是有局部作用域的概念的。伪类 `:scope` 的设计初衷就是匹配局部作用域下的元素。例如，对于下面的代码：

```html
<section>
  <style scoped>
    p {
      color: blue;
    }
    :scope {
      background-color: red;
    }
  </style>
  <p>在作用域内，背景色应该红色。</p>
</section>
<p>在作用域外，默认背景色。</p>
```

理论上，section 标签里面的 p 元素的背景色应该是红色，但目前没有任何浏览器表现为红色。因为目前尚无一种方法来显式建立作用域元素，所以**在样式表中使用时 `:scope` 等效于 `:root`**。但是，它在 JS 中还是有效的，这一点将在 12.1.1 <!--TODO--> 节中进一步展开介绍。

另外，CSS 选择器的局部作用域在 Shadow DOM 中也是有效的。例如，有一个 div 元素：

```html
<div id="hostElement"></div>
```

然后使用 Shadow DOM 为这个 div 元素创建一个 p 元素并且控制其背景色的样式，如下：

```js
// 创建 Shadow DOM
var shadow = hostElement.attachShadow({ mode: 'open' });
// 给 Shadow DOM 添加文字
shadow.innerHTML = '<p>我是由Shadow DOM创建的&ltp&gt元素，我的背景色是？</p>';
// 添加 CSS，p 标签背景色变成黑色
shadow.innerHTML += '<style>p{background-color:#333;color:#fff;}</style>';
```

Shadow DOM 创建的 p 元素的背景色是黑色，而页面原本的 p 元素的背景色不受任何影响。

#### 1.2.3 CSS 选择器的命名空间

CSS 选择器中还有一个命名空间（namespace）的概念。命名空间可以让来自多个 XML 词汇表的元素的属性或样式彼此之间没有冲突，它的使用非常常见，例如 SVG 文件的命名空间：

```css
<svg xmlns="http://www.w3.org/2000/svg" />
```

上述代码中的 xmlns 属性值对应的 URL 地址就是一个简单的命名空间名称，其并不指向实际的在线地址，浏览器不会使用或处理这个 URL。

在 CSS 选择器世界中命名空间的作用也是避免冲突。例如，在 HTML 和 SVG 中都会用到 a 链接，此时就可能发生冲突，可以借助命名空间进行规避，具体方法是，使用 `@namespace` 规则声明命名空间：

```css
@namespace url(http://www.w3.org/1999/xhtml);
@namespace svg url(http://www.w3.org/2000/svg);
/* XHTML中的 <a> 元素 */
a {
}
/* SVG 中 <a> 元素 */
svg|a {
}
/* 同时匹配 XHTML 和 SVG 的 <a> 元素 */
*|a {
}
```

> **注意**：上述 CSS 代码中的 svg 也可以换成其他字符，这里的 svg 并不是表示 svg 标签的意思。

通过一个实际案例来直观地了解一下 CSS 选择器的命名空间。HTML 和 CSS 代码如下：

```html
<p>这是文字：<a href>点击刷新</a></p>
<p>
  这是SVG:
  <svg>
    <a xlink:href><path d="..." /></a>
  </svg>
</p>

<style>
  @namespace 'http://www.w3.org/1999/xhtml';
  @namespace svg 'http://www.w3.org/2000/svg';
  svg|a {
    color: black;
    fill: currentColor;
  }
  a {
    color: gray;
  }
</style>
```

svg|a 中有一个管道符 `|`，管道符前面的字符表示命名空间的代称，管道符后面的内容则是选择器。本例的代码表示在 `http://www.w3.org/2000/svg` 这个命名空间下所有 a 的颜色都是 black，由于 xhtml 的命名空间也被指定了，因此 SVG 中的 a 就不会受标签选择器 a 的影响，即便纯标签选择器 a 的优先级再高也无效。

CSS 选择器命名空间的兼容性很好，至少 10 年前浏览器就已支持，但是，却很少见人在项目中使用它，原因有二：

- 在 HTML 中直接内联 SVG 的应用场景并不多，它更多的是作为独立的 SVG 资源使用，即使内联，也很少有需要对特性 SVG 标签进行样式控制的需求
- 有其他更简单的替代方案

例如，如果希望 SVG 中所有的 a 元素的颜色都是 black，可以直接用：

```css
svg a {
  color: black;
}
```

无须掌握复杂的命名空间语法就能实现想要的效果，这样做的唯一缺点就是增加了 SVG 中 a 元素的优先级，但是在大多数场景下，这对实际开发没有任何影响。综合来看，这是一种性价比高很多的实现方式，几乎找不到需要使用命名空间的理由。

### 1.3 无效 CSS 选择器特性与实际应用

很多 CSS 伪类选择器是最近几年才出现的，浏览器并不支持，浏览器会把这些选择器当作无效选择器，这是没有任何问题的。但是当这些无效的 CSS 选择器和浏览器支持的 CSS 选择器写在一起的时候，会导致整个选择器无效，举个例子，有如下 CSS 代码：

```css
.example:hover,
.example:active,
.example:focus-within {
  color: red;
}
```

`:hover` 和 `:active` 是浏览器很早就支持的两个伪类，但是，由于 IE 浏览器并不支持 `:focus-within` 伪类，会导致 IE 浏览器无法识别整个语句，这就是无效 CSS 选择器特性。

因此，在使用一些新的 CSS 选择器时，出于渐进增强的目的，需要将它们分开书写：

```css
/* IE 浏览器可识别 */
.example:hover,
.example:active {
  color: red;
}
/* IE 浏览器不可识别 */
.example:focus-within {
  color: red;
}
```

不过，在诸多 CSS 选择器中，这种无效选择器特性出现了一个例外，那就是浏览器可以识别以 -webkit- 私有前缀开头的伪元素。

```css
span::-webkit-whatever {
  background: gray;
}
```

除了 IE 浏览器，其他浏览器均支持（Firefox63 及以上版本支持）识别这个 -webkit- 无效伪元素的特性。于是，就可以灵活运用这种特性来帮助完成实际开发。例如，对 IE 浏览器和其他浏览器进行精准区分：

```css
/* IE浏览器 */
.example {
  background: black;
}
/* 其他浏览器 */
.example::-webkit-whatever {
  background: gray;
}
```

当然，上面的无效伪类会导致整行选择器失效的特性也可以用来区分浏览器。

## 二. CSS 选择器的优先级

几乎所有的 CSS 样式冲突、样式覆盖等问题都与 CSS 声明的优先级错位有关。因此，在详细阐述 CSS 选择器的优先级规则之前，先快速了解一下 CSS 全部的优先级规则。

### 2.1 CSS 优先级规则概览

CSS 优先级有着明显的不可逾越的等级制度，其可以划分为 0~5 这 6 个等级，其中前 4 个等级由 CSS 选择器决定，后 2 个等级由书写形式和特定语法决定。

1. 0 级：通配选择器、选择符和逻辑组合伪类

   通配选择器写作星号 `*`。选择符指 `+`、`>`、`~`、`空格`和 `||`。逻辑组合伪类有 `:not()`、`:is()` 和 `:where` 等，这些伪类本身并不影响 CSS 优先级，影响优先级的是括号里面的选择器。

   > **注意**：只有逻辑组合伪类的优先级是 0，其他伪类的优先级并不是这样的。

2. 1 级：标签选择器

3. 2 级：类选择器、属性选择器和伪类

4. 3 级：ID 选择器

5. 4 级：style 属性内联

6. 5 级：!important

> !important 是顶级优先级，可以重置 JS 设置的样式，唯一推荐使用的场景就是使 JS 设置无效。对于其他场景，没有任何使用它的理由，切勿滥用。

不难看出，CSS 选择器的优先级（0 级至 3 级）属于 CSS 优先级的一部分，也是最重要、最复杂的部分，学会 CSS 选择器的优先级等同于学会了完整的 CSS 优先级规则。

### 2.2 深入 CSS 选择器优先级

#### 2.2.1 CSS 选择器优先级的计算规则

对于 CSS 选择器优先级的计算，业界流传甚广的是数值计数法。具体如下：

每一段 CSS 语句的选择器都可以对应一个具体的数值，数值越大优先级越高，其中的 CSS 语句将被优先渲染。其中，出现一个 0 级选择器，优先级数值 +0；出现一个 1 级选择器，优先级数值 +1；出现一个 2 级选择器，优先级数值 +10；出现一个 3 级选择器，优先级数值 +100。

1. 增加 CSS 选择器优先级的小技巧

   实际开发时，难免会遇到需要增加 CSS 选择器优先级的场景。例如，希望增加下面 .foo 类名选择器的权重：

   ```css
   foo {
     color: #333;
   }
   ```

   很多人的做法是增加嵌套，或者是增加一个标签选择器。但这些都不是最好的方法，因为这些方法增加了藕合，降低了可维护性。这里给大家介绍一个增加 CSS 选择器优先级的小技巧，那就是**重复选择器自身**。例如，可以像下面这样做，既提高了优先级，又不会增加藕合，实在是上上之选：

   ```css
   .foo.foo {
   }
   ```

   如果实在不喜欢这种写法，借助必然会存在的属性选择器也是不错的方法。

2. 对数值计数法的点评

   上面提到的 CSS 选择器优先级数值的计数法实际上是一个不严谨的方法，因为 1 和 10 之间的差距实在太小了，这也就意味着连续 10 个标签选择器的优先级就和 1 个类名选择器齐平了。然而事实并非如此，不同等级的选择器之间的差距是无法跨越的存在。但由于在实际开发中，是不会连续写上多达 10 个选择器的，因此不会影响在实际开发过程中计算选择器优先级。

   而且对于使用 CSS 选择器而言，书写习惯远比知识更重要，就算理论知识再扎实，如果平时书写习惯糟糕，也无法避免 CSS 样式覆盖问题、样式冲突等问题的出现。将在第 3 章中深入探讨这个问题<!--TODO-->。

**256 个选择器的越级现象**
实际上，在过去，Chrome 浏览器、Firefox 浏览器下都出现过 256 个选择器的优先级大于上一个选择器级别的现象，后来，大约 2015 年之后，Chrome 浏览器和 Firefox 浏览器都修改了策略，使得再多的选择器的优先级也无法超过上一级，因此，目前越级现象仅在 IE 浏览器中可见。

为什么会有这种有趣的现象呢？早些年查看 Firefox 浏览器的源代码，发现所有的类名都是以 8 字节字符串存储的，8 字节所能容纳的最大值就是 255，因此同时出现 256 个类名的时候，势必会越过其边缘，溢出到 D 区域。而现在采用了 16 字节的字符串存储，能容纳的类型数量足够多了，就不会出现这种现象。

## 三. CSS 选择器的命名

CSS 选择器的命名问题是最常困扰开发者的事情之一。究竟是面向 CSS 属性命名，还是面向 HTML 语义命名？是使用长命名，还是使用短命名？

### 3.1 CSS 选择器是否区分大小写

CSS 选择器有些区分大小写，有些不区分大小写，还有些可以设置为不区分。要搞清楚 CSS 选择器是否区分大小写的问题，还要从 HTML 说起。

在 HTML 中，标签和属性都是不区分大小写的，而属性值是区分大小写的。于是，相对应地，在 CSS 中，标签选择器不区分大小写，属性选择器中的属性也不区分大小写，而类选择器和 ID 选择器本质上是属性值，因此要区分大小写。

然而，随着各大浏览器支持属性选择器中的属性值也不区分大小写（在 `]` 前面加一个 i），已经没有严格意义上的对大小写敏感的选择器了，因为类选择器和 ID 选择器本质上也是属性选择器，因此，如果希望 HTML 中的类名对大小写不敏感，可以这样：

```css
P {
  padding: 10px;
  background-color: black;
}
[CLASS] {
  color: white;
}
[CLASS~='CONTENT' i] {
  text-decoration: line-through;
}
```

更多关于属性选择器大小写敏感的内容参见第 6 章。<!--TODO-->

### 3.2CSS 选择器命名的合法性

这里主要讲一下类选择器和 ID 选择器的命名合法性问题，旨在纠正大家长久以来的错误认识。什么错误认识呢？最常见的就是类名选择器和 ID 选择器不能以数字开头，如下：

```css
.1-foo {
  border: 10px dashed;
  padding: 10px;
} /* 无效 */
```

对，上面这种写法确实无效，但这并不是因为不能以数字开头，而是不能直接写数字，需要将其转义一下，如下：

```css
.\31 -foo {
  border: 10px dashed;
  padding: 10px;
}
```

此时，下面的 HTML 就表现为黑底白字：

```html
<span class="1-foo">颜色是？</span>
```

为什么会有这么奇怪的表示？居然表示成 \31，而且后面还有一个空格！

其实 \31 外加空格是 CSS 中字符 1 的十六进制转码表示，也可以省略空格。其中 31 就是字符 1 的 Unicode 值，如下：

```js
console.log('1'.charCodeAt().toString(16)); // 结果是 31
```

字符 0 的 Unicode 值是 30，字符 9 的 Unicode 值是 39，0~9 这 10 个数字对应的 Unicode 值正好是 30~39。也可以用以下这种方法进行表示：

```css
.\000031-foo {
  border: 10px dashed;
  padding: 10px;
}
```

31 前面用 4 个 0 进行补全，这样 31 后面就不用加空格。类名或者 ID 甚至可以是纯数字。

**规范与更多字符的合法性**
首先，关于命名，看看规范是怎么说的。

![规范中对选择器命名的描述](./image/规范中对选择器命名的描述.png)

图分左右两半，其中左边是选择器首字符，右边是选择器后面的字符。从图中可以清晰地看到，首字符支持的字符类型是 a~z、A~Z、`_` 以及非 ASCll 字符（中文、全角字符等），后面的字符支持的字符类型是 a~z、A~Z、0~9、`_`、`-` 以及非 ASCll 字符，后面的字符支持的字符类型多了数字和短横线。

很多人对选择器的合法性认识就停留在上面的内容，而忽略了图下面的 escape 方块。也就是说，对于其他没有出现的字符只要对它们执行转义重新编码一下也能使其成为支持的字符类型。

也就是说，选择器不仅可以以数字开头，也支持以其他字符开头。这些字符可以是下面的这些。

1. 不合法的 ASCll 字符，如 ！、"、#、$、%、&;、'、(、)、及 ~。
   严格来讲，上述字符也应该完全转码。例如，加号（+）的 Unicode 值是 2b，因此选择器需要写成 \2b 空格，或者 \00002b。但是，对于上述字符，还有一种更优雅的表示方式，那就是直接使用斜杠转义。示意如下：

   ```css
   .\+foo {
     color: red;
   }
   ```

   包括 IE 在内的浏览器都支持上面的斜杠转义写法，因此可以放心使用。唯一需要多提一句的就是冒号 `:`，在 IE7 浏览器下，直接使用 `\:` 是不被支持的，如果需要兼容这些浏览器，可以使用 \3a 加上空格代替。

2. 中文字符。下面的 CSS 也是有效的：

   ```css
   .我是 foo {
     color: red;
   }
   ```

3. 中文标点符号

4. emoji 表情：

   由于 emoji 字符在手机设备或者 OS X 系统上自动显示为 emoji 表情，因此有人会在实验性质的项目中使用 emoji 字符作为类名，这样，展示源代码的时候，会有一个一个的表情出现，这也挺有意思的。

上图中还有两个小圆框，其中一个里面是一根短横线 `-`，还有一个里面是连续两根短横线 `--`，它们是什么意思呢？

意思是，可以直接以短横线开头，如果是一根短横线 `-`，那么短横线后面必须有其他字符、字母或下划线或者其他编码字符；如果是连续两根短横线 `--`，则它的后面不跟任何字符也是合法的。因此，下面两个 CSS 语句都是合法的：

```css
.-- {
  color: red;
} /* 有效 */
.-a-b- {
  color: red;
} /*有效*/
```

对于一些需要特殊标记的元素，可以试试以短横线开头命名。

### 3.3 CSS 选择器的命名

#### 3.3.1 长命名还是短命名

对于使用长命名还是短命名的问题，请使用短命名。例如，一段介绍，类名可以这样：

```css
.some-intro {
  line-height: 1.75;
}
/* 没有必要这样 */
.some-introduction {
  line-height: 1.75;
}
```

后一种方式不仅增加了书写时间，也增加了 CSS 文件的大小。虽然这样做使语义更加准确了，也确实有一定价值，但价值很有限。要知道，日后维护代码时，人们只会关心这个类名有没有在其他地方使用过？改变、删除这个类名会不会出现问题？至于语义，人们真的不关心。

CSS 选择器的语义和 HTML 的语义是不一样的，前者只是为了方便人的识别，它对于机器而言没有任何区别，因此**价值很弱**；但是 HTML 的语义的重要作用是让机器识别，如搜索引擎或者屏幕阅读器等，它是与用户体验与产品价值密切相关的。因此，请使用短命名。

#### 3.3.2 单命名还是组合命名

单命名的优点是字符少、书写快，缺点是容易出现命名冲突的问题；组合命名的优点是不容易出现命名冲突，但写起来较烦琐。样式冲突的性质比书写速度慢严重得多，因此，理论上推荐使用组合命名，但在实际开发中，项目追求的往往是效益最大化，而不是完美的艺术品。因此，具体该如何取舍，不能一概而论，只能从经验层面进行阐述。

1. 对于多人合作、长期维护的项目，千万不要出现以常见单词命名的单命名选择器，因为后期非常容易出现命名冲突的问题，即使项目不会引入第三方的 CSS。

   如果要使用，一定要使用另外的前缀组合将它们保护起来，这个前缀可以是模块名称，或者场景名称。

2. 如果项目会使用第三方的 UI 组件，就算是全站公用的 CSS，也不要出现下面这样的单命名，因为说不定下面的命名就会与第三方 CSS 发生冲突：

   ```css
   .header {
   } /*不建议*/
   .aside {
   } /*不建议*/
   .success {
   } /*不建议*/
   .red {
   } /*不建议*/
   ```

   正确的做法是**加一个统一的前缀，使用组合命名的方式**。可以随意命名这个前缀，可以是项目代号的英文缩写，也可以是产品名称的拼音首字母，因为这个前缀的作用是避免冲突，它并不需要任何语义。但需要注意的是前缀最好不要超过 4 个字母，因为字母多了完全没有任何意义，只会徒增 CSS 文件的大小。

3. 如果项目百分百是自主研发的，以后维护此项目的人也不会盗取别人的 CSS 来充数，则与网站公用结构、颜色相关的这些 CSS 可以使用单命名。

   但对于非公用内容，如标题（.title）、盒子（.box）等就不能使用单命名，因为颜色这类样式是贯穿于整个项目的，具有高度的一致性，而标题（.title）会在很多地方出现，且样式各不相同，如大标题、小标题、弹框标题、模块标题等，容易产生命名冲突。

   对于网站 UI 组件，各个业务模块一定要采用多名称的组合命名方式，且最好都有一个统一的命名前缀。

4. 如果做的项目并不需要长期维护，也不需要多人合作，例如，只是一些运营活动，请务必添加统一的项目前缀，因为这次活动的某些功能和效果日后会被复用，有了统一的前缀，日后直接复制代码就能使用，没有后顾之忧，

但有一类基于 CSS 属性构建的单命名反而更安全，它们比颜色这些类名还要安全，即使项目会引入外部 CSS:

```css
.db {
  display: block;
}
.ml20 {
  margin-left: 20px;
}
.vt {
  vertical-align: top;
}
```

1. 这些选择器命名是面向 CSS 属性的，它们是超越具体项目的存在，只会被重复定义，但不会发生样式冲突。

2. 面向 CSS 属性的命名是机械的、反直觉的，而面向语义的命名符合人类直觉，也就是说，对于一个标题，将它命名为 title 的人很多，但抛弃语义，直接使用 tc 命名的人却廖廖无几。

总结一下，除了多人合作、长期维护、不会引入第三方 CSS 的项目的全站公用样式可以使用单命名，其他场景都需要组合命名。

然而，即使将命名做到极致，也无法完全避免冲突，因为 CSS reset 的冲突是防不胜防的。例如，对于 body 标签选择器的设置，每个网站都不一样，很多第三方 CSS 甚至喜欢使用通配符：

```css
*,
*:before,
*:after {
  box-sizing: border-box;
}
```

后面 2 个伪元素前面的星号是多余的，这不重要，重要的是这段 CSS 会给其他网站布局带来毁灭性的影响，导致大量错位和尺寸变化，因为所有元素默认的盒模型都被改变了。可以使用以下方式来改变 box-sizing，而不改变所有盒模型：

```css
html {
  box-sizing: border-box;
}

*,
*:before,
*:after {
  box-sizing: inherit;
}
```

#### 3.3.3 面向属性的命名和面向语义的命名

面向属性的命名指选择器的命名是跟着具体的 CSS 样式走的，与项目、页面、模块统统没有关系。例如，比较经典的清除浮动类名 .clearfix。

面向语义的命名则是根据应用元素所处的上下文来命名的。

```css
.logo {
}
```

上述两种命名方式各有优缺点：

面向属性的命名的优点在于 CSS 的重用率高，性能最佳，即插即用，方便快捷，开发也极为迅速，因为它省去了大量在 HTML 和 CSS 文件之间切换的时间；不足在于由于属性单一，其适用场景有限，另外因为使用方便，易被过度使用，从而带来更高的维护成本。

面向语义的命名的优点是应用场景广泛，可以实现非常精致的布局效果，扩展方便；不足在于代码唠峻，开发效率一般，因为所有 HTML 都需要命名，哪怕是一个 10 像素的间距。这就导致很多开发者要么选择直接使用标签选择器，要么就选择一个简单的类名，然后通过父子关系限定样式，结果带来了更糟糕的维护问题。

## 四. 元素选择器

### 4.1 元素选择器的级联语法

不同类型的 CSS 选择器的级联使用是非常常见的，但元素选择器的级联语法和其他选择器的级联语法有两个明显的不同之处：

1. **元素选择器是唯一不能重复自身的选择器**

   类选择器、ID 选择器和属性值匹配选择器都可以重复自身，例如：

   ```css
   .foo.foo {
   }
   #foo#foo {
   }
   [foo][foo] {
   }
   ```

   但是元素选择器却不能重复自身：因此，元素选择器无法像其他选择器那样通过重复自身提高优先级，不过好在由于其自身的一些特性，还有其他办法可以提高优先级。

   - 由于所有标准的 HTML 页面都有 html 和 body 元素，因此可以借助这些标签提高优先级：
   - 借助 :not() 伪类，括号里面是任意其他不一样的标签名称即可：

     ```css
     .foo:not(not-foo) {
     }
     .foo:not(a) {
     }
     .foo:not(_) {
     }
     ```

   上面两种提高优先级的方法均没有与其他选择器发生交集，是非常安全的方法，不会因为其他选择器发生变化而失效。

2. **级联使用的时候元素选择器必须写在最前面**

### 4.2 标签选择器优化

#### 4.2.1 标签选择器混合其他选择器的优化

很多开发者在使用属性选择器的时候习惯把标签选择器也带上，例如：

```css
input[type='radio'] {
}
```

实际上，这里的标签选择器是可以省略的，而且推荐省略。因此，很多原生属性是某些标签元素特有的。例如，radio 类型的单选框一定是 input 标签，因此，直接将它写成下面这样就可以了：

```css
[type='radio'] {
}
```

这样，选择器的优先级和类选择器保持一致，可维护性得到提高，同时性能也有提升。

#### 4.2.2 标签选择器与自定义元素

对于现代浏览器，我们可以直接使用自定义元素的标签控制自定义元素的样式，例如：

```html
<x-element>自定义元素</x-elememt>

<style>
x-element {
  color: red;
}
</style>
```

这样文字会呈现为红色。不过默认仅 IE9 及以上版本的浏览器才支持自定义元素标签选择器，如果需要兼容 IE8，需要在 `head` 创建如下所示的一段 JS 代码：

```html
<script>
  document.createElement('x-element');
</script>
```

### 4.3 特殊的标签选择器：通配选择器

通配选择器是一个特殊的标签选择器，它可以指代所有类型的标签元素，包括自定义元素，以及 script、style、title 等元素，但是不包括伪元素。

```css
* {
  box-sizing: border-box;
}
```

但上面的用法并不足以覆盖所有的元素，因为有些元素是无特征的，如 ::before 和 ::after 构成的伪元素，因此，很多人重置所有元素盒模型的时候会这样设置：

```css
*,
*::before,
*::after {
  box-sizing: border-box;
}
```

但后面两个星号是可以省略的，可以直接用：

```css
*,
::before,
::after {
  box-sizing: border-box;
}
```

当通配选择器和其他选择器级联使用的时候，星号都是可以省略的。只有当单独使用通配选择器的时候，才需要把 `*` 字符呈现出来。

由于通配选择器 `*` 匹配所有元素，因此它是比较消耗性能的一种 CSS 选择器，同时由于其影响甚广，容易出现一些意料之外的样式问题，因此请谨慎使用。

## 五. 属性选择器

平常提到的属性选择器指的是 [type="radio"] 这类选择器，实际上，这是一种简称，指的是 “属性值匹配选择器”。实际上，在正式文档中，类选择器和 ID 选择器都属于属性选择器，因为本质上类选择器是 HTML 元素中 class 的属性值，ID 选择器是 HTML 元素中 id 的属性值。

### 5.1 ID 选择器和类选择器

ID 选择器和类选择器都属于属性选择器，它们的身份看起来高贵而特殊，毕竟 HTML 原生属性那么多，就 id 和 class 两个属性有专门的选择器。实际上，正是因为它们足够普通才有此待遇，几乎所有的 HTML 元素都支持这两个属性。

ID 选择器和类选择器虽然性质一致，都属于属性选择器，但是它们的实际表现却有明显差异。

1. **语法不同**
   ID 选择器前面的字符是井号 `#`（U+0023），而类选择器前面的字符是点号 `.`（U+002E）。

2. **优先级不同**

   ID 选择器的优先级比类选择器的优先级高一个等级，由于实际开发中往往以类选择器为主，因此不到万不得已的时候不要使用 ID 选择器，以免带来较高的维护成本。

3. **唯一性与可重复性**

### 5.2 属性值直接匹配选择器

属性值直接匹配选择器包括下面 4 种：

```css
[attr]
[attr="val"]
[attr~="val"]
[attr|="val"]
```

1. `[attr]`
   [attr] 表示只要包含指定的属性就匹配，尤其适用于一些 HTML 布尔属性，这些布尔属性只要有属性值，无论值的内容是什么，都认为这些属性的值是 true。例如，下面所有的输入框的写法都是禁用的：

   ```html
   <input disabled />
   <input disabled="" />
   <input disabled="disabled" />
   <input disabled="true" />
   <input disabled="false" />
   ```

   此时，如果想用属性选择器判断输入框是否禁用，直接用下面的选择器就可以了，无须关心具体的属性值究竟是什么：

   ```css
   [disabled] {
   }
   ```

   说到 disabled,就不得不提另外一个常见的布尔属性 checked，两者看上去近似，实际上却有不小差异！

   checked 在浏览器下有一个很奇特的行为表现，那就是表单控件元素在 checked 状态变化的时候并不会同步修改 checked 属性的值，而 disabled 状态就不会这样。例如，已知 HTML 如下：

   ```html
   <input id="checkbox" type="checkbox" checked disabled />
   ```

   此时，使用 JS 代码修改复选框的状态：

   ```js
   checkbox.checked = false;
   checkbox.disabled = false;
   ```

   浏览器中的 HTML 会变成这样：

   ```html
   <input id="checkbox" type="checkbox" checked />
   ```

   disabled 消失了，但是 checked 属性却还在，也就是明明复选框已经取消了选择，但是 [checked] 依然在生效，这会导致严重的样式显示错误，因此实际开发不能使用 [checked] 进行状态控制，也正是由于这个原因，才有了 `:checked` 这些伪类。不仅原生属性支持属性选择器，自定义属性也是支持的。

2. `[attr="val"]`

   [attr="val"] 是属性值完全匹配选择器，例如，匹配单复选框：

   ```css
   [type='radio']
   [type='checkbox']
   ```

   **其他注意事项**

   1. 不区分单引号和双引号，单引号和双引号都是合法的。
   2. 引号是可以省略的。如果属性值包含空格，则需要转义。
   3. 有如下 HTML：

      ```html
      <input value="20" />
      ```

      此时，下面的选择器是可以匹配的，IE8 及以上版本的浏览器都没问题：

      ```css
      [value='20']
      ```

      此时，如果改变输入框的值为 10,无论是手动输入还是使用 JS 更改，属性选择器都依然按照 [value="20"] 渲染。除非，使用 setAtribute 方法改变属性值：

3. `[attr~="val"]`

   [attr~="val"] 是属性值单词完全匹配选择器，专门用来匹配属性中的单词，其中，`~=` 用来连接属性和属性值。有些属性值（如 class 属性、rel 属性或者一些自定义属性）包含多个关键词，这时可以使用空格分隔这些关键词，例如：

   ```html
   <a href rel="nofollow noopener">链接</a>
   ```

   此时就可以借助该选择器实现匹配，例如：

   ```css
   [rel~="noopener"]
   [rel~="nofollow"]
   ```

   匹配的属性值不能是空字符串。如果匹配的属性值只是部分字符串，那么也是无效的。另外，属性值单词完全匹配选择器对非 ASCII 范围的字符（如中文）也是有效的。

4. `[attr|="val"]`

   `[attr|="val"]` 是属性值起始片段完全匹配选择器，表示具有 attr 属性的元素，其值要么正好是 val，要么以 val 外加短横线-（U+002D）开头，用于连接需要匹配的属性和属性内容。

   ```html
   <!--匹配-->
   <div attr="val"></div>
   <!-1-匹配-->
   <div attr="val-ue"></div>
   <!--匹配-->
   <div attr="val-ue bar"></div>
   <!--不匹配-->
   <div attr="value"></div>
   <!--不匹配-->
   <div attr="val bar"></div>
   <!--不匹配-->
   <div attr="bar val-ue"></div>
   ```

   可以看到，这个选择器必须严格遵循开头匹配的规则。另外，这个选择器设计的初衷是子语言匹配，用在 a 元素的 hreflang 属性或者任意元素的 lang 属性中。例如，同样是中文，它们也会有简体中文和繁体中文的差异，最新的标记如下：

   - 简体中文有 zh-cmn-Hans;
   - 繁体中文有 zh-cmn-Hant;
   - 英文则有 en-US、en-Latn-US、en-GB 等。

   于是，就可以借助该选择器来匹配中文类或英文类语言，这在多语言功能实现时比较有用：

   ```css
   /* 匹配中文类语言 */
   [lang|="zh"]
   /* 匹配英文类语言 */
   [lang|="en"]
   ```

   由于大多数的 Web 开发都用不到多语言，因此该选择器平时很少用到；再加上 `:lang` 伪类的存在，进一步减少了 lang 属性匹配语言的出场机会，更多的是匹配 hreflang 属性中的语言设置。

   其实，只要 HTML 的属性值是以短横线连接的，都可以使用该属性选择器，例如：

   ```html
   <!--旧语法-->
   <input type="datetime" />
   <!--新语法，推荐-->
   <input type="datetime-local" />
   <style>
     [type|='datetime'] {
     } /* 新旧语法全兼容 */
   </style>
   ```

#### 5.2.2 AMCSS 开发模式简介

AMCSS 是 Attribute Modules for CSS 的缩写，表示借助 HTML 属性来进行 CSS 相关开发。

目前主流的开发模式是多个模块由多个类名控制，例如：

```html
<button class="cs-button cs-button-large cs-button-blue">按钮</button>
```

而 AMCSS 则是基于属性控制的，例如：

```html
<button button="large blue">按钮</button>
```

为了避免属性名称冲突，可以给属性添加一个统一的前缀，如 am-，于是有：

```html
<button am-button="large blue">按钮</button>
```

然后借助 [attr~="val"] 这个属性值单词匹配选择器进行匹配。因此，主流类选择器

```txt
button
button-large
button-blue
```

可以转换成

```css
[am-button]
[am-button~="large"]
[am-button~="blue"]
```

这种开发模式的优点是：每个属性有效地声明了一个单独的命名空间，用于封装样式信息，从而产生更易于阅读和维护的 HTML 和 CSS。当布局或样式需要有一个专门的命名空间的时候，就采用 AMCSS 这种开发模式。而对于普通的定位与布局，还是采用类选择器最为合适。

### 5.3 属性值正则匹配选择器

属性值正则匹配选择器包括下面 3 种：

```css
[attr^="val"]
[attr$="val"]
[attr*="val"]
```

这 3 种属性选择器就完全是字符匹配了，而非单词匹配。其中，尖角符号 `^`、美元符号 `$` 以及星号 `*` 都是正则表达式中的特殊标识符，分别表示前匹配、后匹配和任意匹配。这几个选择器的兼容性不错，IE7 及以上版本的浏览器均支持。

#### 5.3.1 详细了解 3 种选择器

1. `[attr^="val"]`

   [attr~="val"] 表示匹配 attr 属性值以字符 val 开头的元素。

   **细节**
   这种选择器可以匹配中文，如果匹配的中文没有包含特殊字符，如空格等，则中文外面的引号是可以省略的。

   实际开发中，开头正则匹配属性选择器用得比较多的地方是判断 a 元素的链接地址类型，也可以用来显示对应的小图标。

2. `[attr$="val"]`

   `[attr$="val"]` 表示匹配 attr 属性值以字符 val 结尾的元素。

   在实际开发中，结尾正则匹配属性选择器用得比较多的地方是判断 a 元素的链接的文件类型，然后是显示对应的小图标。

3. `[attr*="val"]`

   [attr*="val"] 表示匹配 attr 属性值包含字符 val 的元素。它也可以用来匹配链接元素是否是外网地址，例如：

   ```css
   a[href*="//"]: not([href * = 'example.com' ]);
   ```

   此外，它还可以用来匹配 style 属性值，这在实际开发中用得非常多。例如，想知道一个参与 JS 交互的元素是否隐藏，可以这么处理：

   ```css
   /* 该元素隐藏 */
   [style*="display:none"]
   ```

#### 5.3.2 CSS 属性选择器搜索过滤技术

可以借助属性选择器来辅助实现搜索过滤效果，如通讯录、城市列表，这样做性能高，代码少。HTML 结构如下：

```html
<input type="search"placeholder="输入城市名称或拼音" />
<li data-search="重庆市chongqing">重庆市</li>
<li data-search="哈尔滨市haerbin">哈尔滨市<//i>
<li data-search="长春市changchun">长春市<//i>
```

此时，当在输入框中输入内容的时候，只要根据输入内容动态创建一段 CSS 代码就可以实现搜索匹配效果了，无须自己写代码进行匹配验证。

```js
let eleStyle = document.createElement('style');
document.head.appendChild(eleStyle);
// 文本框输入
input.addEventListener('input', () => {
  let value = this.value.trim();
  eleStyle.innerHTML = value ? `[data-search]:not([data-search*="${value}"]){display:none;};";` : '';
});
```

### 5.4 忽略属性值大小写的正则匹配运算符

正则匹配运算符是属性选择器新增的运算符，它可以忽略属性值大小写，使用字符 i 或 I 作为运算符值，但约定俗成都使用小写字母 i 作为运算符。语法如下：

```css
[attr~='val' i] {
}
```

作用对比示意，假设有选择器 [attr*="val"]，则：

```html
<!--不匹配-->
<div attr="VAL"></div>
<!--匹配-->
<div attr="Textval"></div>
<!--不匹配-->
<div attr="Val-ue"></div>
```

如果选择器是 [attr*="val"i]，则：

```html
<!--匹配-->
<div attr="VAL"></div>
<!--匹配-->
<div attr="Textval"></div>
<!--匹配-->
<div attr="Val"></div>
```

可以看到，属性值的大小写被完全无视了。属性值大小写不敏感运算符目前在移动端可以放心使用，尤其在搜索匹配用户昵称或者账户名的时候非常有用，因为用户昵称大小写字母混杂的场景非常常见。

## 六. 用户行为伪类

用户行为伪类是指与用户行为相关的一些伪类，例如，:hover、:active 以及 :focus 等。

### 6.1 手型经过伪类 `:hover`

`:hover` 是各大浏览器最早支持的伪类之一，最早只能用在 a 元素上，目前可以用在所有 HTML 元素上，包括自定义元素。

:hover 不适用于移动端，虽然也能触发，但消失并不敏捷，体验反而奇怪。

:hover 在桌面端网页很常用，例如鼠标经过时改变链接的颜色，或者改变按钮的背景色等。除了这个基本用法，还可以利用 `:hover` 伪类实现 Tips 提示或者下拉列表效果。

#### 6.1.2 非子元素的 :hover 显示

当借助 :hover 伪类实现下拉列表效果的时候，可以通过父子选择器控制的。例如：

```css
.datalist {
  display: none;
}
.datalist-x:hover .datalist {
  display: block;
}
```

然而实际开发的时候，有时候并不方便嵌套标签，此时，也可以借助相邻兄弟选择符实现类似的效果。比如，实现一个鼠标经过链接来预览图片的交互效果。

```html
<a href=>图片链接</a>
<img src="1.jpg" />
```

目标是鼠标经过链接的时候图片一直保持显示，CSS 代码：

```css
img {
  display: none;
}
a:hover + img,
img:hover {
  /* 产鼠标经过链接或鼠标经过图片，图片自身都保持显示 */
  display: inline;
}
```

然而，上面的实现有一个缺陷，那就是如果浮层图片和触发 hover 的链接元素中间有间隙，则鼠标还没有移动到图片上，图片就隐藏起来，导致图片无法持续显示。可以借助 CSS transition 增加延时。

由于 transition 属性对 display 无过渡效果，而对 visibility 有过渡效果，因此，图片默认隐藏需要改成 visibility:hidden，CSS 代码如下：

```css
img {
  /* 拉开间隙 */
  margin-left: 20px;
  visibility: hidden;
  /* 设置延时 */
  transition: visibility 0.2s;
}
a:hover + img,
img:hover {
  visibility: visible;
}
```

### 6.2 激活状态伪类 :active

#### 6.2.1 :active 伪类概述

`:active` 伪类可以用于设置元素激活状态的样式，可以通过点击鼠标主键，也可以通过手指或者触控笔点击触摸屏触发激活状态。:active 伪类支持任意的 HTML 元素，甚至是自定义元素。

然而，落地到实践，:active 伪类并没有理论上那么完美，包括以下几点：

1. IE 浏览器下 :active 样式的应用是无法冒泡的，例如：

   ```css
   img:active {
     outline: 30px solid #ccc;
   }
   p:active {
     background-color: teal;
   }
   ```

   此时，点击 img 元素的时候，在 IE 浏览器下，p 元素是不会触发 :active 伪类样式的，实际上祖先元素的 :active 样式也应当被应用。在 Chrome 以及 Firefox 等浏览器下，其表现符合预期。

2. 在 IE 浏览器下，html、body 元素应用 :active 伪类设置背景色后，背景色是无法还原的。

   具体来说就是，鼠标按下确实应用了 :active 设置的背景色，但是鼠标抬起后背景色却没有还原，而且此时无论怎么点击鼠标，背景色都无法还原。这是一个很奇怪的 bug，普通元素不会有此问题。

3. 移动端 Safari 浏览器下，:active 伪类默认是无效的，需要设置任意的 touch 事件才支持。

    可以加这么一行 JS 代码：

    ```js
    documentbody.addEventListener('ontouchstart', function () {});
    ```

    然而，虽然此时 :active 伪类可以生效了，但是 :active 样式应用的时机还是有问题，因此，如果对细节的要求比较高，建议在 Safari 浏览器下还是使用原生的 -webkit-tap-highlight-color 实现触摸高亮反馈更好：

    ```css
    body {
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0.5);
    }
    ```

4. 键盘访问无法触发 :active 伪类。例如，a 元素在 focus 状态下按下 Enter 键的事件行为与点击一致，但是，不会触发 :active 伪类。

5. :active 伪类的主要作用是反馈点击交互，让用户知道他的点击行为已经成功触发，这对于按钮和链接元素是必不可少的，否则会有体验问题。由于 :active 伪类作用在按下的那一段时间，因此不适合用来实现复杂交互。
