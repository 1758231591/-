# CSS 选择器

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

## 一. 概述

CSS 选择器本身很简单，就是一些特定的选择符号，于是，很多开发者就认为 CSS 选择器的世界很简单，没什么好学的。实际上，CSS 选择器非常强大，它不
仅涉及视觉表现，而且与用户安全、用户体验有非常密切的联系。

### 1.1 为什么 CSS 选择器很强

CSS 选择器能够做的事情远比预想的多得多。CSS 是为样式服务的，它重表现，轻逻辑，如同人的思想一样，相互碰撞才能产生火花。尤其对于 CSS 选择器，它作为 CSS 世界的支柱，与 HTML 结构、浏览器行为、用户行为以及整个 CSS 世界相互依存、相互作用，这必然会产生很多碰撞，让 CSS 选择器变得非常强悍。同时，CSS 选择器本身也并非那么单纯。

### 1.2 CSS 选择器世界的一些基本概念

平常所说的 CSS 选择器实际上是一个统称，是很多基本概念的集合，有必要先了解一下这些基本概念。

#### 1.2.1 选择器、选择符、伪类和伪元素

CSS 选择器可以分为 4 类，即选择器、选择符、伪类和伪元素。

1. **选择器**
   这里的 “选择器” 指的就是平常使用的 CSS 声明块前面的标签、类名等。

2. **选择符**

   CSS 选择器中的选择符有 5 个，分别如下：

   ```css
   /* 后代关系 */
   .container img {
     object-fit: cover;
   }
   /*父子关系*/
   ol > li {
     margin: 5em 0;
   }
   /* 相邻兄弟关系 */
   button + button {
     margin-left: 10px;
   }
   /* 后续兄弟关系 */
   button ~ button {
     margin-left: 10px;
   }
   /*列*/
   .col||td {
     background-color: skyblue;
   }
   ```

   关于选择符的更多知识可以参见第 4 章。<!--TODO-->

3. **伪类**

   伪类的特征是其前面会有一个冒号 `:`，通常与浏览器行为和用户行为相关联，可以看成是 CSS 世界的 JS。伪类和选择符相互配合可以实现非常多的纯 CSS 交互效果。

4. **伪元素**

   伪元素的特征是其前面会有两个冒号 `:`，常见的有 `::before`、`::after`、`::first-letter` 和 `::first-line` 等。

#### 1.2.2 CSS 选择器的作用域

以前 CSS 选择器只有一个全局作用域，也就是在网页任意地方的 CSS 都共用一个文档上下文。

如今 CSS 选择器是有局部作用域的概念的。伪类 `:scope` 的设计初衷就是匹配局部作用域下的元素。例如，对于下面的代码：

```html
<section>
  <style scoped>
    p {
      color: blue;
    }
    :scope {
      background-color: red;
    }
  </style>
  <p>在作用域内，背景色应该红色。</p>
</section>
<p>在作用域外，默认背景色。</p>
```

理论上，section 标签里面的 p 元素的背景色应该是红色，但目前没有任何浏览器表现为红色。因为目前尚无一种方法来显式建立作用域元素，所以**在样式表中使用时 `:scope` 等效于 `:root`**。但是，它在 JS 中还是有效的，这一点将在 12.1.1 <!--TODO--> 节中进一步展开介绍。

另外，CSS 选择器的局部作用域在 Shadow DOM 中也是有效的。例如，有一个 div 元素：

```html
<div id="hostElement"></div>
```

然后使用 Shadow DOM 为这个 div 元素创建一个 p 元素并且控制其背景色的样式，如下：

```js
// 创建 Shadow DOM
var shadow = hostElement.attachShadow({ mode: 'open' });
// 给 Shadow DOM 添加文字
shadow.innerHTML = '<p>我是由Shadow DOM创建的&ltp&gt元素，我的背景色是？</p>';
// 添加 CSS，p 标签背景色变成黑色
shadow.innerHTML += '<style>p{background-color:#333;color:#fff;}</style>';
```

Shadow DOM 创建的 p 元素的背景色是黑色，而页面原本的 p 元素的背景色不受任何影响。

#### 1.2.3 CSS 选择器的命名空间

CSS 选择器中还有一个命名空间（namespace）的概念。命名空间可以让来自多个 XML 词汇表的元素的属性或样式彼此之间没有冲突，它的使用非常常见，例如 SVG 文件的命名空间：

```css
<svg xmlns="http://www.w3.org/2000/svg" />
```

上述代码中的 xmlns 属性值对应的 URL 地址就是一个简单的命名空间名称，其并不指向实际的在线地址，浏览器不会使用或处理这个 URL。

在 CSS 选择器世界中命名空间的作用也是避免冲突。例如，在 HTML 和 SVG 中都会用到 a 链接，此时就可能发生冲突，可以借助命名空间进行规避，具体方法是，使用 `@namespace` 规则声明命名空间：

```css
@namespace url(http://www.w3.org/1999/xhtml);
@namespace svg url(http://www.w3.org/2000/svg);
/* XHTML中的 <a> 元素 */
a {
}
/* SVG 中 <a> 元素 */
svg|a {
}
/* 同时匹配 XHTML 和 SVG 的 <a> 元素 */
*|a {
}
```

> **注意**：上述 CSS 代码中的 svg 也可以换成其他字符，这里的 svg 并不是表示 svg 标签的意思。

通过一个实际案例来直观地了解一下 CSS 选择器的命名空间。HTML 和 CSS 代码如下：

```html
<p>这是文字：<a href>点击刷新</a></p>
<p>
  这是SVG:
  <svg>
    <a xlink:href><path d="..." /></a>
  </svg>
</p>

<style>
  @namespace 'http://www.w3.org/1999/xhtml';
  @namespace svg 'http://www.w3.org/2000/svg';
  svg|a {
    color: black;
    fill: currentColor;
  }
  a {
    color: gray;
  }
</style>
```

svg|a 中有一个管道符 `|`，管道符前面的字符表示命名空间的代称，管道符后面的内容则是选择器。本例的代码表示在 http://www.w3.org/2000/svg 这个命名空间下所有 a 的颜色都是 black，由于 xhtml 的命名空间也被指定了，因此 SVG 中的 a 就不会受标签选择器 a 的影响，即便纯标签选择器 a 的优先级再高也无效。

CSS 选择器命名空间的兼容性很好，至少 10 年前浏览器就已支持，但是，却很少见人在项目中使用它，原因有二：

- 在 HTML 中直接内联 SVG 的应用场景并不多，它更多的是作为独立的 SVG 资源使用，即使内联，也很少有需要对特性 SVG 标签进行样式控制的需求
- 有其他更简单的替代方案

例如，如果希望 SVG 中所有的 a 元素的颜色都是 black，可以直接用：

```css
svg a {
  color: black;
}
```

无须掌握复杂的命名空间语法就能实现想要的效果，这样做的唯一缺点就是增加了 SVG 中 a 元素的优先级，但是在大多数场景下，这对实际开发没有任何影响。综合来看，这是一种性价比高很多的实现方式，几乎找不到需要使用命名空间的理由。

### 1.3 无效 CSS 选择器特性与实际应用

很多 CSS 伪类选择器是最近几年才出现的，浏览器并不支持，浏览器会把这些选择器当作无效选择器，这是没有任何问题的。但是当这些无效的 CSS 选择器和浏览器支持的 CSS 选择器写在一起的时候，会导致整个选择器无效，举个例子，有如下 CSS 代码：

```css
.example:hover,
.example:active,
.example:focus-within {
  color: red;
}
```

`:hover` 和 `:active` 是浏览器很早就支持的两个伪类，但是，由于 IE 浏览器并不支持 `:focus-within` 伪类，会导致 IE 浏览器无法识别整个语句，这就是无效 CSS 选择器特性。

因此，在使用一些新的 CSS 选择器时，出于渐进增强的目的，需要将它们分开书写：

```css
/* IE 浏览器可识别 */
.example:hover,
.example:active {
  color: red;
}
/* IE 浏览器不可识别 */
.example:focus-within {
  color: red;
}
```

不过，在诸多 CSS 选择器中，这种无效选择器特性出现了一个例外，那就是浏览器可以识别以 -webkit- 私有前缀开头的伪元素。

```css
span::-webkit-whatever {
  background: gray;
}
```

除了 IE 浏览器，其他浏览器均支持（Firefox63 及以上版本支持）识别这个 -webkit- 无效伪元素的特性。于是，就可以灵活运用这种特性来帮助完成实际开发。例如，对 IE 浏览器和其他浏览器进行精准区分：

```css
/* IE浏览器 */
.example {
  background: black;
}
/* 其他浏览器 */
.example::-webkit-whatever {
  background: gray;
}
```

当然，上面的无效伪类会导致整行选择器失效的特性也可以用来区分浏览器。

## 二. CSS 选择器的优先级

几乎所有的 CSS 样式冲突、样式覆盖等问题都与 CSS 声明的优先级错位有关。因此，在详细阐述 CSS 选择器的优先级规则之前，先快速了解一下 CSS 全部的优先级规则。

### 2.1 CSS 优先级规则概览

CSS 优先级有着明显的不可逾越的等级制度，其可以划分为 0~5 这 6 个等级，其中前 4 个等级由 CSS 选择器决定，后 2 个等级由书写形式和特定语法决定。

1. 0 级：通配选择器、选择符和逻辑组合伪类

   通配选择器写作星号 `*`。选择符指 `+`、`>`、`~`、`空格`和 `||`。逻辑组合伪类有 `:not()`、`:is()` 和 `:where` 等，这些伪类本身并不影响 CSS 优先级，影响优先级的是括号里面的选择器。

   > **注意**：只有逻辑组合伪类的优先级是 0，其他伪类的优先级并不是这样的。

2. 1 级：标签选择器

3. 2 级：类选择器、属性选择器和伪类

4. 3 级：ID 选择器

5. 4 级：style 属性内联

6. 5 级：!important

> !important 是顶级优先级，可以重置 JS 设置的样式，唯一推荐使用的场景就是使 JS 设置无效。对于其他场景，没有任何使用它的理由，切勿滥用。

不难看出，CSS 选择器的优先级（0 级至 3 级）属于 CSS 优先级的一部分，也是最重要、最复杂的部分，学会 CSS 选择器的优先级等同于学会了完整的 CSS 优先级规则。

### 2.2 深入 CSS 选择器优先级

#### 2.2.1 CSS 选择器优先级的计算规则

对于 CSS 选择器优先级的计算，业界流传甚广的是数值计数法。具体如下：

每一段 CSS 语句的选择器都可以对应一个具体的数值，数值越大优先级越高，其中的 CSS 语句将被优先渲染。其中，出现一个 0 级选择器，优先级数值 +0；出现一个 1 级选择器，优先级数值 +1；出现一个 2 级选择器，优先级数值 +10；出现一个 3 级选择器，优先级数值 +100。

1. 增加 CSS 选择器优先级的小技巧

   实际开发时，难免会遇到需要增加 CSS 选择器优先级的场景。例如，希望增加下面 .foo 类名选择器的权重：

   ```css
   foo {
     color: #333;
   }
   ```

   很多人的做法是增加嵌套，或者是增加一个标签选择器。但这些都不是最好的方法，因为这些方法增加了藕合，降低了可维护性。这里给大家介绍一个增加 CSS 选择器优先级的小技巧，那就是**重复选择器自身**。例如，可以像下面这样做，既提高了优先级，又不会增加藕合，实在是上上之选：

   ```css
   .foo.foo {
   }
   ```

   如果实在不喜欢这种写法，借助必然会存在的属性选择器也是不错的方法。

2. 对数值计数法的点评

   上面提到的 CSS 选择器优先级数值的计数法实际上是一个不严谨的方法，因为 1 和 10 之间的差距实在太小了，这也就意味着连续 10 个标签选择器的优先级就和 1 个类名选择器齐平了。然而事实并非如此，不同等级的选择器之间的差距是无法跨越的存在。但由于在实际开发中，是不会连续写上多达 10 个选择器的，因此不会影响在实际开发过程中计算选择器优先级。

   而且对于使用 CSS 选择器而言，书写习惯远比知识更重要，就算理论知识再扎实，如果平时书写习惯糟糕，也无法避免 CSS 样式覆盖问题、样式冲突等问题的出现。将在第 3 章中深入探讨这个问题<!--TODO-->。

**256 个选择器的越级现象**
实际上，在过去，Chrome 浏览器、Firefox 浏览器下都出现过 256 个选择器的优先级大于上一个选择器级别的现象，后来，大约 2015 年之后，Chrome 浏览器和 Firefox 浏览器都修改了策略，使得再多的选择器的优先级也无法超过上一级，因此，目前越级现象仅在 IE 浏览器中可见。

为什么会有这种有趣的现象呢？早些年查看 Firefox 浏览器的源代码，发现所有的类名都是以 8 字节字符串存储的，8 字节所能容纳的最大值就是 255，因此同时出现 256 个类名的时候，势必会越过其边缘，溢出到 D 区域。而现在采用了 16 字节的字符串存储，能容纳的类型数量足够多了，就不会出现这种现象。

## 三. CSS 选择器的命名

CSS 选择器的命名问题是最常困扰开发者的事情之一。究竟是面向 CSS 属性命名，还是面向 HTML 语义命名？是使用长命名，还是使用短命名？

### 3.1 CSS 选择器是否区分大小写

CSS 选择器有些区分大小写，有些不区分大小写，还有些可以设置为不区分。要搞清楚 CSS 选择器是否区分大小写的问题，还要从 HTML 说起。

在 HTML 中，标签和属性都是不区分大小写的，而属性值是区分大小写的。于是，相对应地，在 CSS 中，标签选择器不区分大小写，属性选择器中的属性也不区分大小写，而类选择器和 ID 选择器本质上是属性值，因此要区分大小写。

然而，随着各大浏览器支持属性选择器中的属性值也不区分大小写（在 `]` 前面加一个 i），已经没有严格意义上的对大小写敏感的选择器了，因为类选择器和 ID 选择器本质上也是属性选择器，因此，如果希望 HTML 中的类名对大小写不敏感，可以这样：

```css
P {
  padding: 10px;
  background-color: black;
}
[CLASS] {
  color: white;
}
[CLASS~='CONTENT' i] {
  text-decoration: line-through;
}
```

更多关于属性选择器大小写敏感的内容参见第 6 章。<!--TODO-->

### 3.2CSS 选择器命名的合法性

这里主要讲一下类选择器和 ID 选择器的命名合法性问题，旨在纠正大家长久以来的错误认识。什么错误认识呢？最常见的就是类名选择器和 ID 选择器不能以数字开头，如下：

```css
.1-foo {
  border: 10px dashed;
  padding: 10px;
} /* 无效 */
```

对，上面这种写法确实无效，但这并不是因为不能以数字开头，而是不能直接写数字，需要将其转义一下，如下：

```css
.\31 -foo {
  border: 10px dashed;
  padding: 10px;
}
```

此时，下面的 HTML 就表现为黑底白字：

```html
<span class="1-foo">颜色是？</span>
```

为什么会有这么奇怪的表示？居然表示成 \31，而且后面还有一个空格！

其实 \31 外加空格是 CSS 中字符 1 的十六进制转码表示，也可以省略空格。其中 31 就是字符 1 的 Unicode 值，如下：

```js
console.log('1'.charCodeAt().toString(16)); // 结果是 31
```

字符 0 的 Unicode 值是 30，字符 9 的 Unicode 值是 39，0~9 这 10 个数字对应的 Unicode 值正好是 30~39。也可以用以下这种方法进行表示：

```css
.\000031-foo {
  border: 10px dashed;
  padding: 10px;
}
```

31 前面用 4 个 0 进行补全，这样 31 后面就不用加空格。类名或者 ID 甚至可以是纯数字。
