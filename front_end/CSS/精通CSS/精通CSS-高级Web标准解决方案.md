---
title: 精通CSS-高级Web标准解决方案
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [精通 CSS-高级 Web 标准解决方案](#精通-css-高级-web-标准解决方案)
  - [一. 基础知识](#一-基础知识)
    - [1.1 组织代码](#11-组织代码)
      - [1.1.1 可维护性](#111-可维护性)
      - [1.1.2 HTML 简史](#112-html-简史)
      - [1.1.3 渐进增强](#113-渐进增强)
    - [1.2 创建结构化、语义化富 HTML](#12-创建结构化-语义化富-html)
      - [1.2.1 ID 和 c1ass 属性](#121-id-和-c1ass-属性)
      - [1.2.2 结构化元素](#122-结构化元素)
      - [1.2.3 div 和 span](#123-div-和-span)
      - [1.2.4 重新定义的表现性文本元素](#124-重新定义的表现性文本元素)
      - [1.2.5 扩展 HTML 语义](#125-扩展-html-语义)
      - [1.2.6 验证](#126-验证)
  - [二. 添加样式](#二-添加样式)
    - [2.1 CSS 选择符](#21-css-选择符)
    - [2.2 层叠](#22-层叠)
    - [2.3 特殊性](#23-特殊性)
      - [2.3.1 利用层叠次序](#231-利用层叠次序)
      - [2.3.2 控制特殊性](#232-控制特殊性)
    - [2.4 继承](#24-继承)
    - [2.5 为文档应用样式](#25-为文档应用样式)
      - [2.5.1 link 与 style 元素](#251-link-与-style-元素)
      - [2.5.2 性能](#252-性能)
  - [三. 可见格式化模型](#三-可见格式化模型)
    - [3.1 盒模型](#31-盒模型)
      - [3.1.1 盒子大小](#311-盒子大小)
      - [3.1.2 最大值和最小值](#312-最大值和最小值)
    - [3.2 可见格式化模型](#32-可见格式化模型)
      - [3.2.1 匿名盒子](#321-匿名盒子)
      - [3.2.2 外边距折叠](#322-外边距折叠)
      - [3.2.3 包含块](#323-包含块)
      - [3.2.4 相对定位](#324-相对定位)
      - [3.2.5 绝对定位](#325-绝对定位)
      - [3.2.6 固定定位](#326-固定定位)
      - [3.2.7 浮动](#327-浮动)
      - [3.2.8 格式化上下文](#328-格式化上下文)
      - [3.2.9 内在大小与外在大小](#329-内在大小与外在大小)
    - [3.3 其他 CSS 布局模块](#33-其他-css-布局模块)
      - [3.3.1 弹性盒布局](#331-弹性盒布局)
      - [3.3.2 网格布局](#332-网格布局)
    - [3.3.3 多栏布局](#333-多栏布局)
    - [3.4 Region](#34-region)
  - [四. 网页排版](#四-网页排版)
    - [4.1 CSS 的基本排版技术](#41-css-的基本排版技术)
      - [4.1.1 文本颜色](#411-文本颜色)
      - [4.1.2 字体族](#412-字体族)
      - [4.1.3 字型大小与行高](#413-字型大小与行高)
      - [4.1.4 行间距、对齐及行盒子的构造](#414-行间距-对齐及行盒子的构造)
    - [4.1.5 文本粗细](#415-文本粗细)
      - [4.1.6 字体样式](#416-字体样式)
      - [4.1.7 大小写变换和小型大写变体](#417-大小写变换和小型大写变体)
      - [4.1.8 控制字母和单词间距](#418-控制字母和单词间距)
    - [4.2 版心宽度、律动和毛边](#42-版心宽度-律动和毛边)
      - [4.2.1 文本缩进与对齐](#421-文本缩进与对齐)
      - [4.2.2 连字符](#422-连字符)
      - [4.2.3 多栏文本](#423-多栏文本)
    - [4.3 Web 字体](#43-web-字体)
      - [4.3.1 许可](#431-许可)
      - [4.3.2 @font-face 规则](#432-font-face-规则)
      - [4.3.3 Web 字体、浏览器与性能](#433-web-字体-浏览器与性能)
      - [4.3.4 使用 JS 加载字体](#434-使用-js-加载字体)
    - [4.4 高级排版特性](#44-高级排版特性)
      - [4.4.1 数字](#441-数字)
      - [4.4.2 字距选项及文本渲染](#442-字距选项及文本渲染)
    - [4.5 文本特效](#45-文本特效)
      - [4.5.1 合理使用文本阴影](#451-合理使用文本阴影)
      - [4.5.2 使用 JS 提升排版品质](#452-使用-js-提升排版品质)

<!-- /code_chunk_output -->

# 精通 CSS-高级 Web 标准解决方案

## 一. 基础知识

### 1.1 组织代码

层叠样式表（CSS，cascading style sheets）的技术和概念，必须以结构良好且有效的 HTML 文档为前提。

#### 1.1.1 可维护性

可维护性可以说是所有优秀代码最重要的特点。相对来说，CSS 是随着代码量增加而最难保持可维护性的语言之一。现代编程语言都有内置的变量、函数和命名空间等特性，这些特性都有利于保持代码的结构和格式化。这些特性 CSS 都没有，所以要按照使用这种语言和组织代码的特殊方式来管理它。

#### 1.1.2 HTML 简史

Tim Berners-Lee 在 1990 年发明了 HTML，当时是为了规范科研文档的格式。HTML 是一种简单的标记语言，为文本赋予了基本的结构和意义，比如标题、列表、定义等。这些文档通常没有什么装饰性的元素，可以方便地通过计算机来检索，而人类可以使用文本终端、Web 浏览器，或者必要时使用屏幕阅读器来阅读它们。

然而，人类是视觉发达的生物。随着万维网被越来越多的人所接受，HTML 也逐渐增加了对展示效果的支持。除了用标题元素标记文档标题，还可以使用粗体标签和不同的字体来创建特殊的视觉效果。本来用于展示数据的表格（tab1e），却成了页面布局的手段；块引用（blockquote）也经常被用来缩进文本，而不是只用来标记引文。HTML 很快就偏离了为内容赋予结构和意义的初衷，变成了一堆字体和表格标签。Web 设计者给这种标记起了个名字，叫 “标签汤”。

正当 Web 变得一团糟之际，CSS 作为解决方案面世了。CSS 的初衷是把跟 HTML 混在一起的表现性标记提取出来，使其自成体系，达到结构与表现分离的目的。这就让有意义的标签或者说语义悄悄返回了 HTML 文档。font 之类的表现性标签可以不用了，而表格布局也可以被逐步取代。对大多数网站而言，CSS 都能提升其可访问性和加载速度。不仅如此，CSS 还给 Web 设计和开发人员带来了更多好处：

- 一种专用于控制视觉样式和布局的语言
- 在同一网站中更易于重用的样式
- 通过关注点分离得到了良好的代码结构

---

**关注点分离**
关注点分离（separation of concerns）是软件开发行业的一个常见概念。对 Web 开发而言，关注点分离不仅适用于标记和样式，同样也适用于编写样式的方式。事实上，**关注点分离也是确保代码可维护性的一种主要方法**。

Unix 开发社区有一句话很好地诠释了**关注点分离的思想，即 “分成小块，松散结合”**（small pieces，loosely joined）。其中，每一 “小块” 都是一个模块，专注于做好一件事。而且，因为这个模块跟其他组件是 “松散结合” 的，所以它可以方便地在系统的其他部分中重用。Unix 中的一 “小块” 可能是一个字数统计函数，可以应用于传入的任何文本片段。而在 Web 开发中，这一 “小块” 可能就是一个商品列表组件，如果能做到 “松散结合”，就可以在一个网站的多个页面或者在同一布局的不同区块中重用。

可以把代码中的这些 “小块” 想象成积木。每一块积木都很简单，但把很多块积木以不同方式组装起来，就可以创造出无比复杂的东西。

---

**HTML 和 CSS 的版本**
CSS 有很多版本，或者 “级别”。了解这些版本产生的背景，有助于了解应该或不应该使用哪些 CSS 特性。万维网联盟（W3C，World Wide Web Consortium）是制定 Web 技术标准的组织，该组织制定的每一个规范要经历几个阶段之后才能成为 W3C 推荐标准。CSS1 是在 1996 年底成为 W3C 推荐标准的，当时只包含字体、颜色和外边距等基本的属性。CSS2 在 1998 年成为推荐标准，增加了浮动和定位等高级特性，此外还有子选择符、相邻选择符和通用选择符等新选择符。

相比之下，CSS3 则采用了完全不同的模式。实际上不存在所谓的 CSS3 规范，因为 CSS3 指的是一系列级别独立的模块。如果规范模块是对之前 CSS 概念的改进，那就从 3 级开始命名。如果不是改进，而是一种全新的技术，那就从 1 级开始命名。而 CSS3，则是指所有足够新的 CSS 规范模块，比如 CSS Backgrounds and Borders Level3、Selectors level4 和 CSS Grid Layout Level 1。这种模块化的方式可以让不同的规范有自己的演进速度。有些 3 级规范，比如 CSS Color level3，已经成为推荐标准。而另外一些可能还处于候选推荐阶段，很多甚至还处于工作草案阶段。

虽然 CSS3 的制定工作在 CSS2 发布后就开始了，但这些新规范一开始的制定速度很缓慢。为此，W3C 在 2002 年发布了 CSS2 Revision 1。CSS 2.1 修正了 CSS2 中的一些错误，删掉了支持度不高或者并非所有浏览器都实现了的一些特性，总体来说就是把 CSS 规范做了一番清理，好为浏览器实现提供更精准的蓝图。CSS 2.1 在 2011 年 6 月成为推荐标准，此时距离 CSS3 启动已经有 10 多年了。由此可见，标准制定主体和浏览器开发商为了确保相应的特性得以原原本本地实现，需要花多么长的时间。不过，浏览器开发商经常会在标准还处于草案阶段时，就发布一些实验性的实现。这样，等到了候选推荐阶段，相应的实现就已经非常稳定了。换句话说，很多 CSS 特性早在相应模块成为推荐标准前就可以使用了。

HTML 的历史也很复杂。HTML4.01 在 1999 年成为推荐标准，与此同时 W3C 也把注意力转向了 XHTML1.0。本来接着要发布 XHTML1.1，但其严格程度在实践中暴露了无法落地的问题，最终被 Web 开发社区抛弃。于是，这个 Web 主要语言的发展停滞了。

2004 年，有几家公司共同组建了 Web 超文本应用技术工作组（WHATWG， Web Hypertext Application Technology Working Group），并致力于开发新的规范。2006 年，W3C 肯定了它们工作的必要性，并欣然加人该工作组。2009 年，W3C 完全放弃 XHTML，正式接纳 WHATWG 制定的新标准，这就是后来的 HTML5。起初，WHATWG 和 W3C 都基于标准调整自己的工作，但后来它们的关系又变得复杂起来。今天，它们分别在编辑两份标准。 WHATWG 那份就叫 HTML，而 W3C 那份则称为 HTML5。没错，这种分裂确实不好。但万幸的是，这两份标准的内容相当接近，因此只讲 HTML5 是没有问题的。

**应该使用哪个版本**
设计者和开发者经常问的一个问题就是应该使用 HTML 或 CSS 的哪个版本。这个问题不好回答。虽然规范反映了标准和 Web 技术开发的进度和焦点，但它其实跟设计者和开发者日常的工作关系不大。真正重要的是知道 HTML 和 CSS 的哪些部分已经在浏览器中实现了，以及这些实现是否稳健，有没有 bug。比如，浏览器提供的这些特性是不是实验性特性，使用时需谨慎?或者，这些特性到底靠不靠谱，是不是已经得到了多数浏览器的支持?

今天，使用 CSS 和 HTML 就要了解浏览器对其中特性的支持程度。要了解浏览器支持情况，推荐几个不错的地方。对于 CSS 属性，可以访问 [“Can I use” 网站](https://caniuse.com)。这个网站可以搜索属性或属性组，结果配有统计信息，显示支持它们的浏览器百分比，包括桌面浏览器和移动浏览器。此外，Mozilla 的开发者文档，即 [MDN](https://developer.mozilla.org/zh-CN/docs/Web)，也是个非常好的参考。

说到浏览器支持，关键要明白，并非所有浏览器都一样，实际上从来就没有完全一样的浏览器。某些 CSS3 特性只得到了少数浏览器的支持。比如，IE11 和 Safari6.1 之前的版本都没有正确支持 Flexbox（Flexible Box Layout）。不过，就算需要支持老版本的浏览器，也不意味着不能使用 Flexbox。核心布局上可以不用 Flexbox，但对于某些特定的组件，Flexbox 可能就非常合适。只要为不支持它的浏览器准备好可以接受的后备代码就行了。

#### 1.1.3 渐进增强

平衡向后兼容性与最新的 HTML 和 CSS 特性，涉及一种叫作**渐进增强**（progressive enhancement）的策略。所谓**渐进增强，大意就是 “首先为最小公分母准备可用的内容，然后再为支持新特性的浏览器添加更多交互优化”**。使用渐进增强策略，意味着代码要分层，每一层增强代码都只会在相应特性被支持或被认为适当的情况下应用。听起来有点复杂，而实际上 HTML 和 CSS 的实现已经部分内置了这一策略。

对 HTML 而言，这意味着浏览器在遇到未知元素或属性时并不会报错，而且也不会对页面产生什么影响。比如，可以在页面里使用 HTML5 定义的新 input 元素。假设表单中有一个电子邮件字段的标记如下：

```html
<input type="text" id="field-email" name="field-email" />
```

要使用新的 input 元素，应该把 type 属性改成这样

```html
<input type="email" id="field-email" name="field-email" />
```

尚未实现这个新字段类型的浏览器碰到它只会想：“这是啥意思呀?不明白。” 然后回退为默认的 text 类型，结果和上面的第一行代码一样。而实现了这个类型的新浏览器则知道 email 想让用户在这里填写什么样的数据。而在很多移动设备中，相应的软键盘还会针对输入电子邮件地址调整界面布局。假如还在这里使用了内置的表单验证，那么支持它的新浏览器也会帮你做验证。这样，既渐进增强了页面，也不会对旧版本浏览器产生不好的影响。

另外一个简单的变化就是，HTML5 把文档类型声明更新为新的简短形式。所谓文档类型，就是位于 HTML 文档第一行的代码，供机器识别当前文档使用的标记语言版本。以往的 HTML 和 XHTML 版本中，这行代码很长很复杂，但在 HTML5 中，它已经简化成 `<!DOCTYPE html>`。今后，只要这样声明 HTML 文档类型就好了，因为这个 HTML5 语法的 doctype 是向后兼容的。

CSS 中的渐进增强同样也反映在浏览器如何对待新属性上。任何浏览器无法识别的属性或值都会导致浏览器丢弃相应的声明。因此，只要同时提供合理的后备声明，使用新属性就不会带来不良后果。

举个例子，很多现代浏览器支持以 rgba 函数方式表示的颜色值。这种方式可以分别传入红绿、蓝通道，以及阿尔法（alpha，即透明度）通道的值。可以这样使用它

```css
.overlay {
  background-color: #000;
  background-color: rgba(0, 0, 0, 0.8);
}
```

这条规则定义了类名为 overlay 的元素背景为黑色，但随后又用 rgba 声明背景色应稍微透明。如果浏览器不支持 rgba，那么相应元素的背景色就是不透明的黑色。如果浏览器支持 rgba，那么第二条声明就会覆盖第一条。也就是说，即使并非所有浏览器都支持 rgba，也可以使用它，只是要先为它声明合适的后备代码。

**厂商前缀**
浏览器厂商也基于相同的原理为自家浏览器引入实验性特性。实验性特性的标准名称前面会加上一个特殊字符串，这样他们自己的浏览器就能识别该特性，而其他浏览器则会忽略该特性。有了这个方案，浏览器厂商就可以添加规范中没有或者尚不成熟的新特性，样式表作者也可以安心地试用这些新属性，不用担心浏览器因不认识它们而破坏页面。比如：

```css
.myThing {
  webkit-transform: translate(0, 10px);
  moz-transform: translate(0, 10px);
  ms-transform: translate(0, 10px);
  transform: translate(0, 10px);
}
```

这里使用了几个不同的前缀，给相应的元素应用了变换(<!--TODO-->第 10 章会介绍)：

- 以 -webkit- 开头的适用于基于 WebKit 的浏览器，如 Safari Chrome 和 Opera 都基于 Blink 引擎，而 Blink 最初也是基于 WebKit 开发的，所以 -webkit- 前缀通常也适用于这 3 个浏览器。
- -moz- 前缀适用于基于 Mozilla 的浏览器，如 Firefox。
- -ms-前缀则适用于微软的 IE。

最后又加了一条不带前缀的声明，这样那些支持标准属性名称的浏览器就不会漏网了。

过去经常出现开发人员漏加不带前缀的标准声明的情况。为此，有些浏览器厂商也开始支持竞争对手引擎特定的前缀，以便让流行的网站能在自己的浏览器上打开。但这样做也造成了混乱，于是多数浏览器厂商抛弃了厂商前缀。那实验性特性呢？有的厂商选择把它们隐藏在 chrome://flags 中，有的选择只在特定的预览版中提供。

**条件规则与检测脚本**
如果希望根据浏览器是否支持某个 CSS 特性来提供完全不同的样式，那么可以选择 `@supports` 块。这个特殊的代码块称为条件规则，它会检测括号中的声明，并且仅在浏览器支持该声明的情况下，才会应用块中的规则：

```css
@supports (display: grid) {
  /* 在支持网格布局的浏览器中要应用的规则 */
}
```

条件规则的问题是其自身也很新，只能将它应用于新的浏览器中，因为旧版本浏览器不支持。此外，还可以通过 JS 来检测支持情况，比如使用 Modernize 这个库。Modernize 的原理是为 HTML 添加支持提示信息，然后可以依据这些信息来编写 CSS。

> 这里关键是要知道：渐进增强可以放下对版本号和规范的很多担忧。只要加点小心，就可以在适当的时候使用一些簇新的特性，同时又不会丢掉使用旧版浏览器的用户。

### 1.2 创建结构化、语义化富 HTML

**语义化标记是优秀 HTML 文档的基础。语义就是以系统方式表示的含义**。对于根据一个形式符号的集合人工创造出的语言（比如 HTML 语言，及其元素和属性）来说，语义指的就是通过使用某个符号想要表示的含义。简而言之，语义化标记意味着在正确的地方使用正确的元素，从而得到有意义的文档。

有意义的文档可以确保尽可能多的人都能够使用，无论用的是最新版本的 Chrome，还是 Lynx 这样只能处理文本的浏览器，甚至是屏幕阅读器或盲文点触设备之类的辅助技术。无论将来项目中会增加多么花哨的图形或交互，**文档的基础语义都应该永远—而且必须永远—不打折扣**。

结构良好的标记也意味着内容更对机器的胃口。机器对，特别是 Googlebot 这种搜索引擎爬虫，对它胃口的内容可以让你的页面在 Google 搜索结果中排名更靠前。这是因为，Googlebot 从页面中获得的相关数据越多，它对页面的索引和排名可能就越准确。于是，页面在搜索结果中出现的位置就可能更靠前。对于 CSS 来说更重要的是，有意义的标记本身为添加样式提供了方便。这些标记不仅描述了文档的结构，而且还为继续装扮它提供了底层的框架。

实际上，编写 CSS 的最新实践都建议先给网站一组 “基础” 样式。设立这么一套基础样式的价值非常之大。虽然实际设计和开发中，它们很快会被继承和覆盖，但有了这么一套基础样式，将来的工作就会有条不紊。这套样式也可以作为校准样式来使用。在不断修改 CSS 的过程中，可以时不时对照一下样式指南中的组件，检查自己是否无意中覆盖了某些不该覆盖的样式。

#### 1.2.1 ID 和 c1ass 属性

有意义的元素提供了不错的基础，却没有提供应用视觉效果所必需的全部 “接入点”。几乎总是要根据上下文来调整基础元素的样式。除了元素本身，还需要一种方式把样式 “接入” 到文档上，这就是 `ID` 和 `class` 属性。

为元素添加 ID 和 class 属性不一定能给文档增加含义或结构。这两个属性只是一种让其他因素来操作与解析文档的通用手段，CSS 也可以利用这一手段。

给属性起名字听起来简单，但在写代码时却是极其重要的（常常也是最难的）。“名不正则言不顺”，起什么名字意味着它是什么，或者应该怎么使用它。**写代码的时候，清晰和明确都是至关重要的原则**。下面就以一个链接列表为例，看看怎么给它的 class 属性一个既容易辨识又好用的值：

```html
<ul class="product-list">
  <li><a href="/product/1">Product 1</a></li>
  <li><a href="/product/2">Product 2</a></li>
  <li><a href="/product/3">Product 3</a></li>
</ul>
```

先利用 class 属性在文档中创造一个 product-list 模块。在 CSS 里，用类名来定义一类事物。这里的 product-list 就意味着它可以是任何商品列表换句话说，为 product-list 写好样式后，不仅可以用在这里，还可以用在网站的其他地方，就像蓝图或者模板一样可以重用。

给元素添加类名时，即使类名明确用于样式，也不要体现出其视觉效果（<!--TODO-->第 12 章会详细讨论这一点，包括什么情况下类名可以体现视觉效果）。**正确的做法是让类名表示组件的类型**。

前面的例子只给元素添加了 class 属性，并没有添加 ID 属性。对于添加样式而言，ID 与 class 属性有一些重要的区别，但针对这个例子而言，最主要的区别是一个 ID 只能应用到页面中的一个元素。也就是说，不能像 product-list 那样使用 ID 把页面中的模块定义为可重用的 “模板”。如果使用了 ID，那么相应的 product-list 在每个页面中只能出现一次。提倡使用 ID 来标识特定模块的特定实例。

实际开发中，一般不建议把 ID 属性作为 CSS 的 “接入点”。利用类来添加样式往往能够让代码更简单也更容易维护。ID 可以用于在文档中标识元素，但通常不用于添加样式。

#### 1.2.2 结构化元素

HTML5 新增了一批结构化元素：

- section
- header
- footer
- nav
- article
- aside
- main

**增加这些新元素是为了在 HTML 文档中创建逻辑性区块**。它们可以用于包含独立内容（article）、导航组件（nav）、特定区块的头部（header），等等。其中，main 元素是最新增加的，用于高亮页面中包含主要内容的区域。**除了 main 之外，所有其他新元素都可以在一个文档中多次出现**，以便让机器和人更好地理解文档。关于如何正确使用这些新元素，建议看看[这个网站](http://html5doctor.com)。

div 元素对文档而言并没有语义价值，只是借助类名作为添加样式的 “接入点” 而已。

#### 1.2.3 div 和 span

既然有了新语义元素，那么 div 元素是否就多余了呢？不是的。在没有合适的语义元素的情况下，div 仍然是给内容分组的一个不错的选择。有时候，会纯粹出于添加样式的目的而在文档中添加一个元素。比如，为实现居中布局而在整个页面外部包装一个元素。

如果有更具语义的结构化元素，那么务必使用它们，需要添加样式时再给它们一个适当的类名。但是，如果只需要一个无语义的元素作为额外的样式接入点，那就使用 div。

因此，**请确保只在额外提供样式接入的情况下才使用 div**，但也不要因为用了几个 div 就感到难为情。在后面介绍的几个具体的例子中，会看到，额外添加的无语义 div 元素对保证代码的清晰和可维护性非常重要。

与 div 元素类似的还有 span。同样，在无须表示语义、仅需添加样式的情况中，可以使用 span。与 div 不同，span 是文本级元素，可以用于在文本流中建立结构。不过在使用无语义的 span 之前，也一样要确保真的不需要使用任何语义元素。比如，使用 time 标记时间和日期，使用 q 标记引用，使用 em 标记需要强调的内容，使用 strong 标记需要重点强调的内容。

#### 1.2.4 重新定义的表现性文本元素

时至今日，`<b>` 和 `<i>` 可以算是幸存的表现性标记了，它们以前分别用于将文本标记为粗体（bold）和斜体（italic）。因为在旧有 Web 内容中，或者通过低水平 WYSIWYG 编辑器创建的内容中，这两个元素随处可见。HTML5 的编辑最终决定保留它们，但改变了它们的含义。

今天，`<i>` 元素用于标识与周围内容不一样的内容，一般在排版上会显示为斜体。HTML5 规范中给出的例子包括另一种语言中的习语，以及一艘船的名字。

`<b>` 元素的含义和 `<i>` 几乎一样，只是针对习惯上标记为粗体的内容。相关的例子包括商品或品类名。

这样的定义确实不够明确，但关键是要知道，**这两个元素与 `<em>` 及 `<strong>` 的区别在于，它们没有任何强调自己所包含内容的意味**。多数情况下，应该选择 `<em>` 或 `<strong>`，因为它们是用来强调及重点强调内容的语义正确的选择。

#### 1.2.5 扩展 HTML 语义

长时间以来，Web 开发者一直在探索给 HTML 有限的词汇表添加新的语义和结构的方式。为内容添加更丰富的语义，对 Web 和基于其构建的工具而言意义重大。虽然建设语义 Web 王国任重而道远，但不管怎么说，还是有了实质性的进步。利用这些成果，HTML 编写者可以为自己的文档添加更细粒度、更具表达性的语义。

**ARIA 的 role 属性**
很多新的 HTML5 元素都考虑到了无障碍访问的场景。比如，如果屏幕阅读器能够理解页面中的 nav 元素，那么它就可以利用这个元素帮助用户定位到相应的内容，或者在必要时返回导航。

另一种实现这个目标的方式是利用无障碍富因特网应用（ARIA，accessible rich Intermetapplication），它是对 HTML 规范的补充。ARIA 提供了针对辅助访问设备添加更多语义的手段，方式就是为文档中的不同元素指定其包含什么内容，或者说它们提供什么功能。比如，role="navigation" 这个 “地标角色” 属性用于声明一个元素具有导航的角色。其他角色有：

- banner
- form
- main
- search
- complementary
- contentinfo
- application

完整的 ARA 角色及其定义，参见 ARIA 规范。ARIA 还支持让开发人员指定更复杂的内容片段和界面元素。例如，在使用 HTML 创建一个音量滑动条部件时，应该包含值为 slider 的 role 属性：

```html
<div id="volume-label">Volume</div>
<div class="volume-rail">
  <a
    href="#"
    class="volume-handle"
    role="slider"
    aria-labelledby="volume-label"
    aria-valuemin="1"
    aria-valuemax="100"
    aria-valuenow="67"
  ></a>
</div>
```

属性 aria-labelledby、aria-valuemin、aria-valuemax 和 aria-valuenow 也分别提供了额外的信息，辅助阅读技术可以利用它们帮助残障用户使用这个滑动部件。

为 HTML 页面中的不同组件添加这些额外的语义属性，同样有助于为元素添加脚本和样式，是典型的多贏策略。

**微格式**
_目前最广泛采用的扩展 HTML 语义的方式是微格式_。微格式是一组标准的命名约定和标记模式，可用于表示特定的数据类型。微格式的命名约定是基于 vCard 和 iCalendar 等已有的数据格式制定的。比如下面的联系人信息就是以 hCard 格式标记的：

```html
<section class="h-card">
  <p>
    <a class="u-url p-name" href="http://andybudd.com/">Andy Budd</a>
    <span class="p-org">Clearleft Ltd</span>
    <a class="u-email" href="mailto:info@andybudd.com">info@andybudd.com</a>
  </p>
  <p class="p-adr">
    <span class="p-locality">Brighton</span>
    <span class="p-country-name">England</span>
  </p>
</section>
```

以微格式标记的联系人信息便于开发人员编写工具从中提取数据。比如可以编写一个浏览器插件，从你浏览的页面中发现微格式，然后让你把联系人信息下载到通讯录，或者把活动信息添加到你的日历应用。目前微格式支持的数据类型包括联系人、活动、菜谱、博文、简历，等等。

微格式也可以用于表示关系，比如一段内容与链接到该内容的另一个 URL 之间的关系微格式得以流行的原因之一是容易实现，迄今已经被 Yahoo 和 Facebook 等内容平台采用，而且已经直接添加到了 WordPress8 和 Drupal 等内容发布工具中。2012 年一项关于结构化数据实现的研究发现，微格式在 Web 上的应用最为广泛。不过最近微数据异军突起，也不容小觑。

**微数据**
微数据是跟 HTM5 一起，作为给 HTML 添加结构化数据的另一种方式而推出的。它的目标与微格式非常相近，但在把微数据嵌入内容方面则有所不同。下面看一看用微数据标记同样的联系人信息会是什么样：

```html
<section itemscope itemtype="http://schema.org/person">
  <p><a itemprop="name" href="http://thatemil.com/">Emil B</a></p>
  <span itemprop="affiliation" itemscope itemtype="http://schema.org/organization">
    <span itemprop="name">inUse Experience AB</span>
  </span>
  <a itemprop="email" href="mailto:emil@thatemil.com">emil@thatemil.com</a>
  <p itemprop="address" itemscope itemtype="http://schema.org/PostalAddress">
    <span class="addressLocality">Malm?</span>,
    <span class="addressCountry">Sweden</span>
  </p>
</section>
```

通过这个例子可以看出，微数据的语法比微格式要烦琐一些，不过这是有原因的。由于微数据设计的时候考虑到了可扩展性，它可以用来表示任意类型的数据。微数据只定义一些语法来表示数据结构，但自身并未定义任何词汇表。相反，微格式则定义了具体的结构化数据，比如 hCard 和 hCalendar。

微数据把定义特定格式的事交给了使用者或第三方。上述例子中使用的格式就是由 Bing、Google 以及 Yahoo 等搜索引擎共同创建的一个[词汇表](https://schema.org)。这几家搜索引擎使用它来辅助索引和排名页面，当然搜索爬虫也会使用这些词汇表，从你的内容中更高效地提取丰富的信息。

#### 1.2.6 验证

即使经过深思熟虑，标记已经非常语义化了，其中也仍然存在输入或者格式错误的风险。这些隐患会带来无法预料的麻烦。这时候就要使用验证了。

现实中的多数 HTML 文档并不是真正有效的 HTML。用规范编写者的话说，就叫作 “未遵行”（nonconformant）。这些文档中存在的问题有元素嵌套不对、包含未经编码的和号（&），以及缺少必要的属性等。浏览器对这类错误非常宽容，总会尝试猜测作者的意图。事实上，HTML 规范中也包含了如何处理无效 HTML 的规定，以确保浏览器厂商以一致的方式处理错误。

总体来说，浏览器如此大度地处理错误是个好事，但不代表可以因此而放弃自己的职守。都应该尽力写出有效的 HTML 文档，这样有利于更快地查找问题，避免错误泛滥。假如碰到一个渲染或布局上的 bug，时又找不出问题所在，最好先验证一下 HTML，以保证样式应用到了格式正确的文档上。

验证 HTML 的工具有很多。比如，可以使用 W3C 网站上的 [HTML 验证器](http://validator.w3.org/)，或者与之相关的插件。其中的 Web Developer 扩展，Firefox、Opera 和 Chrome 都支持。此外，如果项目有自动构建或测试环节，最好在其中加上 HTML 验证。

CSS 也是可以验证的。W3C 的 [CSS 验证器](http://jigsaw.w3.org/css-validator/)。可能认为验证 CSS 没有验证 HTML 那么重要，毕竟 CSS 中的错误一般不会导致 JS 出错，或者导致屏幕阅读器无法打开页面。但是，还是建议重视 CSS，保证其中没有什么低级错误。

根据 CSS 验证器设置而定，验证结果中可能包含很多关于厂商前缀的警告或错误。这些属性或值是浏览器厂商在实验性地支持某些 CSS 特性时使用的一种临时命名约定。比如，webkit-flex 这个 display 属性的值，就是标准 flex 属性值在 WebKit 浏览器上的实验性版本。这些地方虽然会被验证器标记为警告甚至错误，但文件依然能正常使用。总之，只要明白验证器给出的这些标记的真正含义就行了。

验证并不是最终裁决，很多本身很好的页面也会验证失败，这是由于使用了来自第三方或低水准 CMS 的内容，或者使用了试验性 CSS 特性。此外，验证器本身也可能会跟不上标准更新和浏览器实现的步伐。因此不要过于激进，只要把验证当作事先帮助发现一些低级错误的手段即可。

## 二. 添加样式

### 2.1 CSS 选择符

1. **基本选择符**

   - 类型选择符：用于选择特定类型的元素，类型选择符有时也被称为元素选择符。

   - 后代选择符：用于选择某个或某组元素的后代。后代选择符的写法是在两个选择符之间添加空格。
     类型选择符与后代选择符非常适合全面应用基础样式。

   - 想要更精确地选择目标元素，可以使用 ID 选择符和类选择符。顾名思义，这两个选择符通过对应 ID 和 class 属性的值来选择元素。ID 选择符由 `#` 号开头，类选择符由 `.` 开头。

2. **高级选择符**

   - 子选择符（`>`）：只选择一个元素的直接后代，也就是子元素。

   - 相邻同辈选择器（`+`）：选择位于某个元素后面，并与该元素拥有相同父元素的**第一个**元素。

   - 一般同辈选择符（`~`）：选择位于某个元素后面，并与该元素拥有相同父元素的元素的**所有元素**。

   `>` 和 `+` 在这里被称为组合子，因为它们描述了自身两侧的选择符组合的方式。

3. **通用选择符**：通用选择符（`*`）可以匹配任何元素。

4. **属性选择符**
   属性选择符基于元素是否有某个元素或属性是否有某个值来选择元素。

   ```css
   abbr[title] {
     cursor: help;
   }

   input[type='submit'] {
     cursor: pointer;
   }
   ```

   还可通过给属性选择符中的等号前面加上特殊字符，来匹配特定模式：

   - 匹配以某些字符开头的属性值（`^`）：`a[href^="http:"]`
   - 匹配以某些字符结尾的属性值（`$`）：`img[src$='.jpg']`
   - 匹配包含某些字符的属性值（`*`）：`a[href*="/about/"]`
   - 匹配以空格分隔的字符串中的属性值（`~`）：`a[rel~=next]`
   - 可以选择开头是指定值或指定值后连着一个短划线的情况（`|`）：`a[lang|=en]`
     上面的规则可以匹配属性值 en 和 en-us，暗示这个选择符很适合选择属性值中的语言代码。

5. **伪元素**
   有时候想选择的页面区域不是通过元素来表示的，又不想为此给页面添加额外的标记。CSS 为这种情况提供了一些特殊选择符，叫伪元素。如：可以使用 `::first-letter` 伪元素来选择一段文本的第一个字符。

   > **注意**：
   >
   > 1. 使用伪元素插入内容要小心！千万不能用他们插入对交互有实质影响的内容，以避免 CSS 不能正确加载。另外，屏幕阅读器也没有统一的方式解释伪元素，有的会直接忽略它们，有的则会读取其中的内容。
   > 2. 伪元素应该使用双冒号语法，这是为了与伪类区别开，伪类使用单冒号语法。

6. **伪类**

   可以使用伪类选择符，来为文档结构以外的情形添加页面样式。伪类选择符的语法是一个冒号开头，用于选择元素的特定状态或关系。

   > **注意**：很多元素都可以使用 `:hover`，但 在触摸屏和键盘等输入方式下不一定有悬停状态。因此，不能再重要的交互功能中使用 `:hover`。

   **目标与反选**
   另一个有用的伪类是 `:target`，它匹配的元素有一个 ID 属性，而且该属性的值出现在当前页面 URL 末尾的 `#` 号后面。如：打开链接 `http://example.com/blog/1/#comment-3`，找到该页面中标记为 `<article class="comment" id="comment-3">...</article>` 的元素，可以为它设置样式：

   ```css
   .comment:target {
     color: #fffec4;
   }
   ```

   反选伪类（`:not()`）专门用于排除某些选择符，它可以配合除了伪元素和它自身的各种选择符使用。

7. **结构化伪类**

   CSS3 新增了一大批与文档结构有关的新伪类，其中最常用的是 `:nth-child` 选择符，它可以接受 odd（奇数）和 even（偶数）作为参数。这个参数还可以是数值或数值表达式（an + b）。

   ```css
   tr:nth-child(3n + 4) {
     background: #ddd;
   }
   ```

   还有一个伪类选择符也支持这种表达式，`:nth-last-child()` 。这个选择符与 `:nth-child` 类似，只不过倒序计算。

   CSS2.1 中有一个选择第一个子元素的伪元素，叫 `:first-child`，相当于 `:nth-child(1)`。CSS3 又添加了一个选择最后一个子元素的伪元素，`:last-child`，对应 `:nth-last-child(1)`。此外，还有 `:only-child` 和 `:only-of-type`、`:only-last-of-type`。其中，`:only-of-type` 和 `:only-last-of-type` 会选择特定类型的唯一子元素。

8. **表单伪类**

   还有很多伪类专门用于选择表单元素。这些为了根据用户与表单控件交互的方式，来反映表单控件的某种状态。

   例如，HTML5 为表单输入框新增了几个属性，表示必填的 `required` 就是其中之一。可以使用 `:required` 伪类来选择带有 `required` 属性的表单元素。还可以使用 `:optional` 伪类，为没有 `required` 属性的控件添加样式。

   此外，还有针对有效和无效控件的伪类。为满足某个输入框要求填写特定类型内容（如电子邮件地址）的需求，可以根据输入框中当前内容的有效性，应用不同样式：

   ```css
   /* 如果输入框包含有效的电子邮件地址 */
   input[type='email']:valid {
     border-color: green;
   }
   /* 如果输入框中的内容不是有效的电子邮件地址 */
   input[type='email']:invalid {
     border-color: red;
   }
   ```

   还有针对 type 值为 number 的 `:in-range`、`:out-of-range`伪类，针对 readonly 属性的 `:read-only`伪类，以及针对没有 readonly 属性的 `:read-write`伪类。[更多信息](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes)

### 2.2 层叠

稍微复杂的样式表中都可能存在两条甚至多条规则同时选择一个元素的情况。CSS 通过一种叫作层叠（cascade）的机制来处理这种冲突。从 CSS 这个名字就可知这种机制有多重要，因为其中的 C 就是 cascade（SS 是 style sheet，即样式表）。

**层叠机制的原理是为规则赋予不同的重要程度**。最重要的是作者样式表，即由网站开发者所写的样式。其次是用户样式表，用户可以通过浏览器的设置选项，为网页应用自己的样式。排在最后的是浏览器（或用户代码）的默认样式表，它们一般都会被作者样式表覆盖掉。

为了给用户更高的优先权，CSS 允许用户使用 `!important`覆盖任何规则，包括网站作者使用 `!important` 标注的规则。`!important` 标注要放在属性声明的后面。

允许用户使用 `!important` 标注来覆盖规则，主要是出于无障碍交互的需要。比如，允许诵读困难的用户使用高对比度的用户样式表。归纳起来，层叠机制的重要性级别从高到底如下所示：

- 标注为 `!important` 的用户样式
- 标注为 `!important` 的作者样式
- 作者样式
- 用户样式
- 浏览器（或用户代理）的默认样式

在此基础上，规则再按选择符的特殊性进行排序。特殊性高的选择符会覆盖特殊性低的选择符。如果两条规则的特殊性相等，则后定义的规则优先。

### 2.3 特殊性

为了量化规则的特殊性，每种选择符都对应着一个数值。这样，一条规则的特殊性就表示为其每个选择符的累加数值。但这里的累加计算使用的并非十进制加法，而是基于位置累加，以保证 10 个类选择符（或者 40 个，甚至更多的类选择符）累加的特殊性不会大于等于 1 个 ID 选择符的特殊性。这是为了避免 ID 这种高特殊性选择符被一堆低特殊性选择符（如类型选择符）的累加值所覆盖。如果某条规则中用到的选择符不足 10 个，为简单起见，也可以使用十进制来计算其特殊性。

任何选择符的特殊性都对应于如下 4 个级别，即 a、b、c、d：

- 行内样式，a 为 1;
- b 等于 ID 选择符的数目;
- c 等于类（class）选择符、伪类选择符及属性选择符的数目;
- d 等于类型（type）选择符和伪元素选择符的数目。

特殊性计算示例：

| 选择符 | 特殊性 | 十进制特殊性 |
| ----------------- | ------- | ------------ |d
| style="" | 1,0,0,0 | 1000 |
| #content .date {} | 0,1,1,0 | 200 |
| p.comment {} | 0,0,1,1 | 11 |

> **注意**：通用选择符（`*`）的特殊性为 0，无论它在规则声明中出现多少次。

#### 2.3.1 利用层叠次序

如果两条规则特殊性相等，则优先应用后定义的规则，这一点非常重要。这意味着在写样式的时候，必须考虑规则在样式中的位置，以及选择符的次序。

对链接元素使用伪类，就是一个利用层叠次序的典型。如果每个选择符的特殊性都一样，那么它们的次序就很重要了。要是把 a:visited 选择符放在 a:hover 选择符后面，那么在访问过链接之后，悬停样式将不会起作用，因为已经被 a:visited 样式给覆盖了。

#### 2.3.2 控制特殊性

**理解特殊性是写好 CSS 的关键，而控制特殊性则是大型网站开发中最难处理的问题**。利用特殊性，可以先为公用元素设置默认样式，然后在更特殊的元素上覆盖这些样式。最好的做法是从一开始就简化选择符，降低特殊性，减少选择符之间的依赖。对样式进行更细粒度的控制。

### 2.4 继承

任何直接应用给元素的样式都会覆盖继承的样式。因为继承的样式没有任何特殊性，连 0 都算不上。继承是很有用的机制，有了它就可以避免给一个元素的所有后代重复应用相同的样式。合理利用继承有助于减少选择符的数量，降低复杂性。

### 2.5 为文档应用样式

为文档应用样式的方式不止一种，各有利弊。

#### 2.5.1 link 与 style 元素

可以把样式放在 style 元素中，直接放在文档的 head 部分。如果样式不多，又希望立刻应用它们，并且不愿意因为浏览器额外下载文件而耽误时间。可以使用这种方式。

不过，为了让样式表能在多个页面中重用，通常最好把它保存到一个外部文件中。如果样式在外部样式表中，那么有两种方式把它们链接到网页上。最常用的方式是使用 link 元素：

```html
<link href="/c/base.css" rel="stylesheet" />
```

除了 link 元素，还可以使用 `@import` 指令加载外部 CSS 文件：

```html
<style>
  @import url('/c/modules.css');
</style>
```

可以在 HTML 文档的 head 部分把 @import 指令放在 style 中，也可以在外部样式表中使用它。后一种用法意味着，如果网页记载外部样式表，那么浏览器后续可能还需要下载更多 CSS 文件。

表面上看，使用 link 和 @import 指令的结果没什么区别。实际上，link 是比 @import 指令更值得推荐的方法，背后有一些[非常重要的原因](#252-性能)。

使用 link 或 style 在 HTML 中添加多个样式表或样式块时，它们声明的次序就是它们在 HTML 源代码中出现的次序。

#### 2.5.2 性能

选择以什么方式把 CSS 加载到页面中，一定程度上决定了浏览器显示页面的速度。度量 Web 性能的一个重要指标就是网页内容实际显示在屏幕上需要多久。这个指标有时候也叫 “渲染时间” 或 “上屏时间”。现代浏览器在屏幕上渲染内容之前，至少需要两样东西：HTML 和 CSS 这意味着让浏览器尽快下载 HTML 和全部 CSS 极其重要。

不要把 CSS 放到 body 里或者放到页面底部，搞什么 “延迟加载”。浏览器只有掌握了布局页面的全部 CSS 信息，才能给出最佳响应。因为只有这样，它们才知道应该把页面渲染成什么样，从而一次性地把页面绘制到屏幕上，而非一边加载新样式一边重新调整页面。

1. **减少 HTTP 请求**
   在链接外部样式表时，保证链接的文件数量最少至关重要，因为每个文件都需要单独发送次 HTTP 请求。相应地，每次从服务器请求文件，浏览器都需要花一定的时间下载，然后还要花时间应用其中的样式。另外，额外的 HTTP 请求也意味着浏览器会向服务器发送多余的数据，比如 cookie 或请求首部。服务器也必须针对每个请求返回响应首部。两个文件要比一个包含相同 CSS 内容的文件在浏览器和服务器间传递的数据更多。

   线上网页最好把需要加载的 CSS 文件数量控制在 1 或 2 个。只用一个 link 元素加载 CSS 文件，然后在其中使用 @import，并不能把请求控制为 1 个，因为这意味着先需要 1 个请求下载链接的文件，此外还要发送额外的请求取得所有导人的文件。因此，在线上网页中尽量不要使用 `@import`。

2. **压缩和缓存内容**
   使用 GZIP 压缩线上资源也非常重要。CSS 压缩的比率很高，因为它的很多属性和值都是重复的。一般来说，CSS 文件压缩后会减少 70%~80%。这样显然可以减少带宽占用，从而为用户节省时间。多数 Web 服务器都会在浏览器支持的情况下启用自动压缩线上资源。

   类似地，让 Web 服务器帮设置一定的 CSS 文件缓存时间也很重要。理想情况下，浏览器应该只下载一次 CSS 文件，除非线上文件有变化。方法就是通过 HTTP 首部告诉浏览器，把文件缓存较长的一段时间，如果文件有修改，则通过文件名来 “清除缓存”。压缩和合理缓存内容是提升网站性能的最重要的两件事。

3. **不让浏览器渲染阻塞 JS**
   如果在 HTML 文档的 head 元素中加入了 script 元素，浏览器必须先把它链接的脚本下载下来，然后再向用户显示网页内容。换句话说，这种情况下的 HTML 和 CSS 解析完全被下载以及执行脚本阻断了，也就是所谓的 “渲染阻塞”。渲染阻塞会明显拖慢网站加载速度。为此，主流的做法是在 HTML 页面底部的结束标签 `</body>` 之前加载 JS。

   比较现代的做法是在 head 中使用 script 标签，但添加 `async` 和 `defer` 属性。给 script 标签加上 `async` 属性，会异步加载脚本，不阻塞 HTML 解析，但会在脚本加载完毕立即执行时阻断 HTML 解析。给 script 标签加上 `defer` 属性，同样会异步加载脚本，不同的是会在 HTML 解析完毕后再执行加载的脚本。这两个属性该用哪一个，还要看脚本本身的具体内容。

   使用以上方法加载 JS，可以确保浏览器首先解析 HTML 和 CSS，不受请求 JS 文件的影响。至于选择哪个方法，很大程度上取决于浏览器的支持情况：`async` 和 `defer` 属性是 HTML 中定义的，因此还比较新。IE10 和更早版本的 IE 并不支持或不完全支持它们。

## 三. 可见格式化模型

浮动、定位和盒模型是学习 CSS 需要掌握的几个最重要的概念。这几个概念决定了元素在页面是排布和显示的方式，是很多布局技术的举出。近年来，Web 标准也引入了专门用于控制布局的新规范。

### 3.1 盒模型

盒模型是 CSS 的核心概念，描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看做一个矩形盒子，这个盒子包含元素的内容、内边距、边框、外边距。

内边距（padding）是内容区周围的空间。给元素应用的背景会作用于元素内容和内边距。因此，内边距通常用于分隔内容，使其不至于散布到背景的边界。边框（border）会在内边距外侧增加一条框线，这条框线可以是实线、虚线或点划线。边框的外侧是外边距（margin），外边距是围绕在盒子可见部分之外的透明区域，用于在页面中控制元素之间的距离。

有一个与边框类似的属性，即轮廓线（outline）。这个属性可以在边框盒子外围画出一条线，但这条线不影响盒子的布局，也就是不影响盒子的宽度和高度。因此，outline 常用于调试复杂布局，或显示布局效果。

对元素盒子而言，内边距、边框和外边距不是必需的，因此它们的默认值都为 0。不过，用户代码样式表通常会给很多元素添加外边距和内边距。比如，标题通常就会带有一定的外边距，但外边距的值会因浏览器而异。

#### 3.1.1 盒子大小

默认情况下，元素盒子的 width 和 height 属性指的是内容盒子，也就是元素可渲染内容区的宽度和高度。这时候添加边框和内边距并不会影响内容盒子的大小，但会导致整个元素盒子变大。如果想给元素盒子的每一边都添加 5 像素的边框和 5 像素的内边距，同时又想让元素盒子的宽度为 100 像素，则应该把内容区宽度设置为 80 像素。如果这个元素盒子外围还有 10 像素的外边距，那么整个盒子占据空间的宽度就是 120 像素。

通过修改 box-sizing 属性可以改变计算盒子大小的方式。box-sizing 的默认值为 content-box，即把宽度值应用给内容区。通过修改 box-sizing 的值，设置元素的 width 和 height 属性，就可以影响元素盒子的不同区域，这对响应式布局非常有用。

如果把 box-sizing 的值修改为 **border-box**，那么 width 和 height 的值将会包含内边距和边框。此时，外边距仍然会影响盒子在页面中占据的整体空间，即它的宽度不会算到 width 中。这种计算盒子大小的方式更加直观。

#### 3.1.2 最大值和最小值

有时候，特别是在响应式布局中，给一个元素应用 min-width 和 max-width 值很有用。因为这样一来，块级盒子就可以默认自动填充父元素的宽度，但不会收缩到比 min-width 指定的值更窄，或者扩展到比 max-width 指定的值更宽。（第 8 章会讨论响应式设计及其与 CSS 的关系<!--TODO-->。）

与此类似的是 min-height 和 max-height 属性。不过在 CSS 中，设置任何高度值的时候都应该慎重。这是因为元素的高度通常应该取决于所包含的内容，不需要明确设定。否则，万一内容增多，或者文本字号变大，内容就可能跑到高度固定的盒子之外去。即使出于种种原因，需要明确设定默认高度，也最好使用 min-height，因为这个属性允许盒子随内容扩展。

### 3.2 可见格式化模型

常说 p、h1 和 article 这些元素都是块级元素。意思就是说，它们作为元素，显示为内容块或块级盒子（block box）的形式。相对而言，strong、span 和 time 被称为行内元素，因为它们的内容会以行内盒子（inline box）的形式显示在行内。

可以使用 `display` 属性改变生成的盒子类型。如果把 display 属性设置为 none，还可以让浏览器不为相应的元素生成盒子。如果不生成盒子，那么元素及其包含的内容就不会显示出来，也不会占用文档中的空间。

CSS 中有几种不同的定位模型，包括浮动、绝对定位和相对定位。除非特别指定，否则所有盒子都会在常规文档流中生成，即 position 属性的默认值为 static。顾名思义，常规文档流中元素盒子的位置，由元素在 HTML 中的位置决定。

- 块级盒子会沿垂直方向堆叠，盒子在垂直方向上的间距由它们的上、下外边距决定。

- 行内盒子是沿文本流水平排列的，也会随文本换行而换行。它们之间的水平间距可以通过水平方向的内边距、边框和外边距来调节。但行内盒子的高度不受其垂直方向上的内边距、边框和外边距的影响。此外，给行内盒子明确设置高度和宽度也不会起作用。

- **由一行文本形成的水平盒子叫行盒子**（line box），而行盒子的高度由所包含的行内盒子决定。修改行盒子大小的唯一途径就是修改行高（line-height），或者给它内部的行内盒子设置水平方向的边框、内边距或外边距。

- 当然，也可以把元素的 display 属性设置为 `inline-block`。这样设置之后，该元素就会像一个行内盒子一样水平排列。但这个盒子的内部仍然像块级元素一样，能够设置宽度、高度、垂直外边距和内边距。

- 使用表格相关的标记（table、tr、th 等）时，表格本身表现为块级元素，但表格的内容会根据生成的行和列排布。还可以通过设置 display 属性让非表格元素采用表格的布局方式。只要正确地应用 table、table-row 和 table-cell 等值，就可以实现表格布局，无须在 HTML 标记中使用表格标签。

后面的 Flexible Box Layout（也称为 Flexbox）和 Grid Layout 等 CSS 模块，又进一步扩展了 display 属性。通常，这些新布局模式会在它们的外部上下文中创建类似块级的盒子，但会为内部显示内容创建新的规则。

#### 3.2.1 匿名盒子

HTML 元素可以嵌套，元素盒子当然也可以嵌套。多数盒子都是基于明确定义的元素生成的。不过有一种情况，就算不明确定义元素也会生成块级盒子。比如，像下面这样，在 section 这个块级元素的开头加人 “some text”。此时，“some text” 就算没有定义为块级元素，也会被当成块级元素。

```html
<section>
  some text
  <p>Some more text</p>
</section>
```

这种情况下，这个盒子被称为**匿名块盒子**（anonymous block box），因为这个盒子并不与任何特定的元素相关。

类似的情况也存在于块级元素内部的文本级行盒子。假设有一个段落中包含三行文本，这三行文本的每一行都构成了一个匿名行盒子（anonymous line box）除了使用 :first-line 伪元素来添加有限的排版和颜色相关的样式之外，不能直接给匿名块盒子或匿名行盒子应用样式。**关键要知道，在屏幕上看到一切，都会从属于某个盒子**。

#### 3.2.2 外边距折叠

常规块盒子有一种机制叫作外边距折叠。外边距折叠的概念很简单，简而言之，**垂直方向上的两个外边距相遇时，会折叠成一个外边距。折叠后外边距的高度等于两者中较大的那一个高度**。当两个元素垂直堆叠时，上方元素的下外边距会与下方元素的上外边距相折叠。

**外边距折叠只发生在文档常规文本流中块级盒子的垂直方向上**。行内盒子、浮动盒子或绝对定位盒子的外边距不会折叠。

#### 3.2.3 包含块

知道什么决定一个元素的包含块非常重要，将内边距和外边距的值设置为百分比，包含块就是这些百分比值的计算依据。

确定元素的包含块，要看元素是如何定位的。如果元素的定位方式是静态定位（即不指定 position 的值）或相对定位，则其包含块的边界就计算到一个最近的父元素，该元素的 display 属性值必须能够提供类似块级的上下文，如 block、inline-block、table-cell、list-item 等。

默认情况下，width、height、margin 和 padding 的值为百分比时，就以该父元素的尺寸为计算依据。如果当前元素的定位模型改成了 absolute 或 fixed，那么计算依据就会发生变化。

#### 3.2.4 相对定位

把一个元素的 position 属性设置为 relative，该元素仍然会呆在原来的地方。但此后，可以通过设置 top、right、bottom 和 left 属性，使该元素相对于初始位置平移一定距离。比如设置 top 属性为 20 像素，该元素就会相对于其初始位置垂直向下平移 20 像素。而设置 left 属性为 20 像素，则会将该元素向右移动 20 像素，其左侧会出现空白。

无论是否位移，相对定位的元素仍然会在文档流中占用初始的空间。因此，这样平移元素会导致它遮挡其他元素。

#### 3.2.5 绝对定位

相对定位事实上是常规文档流定位模型的一部分，因为元素还是相对于它在常规流中的初始位置来定位。绝对定位则会把元素拿出文档流，因此也就不会再占用原来的空间。与此同时，文档流中的其他元素会各自重新定位，仿佛绝对定位的那个元素没有存在过一样。

绝对定位元素的包含块是距离它最近的定位祖先，也就是 position 属性设置为 static 之外任意值的祖先元素。如果没有这么一个定位祖先，那么它就相对于文档的根元素即 html 元素定位。文档的根元素也叫作起始包含块（initial containing block）。

与相对定位的盒子类似，绝对定位的盒子也可以相对于其包含块向上、下、左、右方向平移。平移绝对定位的元素提供了极大的灵活性，因为可以把元素移动到页面的任意位置。

绝对定位的盒子是脱离了常规文档流的，因此可能会遮挡页面上的其他元素。为了控制这些盒子层叠的次序，可以设置一个叫 `z-index` 的属性。z-index 属性值越大，盒子在层叠中的次序就越靠近用户的眼睛。用 z-index 控制盒子的层叠有不少值得探讨之处，第 6 章再详细介绍<!--TODO-->。

尽管绝对定位对于在页面上任意摆放元素非常有用，但近来已经很少被用来构建整体布局了。绝对定位的盒子脱离了常规文档流，因此很难用它们创建随视口宽度和内容长度变化而变化的自适应或者响应式布局。Web 技术的特点决定了不太可能指定元素在页面上的确切位置和大小。随着对其他 CSS 布局技术掌握得越发熟练，会发现绝对定位在整体布局上几乎没人用了。

#### 3.2.6 固定定位

固定定位是由绝对定位衍生出来的，不同之处在于，固定定位元素的包含块是视口（viewport）。因此，固定定位可用来创建始终停留在窗口相同位置的浮动元素。很多网站都使用这个技术让导航区始终保持可见，有的固定侧栏，有的固定顶栏。这样能确保网站的可用性，因为用户不必再费事寻找了。

#### 3.2.7 浮动

另一种可见形式化模型是浮动模型。浮动盒子可以向左或向右移动，直到其外边沿接触包含块的外边沿，或接触另一个浮动盒子的外边沿。浮动盒子也会脱离常规文档流，因此常规文档流中的其他块级盒子的表现，**几乎**当浮动盒子不存在一样。

**行盒子与清除**
浮动元素会脱离文档流，因此不会再像非浮动元素一样影响其他元素。实际上，严格来讲并非如此。如果浮动元素后面跟着的是常规文档流中的元素，那么这个元素的盒子就会当浮动元素不存在一样。但是，这个元素盒子中的文本内容则会记住浮动元素的大小，并在排布时避开它，为其留出相应的空间。从技术角度来讲，就是跟在浮动元素后面的行盒子会缩短，从而为浮动元素留空，造成文本环绕浮动盒子的效果。事实上，浮动就是为了在网页中实现文本环绕图片的效果而引入的一种布局模型。

要阻止行盒子环绕在浮动盒子外面，需要给包含行盒子的应用 `clear` 属性。clear 属性的值有 left、right、both、none，用于指定盒子的哪一侧不应该紧挨着浮动盒子。清除一个元素时，浏览器会在这个元素上方添加足够大的外边距，从而将元素的上边沿垂直向下推移到浮动元素下方。因此，如果给 “已清除的” 元素添加外边距，那么除非添加的值超过浏览器自动添加的值，否则不会看到效果。

浮动元素除了会导致后面的行盒子缩短，从而造成文本环绕效果之外，不会对周围的元素有任何别的影响，毕竟它已经脱离了文档流。但清除一个元素本质上会为所有前面的浮动元素清理出一块垂直空间。这就为使用浮动布局创造了条件，因为周围的元素可以为浮动的元素腾出地方来。

浮动的元素会被拿出文档流，所以只包含浮动内容的元素，无法在文档流中生成高度。这时，需要在这个元素内部某处应用 clear，在清除的元素上方创造出足够的垂直外边距，从而为包住浮动元素创造出空间，可以使用 :after 伪元素来模拟额外的清除元素：

```css
.block:after {
  content: ' ';
  display: block;
  clear: both;
}
```

#### 3.2.8 格式化上下文

当元素在页面上水平或垂直排布时，它们之间如何相互影响，CSS 有几套不同的规则，其中一套规则叫作格式化上下文（formatting context）。前面已经介绍了行内格式化上下文（inline formatting context）的一些规则。比如，垂直外边距对于行内盒子没有影响。

此外，有些规则规定了页面必须自动包含突出的浮动元素（否则浮动元素中的内容可能会跑到可滚动区域之外），而且所有块级盒子的左边界默认与包含块的左边界对齐（如果文字顺序是从右向左，那么与包含块的右边界对齐）。这组规则就是**块级格式化上下文**（block formatting context）。

还有些规则允许元素建立自己内部的块级格式化上下文，包括：

- display 属性值设置为 inline-block 或 table-cell 之类的元素，可以为内容创建类似块级的上下文

- float 属性值不是 none 的元素

- 绝对定位的元素

- overflow 属性值不是 visible 的元素

前面说过，块边界接触其包含块边界的规则同样适用于前面是浮动元素的内容。浮动元素从页面流中移出后，通过触发其后的元素中行盒子的缩短行为，制造了为自身腾出四周空间的视觉效果。而其后的元素仍然会按照需要，在浮动元素下方拉伸。

当一个元素具备了触发新块级格式化上下文的条件，并且挨着一个浮动元素时，它就会忽略自己的边界必须接触自己的包含块边界的规则。此时，这个元素会收缩到适当大小；不仅行盒子如此，所有盒子都如此。尽量基于简单且可预测的行为来创建布局，这样可以降低代码复杂度，并提高布局稳健性。

#### 3.2.9 内在大小与外在大小

CSS 的 Intrinsic and Extrinsic Sizing Level3 模块定义了一组可以应用给（min- 和 max-）width 和 height 属性的关键字，而非像素或百分比这种长度值。这些关键字代表了明确的长度，要么继承自周围的上下文（外在大小），要么源于元素自身的内容（内在大小），具体数值由浏览器决定。这样可以代替以往使用的隐含值，比如把某个属性设置为 auto，或者使用浮动或块级格式化上下文，在不设置 width 的情况下达到收缩适应的目的。

目前，支持这个模块中定义的关键字的浏览器还很少。但无论如何，这种更稳健的指定尺寸的方式在未来一定非常有用，毕竟可以省掉同时使用多种技术的麻烦。

### 3.3 其他 CSS 布局模块

对于 CSS 这种视觉表现语言来说，稳健又灵活的布局模型无论如何都是必需的。虽然道理显而易见，但这种模型的诞生却并不容易。过去，曾想方设法地利用这门语言中可用的特性来达成自己的目标，哪怕那些特性并不好用。比如最早我们曾使用表格布局，但问题是代码臃肿、语义不当。近来又在使用浮动和绝对定位，但这些技术同样也并非为页面布局而设计。无论是表格还是浮动与定位，都有非常严重的局限性，使用它们只是不得已的选择。

最近出现了一些专门针对创建灵活、稳健页面布局的 CSS 模块。这些模块的进度快慢不一，有的甚至还没有得到较多浏览器支持。后面会详细介绍其中几个模块，此处先概览一下它们的主要功能。

#### 3.3.1 弹性盒布局

弹性盒布局模块（Flexible Box Layout Module），常被称为 Flexbox，是 CSS3 新引入的一种布局模型。Flexbox 支持对子元素水平或垂直布局，以及设置这些子元素的大小、间距和对齐方式。此外，Flexbox 还支持改变元素渲染到页面上的次序，可以跟它们在 HTML 中的次序不同。作为 CSS 常规流模型（行内和块）的升级版，无论是调整内容本身还是适应内容大小，Flexbox 都做到了既精确又灵活。

Flexbox 已经得到浏览器的广泛支持，只是在旧版本正中缺乏支持或支持不完整。好在可以将 Flexbox 与浮动等其他技术组合使用，以确保跨浏览器布局的稳健。第 6 章会专门讲到 Flexbox<!--TODO-->。

#### 3.3.2 网格布局

网格布局（grid layout）是 CSS 中最早成熟的高层布局工具，目标是取代浮动和定位元素的布局方式。网格布局实现了源代码次序的完全分离，从内容结构和个别模块的表现中抽象出了网格系统。Flexbox 关注 “微观”，而网格系统关注 “宏观”，二者正好互补，网格布局还未得到广泛支持，但各家浏览器正在争先恐后地实现它。第 7 章将全面介绍网格布局<!--TODO-->。

### 3.3.3 多栏布局

多栏布局模块（Multi-column Layout Module）的用意很明确，就是实现内容的多栏布局。比如，要排成像报纸那样的多栏样式。可以先指定栏数，也可以先指定每一栏的宽度，然后让浏览器根据可用宽度自动确定栏数。当然，还可以控制栏间距，并在其中应用类似边框的视觉效果。因为多栏布局更倾向于排版而布局，所以把它放在第 4 章介绍<!--TODO-->

### 3.4 Region

CSS Regions Module Level 1 可以实现内容在不同元素间的灌文接排。可以把一个元素作为内容来源，但它不在常规文档流中，其内容可以灌排到页面中的其他占位元素。这意味着布局不再受 HTML 中元素次序的影响，也就是把布局表现从内容结构中解耦了出来。

使用 CSS Region 排出的板式，在以前是无法只用 CSS 实现的，它为将来在网页中再现印刷品的排版样式奠定了基础。不过，很少有浏览器厂商有兴趣实现 CSS Region，因此可能很长时间内都无法使用它。

## 四. 网页排版

排版是平面设计的基础。同样，排版在网页设计中也扮演着重要角色。

### 4.1 CSS 的基本排版技术

拿到一个页面时，所有设计师都会先考虑从基本的版式着手。从 body 元素开始，逐步细化，从而让整个页面具有基本的可读性、层次性和配色。浏览器有默认样式表，它为网页应用了一些必要的排版规则。

#### 4.1.1 文本颜色

对于网页而言，文本颜色也许是最基本的样式之一，但它的效果却很容易被忽视。默认情况下，浏览器会把绝大部分文本渲染为黑色（链接除外，它们的颜色是 “活力蓝”，白底黑字的对比度极高。足够高的对比度是确保网页阅读无障碍的关键，但也往往会被过分强调。事实上由于屏幕的高对比度，白底黑字会让大段文本显得过分密集，反而影响可读性。

#### 4.1.2 字体族

字体族（font-family）属性的值是一个备选字体的列表，用逗号分隔，按优先级从左到右排列。

这种后备机制是 font-family 属性的重要特性，因为不同的操作系统和移动设备可能安装了不同的字体。何况字体的选择也不仅仅是看某种字体是否存在。如果优先的字体中缺少文本中用到的字形，比如重读符号，浏览器会为缺失的符号向后查找其他字体。

关于什么操作系统中默认安装了哪些字体，有些人已经做过相关的[研究整理](https://www.cssfontstack.com)。

字体列表最后通常有 serif 和 sans-serif 被叫作**通用字体族**，充当没有选择的选择。此外，还有 cursive、fantasy 和 monospace 等通用字体族，只不过 serif 和 sans-serif 应该是最常用的两个。如果网页中要显示代码，应该首选 monospace 字体族，也叫“等宽字体”，因为 monospace 的每个字符的宽度都一样，不同行之间的字符可以完美对齐。fantasy 和 cursive 就没那么常用了，分别对应花式字体和手写字体。

> **注意**：列出包含空格的字体族名称时，引号不是非加不可，但最好加上。规范中只要求与通用字体族重名的字体族要加引号，但同时也建议给包含非标准符号的名称加引号，以防浏览器误判。

**字体与字型**
字型（typeface）、字体族（font-family）和字体（font）这 3 个术语经常有人分不清楚。所谓字型（也叫字体族），就是一组代表字母、数字及其他具有统一外观样式的字形（glyph）的集合字型包含的每种字形，通常有粗体、常规、细体、斜体等变体，能够以不同样式显示数值、连字等，还可能有其他变体。

最初，字体指的是一种字型中的某种特定变体所包含的所有字形的集合，由金属制成。这些选出来的字形会被装上印刷机。而在数字排版领域，字体通常指一个存有某种字型表示的文件。假设有一种字型叫 “CSS Mastery”，那么它可能只有一个字体文件，也可能包含多个字体文件，比如 “CSS Mastery 常规” “CSS Mastery 斜体” 或 “ CSS Mastery 细体” 等。

#### 4.1.3 字型大小与行高

几乎所有浏览器中 font-size 的默认大小都是 16 像素，除非用户修改过偏好设置。

`em` 单位用于 font-size 属性时，实际上是一个相应元素继承的 font-size 缩放因子。比如 h3 元素，字型大小就是 `1.314*16=21px`。虽然可以直接设置 21px，但 em 更灵活一些。多数浏览器都允许用户缩放整个页面，即使像素单位也可以缩放。而使用 em 之后，如果用户修改偏好中的默认 font-size 大小，那么相应元素的大小也会相应调整。

因为 em 单位基于继承的大小缩放，所以可以通过缩放父元素的 font-size 来修改页面局部的继承大小。但这样做也有问题（也是使用 em 经常出错的地方）：可能因为调整了某个元素在标记中的位置而意外改变其字型大小。因此，在使用相对长度值的时候，必须留意最终计算得到的值。

对于 font-size 属性，可用**百分比**代替 em。133.3% 在这里与 1.33em 没有区别，选择哪个完全取决于个人偏好。

而最灵活的方式则是使用 `rem` 单位。与 em 类似，rem 也是一个缩放因子，但它始终基于**根元素**的 em 大小缩放（根元素的 em，就是 root element em，即 rem），也就是基于 html 元素的 font-size 缩放。

当 em 用于计算盒模型的大小时，它不是基于继承的 font-size，而是基于元素自身计算的 font-size。因此，不同级别的标题对应的 font-size 是不一样的。为了得到一致的值（同时又要保证灵活），要么使用 rem，要么对每个标题级别都分别以 em 计算 margin-top 值。

rem 单位相对较新，但已经得到所有现代浏览器的支持。为了兼容 IE8 及更早版本的 IE，可以利用 CSS 的容错机制，在基于 rem 的声明之前再声明一个像素单位的值。

> 长度单位还有 mm、cm、in 和 pt 等**绝对物理长度**，这些主要是给打印样式准备的。网页设计不应该使用这些单位。本章不介绍打印样式表，但会在第 8 章<!--TODO-->介绍如何针对不同的媒体类型应用样式。

**基于比例缩放字型大小**
font-size 到底应该选多大，其实没有硬性要求。总体来说，就是要让文本足够大，让人能轻松地看清楚，同时要保证字型大小在当前上下文中比较合适。有些人相信自己的眼睛，认为看着舒服最重要；有些人则相信缜密的数学计算，处处奉科学原理为圭臬。

下面标题的大小大致符合一个叫做 “纯四度”（perfect fourth）的数学比例，即上一级标题会比下一级标题的字型大自身尺寸的 1/4，这里的数值经过舍入，并保留了 3 位小数：

```css
h1 {
  font-size: 2.315em; /* 37px */
}
h2 {
  font-size: 1.75em; /* 28px */
}
h3 {
  font-size: 1.314em; /* 21px */
}
```

此类比例关系对于初始阶段的网页设计至关重要。即使最终还是凭感觉设置字型大小，尽量位置类似的比例关系也是必要的。可以试一试 [Modular Scale 计算器](https://www.modularscale.com/)。

#### 4.1.4 行间距、对齐及行盒子的构造

深入剖析 CSS 行内格式化模型，同时多理解一些排版术语。下图展示了构成一行文本的各个部分：

![行内格式化模型的构造及相关概念](./image/行内格式化模型的构造及相关概念.jpg)

行内格式化，每行文本都会生成一个行盒子。行盒子还可以进一步拆分成表示行内元素（比如上面例子中的 `<strong>` 元素）的行内盒子，或者连接两个行内元素的匿名行内盒子。

行内盒子中的内容区显示文本。内容区的高度由 font-size 的测量尺度，即上图中 “Moon” 末尾那个 1em 见方的块，以及这个块与字形本身的关系来决定。西方传统排版术语 “em” 对应 CSS 中的 em 单位，这个概念最初指大写字母 “M” 的大小，但在网页排版中这个定义已经不适用了。

小写字母 “x” 的上边界决定了所谓的 “x 高度”。不同字体的 x 高度差异很大，因此很难就字体大小给出一个通用的建议。要想知道精确的字型大小，就必须分别测试。

然后，字形会被摆放在内容区中，每个字形都在垂直方向上不偏不倚，使得每个行内盒子的底边都默认对齐于靠近底部的共同水平线，这条线叫**基线**。内容区也不一定会限制住字形，比如某些字体中的小写字母 “g” 就会向下伸出内容区。

最后，**行高指的是行盒子的总高度。更通俗的叫法是行间距**，排版术语叫铅空，就是排字员用来隔开字符行的铅块。但与传统排版不同，CSS 中的 “铅空” 始终都会同时应用到行盒子的上方和下方。

计算方法如下：行盒子的整体行高减去 font-size，得到的值再平分成两份，也就是**半铅空**。如果 line-height 是 30 像素，而 font-size 是 21 像素，那么半铅空就是 4.5 像素。

> **注意**：如果行盒子中包含多个行高不一的行内盒子，那么这个行盒子的最终高度至少等于其中最高的行内盒子。

1. **设置行高**
   设置行高时，需要考虑当前字体大小。一般来说，行高取值在 1.2~1.5 范围内。关键是行与行之间既不能太密，也不能太疏。对于 x 高度较大的字体，行间距应该稍大一些。文本的长度和 font-size 也要考虑，短文本一般设置较小的 line-height。可以给 line-height 设置无单位数值、像素值、百分比值、rem 或 em 值。

   > **注意**：body 元素的所有子元素都会继承 line-height 的计算值。换句话说，就算 body 用的是百分比或 em，其子元素继承的都是计算后得到的像素值，但无单位的值就不会导致这个结果。因此，如果给 line-height 设置没有单位的值，那么子元素继承的是一个系数，永远与自己的 font-size 成比例。

2. **垂直对齐**
   除了 line-height，行内盒子也会受到 `vertical-align` 属性的影响。它的默认值是 baseline，即子元素的基线与父元素的基线对齐。

   其他关键字值有 sup、super、top、 bottom、text-top、text-bottom 和 middle。这些值或多或少都与内容区和父行盒子有着复杂的关系。仅举一例，text-top 或 text-bottom 会让当前元素的内容区与父行盒子的内容区顶部或底部对齐，但只有在行内盒子的 font-size 或 line-height 与其父元素不同时才会有影响。如前所述，关系复杂。

   或许通过设置长度值—无论是像素值，还是 font-size 的相对值（如 em 或 %）—让元素的基线偏离父元素基线是理解垂直对齐的最直观方式。

   > **注意**：影响文本行间距的值不只是 line-height。如果行盒子中有一个元素使用 vertical-align 调整了位置，那么它可能会扩展行盒子的高度。

> **注意**：与行内文本相比，行内块和图片的垂直对齐行为稍有不同，因为它们不一定有自己的唯一基线。第 6 章将介绍如何利用这一点实现特定布局效果<!--TODO-->。

### 4.1.5 文本粗细

使用 `font-weight` 属性来设置标题文本的粗细。有些字体的变体很多，比如 Helvetica Neue Light、Helvetica Neue Bold、Helvetica Neue Black。此时，可以不用给出变体的名字，而只使用关键字：normal、bold、 bolder 和 lighter。也可以直接给出数字值，都是 100 的整数倍：100、200、300、400，等等，最大为 900。

默认值 normal 对应 400，bold 对应 700，这两个粗细值是最常用的。关键字 bolder 和 lighter 的工作机制略有不同，它们的作用是在继承值的基础上把文本变粗或变细。

数字值 100~300 对应的字体名字中通常包含 “Thin” “Hairline” “Ultra Light” 和 “Light” 等字样。反之，数字值 800 或 900 对应的字体名字中可能包含 “Ultra Bold” “Heavy” 或 “Black"。500 或 600 则代表中等粗细。

Avenir Next 和 Segoe UI（都是首选字体）都包含很多粗细的变体。_如果某款字体缺少想要的粗细变体，浏览器会尽量模拟加粗效果，但无论如何不能模拟变细效果。这种模拟的结果往往差强人意_。

#### 4.1.6 字体样式

设置 `font-style: italic` 会从字型中选择斜体显示，前提是存在这个变体。如果不存在，浏览器会通过倾斜字体来模拟，但结果同样也不会太理想。斜体通常用于表示强调，或者表达一种不同的语气。除了 italic 和默认的 normal 以外，也可以给 font-style 设置 `oblique` 关键字（是倾斜文本的另一个变体），但它很少用，因为没有几款字体含有这种变体。

#### 4.1.7 大小写变换和小型大写变体

有时候，设计需要显示与 HTML 源码中不同的大小写。CSS 可以控制英文字母大小写，属性是 `text-transform`。在例子中，h1 元素中的文本是首字母大写的，但通过 CSS 强制把所有字母都显示为大写了：

```css
h1 {
  text-transform: uppercase;
}
```

除了 `uppercase` 这个值，还可以用 `lowercase` 把所有字母变成小写，用 `capitalize` 把每个单词的首字母变成大写，或者使用 `none` 显示 HTML 源码中的默认大小写形式。

**使用 font-variant**
CSS 还有一个属性 `font-variant`，可以通过值 `small-caps` 把英文文本转换成所谓的 “小型大写字母”。“小型大写字母” 也是一种字型的变体，虽然所有字母都大写，但只有首字母是正常大小，其他字母的大小跟原来小写时一样，就像缩小了似的。正确的 small-caps 变体很大程度上会依据字母的字形来变化，而不仅仅是简单地缩小字母。不过能做到这一点的多数是收费字体。浏览器会在没安装这些字体时尝试模拟类似的行为。可以通过 abbr 标签包含的首字母缩写来示范一下浏览器的行为：

```html
<abbr title="National Aeronautics and Space Administration">NASA</abbr>
```

同时还应用了 `text-transform: lowercase`，因为 HTML 源码中的 NASA 本来就大写了。还需要稍微缩小一点 line-height，因为 small-caps 会导致某些浏览器把内容盒子向下移动一点，从而影响整体行盒子的高度：

```css
abbr {
  text-transform: lowercase;
  font-variant: small-caps;
  line-height: 1.25;
}
```

CSS 2.1 只对 font-variant 属性规定了一个有效的值：small-caps。而 CSS Fonts Module Level 3 则大加扩展，增加了很多不同字形的输出选择。浏览器实现相对滞后，但好在有办法支持这些新选择。会在后面介绍高级排版技术时再讲<!--TODO-->。

#### 4.1.8 控制字母和单词间距

一般来说，控制字母和单词间距是字体设计师的事儿。不过 CSS 也提供了一些简陋的工具来控制这些。

首先是 `word-spacing` 属性，功能是控制词间距，很少用。它的值意味着在默认词间距基础上增加或减少一定的量，而默认词间距由当前字体中空白字符的宽度决定。

类似地，可以通过 `letter-spacing` 属性来控制字符间的距离。对于小写英文字母的文本来说，人为改变字母间距并不是好事，因为大多数字型的设计初衷都是让人更容易辨别整个单词，而随意调整字母间距可能导致文本难以辨别。对于大写字母（或小型大写字母）的文本而言，则要视情况而定。比如缩写词，稍微加大一点字母间距有助于阅读。

### 4.2 版心宽度、律动和毛边

接下来探讨一个对阅读体验有着重大影响的因素：行长。用排版的行话说，就是**版心宽度**。过长或过短的文本行会打断人的眼球移动，导致读者无法连续阅读，最后甚至读不下去。

一行文本到底多长才合适，并没有什么终极答案。字体不同、屏幕大小不同、文本内容不同，都会影响行长。只能根据过往的研究和专业人士的建议，在自己设计页面时定义尽量合适的长度。

Robert Bringhurst 的经典图书 _The Elements of Typographic Style_ 提到，主体内容的文本行长通常是 45~75 个字符，平均值为 66 个字符。排版专家 Richard rutter 发现这个建议同样适用于今天的网页，特别是大屏幕中的网页。对于小屏幕（或者远距离观看的大屏幕，如电影或投影）而言，行长至少也应该有 40 个字符。

**要控制行长，可以通过设定包含文本的段落、标题等元素的宽度来实现**。对于页面主体文本而言，Georgia 字体的字母相对较宽（因为其 x 高度较大），因此行长就要考虑使用前述范围的上限。为此，简单地将 article 元素的宽度设置为 36em（平均每个字符 0.5em），并令其在页面上居中。如果视口缩小到比这个值更窄，该元素会自动调整宽度。

```css
article {
  max-width: 36em;
  margin: 0 auto;
}
```

#### 4.2.1 文本缩进与对齐

默认情况下，文本都是左对齐的。文本左对齐有助于找到下一行，保持阅读节奏。对于连续的段落，或者为相邻段落设置 1 行的外边距，或设置段首缩进（`text-index`）。

段落的右边可能参差不齐。这种参差不齐的样式在排版上也有术语，叫做 “毛边”（rag）。在应用文本居中对齐时需要格外小心，除非行长很短。居中文本非常适合小型用户界面元素或短标题的布局，因为两端参差不齐会影响可读性。

`text-align` 属性可以接受下列任意一个关键字值：left、right、center 和 justify。CSS Text Level3 规范还额外定义了几个值，包括 start 和 end。这两个逻辑方向关键字与文本书写模式相对应：多数西方语言都是从左向右书写，因此如果文本语言是英语，那么 start 就代表左对齐，end 代表右对齐。而在从右向左书写的语言中（如阿拉伯语，就正好相反。如果给父元素设置了 dir="rtl" 属性，即从右向左显示，浏览器通常都会自动反转默认的文本方向。

给 `text-align` 属性应用 `justify` 值，可以在单词间平均分布间距，结果就是左右两端对齐消除毛边。这也是印刷业中经常采用的技术，原版包括连字符在内的字体特性都会被修整以适应页面空间。

网页又是另一种媒体，很多因素无法控制。屏幕大小不同、安装的字体不同、浏览器引擎不同，这些都会影响用户最终在页面上看到的结果。如果让文本两端对齐，可能会导致下图的结果，不易认读。由文本空白构成的 “串流”（river of whitespace）会出现，版心宽度越小就越严重。

![文本“串流”现象](./image/文本“串流”现象.jpg)

浏览器处理文本两端对齐时使用的算法挺粗糙的，不如传统出版效果好。虽然可以通过 `text-justify` 属性修改使用的算法，但浏览器对其多个值的支持较弱，基本上只涉及调整非西方语言的字形和单词。

有意思的是，IE 支持这个属性的一个非标准值 newspaper，它好像使用了更聪明的算法。该算法会同时调整字母间距和单词间距。

#### 4.2.2 连字符

如果仍然打算在页面中让文本两端对齐，那么连字符可能会有助于减轻串流问题。为此，可以手工在 HTML 中插入一个表示连字符的实体，即所谓的软连字符 **&shy;**。只有当浏览器需要断词换行时才会显示这个连字符。

![手工插入软连字符](./image/手工插入软连字符.jpg)

对于文章之类的长文本，手动逐个插入连字符并不现实。此时可以使用 `hyphens` 属性，让浏览器帮插入连字符。这个属性相对较新，因此一般要加上浏览器前缀才能生效。IE10 之前的版本、安卓设备中内置的 WebKit 浏览器，甚至连基于 Blink 的 Chrome 和 Opera 都基本不支持 `hyphens`。

要想使用自动连字符功能，需要保证两点：

1. 在网页 html 元素中设置语言代码

   ```html
   <html lang="en"></html>
   ```

2. 通过 CSS 将相关元素的 `hyphens` 属性值设为 auto。

   ```css
   p {
     hyphens: auto;
   }
   ```

要关闭连字符，可以将 `hyphens` 属性值设置为 manual，即手动模式。在手动模式下，软连字符机制会起作用。

#### 4.2.3 多栏文本

把整篇文章的宽度都限制为 36em 可以达到限制版心宽度的目的，但对于大屏幕而言，却又太浪费空间了，留着大片的空白很可惜！有时候，为了有效利用宽屏，可以把文本分成多栏，并对每栏的宽度加以限制。CSS Multi-column Layout Module 定义的属性可以把文本内容切分成多个等宽的栏。

“Multi-column Layout” 这个名字容易让人产生误会，以为使用它定义的属性，就可以在页面上创建带有栏和栏间距控制的网格布局。实际上并不是这样，这个模块定义的属性只是用来把网页中部分内容的版式转换成类似报纸上的分栏效果。当然，利用这些属性创建其他布局效果完全没问题，只是可能并非该模块的初衷罢了。

如果把之前设置的 max-width 增加到 70em，那么可以分成 3 栏。为此，要把 `columns` 属性设置为想要的最小宽度。栏间距通过 `colum-gap` 属性控制：

```css
article {
  max-width: 70em;
  columns: 20em;
  column-gap: 1.5em;
  margin: 0 auto;
}
```

![Multi-column-Layout](./image/Multi-column-Layout.jpg)

这里的 `columns` 属性是 `column-count` 和 `column-width` 属性的简写形式。如果只设置 `column-count` 属性，浏览器会严格生成指定数量的栏，不管宽度如何。如果同时设置了 `column-count` 和 `colum-width`，则前者会作为最大栏数，后者会作为最小栏宽。

```css
article {
  columns: 20em; /* 在保证最小宽度 20em 的前提下，自动设置栏数 */
  column-width: 20em; /* 同上 */

  columns: 3; /* 3栏，自动设置宽度 */
  column-count: 3; /* 同上 */

  columns: 3 20em; /* 至少3栏，每栏宽度至少 20em */
  /* 以下两条声明的組合相当于以上代码的简写形式：*/
  column-count: 3;
  column-width: 20em;
}
```

1. **后备宽度**

   为了在不支持多栏属性的浏览器中确保行长不会超过限度，可以在段落元素上应 max-width 属性。这样一来，旧版本浏览器只会显示一栏，但仍然能保证可读性：

   ```css
   article > p {
     max-width: 36em;
   }
   ```

2. **跨栏**

   在前面的例子中，文章中的所有元素都排在了栏内文本流中。其实可以让某些元素排到该本流之外，强制它们伸长以达到跨栏效果。下图中，文章标题和最后一段（包含来源链接）就横跨了所有栏：

   ```css
   h1,
   source {
     column-span: all; /* 或 column-span: none;，以关闭跨栏特性 */
   }
   ```

   ![column-span跨栏](./image/column-span跨栏.jpg)

   如果让位于文本流中间的一个元素横跨所有栏，那么文本会按照垂直切分后的几栏流动。在下图中，为 h2 元素应用了前面的规则，结果该标题前面后的文本分别灌入了各自的几个分栏。

   ![垂直切分多栏文本流](./image/垂直切分多栏文本流.jpg)

   几乎所有浏览器都支持上述多栏布局属性，IE9 及版本更早的 IE 除外。以下是几条使用建议：

   - 几乎所有浏览器都需要使用合适的开发商前缀。
   - 浏览器对多栏布局属性的实现存在不一致，而且还有一些 bug，其中多数集中于外边距折叠和边框渲染方面。

3. **垂直律动与基线网格**

   在排版时运用一些数学关系很有好处。比如，对于不同标题的大小，采用 “纯四度” 关系（比率约为 1.26）。同时，所有标题都应用了值为 1.5em（相当于一行正文高度）的 margin-top。此外，所有分栏的间距也是统一的。不少设计师非常信奉这种和谐的比例关系，把基本行高作为设计其他部分的基准。

   在印刷设计中，这种律动关系的应用非常普遍，结果就是正文文本都会排进基线网格。即使标题、引用或其他页面部件时不时会打破这种律动，大的格局也不会受影响。这样不仅有助于读者眼球移动时轻松对准文本，还可以在双面印刷时避免背面的文本透过纸面，因为两面都遵循相同的基线。

   在网页设计中，要保证基线准确可是麻烦多了，尤其是在视口会变、允许用户上传图片的情况下。不过在可能的情况下，还是有必要这样做的，比如使用多栏文本布局的时候。

### 4.3 Web 字体

目前为止，在示例中用到的都是用户电脑中安装的字体。Helvetica、Georgia 和 Times New Roman 等网页中常用的英文字体几乎每个电脑都有，因为 Windows 和 macOS X 操作系统多年来一直会预装它们。

多年来，设计师一直梦想着可以在网页中嵌入远程字体，就像在网页中插入图片一样。自 1997 年 IE4 面世以来，相应的技术就已经出现了，只不过到了 2009 年才被 Firefox、Safari 和 Opera 等浏览器普遍支持。

此后，Web 字体有了长足的发展。起初只是个人博客和网站的零星尝试，发展到今天，主流网站乃至政府机关的网站都开始采用定制的 Web 字体。

#### 4.3.1 许可

使用 Web 字体还有一个问题，那就是许可。最开始的时候，字体设计者在授权浏览器下载他们的字体方面非常谨慎，因为担心发生无法控制的侵权问题。这种担忧持续了几年才有所缓解。多数字体设计者都施加了安全限制。比如，只允许从指定的域名下载字体，或者要求定期改字体名，以防止盗链。

**Web 字体托管服务**
尝试 Web 字体最简单的方式，就是使用 Web 字体服务。有一些是收费的，比如 Adobe Typekit、Cloud.typography 以及 Fonts.com，它们会负责相关的一切。还有免费的 Google Fonts，是 Google 汇总并托管的一些免费字体。

这些在线服务会帮用户处理设计者的许可事宜、支持把字体转换为多种格式，确保下载字体包含正确的字符集以及一些优化。然后，通过它们的高速服务器把字体提供给使用者。

使用这些托管服务可以选择一次性许可，也可以选择长期租用。使用字体托管服务的好处是，复杂的事情不用考虑，只要关心如何在网站中使用这些字体就行了。

#### 4.3.2 @font-face 规则

嵌入 Web 字体的关键是 `@font-face` 规则。通过它可以指定浏览器下载 Web 字体的服务器地址，以及如何在样式表中引用该字体。

```css
@font-face {
  font-family: Vollkorn;
  font-weight: bold;
  src: url('fonts/vollkorn/Vollkorn-Bold.woff') format('woff');
}

h1 {
  font-family: Vollkorn, Georgia, serif;
  font-weight: bold;
}
```

前面的 `@font-face` 块声明了在 `font-family` 值为 Vollkorn 且为粗体时应用该规则。之后提供了一个 URL，供浏览器下载包含粗体字体的 Web 开放字体格式（WOFF，Web open font format）文件。

声明了新的字体 Vollkorn 后，就可以在随后的 CSS 中通过 `font-family` 属性正常使用它了。

1. **字体文件格式**
   虽然目前浏览器基本上都已经支持 Web 字体，但它们对字体文件格式的支持却不一致。字体格式的问题很复杂，涉及微软、苹果、Adobe 等公司的发展史。好在所有浏览器开发商都支持标准的 WOFF 格式，有的甚至支持较新的 WOFF2。如果项目需要支持 IE8 及更早版本的 IE、旧版本的 Safari 或早期的安卓设备，那么可能要多写几行代码，补足各种格式的字体文件，比如 SVG、EOT 和 TTF。

   > 如果获得了某款 Web 字体的使用许可，可以通过 Font Squirrel 生成其他格式。

   为了解决旧版本浏览器对字体格式支持的不一致问题，可以在 `@font-face` 规则中声明多个 src 值（与 font-family 很像），包括 `format()` 提示。然后，由浏览器来决定到底使用哪种格式。

   做到这一步，基本上就可以实现 Web 字体的跨浏览器支持了。比如以下的 `@font-face` 规则：

   ```css
   @font-face {
     font-family: Vollkorn;
     src: url('fonts/Vollkorn-Regular.eot#?ie') format('embedded-opentype'), url('fonts/Vollkorn-Regular.woff2') format('woff2'),
       url('fonts/Vollkorn-Regular.woff') format('woff'), url('fonts/Vollkorn-Regular.ttf') format('truetype'),
       url('fonts/Vollkorn-Regular.svg') format('svg');
   }
   ```

   以上例子涵盖了支持 EOT、WOFF（包括 WOFF2）、TTF 和 SVG 的所有浏览器，几乎是现在市面上能见到的所有浏览器了。而且，通过在 src 的值中使用查询字符串，甚至可以满足 IE6~8 的古怪行为。

2. **字体描述符**

   `@font-face` 规则可以接受几个声明，多数是可选的。最常见的列举如下：

   - font-family：必需，字体族的名称。
   - src：必需，URL 或 URL 列表，用于下载字体。
   - font-weight：可选的字体粗细，默认值为 normal。
   - font-style：可选的字体样式，默认值为 normal。

   > **注意**：这些声明与通常规则中的 font 属性不是一回事。这几个都不是属性，而是**字体描述符**（font descriptor）。它们不会改变字体，它们的值只是为了告诉浏览器在什么情况下可以触发使用这个特定的字体文件。

   如果这里的 font-weight 值为 bold，那么就是告诉浏览器：“如果 font-family 中字体的 font-weight 设置成了 bold，那么可以使用这里定义的字体文件。”此处有一个陷阱：假如 Vollkorn 只在这里定义了这么一次，那么其他粗细也可以使用这里的字体文件，无论是否匹配。这是由于标准规定的浏览器加载和选择字体的原则：正确的 font-family 优先于正确的粗细值。

   很多字型包含不同粗细、样式和变体的字体，因此可以在 `@font-face` 块中使用相同的 Vollkorn 名称，但引用不同的字体文件。在下面的例子中，加载了两种不同的字型，声明了具体的粗细值和样式对应的字体文件：

   ```css
   @font-face {
     font-family: AlegreyaSans;
     src: url('fonts/alegreya/AlegreyaSans-Regular.woff2') format('woff2'), url('fonts/alegreya/AlegreyaSans-Regular.woff')
         format('woff');
     /* 字体粗细和样式都为默认值 normal */
   }

   @font-face {
     font-family: Vollkorn;
     src: url('fonts/vollkorn/Vollkorn-Medium.woff2') format('woff2'), url('fonts/vollkorn/Vollkorn-Medium.woff') format('woff');
     font-weight: 500;
   }

   @font-face {
     font-family: Vollkorn;
     font-weight: bold;
     src: url('fonts/vollkorn/Vollkorn-Bold.woff2') format('woff2'), url('fonts/vollkorn/Vollkorn-Bold.woff') format('woff');
   }
   ```

   在随后的样式表中，通过声明不同的粗细值，就可以分别使用不同的字体文件：

   ```css
   body {
     font-family: AlegreyaSans, Helvetica, arial, sans-serif;
   }

   p {
     font-family: Vollkorn, Georgia, Times, 'Times New Roman', serif;
     font-weight: bold; /* 使用 Vollkorn bold 字体 */
   }

   h3 {
     font-weight: 500; /* 使用 Vollkorn Medium 字体 */
   }
   ```

#### 4.3.3 Web 字体、浏览器与性能

Web 字体给网页设计带来了很大的飞跃，但同时也给网页中的实际应用带来了一些麻烦。

首先，浏览器需要下载额外的字体文件，这显然会延长用户等待的时间。使用 Web 字体首先必须注意不要加载过多的字体文件。如果自己托管自己的自定义字体，那么要确保设置适当的缓存首部，以避免不必要的网络开销。除此之外，浏览器在渲染这些字体时也有一些问题。

在下载 Web 字体的时候，浏览器有两种方式处理相应的文本内容：

- 在字体下载完成前暂缓显示文本，术语叫 FOIT（flash of invisible text）。Safari、Chrome 和 IE 默认采用这种方式，问题是用户必须等待字体下载完成才能看到内容。如果用户的网络速度很慢，这个问题会非常明显。

- 在字体下载完成前，浏览器先用一种后备字体显示内容。这样可以避免因网速慢而引起的问题，但也会带来字体切换时的闪动问题。这个闪动有时候也被称为 FOUT（flash of unstyled text）。FOUT 影响用户感知的速度，特别是在后备字体与 Web 字体的大小相差较多的情况下。如果在字体下载完成并应用的瞬间，网页内容跳跃过大，用户可能会失去焦点。

如果想更好地控制浏览器处理 Web 字体的方式，包括如何显示 Web 字体和后备字体，那么可以选择使用 JS 加载字体。

#### 4.3.4 使用 JS 加载字体

最近的 CSS Font Loading 规范定义了一个用于加载字体的实验性 JS API，可惜这个 API 尚未得到浏览器的广泛支持。因此，需要借助第三方库来实现一致的字体加载体验。

Typekit 维护着一个开源 JS 工具，叫 Web Font Loader。这个库体积很小，在浏览器支持的情况下，它会使用原生的字体加载 API；在浏览器不支持的情况下，它会模拟相同的功能。这个库内置支持一些 Web 字体服务，比如 Typekit、Google Fonts 和 Fonts.com，同时也支持自托管的字体。

可以下载这个[库](https://developers.google.com/speed/libraries/#/web-font-loader)，也可以从 Google 的服务器上加载它。Web Font Loader 提供了很多有用的功能，其中最有用的就是确保字体加载的跨浏览器一致性。希望使用它达到的效果是，即使在网速慢的情况下也不会妨碍用户阅读内容。换句话说，想在目标浏览器中实现一致的 FOUT 行为。

Web Font Loader 为以下事件提供了接入点：

- loading：开始加载字体。
- active：字体加载完成。
- inactive：字体加载失败。

在下面例子中，需要把 `@font-face` 块中的所有代码转移到一个独立的样式表 alegreya-vollkorn.css，同时把它放在一个子文件夹 css 中。然后，需要在页面头部添加一小段 JS 代码：

```html
<script type="text/javascript">
  WebFontConfig = {
    custom: {
      families: ['AlegreyaSans:n4,i4', 'Vollkorn:n6,n5,n7'],
      urls: ['css/alegreya-vollkorn.css']
    }
  };

  void (() => {
    let wf = document.createElement('script');
    wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = true;
    let s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>
```

这段代码既负责加载 Web Font loader 脚本，又负责配置后面要使用的字体变体。描述变体的代码在 font-family 名称后面，比如 n4 表示 “normal 样式，400 粗细”，以此类推。在这个样式表中的字体加载后，脚本会自动给 html 元素添加生成的类名。这样，就可以在 CSS 中提前编写加载新字体的规则：

```css
body {
  font-family: Helvetica, arial, sans-serif;
}

.wf-alegreya-n4-active body {
  font-family: Alegreya, Helvetica, arial, sans-serif;
}
```

这两条 CSS 规则的含义是，在 Alegreya 字体加载前，使用准备好的后备字体。而在 Alegreya 字体加载后，脚本会给 html 元素添加 wf-alegreya-n4-active 类，于是浏览器马上启用新下载的字体。这样不仅能保证跨浏览器加载字体的一致性，还有机会为后备字体和 Web 字体分别调整版式。

**匹配后备字体大小**
通过在字体加载期间应用类似的规则，可以控制因 Web 字体与后备字体大小不同带来的版式抖动。希望，在 Web 字体替代后备字体的瞬间，版式抖动尽可能细微且不易被用户察觉。

在下面例子中，Alegreya 字体的 x 高度明显小于 Helvetica 和 Arial（后两个字体的尺寸差不多）。通过微调 font-size 和 line-height，可以让它们的高度尽量接近。同理，还可以通过 word-spacing 来微调字符宽度。这样做的结果是，使用后备字体时的版式与切换为使用 Web 字体时会相差无几。

```css
.wf-alegreyasans-n4-loading p {
  font-size: 0.905em;
  word-spacing: -0.11em;
  line-height: 1.72;
}
```

使用 Web Font loader 要注意的另一件事是在 web 字体加载后设置 `font-size-adjust` 属性。这个属性用于指定 x 高度与 font-size 的比率。在某个字形缺少合适字体的情况下，后备字体会被调整为该比率。这个比率通常是高度的一半（值为 0.5），但也可能不是，有可能导致后备字体与 Web 字体的差异非常明显。在这里用不着测量并设置一个数值，可以直接设置一个关键字 auto，让浏览器替做这件事：

```css
.wf-alegreyasans-n4-active body {
  font-size-adjust: auto;
}
```

### 4.4 高级排版特性

微软和 Adobe 在 20 世纪 90 年代开发的 OpenType 字体格式，支持在字体文件中包含字体的额外设定和特性。如果使用的字体文件（.ttf、.otf 或 .woff/.woff2 都有可能）包含 OpenType 特性，那么在多数现代浏览器中都可以控制更多的 CSS 特性。这些特性包括字距调整（kerning）、连字（ligature）、替代数字（alternative numeral0，以及饰线（swash）等装饰性笔画。

CSS 字体规范中也有许多与 OpenType 对应的属性，比如 font-kerning、font-variant-numeric 和 font-variant-ligatures。浏览器对这些属性的支持并不一致，但可以通过另一个更低级的属性 `font-fearture-settings` 来控制相应的特性。不过最好是两个属性都使用，因为也有浏览器支持上述的对应属性而不支持这个低级属性。

`font-fearture-settings` 接受一些用于切换特性的值，就是 4 个字母的 OpenType 代码，其中也可以带有数值。比如，可以启用下图所示的连字特性。

![font-fearture-settings连字特性](./image/font-fearture-settings连字特性.jpg)

字体设计者可以根据使用目的，为连字特性指定分类。为启用 Vollkorn 中内置的两种连字特性，标准连字（standard ligatures）和任意连字（discretionary ligatures），可以使用以下规则：

```css
p {
  font-variant-ligatures: common-ligatures discretionary-ligatures;
  font-feature-settings: 'liga', 'dlig';
}
```

对支持 OpenType 的浏览器，通过对应的 `font-variant-ligatures` 属性始终可以默认启用标准连字特性，因此前面第一条声明里就没有把标准连字特性写出来。有些浏览器支持 `font-feature-settings` 属性，但语法不一样。另外一些浏览器可能要求在这个属性前面加上开发商前缀。总之，启用常用（common）和任意（discretionary）连字特性的完整规则如下：

```css
p {
  font-variant-ligatures: discretionary-ligatures;
  -webkit-font-feature-settings: 'liga', 'dlig';
  -moz-font-feature-settings: 'liga', 'dlig';
  -moz-font-feature-settings: 'liga=1, dlig=1';
  font-feature-settings: 'liga', 'dlig';
}
```

下面稍微解释一下：

- 影响 OpenType 特性的标准方式是使用加引号的 4 个字符的代码，后接一个关键字 on 或 off（可选），也可以后接一个数字（可选）。代码表示特定的状态，如果不写，则使用默认值 on。

- 以数字 0 表示状态相当于关闭特性。如果特性只有 “开” 和 “关” 两个状态，那么 1 就表示 “开”。有的特性会包含多个 “状态”，可以通过相应的数字来选择，具体数字的含义取决于字体以及想启用的特性。

- 如果想一次性列出多个特性，值之间要用逗号隔开。

- 多数浏览器都以加前缀的属性实现这些特性，因此别忘了加上开发商前缀。

- 针对 Mozilla 浏览器的旧语法稍有不同：多个特性作为一个字符串写在一对引号中，特性之间以逗号隔开；每个特性的状态则以写在等号后面的数字表示。

完整的 OpenType 特性代码，可以在微软的[这个网页](https://docs.microsoft.com/zh-cn/typography/opentype/spec/featurelist)中找到。

#### 4.4.1 数字

有些字体中包含多种数字形式。Georgia 或 Vollkorn 等字体会默认使用老式的数字，也就是数字跟字母一样，有上伸部分（ascender）和下伸部分（descender）。Vollkorn 也包含线性数字，即所有数字都位于基线以上、具有与大写字母一样的高度。通过如下代码分别展示了老式数字和线性数字：

```css
.lining-nums {
  font-variant-numeric: lining-nums;
  font-feature-settings: 'lnum';
}
.old-style {
  font-variant-numeric: oldstyle-nums;
  font-feature-settings: 'onum';
}
```

![线性数字与老式数字](./image/线性数字与老式数字.jpg)

多数字体都有不同宽度的数字（比例数字），跟常规字母一样。如果想在表格或列表中垂直对齐数字，那么可能就需要表列数字。通过如下代码组合使用了下图中的表列数字和线性数字：

```css
table {
  font-variant-numeric: tabular-nums lining-nums;
  font-feature-settings: 'tnum', 'lnum';
}
```

![表列线性数字](./image/表列线性数字.jpg)

#### 4.4.2 字距选项及文本渲染

高品质字体中通常包含用于调整某些字形间距的数据。这种微调间距的过程叫作**字距调整**（kerning）。换句话说，有些字母之间需要加大间隔才不会显得拥挤，而有些字母之间需要缩小间隔才不会显得疏远。

浏览器在渲染文本时通常会基于已知的尺寸自动处理字距，不过也可以手动设置现代浏览器读取字距调整数据。为此，可以设置 `font-kerning` 属性，或者启用 OpenType 的 kern 特性

```css
.kern {
  font-kerning: normal;
  font-feature-settings: 'kern';
}
```

关键字 normal 告诉浏览器从字体中读取字距调整数据（如果有的话）。而 auto 关键字则允许浏览器自作主张，只在它认为合适的时候开启字距调整。比如，在文本很小的情况下，浏览器可能就不会多此一举。最后，如果要明确告诉浏览器不进行字距调整，就使用 none。

> **注意**：在有些浏览器中，启用其他 OpenType 特性（如连字）可能自动触发字距调整。因此，如果希望连字但不调整字距，就需要明确告诉浏览器不进行字距调整。反之，启用 kern 特性也可能触发常见或标准连字特性。

**不要使用 text-rendering 属性**
设置 `text-rendering: optimizeLegibility` 是启用字距调整并同时启用连字的另一种方式。这不是 CSS 标准的方式，而是 SVG 规范中的一个属性，用于告诉浏览器选一种方法来渲染 SVG 中的字母。这个属性的值还有 optimizeSpeed（性能优先）、optimizeGeometricPrecision（更精确）或 optimizeLegibility（可读性）。

这个属性出现时间不短了，也得到了浏览器较好的支持，因此很多网站会采用。在 WebKit 浏览器支持 font-feature-settings 属性以前，这个属性是在旧版浏览器中激活相应特性的唯一方法。然而，这个属性存在一些严重的渲染问题，建议最好不使用它。

### 4.5 文本特效

#### 4.5.1 合理使用文本阴影

CSS 的 `text-shadow` 属性可以用来给文本绘制阴影。给大篇幅的正文文本加阴影不是什么好主意，因为会降低可读性。对于标题或短文本，阴影倒是大有用武之地，非常适合模拟凸版印刷或者喷涂效果。

`text-shadow` 属性的语法非常直观，需要指定相对于源文本 x 轴和 y 轴的偏移量（可正可负）、模糊距离（0 意味着完全不模糊）和颜色值，由空格分隔：

```css
h1 {
  text-shadow: -0.2em 0.4em 2em #ccc;
}
```

除此之外，还可通过用逗号分隔来给文本添加多组阴影。多组阴影会按先后次序堆叠，先定义的在上，后定义的在下。

为同一段文本添加多组阴影可以模拟出压印或浮雕的效果，方法就是在文本上方和下方加上偏暗或偏亮的阴影。偏亮或偏暗阴影的偏移取决于文本相对于背景的明度。暗文本上方加亮阴影且下方加暗阴影就是通常的压印效果，反之亦然。以下代码示例展示了两种不同的效果：

```css
.impressed {
  background-color: #6990e1;
  color: #31446b;
  text-shadow: 0 -1px 1px #b3d6f9, 0 1px 0 #243350;
}
.embossed {
  background-color: #3c5486;
  color: #92b1ef;
  text-shadow: 0 -1px 0 #243350, 0 1px 0 #def2fe;
}
```

进一步发挥想象力，还可以利用多组阴影创造出 3D 效果，比如仿手写广告牌字体。沿对角线每隔 1 像素叠加一个实心阴影就可以创造出这个效果：

```css
h1 {
  font-family: Nunito, 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif;
  color: #d0bb78;
  text-transform: uppercase;
  font-weight: 700;
  /* 以 1px 为单位累加 */
  text-shadow: -1px 1px 0 #743132, -2px 2px 0 #743132, -3px 3px 0 #743132, /* ... */ -22px 22px 0 #743132,
    -23px 23px 0 #743132;
}
```

为了让文字的仿手写体效果更突出。首先，用一批白色阴影给文字加上轮廓。这是因为，广告画工为了在字母油漆未干时就可以继续画阴影，通常会在字母和阴影间留一些空隙。为了把文字边缘包住，得在各个方向上偏移，加上白色阴影。

其次，再运用一个技巧，让阴影颜色沿偏移方向渐变，从而更像 3D 效果。为此，需要亮阴影和暗阴影交错地偏移。这样，利用这些阴影的堆叠，就让一种颜色水平方向比较突出，另种颜色垂直方向比较突出。以下是实现技巧的代码：

```css
h1 {
  /* 省略了一些属性 */
  /* 首先，各个方向上的白色阴影构成轮廓 */
  text-shadow: -2px 2px 0 #fff, 0 -2px 0 #fff, 0 3px 0 #fff, 3px 0 0 #fff, -3px 0 0 #fff, 2px 2px 0 #fff,
    2px -2px 0 #fff, -2px -2px 0 #fff, /* 其次，交错叠加的阴影让颜色沿两个方向凸显 */ -3px 3px 0 #743b34, -4px 3px 0
      #a8564d, -4px 5px 0 #743b34, -5px 4px 0 #a8564d, -5px 6px 0 #743b34, /* 继续叠加 */ -22px 21px 0 #a8564d,
    -22px 23px 0 #743b34, -23px 22px 0 #a8564d, -23px 24px 0 #743b34;
}
```

几乎所有浏览器都支持 text-shadow 属性，只有 IE9 及更早的 IE 不行。对于支持它的浏览器而言，由于绘制阴影开销比较大，请不要滥用。

#### 4.5.2 使用 JS 提升排版品质

也有 CSS 不能完全胜任的情况，比如可以通过 `:first-letter` 伪元素选中一段文本的第一
