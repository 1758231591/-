---
title: 精通CSS-高级Web标准解决方案
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [精通 CSS-高级 Web 标准解决方案](#精通-css-高级-web-标准解决方案)
  - [一. 基础知识](#一-基础知识)
    - [1.1 组织代码](#11-组织代码)
      - [1.1.1 可维护性](#111-可维护性)
      - [1.1.2 HTML 简史](#112-html-简史)
      - [1.1.3 渐进增强](#113-渐进增强)
    - [1.2 创建结构化、语义化富 HTML](#12-创建结构化-语义化富-html)
      - [1.2.1 ID 和 c1ass 属性](#121-id-和-c1ass-属性)
      - [1.2.2 结构化元素](#122-结构化元素)
      - [1.2.3 div 和 span](#123-div-和-span)
      - [1.2.4 重新定义的表现性文本元素](#124-重新定义的表现性文本元素)
      - [1.2.5 扩展 HTML 语义](#125-扩展-html-语义)
      - [1.2.6 验证](#126-验证)
  - [二. 添加样式](#二-添加样式)
    - [2.1 CSS 选择符](#21-css-选择符)
    - [2.2 层叠](#22-层叠)
    - [2.3 特殊性](#23-特殊性)
      - [2.3.1 利用层叠次序](#231-利用层叠次序)
      - [2.3.2 控制特殊性](#232-控制特殊性)
    - [2.4 继承](#24-继承)
    - [2.5 为文档应用样式](#25-为文档应用样式)
      - [2.5.1 link 与 style 元素](#251-link-与-style-元素)
      - [2.5.2 性能](#252-性能)
  - [三. 可见格式化模型](#三-可见格式化模型)
    - [3.1 盒模型](#31-盒模型)
      - [3.1.1 盒子大小](#311-盒子大小)
      - [3.1.2 最大值和最小值](#312-最大值和最小值)
    - [3.2 可见格式化模型](#32-可见格式化模型)
      - [3.2.1 匿名盒子](#321-匿名盒子)
      - [3.2.2 外边距折叠](#322-外边距折叠)
      - [3.2.3 包含块](#323-包含块)
      - [3.2.4 相对定位](#324-相对定位)
      - [3.2.5 绝对定位](#325-绝对定位)
      - [3.2.6 固定定位](#326-固定定位)
      - [3.2.7 浮动](#327-浮动)
      - [3.2.8 格式化上下文](#328-格式化上下文)
      - [3.2.9 内在大小与外在大小](#329-内在大小与外在大小)
    - [3.3 其他 CSS 布局模块](#33-其他-css-布局模块)
      - [3.3.1 弹性盒布局](#331-弹性盒布局)
      - [3.3.2 网格布局](#332-网格布局)
    - [3.3.3 多栏布局](#333-多栏布局)
    - [3.4 Region](#34-region)
  - [四. 网页排版](#四-网页排版)
    - [4.1 CSS 的基本排版技术](#41-css-的基本排版技术)
      - [4.1.1 文本颜色](#411-文本颜色)
      - [4.1.2 字体族](#412-字体族)
      - [4.1.3 字型大小与行高](#413-字型大小与行高)
      - [4.1.4 行间距、对齐及行盒子的构造](#414-行间距-对齐及行盒子的构造)
    - [4.1.5 文本粗细](#415-文本粗细)
      - [4.1.6 字体样式](#416-字体样式)
      - [4.1.7 大小写变换和小型大写变体](#417-大小写变换和小型大写变体)
      - [4.1.8 控制字母和单词间距](#418-控制字母和单词间距)
    - [4.2 版心宽度、律动和毛边](#42-版心宽度-律动和毛边)
      - [4.2.1 文本缩进与对齐](#421-文本缩进与对齐)
      - [4.2.2 连字符](#422-连字符)
      - [4.2.3 多栏文本](#423-多栏文本)
    - [4.3 Web 字体](#43-web-字体)
      - [4.3.1 许可](#431-许可)
      - [4.3.2 @font-face 规则](#432-font-face-规则)
      - [4.3.3 Web 字体、浏览器与性能](#433-web-字体-浏览器与性能)
      - [4.3.4 使用 JS 加载字体](#434-使用-js-加载字体)
    - [4.4 高级排版特性](#44-高级排版特性)
      - [4.4.1 数字](#441-数字)
      - [4.4.2 字距选项及文本渲染](#442-字距选项及文本渲染)
    - [4.5 文本特效](#45-文本特效)
      - [4.5.1 合理使用文本阴影](#451-合理使用文本阴影)
      - [4.5.2 使用 JS 提升排版品质](#452-使用-js-提升排版品质)
  - [五. 漂亮的盒子](#五-漂亮的盒子)
    - [5.1 背景颜色](#51-背景颜色)
    - [5.2 背景图片](#52-背景图片)
      - [5.2.1 背景图片与内容图片](#521-背景图片与内容图片)
      - [5.2.3 加载图片（以及其他文件）](#523-加载图片以及其他文件)
      - [5.2.4 图片格式](#524-图片格式)
    - [5.3 背景图片语法](#53-背景图片语法)
      - [5.3.1 背景位置](#531-背景位置)
      - [5.3.2 背景裁剪与原点](#532-背景裁剪与原点)
      - [5.3.3 背景附着](#533-背景附着)
      - [5.3.4 背景大小](#534-背景大小)
      - [5.3.5 背景属性简写](#535-背景属性简写)
    - [5.4 多重背景](#54-多重背景)
    - [5.5 边框与圆角](#55-边框与圆角)

<!-- /code_chunk_output -->

# 精通 CSS-高级 Web 标准解决方案

## 一. 基础知识

### 1.1 组织代码

层叠样式表（CSS，cascading style sheets）的技术和概念，必须以结构良好且有效的 HTML 文档为前提。

#### 1.1.1 可维护性

可维护性可以说是所有优秀代码最重要的特点。相对来说，CSS 是随着代码量增加而最难保持可维护性的语言之一。现代编程语言都有内置的变量、函数和命名空间等特性，这些特性都有利于保持代码的结构和格式化。这些特性 CSS 都没有，所以要按照使用这种语言和组织代码的特殊方式来管理它。

#### 1.1.2 HTML 简史

Tim Berners-Lee 在 1990 年发明了 HTML，当时是为了规范科研文档的格式。HTML 是一种简单的标记语言，为文本赋予了基本的结构和意义，比如标题、列表、定义等。这些文档通常没有什么装饰性的元素，可以方便地通过计算机来检索，而人类可以使用文本终端、Web 浏览器，或者必要时使用屏幕阅读器来阅读它们。

然而，人类是视觉发达的生物。随着万维网被越来越多的人所接受，HTML 也逐渐增加了对展示效果的支持。除了用标题元素标记文档标题，还可以使用粗体标签和不同的字体来创建特殊的视觉效果。本来用于展示数据的表格（tab1e），却成了页面布局的手段；块引用（blockquote）也经常被用来缩进文本，而不是只用来标记引文。HTML 很快就偏离了为内容赋予结构和意义的初衷，变成了一堆字体和表格标签。Web 设计者给这种标记起了个名字，叫 “标签汤”。

正当 Web 变得一团糟之际，CSS 作为解决方案面世了。CSS 的初衷是把跟 HTML 混在一起的表现性标记提取出来，使其自成体系，达到结构与表现分离的目的。这就让有意义的标签或者说语义悄悄返回了 HTML 文档。font 之类的表现性标签可以不用了，而表格布局也可以被逐步取代。对大多数网站而言，CSS 都能提升其可访问性和加载速度。不仅如此，CSS 还给 Web 设计和开发人员带来了更多好处：

- 一种专用于控制视觉样式和布局的语言
- 在同一网站中更易于重用的样式
- 通过关注点分离得到了良好的代码结构

---

**关注点分离**
关注点分离（separation of concerns）是软件开发行业的一个常见概念。对 Web 开发而言，关注点分离不仅适用于标记和样式，同样也适用于编写样式的方式。事实上，**关注点分离也是确保代码可维护性的一种主要方法**。

Unix 开发社区有一句话很好地诠释了**关注点分离的思想，即 “分成小块，松散结合”**（small pieces，loosely joined）。其中，每一 “小块” 都是一个模块，专注于做好一件事。而且，因为这个模块跟其他组件是 “松散结合” 的，所以它可以方便地在系统的其他部分中重用。Unix 中的一 “小块” 可能是一个字数统计函数，可以应用于传入的任何文本片段。而在 Web 开发中，这一 “小块” 可能就是一个商品列表组件，如果能做到 “松散结合”，就可以在一个网站的多个页面或者在同一布局的不同区块中重用。

可以把代码中的这些 “小块” 想象成积木。每一块积木都很简单，但把很多块积木以不同方式组装起来，就可以创造出无比复杂的东西。

---

**HTML 和 CSS 的版本**
CSS 有很多版本，或者 “级别”。了解这些版本产生的背景，有助于了解应该或不应该使用哪些 CSS 特性。万维网联盟（W3C，World Wide Web Consortium）是制定 Web 技术标准的组织，该组织制定的每一个规范要经历几个阶段之后才能成为 W3C 推荐标准。CSS1 是在 1996 年底成为 W3C 推荐标准的，当时只包含字体、颜色和外边距等基本的属性。CSS2 在 1998 年成为推荐标准，增加了浮动和定位等高级特性，此外还有子选择符、相邻选择符和通用选择符等新选择符。

相比之下，CSS3 则采用了完全不同的模式。实际上不存在所谓的 CSS3 规范，因为 CSS3 指的是一系列级别独立的模块。如果规范模块是对之前 CSS 概念的改进，那就从 3 级开始命名。如果不是改进，而是一种全新的技术，那就从 1 级开始命名。而 CSS3，则是指所有足够新的 CSS 规范模块，比如 CSS Backgrounds and Borders Level3、Selectors level4 和 CSS Grid Layout Level 1。这种模块化的方式可以让不同的规范有自己的演进速度。有些 3 级规范，比如 CSS Color level3，已经成为推荐标准。而另外一些可能还处于候选推荐阶段，很多甚至还处于工作草案阶段。

虽然 CSS3 的制定工作在 CSS2 发布后就开始了，但这些新规范一开始的制定速度很缓慢。为此，W3C 在 2002 年发布了 CSS2 Revision 1。CSS 2.1 修正了 CSS2 中的一些错误，删掉了支持度不高或者并非所有浏览器都实现了的一些特性，总体来说就是把 CSS 规范做了一番清理，好为浏览器实现提供更精准的蓝图。CSS 2.1 在 2011 年 6 月成为推荐标准，此时距离 CSS3 启动已经有 10 多年了。由此可见，标准制定主体和浏览器开发商为了确保相应的特性得以原原本本地实现，需要花多么长的时间。不过，浏览器开发商经常会在标准还处于草案阶段时，就发布一些实验性的实现。这样，等到了候选推荐阶段，相应的实现就已经非常稳定了。换句话说，很多 CSS 特性早在相应模块成为推荐标准前就可以使用了。

HTML 的历史也很复杂。HTML4.01 在 1999 年成为推荐标准，与此同时 W3C 也把注意力转向了 XHTML1.0。本来接着要发布 XHTML1.1，但其严格程度在实践中暴露了无法落地的问题，最终被 Web 开发社区抛弃。于是，这个 Web 主要语言的发展停滞了。

2004 年，有几家公司共同组建了 Web 超文本应用技术工作组（WHATWG， Web Hypertext Application Technology Working Group），并致力于开发新的规范。2006 年，W3C 肯定了它们工作的必要性，并欣然加人该工作组。2009 年，W3C 完全放弃 XHTML，正式接纳 WHATWG 制定的新标准，这就是后来的 HTML5。起初，WHATWG 和 W3C 都基于标准调整自己的工作，但后来它们的关系又变得复杂起来。今天，它们分别在编辑两份标准。 WHATWG 那份就叫 HTML，而 W3C 那份则称为 HTML5。没错，这种分裂确实不好。但万幸的是，这两份标准的内容相当接近，因此只讲 HTML5 是没有问题的。

**应该使用哪个版本**
设计者和开发者经常问的一个问题就是应该使用 HTML 或 CSS 的哪个版本。这个问题不好回答。虽然规范反映了标准和 Web 技术开发的进度和焦点，但它其实跟设计者和开发者日常的工作关系不大。真正重要的是知道 HTML 和 CSS 的哪些部分已经在浏览器中实现了，以及这些实现是否稳健，有没有 bug。比如，浏览器提供的这些特性是不是实验性特性，使用时需谨慎?或者，这些特性到底靠不靠谱，是不是已经得到了多数浏览器的支持?

今天，使用 CSS 和 HTML 就要了解浏览器对其中特性的支持程度。要了解浏览器支持情况，推荐几个不错的地方。对于 CSS 属性，可以访问 [“Can I use” 网站](https://caniuse.com)。这个网站可以搜索属性或属性组，结果配有统计信息，显示支持它们的浏览器百分比，包括桌面浏览器和移动浏览器。此外，Mozilla 的开发者文档，即 [MDN](https://developer.mozilla.org/zh-CN/docs/Web)，也是个非常好的参考。

说到浏览器支持，关键要明白，并非所有浏览器都一样，实际上从来就没有完全一样的浏览器。某些 CSS3 特性只得到了少数浏览器的支持。比如，IE11 和 Safari6.1 之前的版本都没有正确支持 Flexbox（Flexible Box Layout）。不过，就算需要支持老版本的浏览器，也不意味着不能使用 Flexbox。核心布局上可以不用 Flexbox，但对于某些特定的组件，Flexbox 可能就非常合适。只要为不支持它的浏览器准备好可以接受的后备代码就行了。

#### 1.1.3 渐进增强

平衡向后兼容性与最新的 HTML 和 CSS 特性，涉及一种叫作**渐进增强**（progressive enhancement）的策略。所谓**渐进增强，大意就是 “首先为最小公分母准备可用的内容，然后再为支持新特性的浏览器添加更多交互优化”**。使用渐进增强策略，意味着代码要分层，每一层增强代码都只会在相应特性被支持或被认为适当的情况下应用。听起来有点复杂，而实际上 HTML 和 CSS 的实现已经部分内置了这一策略。

对 HTML 而言，这意味着浏览器在遇到未知元素或属性时并不会报错，而且也不会对页面产生什么影响。比如，可以在页面里使用 HTML5 定义的新 input 元素。假设表单中有一个电子邮件字段的标记如下：

```html
<input type="text" id="field-email" name="field-email" />
```

要使用新的 input 元素，应该把 type 属性改成这样

```html
<input type="email" id="field-email" name="field-email" />
```

尚未实现这个新字段类型的浏览器碰到它只会想：“这是啥意思呀?不明白。” 然后回退为默认的 text 类型，结果和上面的第一行代码一样。而实现了这个类型的新浏览器则知道 email 想让用户在这里填写什么样的数据。而在很多移动设备中，相应的软键盘还会针对输入电子邮件地址调整界面布局。假如还在这里使用了内置的表单验证，那么支持它的新浏览器也会帮你做验证。这样，既渐进增强了页面，也不会对旧版本浏览器产生不好的影响。

另外一个简单的变化就是，HTML5 把文档类型声明更新为新的简短形式。所谓文档类型，就是位于 HTML 文档第一行的代码，供机器识别当前文档使用的标记语言版本。以往的 HTML 和 XHTML 版本中，这行代码很长很复杂，但在 HTML5 中，它已经简化成 `<!DOCTYPE html>`。今后，只要这样声明 HTML 文档类型就好了，因为这个 HTML5 语法的 doctype 是向后兼容的。

CSS 中的渐进增强同样也反映在浏览器如何对待新属性上。任何浏览器无法识别的属性或值都会导致浏览器丢弃相应的声明。因此，只要同时提供合理的后备声明，使用新属性就不会带来不良后果。

举个例子，很多现代浏览器支持以 rgba 函数方式表示的颜色值。这种方式可以分别传入红绿、蓝通道，以及阿尔法（alpha，即透明度）通道的值。可以这样使用它

```css
.overlay {
  background-color: #000;
  background-color: rgba(0, 0, 0, 0.8);
}
```

这条规则定义了类名为 overlay 的元素背景为黑色，但随后又用 rgba 声明背景色应稍微透明。如果浏览器不支持 rgba，那么相应元素的背景色就是不透明的黑色。如果浏览器支持 rgba，那么第二条声明就会覆盖第一条。也就是说，即使并非所有浏览器都支持 rgba，也可以使用它，只是要先为它声明合适的后备代码。

**厂商前缀**
浏览器厂商也基于相同的原理为自家浏览器引入实验性特性。实验性特性的标准名称前面会加上一个特殊字符串，这样他们自己的浏览器就能识别该特性，而其他浏览器则会忽略该特性。有了这个方案，浏览器厂商就可以添加规范中没有或者尚不成熟的新特性，样式表作者也可以安心地试用这些新属性，不用担心浏览器因不认识它们而破坏页面。比如：

```css
.myThing {
  webkit-transform: translate(0, 10px);
  moz-transform: translate(0, 10px);
  ms-transform: translate(0, 10px);
  transform: translate(0, 10px);
}
```

这里使用了几个不同的前缀，给相应的元素应用了变换(<!--TODO-->第 10 章会介绍)：

- 以 -webkit- 开头的适用于基于 WebKit 的浏览器，如 Safari Chrome 和 Opera 都基于 Blink 引擎，而 Blink 最初也是基于 WebKit 开发的，所以 -webkit- 前缀通常也适用于这 3 个浏览器。
- -moz- 前缀适用于基于 Mozilla 的浏览器，如 Firefox。
- -ms-前缀则适用于微软的 IE。

最后又加了一条不带前缀的声明，这样那些支持标准属性名称的浏览器就不会漏网了。

过去经常出现开发人员漏加不带前缀的标准声明的情况。为此，有些浏览器厂商也开始支持竞争对手引擎特定的前缀，以便让流行的网站能在自己的浏览器上打开。但这样做也造成了混乱，于是多数浏览器厂商抛弃了厂商前缀。那实验性特性呢？有的厂商选择把它们隐藏在 chrome://flags 中，有的选择只在特定的预览版中提供。

**条件规则与检测脚本**
如果希望根据浏览器是否支持某个 CSS 特性来提供完全不同的样式，那么可以选择 `@supports` 块。这个特殊的代码块称为条件规则，它会检测括号中的声明，并且仅在浏览器支持该声明的情况下，才会应用块中的规则：

```css
@supports (display: grid) {
  /* 在支持网格布局的浏览器中要应用的规则 */
}
```

条件规则的问题是其自身也很新，只能将它应用于新的浏览器中，因为旧版本浏览器不支持。此外，还可以通过 JS 来检测支持情况，比如使用 Modernize 这个库。Modernize 的原理是为 HTML 添加支持提示信息，然后可以依据这些信息来编写 CSS。

> 这里关键是要知道：渐进增强可以放下对版本号和规范的很多担忧。只要加点小心，就可以在适当的时候使用一些簇新的特性，同时又不会丢掉使用旧版浏览器的用户。

### 1.2 创建结构化、语义化富 HTML

**语义化标记是优秀 HTML 文档的基础。语义就是以系统方式表示的含义**。对于根据一个形式符号的集合人工创造出的语言（比如 HTML 语言，及其元素和属性）来说，语义指的就是通过使用某个符号想要表示的含义。简而言之，语义化标记意味着在正确的地方使用正确的元素，从而得到有意义的文档。

有意义的文档可以确保尽可能多的人都能够使用，无论用的是最新版本的 Chrome，还是 Lynx 这样只能处理文本的浏览器，甚至是屏幕阅读器或盲文点触设备之类的辅助技术。无论将来项目中会增加多么花哨的图形或交互，**文档的基础语义都应该永远—而且必须永远—不打折扣**。

结构良好的标记也意味着内容更对机器的胃口。机器对，特别是 Googlebot 这种搜索引擎爬虫，对它胃口的内容可以让你的页面在 Google 搜索结果中排名更靠前。这是因为，Googlebot 从页面中获得的相关数据越多，它对页面的索引和排名可能就越准确。于是，页面在搜索结果中出现的位置就可能更靠前。对于 CSS 来说更重要的是，有意义的标记本身为添加样式提供了方便。这些标记不仅描述了文档的结构，而且还为继续装扮它提供了底层的框架。

实际上，编写 CSS 的最新实践都建议先给网站一组 “基础” 样式。设立这么一套基础样式的价值非常之大。虽然实际设计和开发中，它们很快会被继承和覆盖，但有了这么一套基础样式，将来的工作就会有条不紊。这套样式也可以作为校准样式来使用。在不断修改 CSS 的过程中，可以时不时对照一下样式指南中的组件，检查自己是否无意中覆盖了某些不该覆盖的样式。

#### 1.2.1 ID 和 c1ass 属性

有意义的元素提供了不错的基础，却没有提供应用视觉效果所必需的全部 “接入点”。几乎总是要根据上下文来调整基础元素的样式。除了元素本身，还需要一种方式把样式 “接入” 到文档上，这就是 `ID` 和 `class` 属性。

为元素添加 ID 和 class 属性不一定能给文档增加含义或结构。这两个属性只是一种让其他因素来操作与解析文档的通用手段，CSS 也可以利用这一手段。

给属性起名字听起来简单，但在写代码时却是极其重要的（常常也是最难的）。“名不正则言不顺”，起什么名字意味着它是什么，或者应该怎么使用它。**写代码的时候，清晰和明确都是至关重要的原则**。下面就以一个链接列表为例，看看怎么给它的 class 属性一个既容易辨识又好用的值：

```html
<ul class="product-list">
  <li><a href="/product/1">Product 1</a></li>
  <li><a href="/product/2">Product 2</a></li>
  <li><a href="/product/3">Product 3</a></li>
</ul>
```

先利用 class 属性在文档中创造一个 product-list 模块。在 CSS 里，用类名来定义一类事物。这里的 product-list 就意味着它可以是任何商品列表换句话说，为 product-list 写好样式后，不仅可以用在这里，还可以用在网站的其他地方，就像蓝图或者模板一样可以重用。

给元素添加类名时，即使类名明确用于样式，也不要体现出其视觉效果（<!--TODO-->第 12 章会详细讨论这一点，包括什么情况下类名可以体现视觉效果）。**正确的做法是让类名表示组件的类型**。

前面的例子只给元素添加了 class 属性，并没有添加 ID 属性。对于添加样式而言，ID 与 class 属性有一些重要的区别，但针对这个例子而言，最主要的区别是一个 ID 只能应用到页面中的一个元素。也就是说，不能像 product-list 那样使用 ID 把页面中的模块定义为可重用的 “模板”。如果使用了 ID，那么相应的 product-list 在每个页面中只能出现一次。提倡使用 ID 来标识特定模块的特定实例。

实际开发中，一般不建议把 ID 属性作为 CSS 的 “接入点”。利用类来添加样式往往能够让代码更简单也更容易维护。ID 可以用于在文档中标识元素，但通常不用于添加样式。

#### 1.2.2 结构化元素

HTML5 新增了一批结构化元素：

- section
- header
- footer
- nav
- article
- aside
- main

**增加这些新元素是为了在 HTML 文档中创建逻辑性区块**。它们可以用于包含独立内容（article）、导航组件（nav）、特定区块的头部（header），等等。其中，main 元素是最新增加的，用于高亮页面中包含主要内容的区域。**除了 main 之外，所有其他新元素都可以在一个文档中多次出现**，以便让机器和人更好地理解文档。关于如何正确使用这些新元素，建议看看[这个网站](http://html5doctor.com)。

div 元素对文档而言并没有语义价值，只是借助类名作为添加样式的 “接入点” 而已。

#### 1.2.3 div 和 span

既然有了新语义元素，那么 div 元素是否就多余了呢？不是的。在没有合适的语义元素的情况下，div 仍然是给内容分组的一个不错的选择。有时候，会纯粹出于添加样式的目的而在文档中添加一个元素。比如，为实现居中布局而在整个页面外部包装一个元素。

如果有更具语义的结构化元素，那么务必使用它们，需要添加样式时再给它们一个适当的类名。但是，如果只需要一个无语义的元素作为额外的样式接入点，那就使用 div。

因此，**请确保只在额外提供样式接入的情况下才使用 div**，但也不要因为用了几个 div 就感到难为情。在后面介绍的几个具体的例子中，会看到，额外添加的无语义 div 元素对保证代码的清晰和可维护性非常重要。

与 div 元素类似的还有 span。同样，在无须表示语义、仅需添加样式的情况中，可以使用 span。与 div 不同，span 是文本级元素，可以用于在文本流中建立结构。不过在使用无语义的 span 之前，也一样要确保真的不需要使用任何语义元素。比如，使用 time 标记时间和日期，使用 q 标记引用，使用 em 标记需要强调的内容，使用 strong 标记需要重点强调的内容。

#### 1.2.4 重新定义的表现性文本元素

时至今日，`<b>` 和 `<i>` 可以算是幸存的表现性标记了，它们以前分别用于将文本标记为粗体（bold）和斜体（italic）。因为在旧有 Web 内容中，或者通过低水平 WYSIWYG 编辑器创建的内容中，这两个元素随处可见。HTML5 的编辑最终决定保留它们，但改变了它们的含义。

今天，`<i>` 元素用于标识与周围内容不一样的内容，一般在排版上会显示为斜体。HTML5 规范中给出的例子包括另一种语言中的习语，以及一艘船的名字。

`<b>` 元素的含义和 `<i>` 几乎一样，只是针对习惯上标记为粗体的内容。相关的例子包括商品或品类名。

这样的定义确实不够明确，但关键是要知道，**这两个元素与 `<em>` 及 `<strong>` 的区别在于，它们没有任何强调自己所包含内容的意味**。多数情况下，应该选择 `<em>` 或 `<strong>`，因为它们是用来强调及重点强调内容的语义正确的选择。

#### 1.2.5 扩展 HTML 语义

长时间以来，Web 开发者一直在探索给 HTML 有限的词汇表添加新的语义和结构的方式。为内容添加更丰富的语义，对 Web 和基于其构建的工具而言意义重大。虽然建设语义 Web 王国任重而道远，但不管怎么说，还是有了实质性的进步。利用这些成果，HTML 编写者可以为自己的文档添加更细粒度、更具表达性的语义。

**ARIA 的 role 属性**
很多新的 HTML5 元素都考虑到了无障碍访问的场景。比如，如果屏幕阅读器能够理解页面中的 nav 元素，那么它就可以利用这个元素帮助用户定位到相应的内容，或者在必要时返回导航。

另一种实现这个目标的方式是利用无障碍富因特网应用（ARIA，accessible rich Intermetapplication），它是对 HTML 规范的补充。ARIA 提供了针对辅助访问设备添加更多语义的手段，方式就是为文档中的不同元素指定其包含什么内容，或者说它们提供什么功能。比如，role="navigation" 这个 “地标角色” 属性用于声明一个元素具有导航的角色。其他角色有：

- banner
- form
- main
- search
- complementary
- contentinfo
- application

完整的 ARA 角色及其定义，参见 ARIA 规范。ARIA 还支持让开发人员指定更复杂的内容片段和界面元素。例如，在使用 HTML 创建一个音量滑动条部件时，应该包含值为 slider 的 role 属性：

```html
<div id="volume-label">Volume</div>
<div class="volume-rail">
  <a
    href="#"
    class="volume-handle"
    role="slider"
    aria-labelledby="volume-label"
    aria-valuemin="1"
    aria-valuemax="100"
    aria-valuenow="67"
  ></a>
</div>
```

属性 aria-labelledby、aria-valuemin、aria-valuemax 和 aria-valuenow 也分别提供了额外的信息，辅助阅读技术可以利用它们帮助残障用户使用这个滑动部件。

为 HTML 页面中的不同组件添加这些额外的语义属性，同样有助于为元素添加脚本和样式，是典型的多贏策略。

**微格式**
_目前最广泛采用的扩展 HTML 语义的方式是微格式_。微格式是一组标准的命名约定和标记模式，可用于表示特定的数据类型。微格式的命名约定是基于 vCard 和 iCalendar 等已有的数据格式制定的。比如下面的联系人信息就是以 hCard 格式标记的：

```html
<section class="h-card">
  <p>
    <a class="u-url p-name" href="http://andybudd.com/">Andy Budd</a>
    <span class="p-org">Clearleft Ltd</span>
    <a class="u-email" href="mailto:info@andybudd.com">info@andybudd.com</a>
  </p>
  <p class="p-adr">
    <span class="p-locality">Brighton</span>
    <span class="p-country-name">England</span>
  </p>
</section>
```

以微格式标记的联系人信息便于开发人员编写工具从中提取数据。比如可以编写一个浏览器插件，从你浏览的页面中发现微格式，然后让你把联系人信息下载到通讯录，或者把活动信息添加到你的日历应用。目前微格式支持的数据类型包括联系人、活动、菜谱、博文、简历，等等。

微格式也可以用于表示关系，比如一段内容与链接到该内容的另一个 URL 之间的关系微格式得以流行的原因之一是容易实现，迄今已经被 Yahoo 和 Facebook 等内容平台采用，而且已经直接添加到了 WordPress8 和 Drupal 等内容发布工具中。2012 年一项关于结构化数据实现的研究发现，微格式在 Web 上的应用最为广泛。不过最近微数据异军突起，也不容小觑。

**微数据**
微数据是跟 HTM5 一起，作为给 HTML 添加结构化数据的另一种方式而推出的。它的目标与微格式非常相近，但在把微数据嵌入内容方面则有所不同。下面看一看用微数据标记同样的联系人信息会是什么样：

```html
<section itemscope itemtype="http://schema.org/person">
  <p><a itemprop="name" href="http://thatemil.com/">Emil B</a></p>
  <span itemprop="affiliation" itemscope itemtype="http://schema.org/organization">
    <span itemprop="name">inUse Experience AB</span>
  </span>
  <a itemprop="email" href="mailto:emil@thatemil.com">emil@thatemil.com</a>
  <p itemprop="address" itemscope itemtype="http://schema.org/PostalAddress">
    <span class="addressLocality">Malm?</span>,
    <span class="addressCountry">Sweden</span>
  </p>
</section>
```

通过这个例子可以看出，微数据的语法比微格式要烦琐一些，不过这是有原因的。由于微数据设计的时候考虑到了可扩展性，它可以用来表示任意类型的数据。微数据只定义一些语法来表示数据结构，但自身并未定义任何词汇表。相反，微格式则定义了具体的结构化数据，比如 hCard 和 hCalendar。

微数据把定义特定格式的事交给了使用者或第三方。上述例子中使用的格式就是由 Bing、Google 以及 Yahoo 等搜索引擎共同创建的一个[词汇表](https://schema.org)。这几家搜索引擎使用它来辅助索引和排名页面，当然搜索爬虫也会使用这些词汇表，从你的内容中更高效地提取丰富的信息。

#### 1.2.6 验证

即使经过深思熟虑，标记已经非常语义化了，其中也仍然存在输入或者格式错误的风险。这些隐患会带来无法预料的麻烦。这时候就要使用验证了。

现实中的多数 HTML 文档并不是真正有效的 HTML。用规范编写者的话说，就叫作 “未遵行”（nonconformant）。这些文档中存在的问题有元素嵌套不对、包含未经编码的和号（&），以及缺少必要的属性等。浏览器对这类错误非常宽容，总会尝试猜测作者的意图。事实上，HTML 规范中也包含了如何处理无效 HTML 的规定，以确保浏览器厂商以一致的方式处理错误。

总体来说，浏览器如此大度地处理错误是个好事，但不代表可以因此而放弃自己的职守。都应该尽力写出有效的 HTML 文档，这样有利于更快地查找问题，避免错误泛滥。假如碰到一个渲染或布局上的 bug，时又找不出问题所在，最好先验证一下 HTML，以保证样式应用到了格式正确的文档上。

验证 HTML 的工具有很多。比如，可以使用 W3C 网站上的 [HTML 验证器](http://validator.w3.org/)，或者与之相关的插件。其中的 Web Developer 扩展，Firefox、Opera 和 Chrome 都支持。此外，如果项目有自动构建或测试环节，最好在其中加上 HTML 验证。

CSS 也是可以验证的。W3C 的 [CSS 验证器](http://jigsaw.w3.org/css-validator/)。可能认为验证 CSS 没有验证 HTML 那么重要，毕竟 CSS 中的错误一般不会导致 JS 出错，或者导致屏幕阅读器无法打开页面。但是，还是建议重视 CSS，保证其中没有什么低级错误。

根据 CSS 验证器设置而定，验证结果中可能包含很多关于厂商前缀的警告或错误。这些属性或值是浏览器厂商在实验性地支持某些 CSS 特性时使用的一种临时命名约定。比如，webkit-flex 这个 display 属性的值，就是标准 flex 属性值在 WebKit 浏览器上的实验性版本。这些地方虽然会被验证器标记为警告甚至错误，但文件依然能正常使用。总之，只要明白验证器给出的这些标记的真正含义就行了。

验证并不是最终裁决，很多本身很好的页面也会验证失败，这是由于使用了来自第三方或低水准 CMS 的内容，或者使用了试验性 CSS 特性。此外，验证器本身也可能会跟不上标准更新和浏览器实现的步伐。因此不要过于激进，只要把验证当作事先帮助发现一些低级错误的手段即可。

## 二. 添加样式

### 2.1 CSS 选择符

1. **基本选择符**

   - 类型选择符：用于选择特定类型的元素，类型选择符有时也被称为元素选择符。

   - 后代选择符：用于选择某个或某组元素的后代。后代选择符的写法是在两个选择符之间添加空格。
     类型选择符与后代选择符非常适合全面应用基础样式。

   - 想要更精确地选择目标元素，可以使用 ID 选择符和类选择符。顾名思义，这两个选择符通过对应 ID 和 class 属性的值来选择元素。ID 选择符由 `#` 号开头，类选择符由 `.` 开头。

2. **高级选择符**

   - 子选择符（`>`）：只选择一个元素的直接后代，也就是子元素。

   - 相邻同辈选择器（`+`）：选择位于某个元素后面，并与该元素拥有相同父元素的**第一个**元素。

   - 一般同辈选择符（`~`）：选择位于某个元素后面，并与该元素拥有相同父元素的元素的**所有元素**。

   `>` 和 `+` 在这里被称为组合子，因为它们描述了自身两侧的选择符组合的方式。

3. **通用选择符**：通用选择符（`*`）可以匹配任何元素。

4. **属性选择符**
   属性选择符基于元素是否有某个元素或属性是否有某个值来选择元素。

   ```css
   abbr[title] {
     cursor: help;
   }

   input[type='submit'] {
     cursor: pointer;
   }
   ```

   还可通过给属性选择符中的等号前面加上特殊字符，来匹配特定模式：

   - 匹配以某些字符开头的属性值（`^`）：`a[href^="http:"]`
   - 匹配以某些字符结尾的属性值（`$`）：`img[src$='.jpg']`
   - 匹配包含某些字符的属性值（`*`）：`a[href*="/about/"]`
   - 匹配以空格分隔的字符串中的属性值（`~`）：`a[rel~=next]`
   - 可以选择开头是指定值或指定值后连着一个短划线的情况（`|`）：`a[lang|=en]`
     上面的规则可以匹配属性值 en 和 en-us，暗示这个选择符很适合选择属性值中的语言代码。

5. **伪元素**
   有时候想选择的页面区域不是通过元素来表示的，又不想为此给页面添加额外的标记。CSS 为这种情况提供了一些特殊选择符，叫伪元素。如：可以使用 `::first-letter` 伪元素来选择一段文本的第一个字符。

   > **注意**：
   >
   > 1. 使用伪元素插入内容要小心！千万不能用他们插入对交互有实质影响的内容，以避免 CSS 不能正确加载。另外，屏幕阅读器也没有统一的方式解释伪元素，有的会直接忽略它们，有的则会读取其中的内容。
   > 2. 伪元素应该使用双冒号语法，这是为了与伪类区别开，伪类使用单冒号语法。

6. **伪类**

   可以使用伪类选择符，来为文档结构以外的情形添加页面样式。伪类选择符的语法是一个冒号开头，用于选择元素的特定状态或关系。

   > **注意**：很多元素都可以使用 `:hover`，但 在触摸屏和键盘等输入方式下不一定有悬停状态。因此，不能再重要的交互功能中使用 `:hover`。

   **目标与反选**
   另一个有用的伪类是 `:target`，它匹配的元素有一个 ID 属性，而且该属性的值出现在当前页面 URL 末尾的 `#` 号后面。如：打开链接 `http://example.com/blog/1/#comment-3`，找到该页面中标记为 `<article class="comment" id="comment-3">...</article>` 的元素，可以为它设置样式：

   ```css
   .comment:target {
     color: #fffec4;
   }
   ```

   反选伪类（`:not()`）专门用于排除某些选择符，它可以配合除了伪元素和它自身的各种选择符使用。

7. **结构化伪类**

   CSS3 新增了一大批与文档结构有关的新伪类，其中最常用的是 `:nth-child` 选择符，它可以接受 odd（奇数）和 even（偶数）作为参数。这个参数还可以是数值或数值表达式（an + b）。

   ```css
   tr:nth-child(3n + 4) {
     background: #ddd;
   }
   ```

   还有一个伪类选择符也支持这种表达式，`:nth-last-child()` 。这个选择符与 `:nth-child` 类似，只不过倒序计算。

   CSS2.1 中有一个选择第一个子元素的伪元素，叫 `:first-child`，相当于 `:nth-child(1)`。CSS3 又添加了一个选择最后一个子元素的伪元素，`:last-child`，对应 `:nth-last-child(1)`。此外，还有 `:only-child` 和 `:only-of-type`、`:only-last-of-type`。其中，`:only-of-type` 和 `:only-last-of-type` 会选择特定类型的唯一子元素。

8. **表单伪类**

   还有很多伪类专门用于选择表单元素。这些为了根据用户与表单控件交互的方式，来反映表单控件的某种状态。

   例如，HTML5 为表单输入框新增了几个属性，表示必填的 `required` 就是其中之一。可以使用 `:required` 伪类来选择带有 `required` 属性的表单元素。还可以使用 `:optional` 伪类，为没有 `required` 属性的控件添加样式。

   此外，还有针对有效和无效控件的伪类。为满足某个输入框要求填写特定类型内容（如电子邮件地址）的需求，可以根据输入框中当前内容的有效性，应用不同样式：

   ```css
   /* 如果输入框包含有效的电子邮件地址 */
   input[type='email']:valid {
     border-color: green;
   }
   /* 如果输入框中的内容不是有效的电子邮件地址 */
   input[type='email']:invalid {
     border-color: red;
   }
   ```

   还有针对 type 值为 number 的 `:in-range`、`:out-of-range`伪类，针对 readonly 属性的 `:read-only`伪类，以及针对没有 readonly 属性的 `:read-write`伪类。[更多信息](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes)

### 2.2 层叠

稍微复杂的样式表中都可能存在两条甚至多条规则同时选择一个元素的情况。CSS 通过一种叫作层叠（cascade）的机制来处理这种冲突。从 CSS 这个名字就可知这种机制有多重要，因为其中的 C 就是 cascade（SS 是 style sheet，即样式表）。

**层叠机制的原理是为规则赋予不同的重要程度**。最重要的是作者样式表，即由网站开发者所写的样式。其次是用户样式表，用户可以通过浏览器的设置选项，为网页应用自己的样式。排在最后的是浏览器（或用户代码）的默认样式表，它们一般都会被作者样式表覆盖掉。

为了给用户更高的优先权，CSS 允许用户使用 `!important`覆盖任何规则，包括网站作者使用 `!important` 标注的规则。`!important` 标注要放在属性声明的后面。

允许用户使用 `!important` 标注来覆盖规则，主要是出于无障碍交互的需要。比如，允许诵读困难的用户使用高对比度的用户样式表。归纳起来，层叠机制的重要性级别从高到底如下所示：

- 标注为 `!important` 的用户样式
- 标注为 `!important` 的作者样式
- 作者样式
- 用户样式
- 浏览器（或用户代理）的默认样式

在此基础上，规则再按选择符的特殊性进行排序。特殊性高的选择符会覆盖特殊性低的选择符。如果两条规则的特殊性相等，则后定义的规则优先。

### 2.3 特殊性

为了量化规则的特殊性，每种选择符都对应着一个数值。这样，一条规则的特殊性就表示为其每个选择符的累加数值。但这里的累加计算使用的并非十进制加法，而是基于位置累加，以保证 10 个类选择符（或者 40 个，甚至更多的类选择符）累加的特殊性不会大于等于 1 个 ID 选择符的特殊性。这是为了避免 ID 这种高特殊性选择符被一堆低特殊性选择符（如类型选择符）的累加值所覆盖。如果某条规则中用到的选择符不足 10 个，为简单起见，也可以使用十进制来计算其特殊性。

任何选择符的特殊性都对应于如下 4 个级别，即 a、b、c、d：

- 行内样式，a 为 1;
- b 等于 ID 选择符的数目;
- c 等于类（class）选择符、伪类选择符及属性选择符的数目;
- d 等于类型（type）选择符和伪元素选择符的数目。

特殊性计算示例：

| 选择符 | 特殊性 | 十进制特殊性 |
| ----------------- | ------- | ------------ |d
| style="" | 1,0,0,0 | 1000 |
| #content .date {} | 0,1,1,0 | 200 |
| p.comment {} | 0,0,1,1 | 11 |

> **注意**：通用选择符（`*`）的特殊性为 0，无论它在规则声明中出现多少次。

#### 2.3.1 利用层叠次序

如果两条规则特殊性相等，则优先应用后定义的规则，这一点非常重要。这意味着在写样式的时候，必须考虑规则在样式中的位置，以及选择符的次序。

对链接元素使用伪类，就是一个利用层叠次序的典型。如果每个选择符的特殊性都一样，那么它们的次序就很重要了。要是把 a:visited 选择符放在 a:hover 选择符后面，那么在访问过链接之后，悬停样式将不会起作用，因为已经被 a:visited 样式给覆盖了。

#### 2.3.2 控制特殊性

**理解特殊性是写好 CSS 的关键，而控制特殊性则是大型网站开发中最难处理的问题**。利用特殊性，可以先为公用元素设置默认样式，然后在更特殊的元素上覆盖这些样式。最好的做法是从一开始就简化选择符，降低特殊性，减少选择符之间的依赖。对样式进行更细粒度的控制。

### 2.4 继承

任何直接应用给元素的样式都会覆盖继承的样式。因为继承的样式没有任何特殊性，连 0 都算不上。继承是很有用的机制，有了它就可以避免给一个元素的所有后代重复应用相同的样式。合理利用继承有助于减少选择符的数量，降低复杂性。

### 2.5 为文档应用样式

为文档应用样式的方式不止一种，各有利弊。

#### 2.5.1 link 与 style 元素

可以把样式放在 style 元素中，直接放在文档的 head 部分。如果样式不多，又希望立刻应用它们，并且不愿意因为浏览器额外下载文件而耽误时间。可以使用这种方式。

不过，为了让样式表能在多个页面中重用，通常最好把它保存到一个外部文件中。如果样式在外部样式表中，那么有两种方式把它们链接到网页上。最常用的方式是使用 link 元素：

```html
<link href="/c/base.css" rel="stylesheet" />
```

除了 link 元素，还可以使用 `@import` 指令加载外部 CSS 文件：

```html
<style>
  @import url('/c/modules.css');
</style>
```

可以在 HTML 文档的 head 部分把 @import 指令放在 style 中，也可以在外部样式表中使用它。后一种用法意味着，如果网页记载外部样式表，那么浏览器后续可能还需要下载更多 CSS 文件。

表面上看，使用 link 和 @import 指令的结果没什么区别。实际上，link 是比 @import 指令更值得推荐的方法，背后有一些[非常重要的原因](#252-性能)。

使用 link 或 style 在 HTML 中添加多个样式表或样式块时，它们声明的次序就是它们在 HTML 源代码中出现的次序。

#### 2.5.2 性能

选择以什么方式把 CSS 加载到页面中，一定程度上决定了浏览器显示页面的速度。度量 Web 性能的一个重要指标就是网页内容实际显示在屏幕上需要多久。这个指标有时候也叫 “渲染时间” 或 “上屏时间”。现代浏览器在屏幕上渲染内容之前，至少需要两样东西：HTML 和 CSS 这意味着让浏览器尽快下载 HTML 和全部 CSS 极其重要。

不要把 CSS 放到 body 里或者放到页面底部，搞什么 “延迟加载”。浏览器只有掌握了布局页面的全部 CSS 信息，才能给出最佳响应。因为只有这样，它们才知道应该把页面渲染成什么样，从而一次性地把页面绘制到屏幕上，而非一边加载新样式一边重新调整页面。

1. **减少 HTTP 请求**
   在链接外部样式表时，保证链接的文件数量最少至关重要，因为每个文件都需要单独发送次 HTTP 请求。相应地，每次从服务器请求文件，浏览器都需要花一定的时间下载，然后还要花时间应用其中的样式。另外，额外的 HTTP 请求也意味着浏览器会向服务器发送多余的数据，比如 cookie 或请求首部。服务器也必须针对每个请求返回响应首部。两个文件要比一个包含相同 CSS 内容的文件在浏览器和服务器间传递的数据更多。

   线上网页最好把需要加载的 CSS 文件数量控制在 1 或 2 个。只用一个 link 元素加载 CSS 文件，然后在其中使用 @import，并不能把请求控制为 1 个，因为这意味着先需要 1 个请求下载链接的文件，此外还要发送额外的请求取得所有导人的文件。因此，在线上网页中尽量不要使用 `@import`。

2. **压缩和缓存内容**
   使用 GZIP 压缩线上资源也非常重要。CSS 压缩的比率很高，因为它的很多属性和值都是重复的。一般来说，CSS 文件压缩后会减少 70%~80%。这样显然可以减少带宽占用，从而为用户节省时间。多数 Web 服务器都会在浏览器支持的情况下启用自动压缩线上资源。

   类似地，让 Web 服务器帮设置一定的 CSS 文件缓存时间也很重要。理想情况下，浏览器应该只下载一次 CSS 文件，除非线上文件有变化。方法就是通过 HTTP 首部告诉浏览器，把文件缓存较长的一段时间，如果文件有修改，则通过文件名来 “清除缓存”。压缩和合理缓存内容是提升网站性能的最重要的两件事。

3. **不让浏览器渲染阻塞 JS**
   如果在 HTML 文档的 head 元素中加入了 script 元素，浏览器必须先把它链接的脚本下载下来，然后再向用户显示网页内容。换句话说，这种情况下的 HTML 和 CSS 解析完全被下载以及执行脚本阻断了，也就是所谓的 “渲染阻塞”。渲染阻塞会明显拖慢网站加载速度。为此，主流的做法是在 HTML 页面底部的结束标签 `</body>` 之前加载 JS。

   比较现代的做法是在 head 中使用 script 标签，但添加 `async` 和 `defer` 属性。给 script 标签加上 `async` 属性，会异步加载脚本，不阻塞 HTML 解析，但会在脚本加载完毕立即执行时阻断 HTML 解析。给 script 标签加上 `defer` 属性，同样会异步加载脚本，不同的是会在 HTML 解析完毕后再执行加载的脚本。这两个属性该用哪一个，还要看脚本本身的具体内容。

   使用以上方法加载 JS，可以确保浏览器首先解析 HTML 和 CSS，不受请求 JS 文件的影响。至于选择哪个方法，很大程度上取决于浏览器的支持情况：`async` 和 `defer` 属性是 HTML 中定义的，因此还比较新。IE10 和更早版本的 IE 并不支持或不完全支持它们。

## 三. 可见格式化模型

浮动、定位和盒模型是学习 CSS 需要掌握的几个最重要的概念。这几个概念决定了元素在页面是排布和显示的方式，是很多布局技术的举出。近年来，Web 标准也引入了专门用于控制布局的新规范。

### 3.1 盒模型

盒模型是 CSS 的核心概念，描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看做一个矩形盒子，这个盒子包含元素的内容、内边距、边框、外边距。

内边距（padding）是内容区周围的空间。给元素应用的背景会作用于元素内容和内边距。因此，内边距通常用于分隔内容，使其不至于散布到背景的边界。边框（border）会在内边距外侧增加一条框线，这条框线可以是实线、虚线或点划线。边框的外侧是外边距（margin），外边距是围绕在盒子可见部分之外的透明区域，用于在页面中控制元素之间的距离。

有一个与边框类似的属性，即轮廓线（outline）。这个属性可以在边框盒子外围画出一条线，但这条线不影响盒子的布局，也就是不影响盒子的宽度和高度。因此，outline 常用于调试复杂布局，或显示布局效果。

对元素盒子而言，内边距、边框和外边距不是必需的，因此它们的默认值都为 0。不过，用户代码样式表通常会给很多元素添加外边距和内边距。比如，标题通常就会带有一定的外边距，但外边距的值会因浏览器而异。

#### 3.1.1 盒子大小

默认情况下，元素盒子的 width 和 height 属性指的是内容盒子，也就是元素可渲染内容区的宽度和高度。这时候添加边框和内边距并不会影响内容盒子的大小，但会导致整个元素盒子变大。如果想给元素盒子的每一边都添加 5 像素的边框和 5 像素的内边距，同时又想让元素盒子的宽度为 100 像素，则应该把内容区宽度设置为 80 像素。如果这个元素盒子外围还有 10 像素的外边距，那么整个盒子占据空间的宽度就是 120 像素。

通过修改 box-sizing 属性可以改变计算盒子大小的方式。box-sizing 的默认值为 content-box，即把宽度值应用给内容区。通过修改 box-sizing 的值，设置元素的 width 和 height 属性，就可以影响元素盒子的不同区域，这对响应式布局非常有用。

如果把 box-sizing 的值修改为 **border-box**，那么 width 和 height 的值将会包含内边距和边框。此时，外边距仍然会影响盒子在页面中占据的整体空间，即它的宽度不会算到 width 中。这种计算盒子大小的方式更加直观。

#### 3.1.2 最大值和最小值

有时候，特别是在响应式布局中，给一个元素应用 min-width 和 max-width 值很有用。因为这样一来，块级盒子就可以默认自动填充父元素的宽度，但不会收缩到比 min-width 指定的值更窄，或者扩展到比 max-width 指定的值更宽。（第 8 章会讨论响应式设计及其与 CSS 的关系<!--TODO-->。）

与此类似的是 min-height 和 max-height 属性。不过在 CSS 中，设置任何高度值的时候都应该慎重。这是因为元素的高度通常应该取决于所包含的内容，不需要明确设定。否则，万一内容增多，或者文本字号变大，内容就可能跑到高度固定的盒子之外去。即使出于种种原因，需要明确设定默认高度，也最好使用 min-height，因为这个属性允许盒子随内容扩展。

### 3.2 可见格式化模型

常说 p、h1 和 article 这些元素都是块级元素。意思就是说，它们作为元素，显示为内容块或块级盒子（block box）的形式。相对而言，strong、span 和 time 被称为行内元素，因为它们的内容会以行内盒子（inline box）的形式显示在行内。

可以使用 `display` 属性改变生成的盒子类型。如果把 display 属性设置为 none，还可以让浏览器不为相应的元素生成盒子。如果不生成盒子，那么元素及其包含的内容就不会显示出来，也不会占用文档中的空间。

CSS 中有几种不同的定位模型，包括浮动、绝对定位和相对定位。除非特别指定，否则所有盒子都会在常规文档流中生成，即 position 属性的默认值为 static。顾名思义，常规文档流中元素盒子的位置，由元素在 HTML 中的位置决定。

- 块级盒子会沿垂直方向堆叠，盒子在垂直方向上的间距由它们的上、下外边距决定。

- 行内盒子是沿文本流水平排列的，也会随文本换行而换行。它们之间的水平间距可以通过水平方向的内边距、边框和外边距来调节。但行内盒子的高度不受其垂直方向上的内边距、边框和外边距的影响。此外，给行内盒子明确设置高度和宽度也不会起作用。

- **由一行文本形成的水平盒子叫行盒子**（line box），而行盒子的高度由所包含的行内盒子决定。修改行盒子大小的唯一途径就是修改行高（line-height），或者给它内部的行内盒子设置水平方向的边框、内边距或外边距。

- 当然，也可以把元素的 display 属性设置为 `inline-block`。这样设置之后，该元素就会像一个行内盒子一样水平排列。但这个盒子的内部仍然像块级元素一样，能够设置宽度、高度、垂直外边距和内边距。

- 使用表格相关的标记（table、tr、th 等）时，表格本身表现为块级元素，但表格的内容会根据生成的行和列排布。还可以通过设置 display 属性让非表格元素采用表格的布局方式。只要正确地应用 table、table-row 和 table-cell 等值，就可以实现表格布局，无须在 HTML 标记中使用表格标签。

后面的 Flexible Box Layout（也称为 Flexbox）和 Grid Layout 等 CSS 模块，又进一步扩展了 display 属性。通常，这些新布局模式会在它们的外部上下文中创建类似块级的盒子，但会为内部显示内容创建新的规则。

#### 3.2.1 匿名盒子

HTML 元素可以嵌套，元素盒子当然也可以嵌套。多数盒子都是基于明确定义的元素生成的。不过有一种情况，就算不明确定义元素也会生成块级盒子。比如，像下面这样，在 section 这个块级元素的开头加人 “some text”。此时，“some text” 就算没有定义为块级元素，也会被当成块级元素。

```html
<section>
  some text
  <p>Some more text</p>
</section>
```

这种情况下，这个盒子被称为**匿名块盒子**（anonymous block box），因为这个盒子并不与任何特定的元素相关。

类似的情况也存在于块级元素内部的文本级行盒子。假设有一个段落中包含三行文本，这三行文本的每一行都构成了一个匿名行盒子（anonymous line box）除了使用 :first-line 伪元素来添加有限的排版和颜色相关的样式之外，不能直接给匿名块盒子或匿名行盒子应用样式。**关键要知道，在屏幕上看到一切，都会从属于某个盒子**。

#### 3.2.2 外边距折叠

常规块盒子有一种机制叫作外边距折叠。外边距折叠的概念很简单，简而言之，**垂直方向上的两个外边距相遇时，会折叠成一个外边距。折叠后外边距的高度等于两者中较大的那一个高度**。当两个元素垂直堆叠时，上方元素的下外边距会与下方元素的上外边距相折叠。

**外边距折叠只发生在文档常规文本流中块级盒子的垂直方向上**。行内盒子、浮动盒子或绝对定位盒子的外边距不会折叠。

#### 3.2.3 包含块

知道什么决定一个元素的包含块非常重要，将内边距和外边距的值设置为百分比，包含块就是这些百分比值的计算依据。

确定元素的包含块，要看元素是如何定位的。如果元素的定位方式是静态定位（即不指定 position 的值）或相对定位，则其包含块的边界就计算到一个最近的父元素，该元素的 display 属性值必须能够提供类似块级的上下文，如 block、inline-block、table-cell、list-item 等。

默认情况下，width、height、margin 和 padding 的值为百分比时，就以该父元素的尺寸为计算依据。如果当前元素的定位模型改成了 absolute 或 fixed，那么计算依据就会发生变化。

#### 3.2.4 相对定位

把一个元素的 position 属性设置为 relative，该元素仍然会呆在原来的地方。但此后，可以通过设置 top、right、bottom 和 left 属性，使该元素相对于初始位置平移一定距离。比如设置 top 属性为 20 像素，该元素就会相对于其初始位置垂直向下平移 20 像素。而设置 left 属性为 20 像素，则会将该元素向右移动 20 像素，其左侧会出现空白。

无论是否位移，相对定位的元素仍然会在文档流中占用初始的空间。因此，这样平移元素会导致它遮挡其他元素。

#### 3.2.5 绝对定位

相对定位事实上是常规文档流定位模型的一部分，因为元素还是相对于它在常规流中的初始位置来定位。绝对定位则会把元素拿出文档流，因此也就不会再占用原来的空间。与此同时，文档流中的其他元素会各自重新定位，仿佛绝对定位的那个元素没有存在过一样。

绝对定位元素的包含块是距离它最近的定位祖先，也就是 position 属性设置为 static 之外任意值的祖先元素。如果没有这么一个定位祖先，那么它就相对于文档的根元素即 html 元素定位。文档的根元素也叫作起始包含块（initial containing block）。

与相对定位的盒子类似，绝对定位的盒子也可以相对于其包含块向上、下、左、右方向平移。平移绝对定位的元素提供了极大的灵活性，因为可以把元素移动到页面的任意位置。

绝对定位的盒子是脱离了常规文档流的，因此可能会遮挡页面上的其他元素。为了控制这些盒子层叠的次序，可以设置一个叫 `z-index` 的属性。z-index 属性值越大，盒子在层叠中的次序就越靠近用户的眼睛。用 z-index 控制盒子的层叠有不少值得探讨之处，第 6 章再详细介绍<!--TODO-->。

尽管绝对定位对于在页面上任意摆放元素非常有用，但近来已经很少被用来构建整体布局了。绝对定位的盒子脱离了常规文档流，因此很难用它们创建随视口宽度和内容长度变化而变化的自适应或者响应式布局。Web 技术的特点决定了不太可能指定元素在页面上的确切位置和大小。随着对其他 CSS 布局技术掌握得越发熟练，会发现绝对定位在整体布局上几乎没人用了。

#### 3.2.6 固定定位

固定定位是由绝对定位衍生出来的，不同之处在于，固定定位元素的包含块是视口（viewport）。因此，固定定位可用来创建始终停留在窗口相同位置的浮动元素。很多网站都使用这个技术让导航区始终保持可见，有的固定侧栏，有的固定顶栏。这样能确保网站的可用性，因为用户不必再费事寻找了。

#### 3.2.7 浮动

另一种可见形式化模型是浮动模型。浮动盒子可以向左或向右移动，直到其外边沿接触包含块的外边沿，或接触另一个浮动盒子的外边沿。浮动盒子也会脱离常规文档流，因此常规文档流中的其他块级盒子的表现，**几乎**当浮动盒子不存在一样。

**行盒子与清除**
浮动元素会脱离文档流，因此不会再像非浮动元素一样影响其他元素。实际上，严格来讲并非如此。如果浮动元素后面跟着的是常规文档流中的元素，那么这个元素的盒子就会当浮动元素不存在一样。但是，这个元素盒子中的文本内容则会记住浮动元素的大小，并在排布时避开它，为其留出相应的空间。从技术角度来讲，就是跟在浮动元素后面的行盒子会缩短，从而为浮动元素留空，造成文本环绕浮动盒子的效果。事实上，浮动就是为了在网页中实现文本环绕图片的效果而引入的一种布局模型。

要阻止行盒子环绕在浮动盒子外面，需要给包含行盒子的应用 `clear` 属性。clear 属性的值有 left、right、both、none，用于指定盒子的哪一侧不应该紧挨着浮动盒子。清除一个元素时，浏览器会在这个元素上方添加足够大的外边距，从而将元素的上边沿垂直向下推移到浮动元素下方。因此，如果给 “已清除的” 元素添加外边距，那么除非添加的值超过浏览器自动添加的值，否则不会看到效果。

浮动元素除了会导致后面的行盒子缩短，从而造成文本环绕效果之外，不会对周围的元素有任何别的影响，毕竟它已经脱离了文档流。但清除一个元素本质上会为所有前面的浮动元素清理出一块垂直空间。这就为使用浮动布局创造了条件，因为周围的元素可以为浮动的元素腾出地方来。

浮动的元素会被拿出文档流，所以只包含浮动内容的元素，无法在文档流中生成高度。这时，需要在这个元素内部某处应用 clear，在清除的元素上方创造出足够的垂直外边距，从而为包住浮动元素创造出空间，可以使用 :after 伪元素来模拟额外的清除元素：

```css
.block:after {
  content: ' ';
  display: block;
  clear: both;
}
```

#### 3.2.8 格式化上下文

当元素在页面上水平或垂直排布时，它们之间如何相互影响，CSS 有几套不同的规则，其中一套规则叫作格式化上下文（formatting context）。前面已经介绍了行内格式化上下文（inline formatting context）的一些规则。比如，垂直外边距对于行内盒子没有影响。

此外，有些规则规定了页面必须自动包含突出的浮动元素（否则浮动元素中的内容可能会跑到可滚动区域之外），而且所有块级盒子的左边界默认与包含块的左边界对齐（如果文字顺序是从右向左，那么与包含块的右边界对齐）。这组规则就是**块级格式化上下文**（block formatting context）。

还有些规则允许元素建立自己内部的块级格式化上下文，包括：

- display 属性值设置为 inline-block 或 table-cell 之类的元素，可以为内容创建类似块级的上下文

- float 属性值不是 none 的元素

- 绝对定位的元素

- overflow 属性值不是 visible 的元素

前面说过，块边界接触其包含块边界的规则同样适用于前面是浮动元素的内容。浮动元素从页面流中移出后，通过触发其后的元素中行盒子的缩短行为，制造了为自身腾出四周空间的视觉效果。而其后的元素仍然会按照需要，在浮动元素下方拉伸。

当一个元素具备了触发新块级格式化上下文的条件，并且挨着一个浮动元素时，它就会忽略自己的边界必须接触自己的包含块边界的规则。此时，这个元素会收缩到适当大小；不仅行盒子如此，所有盒子都如此。尽量基于简单且可预测的行为来创建布局，这样可以降低代码复杂度，并提高布局稳健性。

#### 3.2.9 内在大小与外在大小

CSS 的 Intrinsic and Extrinsic Sizing Level3 模块定义了一组可以应用给（min- 和 max-）width 和 height 属性的关键字，而非像素或百分比这种长度值。这些关键字代表了明确的长度，要么继承自周围的上下文（外在大小），要么源于元素自身的内容（内在大小），具体数值由浏览器决定。这样可以代替以往使用的隐含值，比如把某个属性设置为 auto，或者使用浮动或块级格式化上下文，在不设置 width 的情况下达到收缩适应的目的。

目前，支持这个模块中定义的关键字的浏览器还很少。但无论如何，这种更稳健的指定尺寸的方式在未来一定非常有用，毕竟可以省掉同时使用多种技术的麻烦。

### 3.3 其他 CSS 布局模块

对于 CSS 这种视觉表现语言来说，稳健又灵活的布局模型无论如何都是必需的。虽然道理显而易见，但这种模型的诞生却并不容易。过去，曾想方设法地利用这门语言中可用的特性来达成自己的目标，哪怕那些特性并不好用。比如最早我们曾使用表格布局，但问题是代码臃肿、语义不当。近来又在使用浮动和绝对定位，但这些技术同样也并非为页面布局而设计。无论是表格还是浮动与定位，都有非常严重的局限性，使用它们只是不得已的选择。

最近出现了一些专门针对创建灵活、稳健页面布局的 CSS 模块。这些模块的进度快慢不一，有的甚至还没有得到较多浏览器支持。后面会详细介绍其中几个模块，此处先概览一下它们的主要功能。

#### 3.3.1 弹性盒布局

弹性盒布局模块（Flexible Box Layout Module），常被称为 Flexbox，是 CSS3 新引入的一种布局模型。Flexbox 支持对子元素水平或垂直布局，以及设置这些子元素的大小、间距和对齐方式。此外，Flexbox 还支持改变元素渲染到页面上的次序，可以跟它们在 HTML 中的次序不同。作为 CSS 常规流模型（行内和块）的升级版，无论是调整内容本身还是适应内容大小，Flexbox 都做到了既精确又灵活。

Flexbox 已经得到浏览器的广泛支持，只是在旧版本正中缺乏支持或支持不完整。好在可以将 Flexbox 与浮动等其他技术组合使用，以确保跨浏览器布局的稳健。第 6 章会专门讲到 Flexbox<!--TODO-->。

#### 3.3.2 网格布局

网格布局（grid layout）是 CSS 中最早成熟的高层布局工具，目标是取代浮动和定位元素的布局方式。网格布局实现了源代码次序的完全分离，从内容结构和个别模块的表现中抽象出了网格系统。Flexbox 关注 “微观”，而网格系统关注 “宏观”，二者正好互补，网格布局还未得到广泛支持，但各家浏览器正在争先恐后地实现它。第 7 章将全面介绍网格布局<!--TODO-->。

### 3.3.3 多栏布局

多栏布局模块（Multi-column Layout Module）的用意很明确，就是实现内容的多栏布局。比如，要排成像报纸那样的多栏样式。可以先指定栏数，也可以先指定每一栏的宽度，然后让浏览器根据可用宽度自动确定栏数。当然，还可以控制栏间距，并在其中应用类似边框的视觉效果。因为多栏布局更倾向于排版而布局，所以把它放在第 4 章介绍<!--TODO-->

### 3.4 Region

CSS Regions Module Level 1 可以实现内容在不同元素间的灌文接排。可以把一个元素作为内容来源，但它不在常规文档流中，其内容可以灌排到页面中的其他占位元素。这意味着布局不再受 HTML 中元素次序的影响，也就是把布局表现从内容结构中解耦了出来。

使用 CSS Region 排出的板式，在以前是无法只用 CSS 实现的，它为将来在网页中再现印刷品的排版样式奠定了基础。不过，很少有浏览器厂商有兴趣实现 CSS Region，因此可能很长时间内都无法使用它。

## 四. 网页排版

排版是平面设计的基础。同样，排版在网页设计中也扮演着重要角色。

### 4.1 CSS 的基本排版技术

拿到一个页面时，所有设计师都会先考虑从基本的版式着手。从 body 元素开始，逐步细化，从而让整个页面具有基本的可读性、层次性和配色。浏览器有默认样式表，它为网页应用了一些必要的排版规则。

#### 4.1.1 文本颜色

对于网页而言，文本颜色也许是最基本的样式之一，但它的效果却很容易被忽视。默认情况下，浏览器会把绝大部分文本渲染为黑色（链接除外，它们的颜色是 “活力蓝”，白底黑字的对比度极高。足够高的对比度是确保网页阅读无障碍的关键，但也往往会被过分强调。事实上由于屏幕的高对比度，白底黑字会让大段文本显得过分密集，反而影响可读性。

#### 4.1.2 字体族

字体族（font-family）属性的值是一个备选字体的列表，用逗号分隔，按优先级从左到右排列。

这种后备机制是 font-family 属性的重要特性，因为不同的操作系统和移动设备可能安装了不同的字体。何况字体的选择也不仅仅是看某种字体是否存在。如果优先的字体中缺少文本中用到的字形，比如重读符号，浏览器会为缺失的符号向后查找其他字体。

关于什么操作系统中默认安装了哪些字体，有些人已经做过相关的[研究整理](https://www.cssfontstack.com)。

字体列表最后通常有 serif 和 sans-serif 被叫作**通用字体族**，充当没有选择的选择。此外，还有 cursive、fantasy 和 monospace 等通用字体族，只不过 serif 和 sans-serif 应该是最常用的两个。如果网页中要显示代码，应该首选 monospace 字体族，也叫“等宽字体”，因为 monospace 的每个字符的宽度都一样，不同行之间的字符可以完美对齐。fantasy 和 cursive 就没那么常用了，分别对应花式字体和手写字体。

> **注意**：列出包含空格的字体族名称时，引号不是非加不可，但最好加上。规范中只要求与通用字体族重名的字体族要加引号，但同时也建议给包含非标准符号的名称加引号，以防浏览器误判。

**字体与字型**
字型（typeface）、字体族（font-family）和字体（font）这 3 个术语经常有人分不清楚。所谓字型（也叫字体族），就是一组代表字母、数字及其他具有统一外观样式的字形（glyph）的集合字型包含的每种字形，通常有粗体、常规、细体、斜体等变体，能够以不同样式显示数值、连字等，还可能有其他变体。

最初，字体指的是一种字型中的某种特定变体所包含的所有字形的集合，由金属制成。这些选出来的字形会被装上印刷机。而在数字排版领域，字体通常指一个存有某种字型表示的文件。假设有一种字型叫 “CSS Mastery”，那么它可能只有一个字体文件，也可能包含多个字体文件，比如 “CSS Mastery 常规” “CSS Mastery 斜体” 或 “ CSS Mastery 细体” 等。

#### 4.1.3 字型大小与行高

几乎所有浏览器中 font-size 的默认大小都是 16 像素，除非用户修改过偏好设置。

`em` 单位用于 font-size 属性时，实际上是一个相应元素继承的 font-size 缩放因子。比如 h3 元素，字型大小就是 `1.314*16=21px`。虽然可以直接设置 21px，但 em 更灵活一些。多数浏览器都允许用户缩放整个页面，即使像素单位也可以缩放。而使用 em 之后，如果用户修改偏好中的默认 font-size 大小，那么相应元素的大小也会相应调整。

因为 em 单位基于继承的大小缩放，所以可以通过缩放父元素的 font-size 来修改页面局部的继承大小。但这样做也有问题（也是使用 em 经常出错的地方）：可能因为调整了某个元素在标记中的位置而意外改变其字型大小。因此，在使用相对长度值的时候，必须留意最终计算得到的值。

对于 font-size 属性，可用**百分比**代替 em。133.3% 在这里与 1.33em 没有区别，选择哪个完全取决于个人偏好。

而最灵活的方式则是使用 `rem` 单位。与 em 类似，rem 也是一个缩放因子，但它始终基于**根元素**的 em 大小缩放（根元素的 em，就是 root element em，即 rem），也就是基于 html 元素的 font-size 缩放。

当 em 用于计算盒模型的大小时，它不是基于继承的 font-size，而是基于元素自身计算的 font-size。因此，不同级别的标题对应的 font-size 是不一样的。为了得到一致的值（同时又要保证灵活），要么使用 rem，要么对每个标题级别都分别以 em 计算 margin-top 值。

rem 单位相对较新，但已经得到所有现代浏览器的支持。为了兼容 IE8 及更早版本的 IE，可以利用 CSS 的容错机制，在基于 rem 的声明之前再声明一个像素单位的值。

> 长度单位还有 mm、cm、in 和 pt 等**绝对物理长度**，这些主要是给打印样式准备的。网页设计不应该使用这些单位。本章不介绍打印样式表，但会在第 8 章<!--TODO-->介绍如何针对不同的媒体类型应用样式。

**基于比例缩放字型大小**
font-size 到底应该选多大，其实没有硬性要求。总体来说，就是要让文本足够大，让人能轻松地看清楚，同时要保证字型大小在当前上下文中比较合适。有些人相信自己的眼睛，认为看着舒服最重要；有些人则相信缜密的数学计算，处处奉科学原理为圭臬。

下面标题的大小大致符合一个叫做 “纯四度”（perfect fourth）的数学比例，即上一级标题会比下一级标题的字型大自身尺寸的 1/4，这里的数值经过舍入，并保留了 3 位小数：

```css
h1 {
  font-size: 2.315em; /* 37px */
}
h2 {
  font-size: 1.75em; /* 28px */
}
h3 {
  font-size: 1.314em; /* 21px */
}
```

此类比例关系对于初始阶段的网页设计至关重要。即使最终还是凭感觉设置字型大小，尽量位置类似的比例关系也是必要的。可以试一试 [Modular Scale 计算器](https://www.modularscale.com/)。

#### 4.1.4 行间距、对齐及行盒子的构造

深入剖析 CSS 行内格式化模型，同时多理解一些排版术语。下图展示了构成一行文本的各个部分：

![行内格式化模型的构造及相关概念](./image/行内格式化模型的构造及相关概念.jpg)

行内格式化，每行文本都会生成一个行盒子。行盒子还可以进一步拆分成表示行内元素（比如上面例子中的 `<strong>` 元素）的行内盒子，或者连接两个行内元素的匿名行内盒子。

行内盒子中的内容区显示文本。内容区的高度由 font-size 的测量尺度，即上图中 “Moon” 末尾那个 1em 见方的块，以及这个块与字形本身的关系来决定。西方传统排版术语 “em” 对应 CSS 中的 em 单位，这个概念最初指大写字母 “M” 的大小，但在网页排版中这个定义已经不适用了。

小写字母 “x” 的上边界决定了所谓的 “x 高度”。不同字体的 x 高度差异很大，因此很难就字体大小给出一个通用的建议。要想知道精确的字型大小，就必须分别测试。

然后，字形会被摆放在内容区中，每个字形都在垂直方向上不偏不倚，使得每个行内盒子的底边都默认对齐于靠近底部的共同水平线，这条线叫**基线**。内容区也不一定会限制住字形，比如某些字体中的小写字母 “g” 就会向下伸出内容区。

最后，**行高指的是行盒子的总高度。更通俗的叫法是行间距**，排版术语叫铅空，就是排字员用来隔开字符行的铅块。但与传统排版不同，CSS 中的 “铅空” 始终都会同时应用到行盒子的上方和下方。

计算方法如下：行盒子的整体行高减去 font-size，得到的值再平分成两份，也就是**半铅空**。如果 line-height 是 30 像素，而 font-size 是 21 像素，那么半铅空就是 4.5 像素。

> **注意**：如果行盒子中包含多个行高不一的行内盒子，那么这个行盒子的最终高度至少等于其中最高的行内盒子。

1. **设置行高**
   设置行高时，需要考虑当前字体大小。一般来说，行高取值在 1.2~1.5 范围内。关键是行与行之间既不能太密，也不能太疏。对于 x 高度较大的字体，行间距应该稍大一些。文本的长度和 font-size 也要考虑，短文本一般设置较小的 line-height。可以给 line-height 设置无单位数值、像素值、百分比值、rem 或 em 值。

   > **注意**：body 元素的所有子元素都会继承 line-height 的计算值。换句话说，就算 body 用的是百分比或 em，其子元素继承的都是计算后得到的像素值，但无单位的值就不会导致这个结果。因此，如果给 line-height 设置没有单位的值，那么子元素继承的是一个系数，永远与自己的 font-size 成比例。

2. **垂直对齐**
   除了 line-height，行内盒子也会受到 `vertical-align` 属性的影响。它的默认值是 baseline，即子元素的基线与父元素的基线对齐。

   其他关键字值有 sup、super、top、 bottom、text-top、text-bottom 和 middle。这些值或多或少都与内容区和父行盒子有着复杂的关系。仅举一例，text-top 或 text-bottom 会让当前元素的内容区与父行盒子的内容区顶部或底部对齐，但只有在行内盒子的 font-size 或 line-height 与其父元素不同时才会有影响。如前所述，关系复杂。

   或许通过设置长度值—无论是像素值，还是 font-size 的相对值（如 em 或 %）—让元素的基线偏离父元素基线是理解垂直对齐的最直观方式。

   > **注意**：影响文本行间距的值不只是 line-height。如果行盒子中有一个元素使用 vertical-align 调整了位置，那么它可能会扩展行盒子的高度。

> **注意**：与行内文本相比，行内块和图片的垂直对齐行为稍有不同，因为它们不一定有自己的唯一基线。第 6 章将介绍如何利用这一点实现特定布局效果<!--TODO-->。

### 4.1.5 文本粗细

使用 `font-weight` 属性来设置标题文本的粗细。有些字体的变体很多，比如 Helvetica Neue Light、Helvetica Neue Bold、Helvetica Neue Black。此时，可以不用给出变体的名字，而只使用关键字：normal、bold、 bolder 和 lighter。也可以直接给出数字值，都是 100 的整数倍：100、200、300、400，等等，最大为 900。

默认值 normal 对应 400，bold 对应 700，这两个粗细值是最常用的。关键字 bolder 和 lighter 的工作机制略有不同，它们的作用是在继承值的基础上把文本变粗或变细。

数字值 100~300 对应的字体名字中通常包含 “Thin” “Hairline” “Ultra Light” 和 “Light” 等字样。反之，数字值 800 或 900 对应的字体名字中可能包含 “Ultra Bold” “Heavy” 或 “Black"。500 或 600 则代表中等粗细。

Avenir Next 和 Segoe UI（都是首选字体）都包含很多粗细的变体。_如果某款字体缺少想要的粗细变体，浏览器会尽量模拟加粗效果，但无论如何不能模拟变细效果。这种模拟的结果往往差强人意_。

#### 4.1.6 字体样式

设置 `font-style: italic` 会从字型中选择斜体显示，前提是存在这个变体。如果不存在，浏览器会通过倾斜字体来模拟，但结果同样也不会太理想。斜体通常用于表示强调，或者表达一种不同的语气。除了 italic 和默认的 normal 以外，也可以给 font-style 设置 `oblique` 关键字（是倾斜文本的另一个变体），但它很少用，因为没有几款字体含有这种变体。

#### 4.1.7 大小写变换和小型大写变体

有时候，设计需要显示与 HTML 源码中不同的大小写。CSS 可以控制英文字母大小写，属性是 `text-transform`。在例子中，h1 元素中的文本是首字母大写的，但通过 CSS 强制把所有字母都显示为大写了：

```css
h1 {
  text-transform: uppercase;
}
```

除了 `uppercase` 这个值，还可以用 `lowercase` 把所有字母变成小写，用 `capitalize` 把每个单词的首字母变成大写，或者使用 `none` 显示 HTML 源码中的默认大小写形式。

**使用 font-variant**
CSS 还有一个属性 `font-variant`，可以通过值 `small-caps` 把英文文本转换成所谓的 “小型大写字母”。“小型大写字母” 也是一种字型的变体，虽然所有字母都大写，但只有首字母是正常大小，其他字母的大小跟原来小写时一样，就像缩小了似的。正确的 small-caps 变体很大程度上会依据字母的字形来变化，而不仅仅是简单地缩小字母。不过能做到这一点的多数是收费字体。浏览器会在没安装这些字体时尝试模拟类似的行为。可以通过 abbr 标签包含的首字母缩写来示范一下浏览器的行为：

```html
<abbr title="National Aeronautics and Space Administration">NASA</abbr>
```

同时还应用了 `text-transform: lowercase`，因为 HTML 源码中的 NASA 本来就大写了。还需要稍微缩小一点 line-height，因为 small-caps 会导致某些浏览器把内容盒子向下移动一点，从而影响整体行盒子的高度：

```css
abbr {
  text-transform: lowercase;
  font-variant: small-caps;
  line-height: 1.25;
}
```

CSS 2.1 只对 font-variant 属性规定了一个有效的值：small-caps。而 CSS Fonts Module Level 3 则大加扩展，增加了很多不同字形的输出选择。浏览器实现相对滞后，但好在有办法支持这些新选择。会在后面介绍高级排版技术时再讲<!--TODO-->。

#### 4.1.8 控制字母和单词间距

一般来说，控制字母和单词间距是字体设计师的事儿。不过 CSS 也提供了一些简陋的工具来控制这些。

首先是 `word-spacing` 属性，功能是控制词间距，很少用。它的值意味着在默认词间距基础上增加或减少一定的量，而默认词间距由当前字体中空白字符的宽度决定。

类似地，可以通过 `letter-spacing` 属性来控制字符间的距离。对于小写英文字母的文本来说，人为改变字母间距并不是好事，因为大多数字型的设计初衷都是让人更容易辨别整个单词，而随意调整字母间距可能导致文本难以辨别。对于大写字母（或小型大写字母）的文本而言，则要视情况而定。比如缩写词，稍微加大一点字母间距有助于阅读。

### 4.2 版心宽度、律动和毛边

接下来探讨一个对阅读体验有着重大影响的因素：行长。用排版的行话说，就是**版心宽度**。过长或过短的文本行会打断人的眼球移动，导致读者无法连续阅读，最后甚至读不下去。

一行文本到底多长才合适，并没有什么终极答案。字体不同、屏幕大小不同、文本内容不同，都会影响行长。只能根据过往的研究和专业人士的建议，在自己设计页面时定义尽量合适的长度。

Robert Bringhurst 的经典图书 _The Elements of Typographic Style_ 提到，主体内容的文本行长通常是 45~75 个字符，平均值为 66 个字符。排版专家 Richard rutter 发现这个建议同样适用于今天的网页，特别是大屏幕中的网页。对于小屏幕（或者远距离观看的大屏幕，如电影或投影）而言，行长至少也应该有 40 个字符。

**要控制行长，可以通过设定包含文本的段落、标题等元素的宽度来实现**。对于页面主体文本而言，Georgia 字体的字母相对较宽（因为其 x 高度较大），因此行长就要考虑使用前述范围的上限。为此，简单地将 article 元素的宽度设置为 36em（平均每个字符 0.5em），并令其在页面上居中。如果视口缩小到比这个值更窄，该元素会自动调整宽度。

```css
article {
  max-width: 36em;
  margin: 0 auto;
}
```

#### 4.2.1 文本缩进与对齐

默认情况下，文本都是左对齐的。文本左对齐有助于找到下一行，保持阅读节奏。对于连续的段落，或者为相邻段落设置 1 行的外边距，或设置段首缩进（`text-index`）。

段落的右边可能参差不齐。这种参差不齐的样式在排版上也有术语，叫做 “毛边”（rag）。在应用文本居中对齐时需要格外小心，除非行长很短。居中文本非常适合小型用户界面元素或短标题的布局，因为两端参差不齐会影响可读性。

`text-align` 属性可以接受下列任意一个关键字值：left、right、center 和 justify。CSS Text Level3 规范还额外定义了几个值，包括 start 和 end。这两个逻辑方向关键字与文本书写模式相对应：多数西方语言都是从左向右书写，因此如果文本语言是英语，那么 start 就代表左对齐，end 代表右对齐。而在从右向左书写的语言中（如阿拉伯语，就正好相反。如果给父元素设置了 dir="rtl" 属性，即从右向左显示，浏览器通常都会自动反转默认的文本方向。

给 `text-align` 属性应用 `justify` 值，可以在单词间平均分布间距，结果就是左右两端对齐消除毛边。这也是印刷业中经常采用的技术，原版包括连字符在内的字体特性都会被修整以适应页面空间。

网页又是另一种媒体，很多因素无法控制。屏幕大小不同、安装的字体不同、浏览器引擎不同，这些都会影响用户最终在页面上看到的结果。如果让文本两端对齐，可能会导致下图的结果，不易认读。由文本空白构成的 “串流”（river of whitespace）会出现，版心宽度越小就越严重。

![文本“串流”现象](./image/文本“串流”现象.jpg)

浏览器处理文本两端对齐时使用的算法挺粗糙的，不如传统出版效果好。虽然可以通过 `text-justify` 属性修改使用的算法，但浏览器对其多个值的支持较弱，基本上只涉及调整非西方语言的字形和单词。

有意思的是，IE 支持这个属性的一个非标准值 newspaper，它好像使用了更聪明的算法。该算法会同时调整字母间距和单词间距。

#### 4.2.2 连字符

如果仍然打算在页面中让文本两端对齐，那么连字符可能会有助于减轻串流问题。为此，可以手工在 HTML 中插入一个表示连字符的实体，即所谓的软连字符 **&shy;**。只有当浏览器需要断词换行时才会显示这个连字符。

![手工插入软连字符](./image/手工插入软连字符.jpg)

对于文章之类的长文本，手动逐个插入连字符并不现实。此时可以使用 `hyphens` 属性，让浏览器帮插入连字符。这个属性相对较新，因此一般要加上浏览器前缀才能生效。IE10 之前的版本、安卓设备中内置的 WebKit 浏览器，甚至连基于 Blink 的 Chrome 和 Opera 都基本不支持 `hyphens`。

要想使用自动连字符功能，需要保证两点：

1. 在网页 html 元素中设置语言代码

   ```html
   <html lang="en"></html>
   ```

2. 通过 CSS 将相关元素的 `hyphens` 属性值设为 auto。

   ```css
   p {
     hyphens: auto;
   }
   ```

要关闭连字符，可以将 `hyphens` 属性值设置为 manual，即手动模式。在手动模式下，软连字符机制会起作用。

#### 4.2.3 多栏文本

把整篇文章的宽度都限制为 36em 可以达到限制版心宽度的目的，但对于大屏幕而言，却又太浪费空间了，留着大片的空白很可惜！有时候，为了有效利用宽屏，可以把文本分成多栏，并对每栏的宽度加以限制。CSS Multi-column Layout Module 定义的属性可以把文本内容切分成多个等宽的栏。

“Multi-column Layout” 这个名字容易让人产生误会，以为使用它定义的属性，就可以在页面上创建带有栏和栏间距控制的网格布局。实际上并不是这样，这个模块定义的属性只是用来把网页中部分内容的版式转换成类似报纸上的分栏效果。当然，利用这些属性创建其他布局效果完全没问题，只是可能并非该模块的初衷罢了。

如果把之前设置的 max-width 增加到 70em，那么可以分成 3 栏。为此，要把 `columns` 属性设置为想要的最小宽度。栏间距通过 `colum-gap` 属性控制：

```css
article {
  max-width: 70em;
  columns: 20em;
  column-gap: 1.5em;
  margin: 0 auto;
}
```

![Multi-column-Layout](./image/Multi-column-Layout.jpg)

这里的 `columns` 属性是 `column-count` 和 `column-width` 属性的简写形式。如果只设置 `column-count` 属性，浏览器会严格生成指定数量的栏，不管宽度如何。如果同时设置了 `column-count` 和 `colum-width`，则前者会作为最大栏数，后者会作为最小栏宽。

```css
article {
  columns: 20em; /* 在保证最小宽度 20em 的前提下，自动设置栏数 */
  column-width: 20em; /* 同上 */

  columns: 3; /* 3栏，自动设置宽度 */
  column-count: 3; /* 同上 */

  columns: 3 20em; /* 至少3栏，每栏宽度至少 20em */
  /* 以下两条声明的組合相当于以上代码的简写形式：*/
  column-count: 3;
  column-width: 20em;
}
```

1. **后备宽度**

   为了在不支持多栏属性的浏览器中确保行长不会超过限度，可以在段落元素上应 max-width 属性。这样一来，旧版本浏览器只会显示一栏，但仍然能保证可读性：

   ```css
   article > p {
     max-width: 36em;
   }
   ```

2. **跨栏**

   在前面的例子中，文章中的所有元素都排在了栏内文本流中。其实可以让某些元素排到该本流之外，强制它们伸长以达到跨栏效果。下图中，文章标题和最后一段（包含来源链接）就横跨了所有栏：

   ```css
   h1,
   source {
     column-span: all; /* 或 column-span: none;，以关闭跨栏特性 */
   }
   ```

   ![column-span跨栏](./image/column-span跨栏.jpg)

   如果让位于文本流中间的一个元素横跨所有栏，那么文本会按照垂直切分后的几栏流动。在下图中，为 h2 元素应用了前面的规则，结果该标题前面后的文本分别灌入了各自的几个分栏。

   ![垂直切分多栏文本流](./image/垂直切分多栏文本流.jpg)

   几乎所有浏览器都支持上述多栏布局属性，IE9 及版本更早的 IE 除外。以下是几条使用建议：

   - 几乎所有浏览器都需要使用合适的开发商前缀。
   - 浏览器对多栏布局属性的实现存在不一致，而且还有一些 bug，其中多数集中于外边距折叠和边框渲染方面。

3. **垂直律动与基线网格**

   在排版时运用一些数学关系很有好处。比如，对于不同标题的大小，采用 “纯四度” 关系（比率约为 1.26）。同时，所有标题都应用了值为 1.5em（相当于一行正文高度）的 margin-top。此外，所有分栏的间距也是统一的。不少设计师非常信奉这种和谐的比例关系，把基本行高作为设计其他部分的基准。

   在印刷设计中，这种律动关系的应用非常普遍，结果就是正文文本都会排进基线网格。即使标题、引用或其他页面部件时不时会打破这种律动，大的格局也不会受影响。这样不仅有助于读者眼球移动时轻松对准文本，还可以在双面印刷时避免背面的文本透过纸面，因为两面都遵循相同的基线。

   在网页设计中，要保证基线准确可是麻烦多了，尤其是在视口会变、允许用户上传图片的情况下。不过在可能的情况下，还是有必要这样做的，比如使用多栏文本布局的时候。

### 4.3 Web 字体

目前为止，在示例中用到的都是用户电脑中安装的字体。Helvetica、Georgia 和 Times New Roman 等网页中常用的英文字体几乎每个电脑都有，因为 Windows 和 macOS X 操作系统多年来一直会预装它们。

多年来，设计师一直梦想着可以在网页中嵌入远程字体，就像在网页中插入图片一样。自 1997 年 IE4 面世以来，相应的技术就已经出现了，只不过到了 2009 年才被 Firefox、Safari 和 Opera 等浏览器普遍支持。

此后，Web 字体有了长足的发展。起初只是个人博客和网站的零星尝试，发展到今天，主流网站乃至政府机关的网站都开始采用定制的 Web 字体。

#### 4.3.1 许可

使用 Web 字体还有一个问题，那就是许可。最开始的时候，字体设计者在授权浏览器下载他们的字体方面非常谨慎，因为担心发生无法控制的侵权问题。这种担忧持续了几年才有所缓解。多数字体设计者都施加了安全限制。比如，只允许从指定的域名下载字体，或者要求定期改字体名，以防止盗链。

**Web 字体托管服务**
尝试 Web 字体最简单的方式，就是使用 Web 字体服务。有一些是收费的，比如 Adobe Typekit、Cloud.typography 以及 Fonts.com，它们会负责相关的一切。还有免费的 Google Fonts，是 Google 汇总并托管的一些免费字体。

这些在线服务会帮用户处理设计者的许可事宜、支持把字体转换为多种格式，确保下载字体包含正确的字符集以及一些优化。然后，通过它们的高速服务器把字体提供给使用者。

使用这些托管服务可以选择一次性许可，也可以选择长期租用。使用字体托管服务的好处是，复杂的事情不用考虑，只要关心如何在网站中使用这些字体就行了。

#### 4.3.2 @font-face 规则

嵌入 Web 字体的关键是 `@font-face` 规则。通过它可以指定浏览器下载 Web 字体的服务器地址，以及如何在样式表中引用该字体。

```css
@font-face {
  font-family: Vollkorn;
  font-weight: bold;
  src: url('fonts/vollkorn/Vollkorn-Bold.woff') format('woff');
}

h1 {
  font-family: Vollkorn, Georgia, serif;
  font-weight: bold;
}
```

前面的 `@font-face` 块声明了在 `font-family` 值为 Vollkorn 且为粗体时应用该规则。之后提供了一个 URL，供浏览器下载包含粗体字体的 Web 开放字体格式（WOFF，Web open font format）文件。

声明了新的字体 Vollkorn 后，就可以在随后的 CSS 中通过 `font-family` 属性正常使用它了。

1. **字体文件格式**
   虽然目前浏览器基本上都已经支持 Web 字体，但它们对字体文件格式的支持却不一致。字体格式的问题很复杂，涉及微软、苹果、Adobe 等公司的发展史。好在所有浏览器开发商都支持标准的 WOFF 格式，有的甚至支持较新的 WOFF2。如果项目需要支持 IE8 及更早版本的 IE、旧版本的 Safari 或早期的安卓设备，那么可能要多写几行代码，补足各种格式的字体文件，比如 SVG、EOT 和 TTF。

   > 如果获得了某款 Web 字体的使用许可，可以通过 Font Squirrel 生成其他格式。

   为了解决旧版本浏览器对字体格式支持的不一致问题，可以在 `@font-face` 规则中声明多个 src 值（与 font-family 很像），包括 `format()` 提示。然后，由浏览器来决定到底使用哪种格式。

   做到这一步，基本上就可以实现 Web 字体的跨浏览器支持了。比如以下的 `@font-face` 规则：

   ```css
   @font-face {
     font-family: Vollkorn;
     src: url('fonts/Vollkorn-Regular.eot#?ie') format('embedded-opentype'), url('fonts/Vollkorn-Regular.woff2') format('woff2'),
       url('fonts/Vollkorn-Regular.woff') format('woff'), url('fonts/Vollkorn-Regular.ttf') format('truetype'),
       url('fonts/Vollkorn-Regular.svg') format('svg');
   }
   ```

   以上例子涵盖了支持 EOT、WOFF（包括 WOFF2）、TTF 和 SVG 的所有浏览器，几乎是现在市面上能见到的所有浏览器了。而且，通过在 src 的值中使用查询字符串，甚至可以满足 IE6~8 的古怪行为。

2. **字体描述符**

   `@font-face` 规则可以接受几个声明，多数是可选的。最常见的列举如下：

   - font-family：必需，字体族的名称。
   - src：必需，URL 或 URL 列表，用于下载字体。
   - font-weight：可选的字体粗细，默认值为 normal。
   - font-style：可选的字体样式，默认值为 normal。

   > **注意**：这些声明与通常规则中的 font 属性不是一回事。这几个都不是属性，而是**字体描述符**（font descriptor）。它们不会改变字体，它们的值只是为了告诉浏览器在什么情况下可以触发使用这个特定的字体文件。

   如果这里的 font-weight 值为 bold，那么就是告诉浏览器：“如果 font-family 中字体的 font-weight 设置成了 bold，那么可以使用这里定义的字体文件。”此处有一个陷阱：假如 Vollkorn 只在这里定义了这么一次，那么其他粗细也可以使用这里的字体文件，无论是否匹配。这是由于标准规定的浏览器加载和选择字体的原则：正确的 font-family 优先于正确的粗细值。

   很多字型包含不同粗细、样式和变体的字体，因此可以在 `@font-face` 块中使用相同的 Vollkorn 名称，但引用不同的字体文件。在下面的例子中，加载了两种不同的字型，声明了具体的粗细值和样式对应的字体文件：

   ```css
   @font-face {
     font-family: AlegreyaSans;
     src: url('fonts/alegreya/AlegreyaSans-Regular.woff2') format('woff2'), url('fonts/alegreya/AlegreyaSans-Regular.woff')
         format('woff');
     /* 字体粗细和样式都为默认值 normal */
   }

   @font-face {
     font-family: Vollkorn;
     src: url('fonts/vollkorn/Vollkorn-Medium.woff2') format('woff2'), url('fonts/vollkorn/Vollkorn-Medium.woff') format('woff');
     font-weight: 500;
   }

   @font-face {
     font-family: Vollkorn;
     font-weight: bold;
     src: url('fonts/vollkorn/Vollkorn-Bold.woff2') format('woff2'), url('fonts/vollkorn/Vollkorn-Bold.woff') format('woff');
   }
   ```

   在随后的样式表中，通过声明不同的粗细值，就可以分别使用不同的字体文件：

   ```css
   body {
     font-family: AlegreyaSans, Helvetica, arial, sans-serif;
   }

   p {
     font-family: Vollkorn, Georgia, Times, 'Times New Roman', serif;
     font-weight: bold; /* 使用 Vollkorn bold 字体 */
   }

   h3 {
     font-weight: 500; /* 使用 Vollkorn Medium 字体 */
   }
   ```

#### 4.3.3 Web 字体、浏览器与性能

Web 字体给网页设计带来了很大的飞跃，但同时也给网页中的实际应用带来了一些麻烦。

首先，浏览器需要下载额外的字体文件，这显然会延长用户等待的时间。使用 Web 字体首先必须注意不要加载过多的字体文件。如果自己托管自己的自定义字体，那么要确保设置适当的缓存首部，以避免不必要的网络开销。除此之外，浏览器在渲染这些字体时也有一些问题。

在下载 Web 字体的时候，浏览器有两种方式处理相应的文本内容：

- 在字体下载完成前暂缓显示文本，术语叫 FOIT（flash of invisible text）。Safari、Chrome 和 IE 默认采用这种方式，问题是用户必须等待字体下载完成才能看到内容。如果用户的网络速度很慢，这个问题会非常明显。

- 在字体下载完成前，浏览器先用一种后备字体显示内容。这样可以避免因网速慢而引起的问题，但也会带来字体切换时的闪动问题。这个闪动有时候也被称为 FOUT（flash of unstyled text）。FOUT 影响用户感知的速度，特别是在后备字体与 Web 字体的大小相差较多的情况下。如果在字体下载完成并应用的瞬间，网页内容跳跃过大，用户可能会失去焦点。

如果想更好地控制浏览器处理 Web 字体的方式，包括如何显示 Web 字体和后备字体，那么可以选择使用 JS 加载字体。

#### 4.3.4 使用 JS 加载字体

最近的 CSS Font Loading 规范定义了一个用于加载字体的实验性 JS API，可惜这个 API 尚未得到浏览器的广泛支持。因此，需要借助第三方库来实现一致的字体加载体验。

Typekit 维护着一个开源 JS 工具，叫 Web Font Loader。这个库体积很小，在浏览器支持的情况下，它会使用原生的字体加载 API；在浏览器不支持的情况下，它会模拟相同的功能。这个库内置支持一些 Web 字体服务，比如 Typekit、Google Fonts 和 Fonts.com，同时也支持自托管的字体。

可以下载这个[库](https://developers.google.com/speed/libraries/#/web-font-loader)，也可以从 Google 的服务器上加载它。Web Font Loader 提供了很多有用的功能，其中最有用的就是确保字体加载的跨浏览器一致性。希望使用它达到的效果是，即使在网速慢的情况下也不会妨碍用户阅读内容。换句话说，想在目标浏览器中实现一致的 FOUT 行为。

Web Font Loader 为以下事件提供了接入点：

- loading：开始加载字体。
- active：字体加载完成。
- inactive：字体加载失败。

在下面例子中，需要把 `@font-face` 块中的所有代码转移到一个独立的样式表 alegreya-vollkorn.css，同时把它放在一个子文件夹 css 中。然后，需要在页面头部添加一小段 JS 代码：

```html
<script type="text/javascript">
  WebFontConfig = {
    custom: {
      families: ['AlegreyaSans:n4,i4', 'Vollkorn:n6,n5,n7'],
      urls: ['css/alegreya-vollkorn.css']
    }
  };

  void (() => {
    let wf = document.createElement('script');
    wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = true;
    let s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>
```

这段代码既负责加载 Web Font loader 脚本，又负责配置后面要使用的字体变体。描述变体的代码在 font-family 名称后面，比如 n4 表示 “normal 样式，400 粗细”，以此类推。在这个样式表中的字体加载后，脚本会自动给 html 元素添加生成的类名。这样，就可以在 CSS 中提前编写加载新字体的规则：

```css
body {
  font-family: Helvetica, arial, sans-serif;
}

.wf-alegreya-n4-active body {
  font-family: Alegreya, Helvetica, arial, sans-serif;
}
```

这两条 CSS 规则的含义是，在 Alegreya 字体加载前，使用准备好的后备字体。而在 Alegreya 字体加载后，脚本会给 html 元素添加 wf-alegreya-n4-active 类，于是浏览器马上启用新下载的字体。这样不仅能保证跨浏览器加载字体的一致性，还有机会为后备字体和 Web 字体分别调整版式。

**匹配后备字体大小**
通过在字体加载期间应用类似的规则，可以控制因 Web 字体与后备字体大小不同带来的版式抖动。希望，在 Web 字体替代后备字体的瞬间，版式抖动尽可能细微且不易被用户察觉。

在下面例子中，Alegreya 字体的 x 高度明显小于 Helvetica 和 Arial（后两个字体的尺寸差不多）。通过微调 font-size 和 line-height，可以让它们的高度尽量接近。同理，还可以通过 word-spacing 来微调字符宽度。这样做的结果是，使用后备字体时的版式与切换为使用 Web 字体时会相差无几。

```css
.wf-alegreyasans-n4-loading p {
  font-size: 0.905em;
  word-spacing: -0.11em;
  line-height: 1.72;
}
```

使用 Web Font loader 要注意的另一件事是在 web 字体加载后设置 `font-size-adjust` 属性。这个属性用于指定 x 高度与 font-size 的比率。在某个字形缺少合适字体的情况下，后备字体会被调整为该比率。这个比率通常是高度的一半（值为 0.5），但也可能不是，有可能导致后备字体与 Web 字体的差异非常明显。在这里用不着测量并设置一个数值，可以直接设置一个关键字 auto，让浏览器替做这件事：

```css
.wf-alegreyasans-n4-active body {
  font-size-adjust: auto;
}
```

### 4.4 高级排版特性

微软和 Adobe 在 20 世纪 90 年代开发的 OpenType 字体格式，支持在字体文件中包含字体的额外设定和特性。如果使用的字体文件（.ttf、.otf 或 .woff/.woff2 都有可能）包含 OpenType 特性，那么在多数现代浏览器中都可以控制更多的 CSS 特性。这些特性包括字距调整（kerning）、连字（ligature）、替代数字（alternative numeral0，以及饰线（swash）等装饰性笔画。

CSS 字体规范中也有许多与 OpenType 对应的属性，比如 font-kerning、font-variant-numeric 和 font-variant-ligatures。浏览器对这些属性的支持并不一致，但可以通过另一个更低级的属性 `font-fearture-settings` 来控制相应的特性。不过最好是两个属性都使用，因为也有浏览器支持上述的对应属性而不支持这个低级属性。

`font-fearture-settings` 接受一些用于切换特性的值，就是 4 个字母的 OpenType 代码，其中也可以带有数值。比如，可以启用下图所示的连字特性。

![font-fearture-settings连字特性](./image/font-fearture-settings连字特性.jpg)

字体设计者可以根据使用目的，为连字特性指定分类。为启用 Vollkorn 中内置的两种连字特性，标准连字（standard ligatures）和任意连字（discretionary ligatures），可以使用以下规则：

```css
p {
  font-variant-ligatures: common-ligatures discretionary-ligatures;
  font-feature-settings: 'liga', 'dlig';
}
```

对支持 OpenType 的浏览器，通过对应的 `font-variant-ligatures` 属性始终可以默认启用标准连字特性，因此前面第一条声明里就没有把标准连字特性写出来。有些浏览器支持 `font-feature-settings` 属性，但语法不一样。另外一些浏览器可能要求在这个属性前面加上开发商前缀。总之，启用常用（common）和任意（discretionary）连字特性的完整规则如下：

```css
p {
  font-variant-ligatures: discretionary-ligatures;
  -webkit-font-feature-settings: 'liga', 'dlig';
  -moz-font-feature-settings: 'liga', 'dlig';
  -moz-font-feature-settings: 'liga=1, dlig=1';
  font-feature-settings: 'liga', 'dlig';
}
```

下面稍微解释一下：

- 影响 OpenType 特性的标准方式是使用加引号的 4 个字符的代码，后接一个关键字 on 或 off（可选），也可以后接一个数字（可选）。代码表示特定的状态，如果不写，则使用默认值 on。

- 以数字 0 表示状态相当于关闭特性。如果特性只有 “开” 和 “关” 两个状态，那么 1 就表示 “开”。有的特性会包含多个 “状态”，可以通过相应的数字来选择，具体数字的含义取决于字体以及想启用的特性。

- 如果想一次性列出多个特性，值之间要用逗号隔开。

- 多数浏览器都以加前缀的属性实现这些特性，因此别忘了加上开发商前缀。

- 针对 Mozilla 浏览器的旧语法稍有不同：多个特性作为一个字符串写在一对引号中，特性之间以逗号隔开；每个特性的状态则以写在等号后面的数字表示。

完整的 OpenType 特性代码，可以在微软的[这个网页](https://docs.microsoft.com/zh-cn/typography/opentype/spec/featurelist)中找到。

#### 4.4.1 数字

有些字体中包含多种数字形式。Georgia 或 Vollkorn 等字体会默认使用老式的数字，也就是数字跟字母一样，有上伸部分（ascender）和下伸部分（descender）。Vollkorn 也包含线性数字，即所有数字都位于基线以上、具有与大写字母一样的高度。通过如下代码分别展示了老式数字和线性数字：

```css
.lining-nums {
  font-variant-numeric: lining-nums;
  font-feature-settings: 'lnum';
}
.old-style {
  font-variant-numeric: oldstyle-nums;
  font-feature-settings: 'onum';
}
```

![线性数字与老式数字](./image/线性数字与老式数字.jpg)

多数字体都有不同宽度的数字（比例数字），跟常规字母一样。如果想在表格或列表中垂直对齐数字，那么可能就需要表列数字。通过如下代码组合使用了下图中的表列数字和线性数字：

```css
table {
  font-variant-numeric: tabular-nums lining-nums;
  font-feature-settings: 'tnum', 'lnum';
}
```

![表列线性数字](./image/表列线性数字.jpg)

#### 4.4.2 字距选项及文本渲染

高品质字体中通常包含用于调整某些字形间距的数据。这种微调间距的过程叫作**字距调整**（kerning）。换句话说，有些字母之间需要加大间隔才不会显得拥挤，而有些字母之间需要缩小间隔才不会显得疏远。

浏览器在渲染文本时通常会基于已知的尺寸自动处理字距，不过也可以手动设置现代浏览器读取字距调整数据。为此，可以设置 `font-kerning` 属性，或者启用 OpenType 的 kern 特性

```css
.kern {
  font-kerning: normal;
  font-feature-settings: 'kern';
}
```

关键字 normal 告诉浏览器从字体中读取字距调整数据（如果有的话）。而 auto 关键字则允许浏览器自作主张，只在它认为合适的时候开启字距调整。比如，在文本很小的情况下，浏览器可能就不会多此一举。最后，如果要明确告诉浏览器不进行字距调整，就使用 none。

> **注意**：在有些浏览器中，启用其他 OpenType 特性（如连字）可能自动触发字距调整。因此，如果希望连字但不调整字距，就需要明确告诉浏览器不进行字距调整。反之，启用 kern 特性也可能触发常见或标准连字特性。

**不要使用 text-rendering 属性**
设置 `text-rendering: optimizeLegibility` 是启用字距调整并同时启用连字的另一种方式。这不是 CSS 标准的方式，而是 SVG 规范中的一个属性，用于告诉浏览器选一种方法来渲染 SVG 中的字母。这个属性的值还有 optimizeSpeed（性能优先）、optimizeGeometricPrecision（更精确）或 optimizeLegibility（可读性）。

这个属性出现时间不短了，也得到了浏览器较好的支持，因此很多网站会采用。在 WebKit 浏览器支持 font-feature-settings 属性以前，这个属性是在旧版浏览器中激活相应特性的唯一方法。然而，这个属性存在一些严重的渲染问题，建议最好不使用它。

### 4.5 文本特效

#### 4.5.1 合理使用文本阴影

CSS 的 `text-shadow` 属性可以用来给文本绘制阴影。给大篇幅的正文文本加阴影不是什么好主意，因为会降低可读性。对于标题或短文本，阴影倒是大有用武之地，非常适合模拟凸版印刷或者喷涂效果。

`text-shadow` 属性的语法非常直观，需要指定相对于源文本 x 轴和 y 轴的偏移量（可正可负）、模糊距离（0 意味着完全不模糊）和颜色值，由空格分隔：

```css
h1 {
  text-shadow: -0.2em 0.4em 2em #ccc;
}
```

除此之外，还可通过用逗号分隔来给文本添加多组阴影。多组阴影会按先后次序堆叠，先定义的在上，后定义的在下。

为同一段文本添加多组阴影可以模拟出压印或浮雕的效果，方法就是在文本上方和下方加上偏暗或偏亮的阴影。偏亮或偏暗阴影的偏移取决于文本相对于背景的明度。暗文本上方加亮阴影且下方加暗阴影就是通常的压印效果，反之亦然。以下代码示例展示了两种不同的效果：

```css
.impressed {
  background-color: #6990e1;
  color: #31446b;
  text-shadow: 0 -1px 1px #b3d6f9, 0 1px 0 #243350;
}
.embossed {
  background-color: #3c5486;
  color: #92b1ef;
  text-shadow: 0 -1px 0 #243350, 0 1px 0 #def2fe;
}
```

进一步发挥想象力，还可以利用多组阴影创造出 3D 效果，比如仿手写广告牌字体。沿对角线每隔 1 像素叠加一个实心阴影就可以创造出这个效果：

```css
h1 {
  font-family: Nunito, 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif;
  color: #d0bb78;
  text-transform: uppercase;
  font-weight: 700;
  /* 以 1px 为单位累加 */
  text-shadow: -1px 1px 0 #743132, -2px 2px 0 #743132, -3px 3px 0 #743132, /* ... */ -22px 22px 0 #743132,
    -23px 23px 0 #743132;
}
```

为了让文字的仿手写体效果更突出。首先，用一批白色阴影给文字加上轮廓。这是因为，广告画工为了在字母油漆未干时就可以继续画阴影，通常会在字母和阴影间留一些空隙。为了把文字边缘包住，得在各个方向上偏移，加上白色阴影。

其次，再运用一个技巧，让阴影颜色沿偏移方向渐变，从而更像 3D 效果。为此，需要亮阴影和暗阴影交错地偏移。这样，利用这些阴影的堆叠，就让一种颜色水平方向比较突出，另种颜色垂直方向比较突出。以下是实现技巧的代码：

```css
h1 {
  /* 省略了一些属性 */
  /* 首先，各个方向上的白色阴影构成轮廓 */
  text-shadow: -2px 2px 0 #fff, 0 -2px 0 #fff, 0 3px 0 #fff, 3px 0 0 #fff, -3px 0 0 #fff, 2px 2px 0 #fff,
    2px -2px 0 #fff, -2px -2px 0 #fff, /* 其次，交错叠加的阴影让颜色沿两个方向凸显 */ -3px 3px 0 #743b34, -4px 3px 0
      #a8564d, -4px 5px 0 #743b34, -5px 4px 0 #a8564d, -5px 6px 0 #743b34, /* 继续叠加 */ -22px 21px 0 #a8564d,
    -22px 23px 0 #743b34, -23px 22px 0 #a8564d, -23px 24px 0 #743b34;
}
```

几乎所有浏览器都支持 text-shadow 属性，只有 IE9 及更早的 IE 不行。对于支持它的浏览器而言，由于绘制阴影开销比较大，请不要滥用。

#### 4.5.2 使用 JS 提升排版品质

也有 CSS 不能完全胜任的情况，比如可以通过 `:first-letter` 伪元素选中一段文本的第一个字母，但没有选择符能单独选择其他字母。假如想让每个字母拥有不同的颜色，那唯一的办法就是把每个字母都单独包装在一个元素中，然后以元素为目标来选择。这个办法也不是十分可靠，特别是在无法手动控制标记的情况下。

好在可以通过 JS 来创建其他字母的接入点。jQuery 插件 lettering.js 可以帮上忙。

除了这个插件，还有海量的其他 JS 解决方案，可以帮助处理文本。下面推荐几个：

- fitText.js：由 Paravel 公司 lettering.js 开发团队开发的另一款 jQuery 插件，可以让文本随页面大小缩放。
- BitText.js：Filament Group 的 Zach Leatherman 写的脚本，可以让一行文本放大到尽可能与包含它的容器一般大。
- Widowtamer：Gridset.com 的 Nathan Ford 写的脚本，通过在一段的末尾每隔一定距离就在单词间插入非换行空白符，来防止出现意外的孤行。

## 五. 漂亮的盒子

HTML 文档中的所有元素都由矩形盒子构成的。

### 5.1 背景颜色

**颜色值与不透明值**
可以使用了十六进制表示法指定颜色。所谓十六进制表示法，就是一个 `#` 后面加上 6 位十六进制数字构成的字符串。这个字符串由 3 组数字（每组各 2 位）构成，每个数字的取值范围是 0-F。十六进制的意思就是每个数字都可能有 16 种不同的值，因此除了 0~9 这 10 个数，还要用 A~F 补足第 11-16 位数。

3 组数字分别表示颜色中的红、绿、蓝（RGB）通道的值。每种颜色通道的值有 256 种可能，也就是 2 位十六进制数所能表示的可能性（16×16=256）。如果 3 组数字中每组的 2 位数字相同，可以简写成 3 位数字，比如 `#aabbcc` 可以简写成 `#abc`。

> 颜色值也可以用预定义的关键字表示，比如 red、black、teal、goldenrod 或 darkseagreen。有些关键字的名字非常古怪，因为它们源自一个古老的图形处理系统，叫 X11。这个系统的开发者从一盒蜡笔的颜色中选取了这些关键字。实际上，除了有助于快速排错，好像没什么理由使用这些关键字。

RGB 值可以用另一种方式表示，即 rgb() 函数式表示法。RGB 的每个值可以是一个十进制数值，取值范围为 0-255；也可以是一个百分比值，取值范围为 0%~100%。用 rgb() 表示法表示 `rgb(186, 218, 85)`。

十六进制及 rgb() 函数表示法从 CSS1 诞生起就有了。CSS 规范之后又提供了新的表示颜色的方法：hsl()、rgba( )和 hsla()。

- **hsl() 函数式表示法**
  十六进制和 RGB 表示法反映的都是计算机如何在显示器上显示颜色，即红、绿、蓝三原色的混合。而 hsl() 函数表示法则反映了另一种描述颜色的方式：**色相-饱和度-亮度**（hue-saturation-lightness），即 HSL 模型。色相的值取自下图所示的色轮，在这个色轮上，颜色的融入关系取决于度数：红色在顶部（0 度），绿色在顺时针方向 1/3 圆的位置（120 度），而蓝色在 2/3 圆的位置（240 度）。

  ![hsl色轮](./image/hsl色轮.jpg)

  使用 hsl() 语法需要传入三个参数，第一个是角度，第二和第三个是百分比值。这两个百分比值分别代表 “颜料” 的量（饱和度）和亮度。以下是 hsl() 表示法的示例：

  ```css
  .box {
    background-color: hsl(74, 64%, 59%);
  }
  ```

  > **注意**：使用哪种表示法来表示颜色没有本质区别，它们只是表示同一事物的不同方法而已。

- **rgba()**
  rgba() 是 RGB 的加强版。其中，末尾的 a 表示 alpha，是用于控制透明度的阿尔法通道。如果想设置同样颜色的背景，但透明度为 50%，可以这样做：

  ```css
  .box {
    background-color: rgba(186, 218, 85, 0.5);
  }
  ```

  第四个参数值表示透明度，取值范围为 0~1.0，1.0 表示完全不透明，0 表示完全透明。

- **hsla() 表示法**
  hsla() 表示法。它与 hsla() 的关系跟 rgba() 与 rgb() 之间的关系一样，都可以接受一个表示透明度的参数，用以设置颜色的透明程度：

  ```css
  .box {
    background-color: hsla(74, 64%, 59%, 0.5);
  }
  ```

知道了如何控制颜色的透明度之后，还应该知道 CSS 也提供另一种方式来控制透明度，那就是 `opacity` 属性：

```css
.box {
  background-color: #bada55;
  opacity: 0.5;
}
```

这样会让 .box 元素拥有和前面的例子相同的颜色和透明度。那么两者有什么不同呢？在前面的例子中，只让背景颜色变得透明；而这里让整个元素都变透明了，包括**元素中包含的内容**。使用 `opacity` 把一个元素设置为透明后，将无法再让其子元素变得不那么透明。

实践中，这意味着带透明度的颜色值非常适合半透明的背景和或文本，而较低的不透明度则会让整个元素有淡出效果。

### 5.2 背景图片

添加背景颜色可以让页面色彩更加丰富。但有时候，也想使用图片作为元素的背景。CSS 为实现这个提供了充足的工具。

#### 5.2.1 背景图片与内容图片

如果图片从网页中去掉之后，网页本身仍然有意义，那么该图片就可以当作背景图片。如果网站的观感完全变了，但图片本身仍然有意义，那么该图片就可以当作内容图片。

背景图片有一个相关属性 `background-repeat` 可以让图片平铺到整个元素盒子。`background-repeat` 属性的默认值为 repeat，意思是背景图片要沿 x 轴和 y 轴重复。这个特性对花纹图案的背景图片非常有用，但对照片可能就不合适了。可以明确声明 repeat-x 或 repeat-y 来限定图片只沿某个轴的方向重复，还可以通过 no-repeat 完全禁止重复。

Level3 Backgrounds and Borders 规范重新定义了这个属性，扩展了语法，并增加了关键字。首先，支持以空格分隔的针对两个方向的关键字声明语法。换句话说，以下声明等价于使用 repeat-x：

```css
.profile-box {
  background-repeat: repeat no-repeat;
}
```

其次，增加了新关键字。在支持的浏览器中，可以单独或一起设置 `space` 和 `round` 关键字：

- `space`的意思是，如果（未经裁剪和缩放的）背景图片可以在元素内部完全重复两次以上，那么它就会重复相应的次数，重复的图片之间填充空白，从而让第一张和最后一张图片都紧挨着元素的边缘。
- `round` 则意味着图片会被缩放，从而恰好能在元素中重复整数次。

说实话，这些新的重复特性没太大用处。如果想用符号或图案作为背景，从而让设计保持某种对称性，它们可能有用，但同时也会带来如何设置图片宽高比的难题。当然，浏览器的支持也参差不齐。

#### 5.2.3 加载图片（以及其他文件）

使用 url() 函数式表示法时，可以使用相对路径，如 url(img/cat.jpg)。浏览器此时会在保存当前样式表的目录的 img 子目标中寻找图片。如果路径以一个斜杠开头，如 /img/cat.jpg，则浏览器会在相对于 CSS 文件所在域的顶级目录的 img 子目录中寻找图片。

这里也可以使用绝对路径，那就要把协议、域名、路径和文件名都写全，比如：`http://example.com/img/my-background.jpg`。

除了相对路径和绝对路径，加载图片（或其他资源）也可以不指向文件，而是在样式表中直接嵌入数据。这时候要用到**数据 URI**（data URI），数据 URI 的值是由文件中二进制编码的数据转换而来的长字符串。有很多工具可以帮助实现这种转换。

拿到转换得到的结果后，可以将其直接粘贴到 url() 函数中，同时也将这些数据保存在样式表里。下面是一个使用数据 URI 的例子：

```css
.egg {
  background-image: url(data:image/png;base64,ivBORWOKGgoAAAANSUhEUgAAAC BAAAAOAQAAAACkhYXAAAAAJElEQVR4AWP/R.,and so on, random (? data for a long time.*/4DWIMtzFJs99p9xkoXfsddZ/hlhiY/AYib1vsSbdn+P9vf/1/hV8//oBIIICRZ///r3sPMqHSPCN9MLvn1s6SfIbbUWF 174HkdTB5rWw/w51nN8VZIbrgJDuI/PMTRP7+ByK//68HkeUg8v3//W]kWwJ5GOR+w5Wyv8P1gsxB2EmwhYAgeerNiRVNy EAAAAASUVORKSCYII-);
}
```

开头的 **data:image/png;base64** 告诉浏览器后面是什么文件的数据，接下来的内容则全部是转换为字符的实际像素数据。

使用嵌入的数据 URI 有好处也有坏处。使用它主要是**为了减少 HTTP 请求**，但与此同时也会增加样式表体积，因此请慎重使用，只使用在一些小图标上。

#### 5.2.4 图片格式

网页中可以使用的图片格式很多，既可以作为内容图片，也可以作为背景图片。以下是简单的列举：

- JPEG：一种位图格式，有损压缩，压缩率越高，损失细节越多，适合照片。不支持透明度设置。
- PNG：一种位图格式，无损压缩，不适合照片（因为文件会很大），适合图标、插图等小尺寸文件。支持阿尔法透明度设置。
- GIF：早期的位图格式，与 PNG 类似，主要用于动图。严格来讲，除动图外，GIF 基本已被 PNG 取代。实际上 PNG 也支持动图，只是浏览器支持落后。GIF 支持透明度设置，但不支持阿尔法分极，因此边缘会有 “锯齿”。
- SVG：一种矢量图形格式，本身也是一种标记语言。SVG 可以直接嵌入到网页中，也可以作为资源引用；可以作为背景图，也可以作为内容图。
- WebP：Google 开发的一种新图片格式，结合了 JPEG 的高压缩率和 PNG 的阿尔法透明特性。目前，浏览器对 WebP 的支持还参差不齐，但应该很快会普及。

以上除了 SVG 都是位图格式的。位图意味着文件会包含每个像素的数据，拥有内在的维度（宽度和高度）。对于细节丰富的图片，比如照片或详细示意图，位图很合适。但很多情况下，真正合适的则是 SVG 图形，其文件中包含的是如何在屏幕上绘制图形的指令。由于包含的是指令，SVG 图形可以任意缩放，也可以在任意像素密度的屏幕上清晰呈现。换句话说，**SVG 图形永远不会丢失细节，也不会出现 “锯齿”**。

### 5.3 背景图片语法

#### 5.3.1 背景位置

背景图片的位置由 `background-position` 属性控制。

```css
/* 把背景图片定位到元素中心 */
.profile-box {
  width: 100%;
  height: 100%;
  background-color: #8da9cf;
  background-image: url(img/big-cat.jpg);
  background-repeat: no-repeat;
  background-position: 50% 50%;
}
```

`background-position` 属性既可以使用关键字，也可以使用像素、em 或百分比。最简单的情况下，可以只给两个值：一个表示相对于左侧的偏移量，一个表示相对于顶部的偏移量。

> **注意**：有些浏览器支持 `background-position-x` 和 `background-position-y` 属性，这两个属性分别用于独立地在每个轴向上定位图片。这两个非标准属性是 IE 最早提出来的，目前正在标准化的过程中。

如果使用像素或 em 单位来设置背景图片的位置，那么图片的左上角会相对于元素的左上角定位，也就是会偏移指定的数值。比如，要是在水平和垂直方向都指定了 20 像素，那么图片左上角就会偏移到距元素左边和上边均为 20 像素的点。如果设置背景图片的位置时使用了百分比，那么情况就不一样了。百分比值不像绝对数值那样会定位背景图片的左上角，而是定位图片中对应的点。如果水平和垂直方向都设置为 20%，那么定位的实际上是距图片左边和上边各 20% 的点，而这个点会与距离父元素左边和上边各 20% 的点重合。

![图片定位](./image/图片定位.jpg)

使用关键字来对齐背景图片，要在 x 轴上用 left、center 或 right，在 y 轴上用 top、center 或 bottom。顺序一般都是先 x 轴后 y 轴。这样既能保持一致，又能一目了然，还能避免错误。在只使用两个关键字的情况下，规范并没有限定顺序（如可以用 top left）但在一个关键字加上一个长度值的情况下，规则本身将无效，比如以下声明：

```css
.box {
  background-position: 50% left; /* 不要这样写 */
}
```

背景图片定位的这一限制一直是很多问题的来源。以下图为例，这里的文本内容长度不定，后面跟着一个图标，图标四周有空白。此时没办法使用像素或 em 来定位图标，因为不知道它距左边缘有多远。

![文本加靠右图标](./image/文本加靠右图标.jpg)

以前的解决方案有两种：

- 给这个图标一个包装元素，然后定位该元素；
- 使用背景图片，把 x 轴定位设为 100%，而图片右侧以透明像素形式加入空白区。

其中使用 CSS 的后一个方案并不完美，因为不能通过 CSS 控制空白区。好在 Level3 Backgrounds and Borders 规范给出了新方案。新语法允许给 `background-position` 添加外边空声明，先写边界关键字，再写长度值。代码如下：

```html
<p>
  <a href="/activate" class="link-with-icon">Activate flux capacitor</a>
</p>

<style>
  .link-with-icon {
    padding-right: 2em;
    background-image: url(img/icon.png);
    background-repeat: no-repeat;
    background-position: right 1em top 50%;
  }
</style>
```

这个例子意味着把图片定位在距离右边缘 1em、距离上边缘 50% 的位置。问题解决了！在 IE8 或 Safari7 及更早的版本不支持这个新语法。可以根据自己的情况，在可用的时候使用这个语法。

**calc() 函数**
使用另一个 CSS 特性，可以实现与前面示例相同的效果，但支持度可能更高一些。这个特性就是 `calc()` 函数式表示法。使用 calc() 可以让浏览器代替计算任何数值（角度、像素、百分比，等等），甚至还支持动态计算的混合单位。换句话说，可以让浏览器计算 “100% + x 像素”，而这非常适合某元素以百分比缩放或定位时与使用 em 或像素单位冲突的情况。

对于前面讨论的 “背景图片右侧定位” 问题，可以使用 calc() 表示法像下面这样表达同样的 x 轴定位：

```css
.link-with-icon {
  /* 为简洁起见，省略了其他属性 */
  background-position: calc(100%- 1em) 50%;
}
```

> **注意**：IE9 也支持 calc() 表示法，可惜与 background-position 一起使用时存在严重 bug，会导致浏览器崩渍。不过 calc() 的应用范围其实非常广泛，可用于计算元素大小、字体大小，等等。

calc() 函数表示法可以与 4 个操作符一起使用：加（+）、减（-）、乘（`*`）、除（/）。可以给 calc 传人多个值。

> **注意**：使用 calc() 时，需要在加号和减号两侧加空格。这是为了让浏览器把操作符与数值中的符号（如 -10px 中的负号）区分开来。

#### 5.3.2 背景裁剪与原点

默认情况下，背景图片是绘制在元素边框以内的。如果（使用下面介绍的 `background-origin`）把背景图片定位到边框下方，而边框又被设置为半透明，那么图片边缘就会出现半透明的边框。

使用 `background-clip` 属性可以改变这个行为。这个属性的默认值为 border-box，将其改为 padding-box 就可以把图片裁剪到内边距盒子以内。而 content-box 值则会把图片位于内边距及其之外的部分裁剪掉。

即使 background-clip 属性的值改变了，**背景定位默认的原点（开始定位背景图片的参照点）仍然在代码中声明的内边距盒子（padding-box）的左上角**。换句话说，定位值从元素边框内开始计算。

也可以使用 `background-origin` 属性控制原点的位置。这个属性与 `background-clip` 一样，也接受盒模型相关的几个值：border-box、padding-box、content-box。

`background-clip` 和 `background-origin` 都是 Level3 Backgrounds and Borders 规范定义的。

#### 5.3.3 背景附着

背景会附着在指定元素的后面，如果滚动页面，那么背景也会随着元素移动而移动。可以通过 `background-attachment` 属性改变这种行为。如果想让背景图在页面滚动时 “粘” 在页面上，可以使用以下代码：

```css
.protile {
  background-attachment: fixed;
}
```

除了 fixed 和默认值 scroll，还可以把 `background-attachment` 设为 local。这个属性值的效果不太容易通过纸面来展示。它与 scroll 的区别在于，scroll 会让背景图片相对于元素本身固定，而 local 则会让背景图片相对于元素中的内容固定。换句话说，如果元素设置了固定的大小，且 overflow 属性设置为 auto 或 scroll，因而其中的内容在超出元素范围时会出现滚动条，那么这种情况下，在元素内部滚动显示更多内容时，背景图片会随着内容移动。

桌面浏览器对 local 值的支持相对比较好，但相应的移动端浏览器则表现欠佳。当然，移动浏览器忽略这个属性（以及 fixed 值）是可以理解的。毕竟在触摸滚动的小屏幕上，元素内容滚动会造成可用性障碍。事实上，规范本身也允许在确实不合适的情况下忽略 `background-attachment` 属性。

#### 5.3.4 背景大小

如果使用了一张大图覆盖了整个元素。那么在小屏幕上，那么图片会被剪切掉。反之，如果屏幕特别大，那么元素边缘可能出现空白。要避免上述情况，不管页面如何缩放，都让内容保持自己的宽高比，就要使用 `background-size` 属性。

给 `background-size` 明确指定一个值，可以重新设置图片大小，也可以让它随元素大小缩放而缩放。要让图片随元素缩放而缩放，则必须使用百分比值。

> **注意**：百分比值并不是相对于图片固有大小，而是相对于容器大小。因此，简单地把图片宽度和高度都设置成百分比值，可能会因容器高度变化而导致图片变形。更好的做法是**只给一个维度设置百分比值**，另一个维度设置关键字值 auto。

百分比值赋予了控制的灵活度，但也不是任何情况下都适用。有时候，会希望背景图片的任何一边都不要被切掉。还有一种情况，希望背景图片始终都能完全覆盖元素。CSS 为此也提供了一些关键字值：

- **contain**
  可以把背景大小设置为 `contain`。这个值可以让浏览器尽可能保持图片最大化，同时不改变图片的宽高比。但浏览器会自动决定哪一边使用 auto 值，哪一边使用 100%。在高而窄的元素中，方形背景最多 100% 宽，因此垂直方向会出现空白；而在较宽的元素中，背景最多 100% 高，因此水平方向会出现空白。

- **cover**
  第二个关键字是 `cover`，意思是图片会缩放以保证覆盖元素的每一个像素，同时不会变形。在一个高而窄的元素中，元素高度会被填满，但图片左右两边会被切掉；而在一个较宽的元素中，元素宽度会被填满，但图片上下两边会被切掉。

#### 5.3.5 背景属性简写

CSS 背景有一个 `background` 简写属性，可以同时设置一堆背景相关的属性。通常，通过这个简写属性指定的具体属性值的顺序可以随意，浏览器会自己弄明白写的关键字和语法的含义。不过也有两点需要注意：

1. 因为两个长度值既可以用于 `background-position`，也可以用于 `background-size`，所以两个都需要声明，而且要先声明 background-position，后声明 background-size，值之间以斜杠（/）分隔。

2. 因为 `*-box` 关键字（border-box padding-box 或 content-box）既可以用于 background-origin，也可以用于 background-clip，所以有如下规则

   - 如果只存在一个 `*-box` 关键字，则 background-origin 和 background-clip 都取这个关键字值。
   - 如果存在两个 `*-box` 关键字，则第一个设置 background-origin，第二设置 background-clip。

下面是一个综合了各种背景属性的例子：

```css
.profile-box {
  background: url(img/cat.jpg) 50% 50% / cover no-repeat padding-box content-box #bada55;
}
```

> **注意**：使用 background 这个简写属性，它会把所有没有明确指出的属性都重置为其默认值。因此，如果要使用它，应该把它放在声明的第一位，然后再根据需要来覆盖特定的属性值。虽说使用简写属性可以少敲几下键盘，但一般而言，明确的代码更不容易出错，而且也更容易让人理解。

### 5.4 多重背景

一般来说只使用一张图片作为背景，但 Level3 Backgrounds and Borders 规范现在支持一个元素设置多个背景图片。因此，每个背景属性也就有了相应的多值语法，多个值由逗号分隔。下面就是一个例子，效果如下图所示：

```css
.multi-bg {
  background-image: url(img/spades.png), url(img/hearts.png), url(img/diamonds.png), url(img/clubs.png);
  background-position: left top, right top, left bottom, right bottom;
  background-repeat: no-repeat, no-repeat, no-repeat, no-repeat;
  background-color: pink;
}
```

![多重背景](./image/多重背景.jpg)

多重背景按声明的先后次序自上而下堆叠，最先声明的在最上面，最后声明的在最下面。背景颜色层在所有背景图片下面。

![多重背景上下堆叠](./image/多重背景上下堆叠.jpg)

也可以使用简写属性来声明多个背景图片：

```css
.multi-bg-shorthand {
  background: url(img/spades.png) left top no-repeat, url(img/hearts.png) right top no-repeat,
    url(img/diamonds.png) left bottom no-repeat, url(img/clubs.png) right bottom no-repeat, pink;
}
```

但这种语法只能在最后一个背景层声明一种颜色。如果随后的背景属性值少于背景图片的个数，那么相应的值会循环使用。这就意味着，如果所有背景图片的当前属性值都一样，那么只需要声明一个；如果是两个值交替，那么只需要声明两个。因此，前面例子中重复出现的 no-repeat 值，就可以写成下面这样了：

```css
.multi-bg-shorthand {
  background: url(img/spades.png) left top, url(img/hearts.png) right top, url(img/diamonds.png) left bottom, url(img/clubs.png)
      right bottom, pink;

  background-repeat: no-repeat; /* 用于 4 张图片 */
}
```

因为上述多值语法是在 Level3 规范中定义的所以一些旧版本浏览器不支持。多数情况下，通过添加一个单背景声明，可以实现还算不错的后备效果：

```css
.multi-fallback {
  background-image: url(simple.jpg);
  background-image: url(modern.png), url(snazzy.png), url(wow.png);
}
```

此时旧版本浏览器只会显示一个背景图片，忽略第二条声明，而新版本浏览器则会忽略第一条声明，因为第二条会覆盖它。

### 5.5 边框与圆角

现代浏览器对盒模型的边框都提供了一定的控制，包括插入图片和圆角，让边框不再是简单的矩形：

- 可以分别为盒子的各边设置边框，也可以一次性为四边设置边框。
- 可以使用 `border-width` 一次性设置所有边框的宽度，也可以使用 `border-top-width` 这样的方位属性设置某条边框的宽度。除非明确指定 `box-sizing` 属性，否则边框宽度会影响盒子的尺寸。
- 同理，可以使用 `border-color` 设置所有边框的颜色，也可以使用 `border-left-color`这样的方位属性设置某条边框的颜色。
- 边框的样式可以使用 `border-style`（或 `border-right-style` 这样的方位属性设置），取值中最常用的是 solid、dashed 或 dotted 等关键字。当然也有不太常用的，比如 double（在 border-width 指定的宽度表面绘制两条平行线）、groove 和 inset。这几个很少有人用。一是它们看起来让人觉得怪模怪样，二是这样一来就只能靠浏览器来决定边框的模样了。因为这几个关键字到底解释成什么样，规范里也没说。另外，可以通过 `border-style:none` 删除全部边框。
- 可以使用 border 简写属性来设置所有边框属性。具体来说，可以把所有边设置成相同的宽度、样式、颜色，比如 `border:2px solid #006;`。

#### 5.5.1 边框半径圆角

1. **边框半径简写**
   给 `border-radius` 属性一个长度值，就可以一次性设置盒子四个角的半径。

2. **更复杂的圆角语法**
   也可以使用简写语法分别设置每个圆角的半径，即从左上角开始，按顺时针方向依次列出各个值：

   ```css
   .box {
     border-radius: 0.5em 2em 0.5em 2em;
   }
   ```

   以上声明中每个值本身其实也是简写，它们各自表示相应圆角水平和垂直方向拥有相同的半径。如果想把每个角设置成非对称的，也可以用两组值分别指定两个方向的半径，先水平再垂直，两组值以斜杠分隔：

   ```css
   .box {
     border-radius: 2em 0.5em 1em 0.5em / 0.5em 2em 0.5em 1em;
   }
   ```

   如果对角的值相同，那就可以省略右下和左下角的值，因为在只有两个或三个值的情况下，其他值会自动填入：

   ```css
   .box {
     border-radius: 2em 3em; /* 右下角和左下角重用前面的值  */
   }
   ```

3. **设置一个角的半径**

   也可以使用 `border-top-left-radius`、`border-top-right-radius` 等属性设置某个角的半径。可以像前面一样，给这些针对个别角的属性指定一个值，从而得到一个对称的角。或者指定两个值，以斜杠分隔，分别控制水平和垂直两个方向的半径。

#### 5.5.2 创建正圆和胶囊形状

设置圆角半径，实际上还可以使用百分比值。在给 `border-radius` 指定百分比值时，x 轴和 y 轴分别相对于元素的宽度和高度来计算实际值。换句话说，可以很容易地把一个正方形的元素变成圆形，只要把圆角半径设置成至少 50% 就好。

实际上确实没理由给任何一个角设置超过 50% 的值。不过，应该知道：如果两个圆角的弧线相交，那么两个轴向就会分别缩小半径，直到圆弧不再相交。对于方形元素的对称圆角而言，任何大于 50% 的值都会得到圆形。对于圆角半径相同的一个矩形元素而言，结果可能是一个椭圆形，因为圆角在两个方向上是按照宽度或长度比例缩小的。

圆形是比较常见的界面元素，但椭圆形就不那么受欢迎了。有时候，更希望看到 “胶囊形”，即一个矩形的两端各带一个半圆形。这种形状在工程上称为 “长圆形”（obround）。百分比值和绝对值都无法直接实现这种形状，除非知道元素的大小，而这在网页设计中并不常见。

不过，可以利用 `border-radius` 计算上的一个特性来达到目的。圆角弧线为保证不相交会自动缩小半径。而在使用长度值(而非百分比值)时，半径并不相对于元素大小而缩小，最终会得到对称的效果。因此，在创建胶囊两头的半圆形时，可以故意指定一个比所需半径大的值，以得到半圆形：

```css
.obround {
  border-radius: 999em; /* 任意非常大的值 */
}
```

首先，矩形的方角变成圆角后，元素对布局的影响跟没变成圆角前一样，这是没有改变的。其次，改变的是变成圆角后元素的可点击（或“可触摸”）区域，会以变化之后的圆角为准。因此，在使用圆角矩形按钮时，需要保证可点击的面积不要太小。

#### 5.5.3 边框图片

Level3 Backgrounds and Borders 规范还允许开发者为元素指定一张图片作为边框。`border-image` 属性支持把一张图片切成 9 块，只管定义切图规则，浏览器会自动把每一块应用到指定的边框位置。而且通过运用所谓的 “九宫格缩放” 技术，边框图片不会在图片缩放时发生变形。

演示边框图片的典型示例，非相框莫属了。构成相框的图片是正方形的，边长为 120 像素。从上、右、下、左各方向内推 40 像素画一条虚线，就把它分成了 9 块。

![边框图片](./image/边框图片.png)

`border-image` 属性会自动把每一块中的图片作为背景应用到边框的相应位置：左上角的图片应用到元素左上角，上中部的图片应用到元素上方，右上角的图片应用到元素右上角，以此类推。默认情况下，中间那 1/9 会被忽略，也可以改变这个行为。

此外，也可以告诉浏览器让上、右、下、左方位的图片如何覆盖边框。比如，可以拉伸、重复或补白（即只重复能够完整显示的次数余下的空间以空白填充跟最新的 background-repeat 关键字很像）。默认情况下，每边中段的图片会拉伸。为了展示边框图片，必须设置适当的边框宽度，进而拉伸各个边框对应的图片。

```css
.motto {
  border: 40px solid #f9b256;
  border-image: url(picture-frame.png) 40;
  /* 与 border-image: url(picture-frame.png) 40 40 40 40 stretch; 效果相同 */
}
```

前面的代码会加载图片 picture-frame.png，在每边向内 40 像素的位置切开，拉伸上、右、下、左边中段的图片。

> **注意**：
>
> 1. 指定切片参考线位置的 “40 像素” 没有 px 单位，这是为了同时适应 SVG 和位图而使用的小技巧。
> 2. 必须把 border 简写（如果使用的话）放在 `border-image` 属性前面。这是因为规范规定简写语法会重置所有边框属性，不仅限于其自身指定的属性。

除了 border-image，还有针对每一边的边框图片属性。事实上，还有一堆属性可以用来控制边框图片。但开发者曾经非常期盼浏览器支持边框图片。究其原因，主要是可以借助它来创建圆角边框。既然已经有了 `border-radius`，那又何必舍近求远呢。

### 5.6 盒阴影

讲完了背景图片和边框，接下来再看一种给页面添加视觉效果的方式：阴影。CSS 属性 `box-shadow· 可以给元素添加阴影，而且这个属性浏览器基本都支持，

`box-shadow` 属性的语法与 `text-shadow` 类似，但有一些新东西。

比如，下面的代码给用户头像加了一个阴影：

```css
.profile-photo {
  box-shadow: 0.25em 0.25em 0.5em rgba(0, 0, 0.3);
}
```

这个例子中代码的语法跟 text-shadow 完全一样：头两个值表示 x 轴和 y 轴的偏移；第三个值表示模糊半径（阴影边界的模糊程度）；最后是颜色，使用 rgba()。而且阴影的形状跟盒子的圆角也是一致的。

#### 5.6.1 扩展半径：调整阴影大小

box-shadow 比 text-shadow 稍微灵活一点。比如，可以在模糊半径的值后面再加一个表示扩展半径，用于扩展阴影的大小。这个值默认为，即阴影与所属元素一样大。增大这个值阴影相应增大，负值导致阴影缩小。

```css
.larger-shadow {
  box-shadow: 1em 1em 0.5em 0.5em rgba(0, 0, 0, 0.3);
}
.smaller-shadow {
  box-shadow: 1em 1em. 5em -0.5em rgba(0, 0, 0, 0.3);
}
```

#### 5.6.2 内阴影

box-shadow 的另一个比 text-shadow 更为灵活之处是可以使用 `inset` 关键字。这个关键字
