---
title: 精通CSS-高级Web标准解决方案
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [精通 CSS-高级 Web 标准解决方案](#精通-css-高级-web-标准解决方案)
  - [一. 基础知识](#一-基础知识)
    - [1.1 组织代码](#11-组织代码)
      - [1.1.1 可维护性](#111-可维护性)

<!-- /code_chunk_output -->

# 精通 CSS-高级 Web 标准解决方案

## 一. 基础知识

### 1.1 组织代码

层叠样式表（CSS，cascading style sheets）的技术和概念，必须以结构良好且有效的 HTML 文档为前提。

#### 1.1.1 可维护性

可维护性可以说是所有优秀代码最重要的特点。相对来说，CSS 是随着代码量增加而最难保持可维护性的语言之一。现代编程语言都有内置的变量、函数和命名空间等特性，这些特性都有利于保持代码的结构和格式化。这些特性 CSS 都没有，所以要按照使用这种语言和组织代码的特殊方式来管理它。

#### 1.1.2 HTML 简史

Tim Berners-Lee 在 1990 年发明了 HTML，当时是为了规范科研文档的格式。HTML 是一种简单的标记语言，为文本赋予了基本的结构和意义，比如标题、列表、定义等。这些文档通常没有什么装饰性的元素，可以方便地通过计算机来检索，而人类可以使用文本终端、Web 浏览器，或者必要时使用屏幕阅读器来阅读它们。

然而，人类是视觉发达的生物。随着万维网被越来越多的人所接受，HTML 也逐渐增加了对展示效果的支持。除了用标题元素标记文档标题，还可以使用粗体标签和不同的字体来创建特殊的视觉效果。本来用于展示数据的表格（tab1e），却成了页面布局的手段；块引用（blockquote）也经常被用来缩进文本，而不是只用来标记引文。HTML 很快就偏离了为内容赋予结构和意义的初衷，变成了一堆字体和表格标签。Web 设计者给这种标记起了个名字，叫 “标签汤”。

正当 Web 变得一团糟之际，CSS 作为解决方案面世了。CSS 的初衷是把跟 HTML 混在一起的表现性标记提取出来，使其自成体系，达到结构与表现分离的目的。这就让有意义的标签或者说语义悄悄返回了 HTML 文档。font 之类的表现性标签可以不用了，而表格布局也可以被逐步取代。对大多数网站而言，CSS 都能提升其可访问性和加载速度。不仅如此，CSS 还给 Web 设计和开发人员带来了更多好处：

- 一种专用于控制视觉样式和布局的语言
- 在同一网站中更易于重用的样式
- 通过关注点分离得到了良好的代码结构

---

**关注点分离**
关注点分离（separation of concerns）是软件开发行业的一个常见概念。对 Web 开发而言，关注点分离不仅适用于标记和样式，同样也适用于编写样式的方式。事实上，**关注点分离也是确保代码可维护性的一种主要方法**。

Unix 开发社区有一句话很好地诠释了**关注点分离的思想，即 “分成小块，松散结合”**（small pieces，loosely joined）。其中，每一 “小块” 都是一个模块，专注于做好一件事。而且，因为这个模块跟其他组件是 “松散结合” 的，所以它可以方便地在系统的其他部分中重用。Unix 中的一 “小块” 可能是一个字数统计函数，可以应用于传入的任何文本片段。而在 Web 开发中，这一 “小块” 可能就是一个商品列表组件，如果能做到 “松散结合”，就可以在一个网站的多个页面或者在同一布局的不同区块中重用。

可以把代码中的这些 “小块” 想象成积木。每一块积木都很简单，但把很多块积木以不同方式组装起来，就可以创造出无比复杂的东西。

---

**HTML 和 CSS 的版本**
CSS 有很多版本，或者 “级别”。了解这些版本产生的背景，有助于了解应该或不应该使用哪些 CSS 特性。万维网联盟（W3C，World Wide Web Consortium）是制定 Web 技术标准的组织，该组织制定的每一个规范要经历几个阶段之后才能成为 W3C 推荐标准。CSS1 是在 1996 年底成为 W3C 推荐标准的，当时只包含字体、颜色和外边距等基本的属性。CSS2 在 1998 年成为推荐标准，增加了浮动和定位等高级特性，此外还有子选择符、相邻选择符和通用选择符等新选择符。

相比之下，CSS3 则采用了完全不同的模式。实际上不存在所谓的 CSS3 规范，因为 CSS3 指的是一系列级别独立的模块。如果规范模块是对之前 CSS 概念的改进，那就从 3 级开始命名。如果不是改进，而是一种全新的技术，那就从 1 级开始命名。而 CSS3，则是指所有足够新的 CSS 规范模块，比如 CSS Backgrounds and Borders Level3、Selectors level4 和 CSS Grid Layout Level 1。这种模块化的方式可以让不同的规范有自己的演进速度。有些 3 级规范，比如 CSS Color level3，已经成为推荐标准。而另外一些可能还处于候选推荐阶段，很多甚至还处于工作草案阶段。

虽然 CSS3 的制定工作在 CSS2 发布后就开始了，但这些新规范一开始的制定速度很缓慢。为此，W3C 在 2002 年发布了 CSS2 Revision 1。CSS 2.1 修正了 CSS2 中的一些错误，删掉了支持度不高或者并非所有浏览器都实现了的一些特性，总体来说就是把 CSS 规范做了一番清理，好为浏览器实现提供更精准的蓝图。CSS 2.1 在 2011 年 6 月成为推荐标准，此时距离 CSS3 启动已经有 10 多年了。由此可见，标准制定主体和浏览器开发商为了确保相应的特性得以原原本本地实现，需要花多么长的时间。不过，浏览器开发商经常会在标准还处于草案阶段时，就发布一些实验性的实现。这样，等到了候选推荐阶段，相应的实现就已经非常稳定了。换句话说，很多 CSS 特性早在相应模块成为推荐标准前就可以使用了。

HTML 的历史也很复杂。HTML4.01 在 1999 年成为推荐标准，与此同时 W3C 也把注意力转向了 XHTML1.0。本来接着要发布 XHTML1.1，但其严格程度在实践中暴露了无法落地的问题，最终被 Web 开发社区抛弃。于是，这个 Web 主要语言的发展停滞了。

2004 年，有几家公司共同组建了 Web 超文本应用技术工作组（WHATWG， Web Hypertext Application Technology Working Group），并致力于开发新的规范。2006 年，W3C 肯定了它们工作的必要性，并欣然加人该工作组。2009 年，W3C 完全放弃 XHTML，正式接纳 WHATWG 制定的新标准，这就是后来的 HTML5。起初，WHATWG 和 W3C 都基于标准调整自己的工作，但后来它们的关系又变得复杂起来。今天，它们分别在编辑两份标准。 WHATWG 那份就叫 HTML，而 W3C 那份则称为 HTML5。没错，这种分裂确实不好。但万幸的是，这两份标准的内容相当接近，因此只讲 HTML5 是没有问题的。

**应该使用哪个版本**
设计者和开发者经常问的一个问题就是应该使用 HTML 或 CSS 的哪个版本。这个问题不好回答。虽然规范反映了标准和 Web 技术开发的进度和焦点，但它其实跟设计者和开发者日常的工作关系不大。真正重要的是知道 HTML 和 CSS 的哪些部分已经在浏览器中实现了，以及这些实现是否稳健，有没有 bug。比如，浏览器提供的这些特性是不是实验性特性，使用时需谨慎?或者，这些特性到底靠不靠谱，是不是已经得到了多数浏览器的支持?

今天，使用 CSS 和 HTML 就要了解浏览器对其中特性的支持程度。要了解浏览器支持情况，推荐几个不错的地方。对于 CSS 属性，可以访问 [“Can I use” 网站](https://caniuse.com)。这个网站可以搜索属性或属性组，结果配有统计信息，显示支持它们的浏览器百分比，包括桌面浏览器和移动浏览器。此外，Mozilla 的开发者文档，即 [MDN](https://developer.mozilla.org/zh-CN/docs/Web)，也是个非常好的参考。

说到浏览器支持，关键要明白，并非所有浏览器都一样，实际上从来就没有完全一样的浏览器。某些 CSS3 特性只得到了少数浏览器的支持。比如，IE11 和 Safari6.1 之前的版本都没有正确支持 Flexbox（Flexible Box Layout）。不过，就算需要支持老版本的浏览器，也不意味着不能使用 Flexbox。核心布局上可以不用 Flexbox，但对于某些特定的组件，Flexbox 可能就非常合适。只要为不支持它的浏览器准备好可以接受的后备代码就行了。

#### 1.1.3 渐进增强

平衡向后兼容性与最新的 HTML 和 CSS 特性，涉及一种叫作**渐进增强**（progressive enhancement）的策略。所谓**渐进增强，大意就是 “首先为最小公分母准备可用的内容，然后再为支持新特性的浏览器添加更多交互优化”**。使用渐进增强策略，意味着代码要分层，每一层增强代码都只会在相应特性被支持或被认为适当的情况下应用。听起来有点复杂，而实际上 HTML 和 CSS 的实现已经部分内置了这一策略。

对 HTML 而言，这意味着浏览器在遇到未知元素或属性时并不会报错，而且也不会对页面产生什么影响。比如，可以在页面里使用 HTML5 定义的新 input 元素。假设表单中有一个电子邮件字段的标记如下：

```html
<input type="text" id="field-email" name="field-email" />
```

要使用新的 input 元素，应该把 type 属性改成这样

```html
<input type="email" id="field-email" name="field-email" />
```

尚未实现这个新字段类型的浏览器碰到它只会想：“这是啥意思呀?不明白。” 然后回退为默认的 text 类型，结果和上面的第一行代码一样。而实现了这个类型的新浏览器则知道 email 想让用户在这里填写什么样的数据。而在很多移动设备中，相应的软键盘还会针对输入电子邮件地址调整界面布局。假如还在这里使用了内置的表单验证，那么支持它的新浏览器也会帮你做验证。这样，既渐进增强了页面，也不会对旧版本浏览器产生不好的影响。

另外一个简单的变化就是，HTML5 把文档类型声明更新为新的简短形式。所谓文档类型，就是位于 HTML 文档第一行的代码，供机器识别当前文档使用的标记语言版本。以往的 HTML 和 XHTML 版本中，这行代码很长很复杂，但在 HTML5 中，它已经简化成 `<!DOCTYPE html>`。今后，只要这样声明 HTML 文档类型就好了，因为这个 HTML5 语法的 doctype 是向后兼容的。

CSS 中的渐进增强同样也反映在浏览器如何对待新属性上。任何浏览器无法识别的属性或值都会导致浏览器丢弃相应的声明。因此，只要同时提供合理的后备声明，使用新属性就不会带来不良后果。

举个例子，很多现代浏览器支持以 rgba 函数方式表示的颜色值。这种方式可以分别传入红绿、蓝通道，以及阿尔法（alpha，即透明度）通道的值。可以这样使用它

```css
.overlay {
  background-color: #000;
  background-color: rgba(0, 0, 0, 0.8);
}
```

这条规则定义了类名为 overlay 的元素背景为黑色，但随后又用 rgba 声明背景色应稍微透明。如果浏览器不支持 rgba，那么相应元素的背景色就是不透明的黑色。如果浏览器支持 rgba，那么第二条声明就会覆盖第一条。也就是说，即使并非所有浏览器都支持 rgba，也可以使用它，只是要先为它声明合适的后备代码。

**厂商前缀**
浏览器厂商也基于相同的原理为自家浏览器引入实验性特性。实验性特性的标准名称前面会加上一个特殊字符串，这样他们自己的浏览器就能识别该特性，而其他浏览器则会忽略该特性。有了这个方案，浏览器厂商就可以添加规范中没有或者尚不成熟的新特性，样式表作者也可以安心地试用这些新属性，不用担心浏览器因不认识它们而破坏页面。比如：

```css
.myThing {
  webkit-transform: translate(0, 10px);
  moz-transform: translate(0, 10px);
  ms-transform: translate(0, 10px);
  transform: translate(0, 10px);
}
```

这里使用了几个不同的前缀，给相应的元素应用了变换(<!--TODO-->第 10 章会介绍)：

- 以 -webkit- 开头的适用于基于 WebKit 的浏览器，如 Safari Chrome 和 Opera 都基于 Blink 引擎，而 Blink 最初也是基于 WebKit 开发的，所以 -webkit- 前缀通常也适用于这 3 个浏览器。
- -moz- 前缀适用于基于 Mozilla 的浏览器，如 Firefox。
- -ms-前缀则适用于微软的 IE。

最后又加了一条不带前缀的声明，这样那些支持标准属性名称的浏览器就不会漏网了。

过去经常出现开发人员漏加不带前缀的标准声明的情况。为此，有些浏览器厂商也开始支持竞争对手引擎特定的前缀，以便让流行的网站能在自己的浏览器上打开。但这样做也造成了混乱，于是多数浏览器厂商抛弃了厂商前缀。那实验性特性呢？有的厂商选择把它们隐藏在 chrome://flags 中，有的选择只在特定的预览版中提供。

**条件规则与检测脚本**
如果希望根据浏览器是否支持某个 CSS 特性来提供完全不同的样式，那么可以选择 `@supports` 块。这个特殊的代码块称为条件规则，它会检测括号中的声明，并且仅在浏览器支持该声明的情况下，才会应用块中的规则：

```css
@supports (display: grid) {
  /* 在支持网格布局的浏览器中要应用的规则 */
}
```

条件规则的问题是其自身也很新，只能将它应用于新的浏览器中，因为旧版本浏览器不支持。此外，还可以通过 JS 来检测支持情况，比如使用 Modernize 这个库。Modernize 的原理是为 HTML 添加支持提示信息，然后可以依据这些信息来编写 CSS。

> 这里关键是要知道：渐进增强可以放下对版本号和规范的很多担忧。只要加点小心，就可以在适当的时候使用一些簇新的特性，同时又不会丢掉使用旧版浏览器的用户。

### 1.2 创建结构化、语义化富 HTML

**语义化标记是优秀 HTML 文档的基础。语义就是以系统方式表示的含义**。对于根据一个形式符号的集合人工创造出的语言（比如 HTML 语言，及其元素和属性）来说，语义指的就是通过使用某个符号想要表示的含义。简而言之，语义化标记意味着在正确的地方使用正确的元素，从而得到有意义的文档。

有意义的文档可以确保尽可能多的人都能够使用，无论用的是最新版本的 Chrome，还是 Lynx 这样只能处理文本的浏览器，甚至是屏幕阅读器或盲文点触设备之类的辅助技术。无论将来项目中会增加多么花哨的图形或交互，**文档的基础语义都应该永远—而且必须永远—不打折扣**。

结构良好的标记也意味着内容更对机器的胃口。机器对，特别是 Googlebot 这种搜索引擎爬虫，对它胃口的内容可以让你的页面在 Google 搜索结果中排名更靠前。这是因为，Googlebot 从页面中获得的相关数据越多，它对页面的索引和排名可能就越准确。于是，页面在搜索结果中出现的位置就可能更靠前。对于 CSS 来说更重要的是，有意义的标记本身为添加样式提供了方便。这些标记不仅描述了文档的结构，而且还为继续装扮它提供了底层的框架。

实际上，编写 CSS 的最新实践都建议先给网站一组 “基础” 样式。设立这么一套基础样式的价值非常之大。虽然实际设计和开发中，它们很快会被继承和覆盖，但有了这么一套基础样式，将来的工作就会有条不紊。这套样式也可以作为校准样式来使用。在不断修改 CSS 的过程中，可以时不时对照一下样式指南中的组件，检查自己是否无意中覆盖了某些不该覆盖的样式。

#### 1.2.1 ID 和 c1ass 属性

有意义的元素提供了不错的基础，却没有提供应用视觉效果所必需的全部 “接入点”。几乎总是要根据上下文来调整基础元素的样式。除了元素本身，还需要一种方式把样式 “接入” 到文档上，这就是 `ID` 和 `class` 属性。

为元素添加 ID 和 class 属性不一定能给文档增加含义或结构。这两个属性只是一种让其他因素来操作与解析文档的通用手段，CSS 也可以利用这一手段。

给属性起名字听起来简单，但在写代码时却是极其重要的（常常也是最难的）。“名不正则言不顺”，起什么名字意味着它是什么，或者应该怎么使用它。**写代码的时候，清晰和明确都是至关重要的原则**。下面就以一个链接列表为例，看看怎么给它的 class 属性一个既容易辨识又好用的值：

```html
<ul class="product-list">
  <li><a href="/product/1">Product 1</a></li>
  <li><a href="/product/2">Product 2</a></li>
  <li><a href="/product/3">Product 3</a></li>
</ul>
```

先利用 class 属性在文档中创造一个 product-list 模块。在 CSS 里，用类名来定义一类事物。这里的 product-list 就意味着它可以是任何商品列表换句话说，为 product-list 写好样式后，不仅可以用在这里，还可以用在网站的其他地方，就像蓝图或者模板一样可以重用。

给元素添加类名时，即使类名明确用于样式，也不要体现出其视觉效果（<!--TODO-->第 12 章会详细讨论这一点，包括什么情况下类名可以体现视觉效果）。**正确的做法是让类名表示组件的类型**。

前面的例子只给元素添加了 class 属性，并没有添加 ID 属性。对于添加样式而言，ID 与 class 属性有一些重要的区别，但针对这个例子而言，最主要的区别是一个 ID 只能应用到页面中的一个元素。也就是说，不能像 product-list 那样使用 ID 把页面中的模块定义为可重用的 “模板”。如果使用了 ID，那么相应的 product-list 在每个页面中只能出现一次。提倡使用 ID 来标识特定模块的特定实例。

实际开发中，一般不建议把 ID 属性作为 CSS 的 “接入点”。利用类来添加样式往往能够让代码更简单也更容易维护。ID 可以用于在文档中标识元素，但通常不用于添加样式。

#### 1.2.2 结构化元素

HTML5 新增了一批结构化元素：

- section
- header
- footer
- nav
- article
- aside
- main

**增加这些新元素是为了在 HTML 文档中创建逻辑性区块**。它们可以用于包含独立内容（article）、导航组件（nav）、特定区块的头部（header），等等。其中，main 元素是最新增加的，用于高亮页面中包含主要内容的区域。**除了 main 之外，所有其他新元素都可以在一个文档中多次出现**，以便让机器和人更好地理解文档。关于如何正确使用这些新元素，建议看看[这个网站](http://html5doctor.com)。

div 元素对文档而言并没有语义价值，只是借助类名作为添加样式的 “接入点” 而已。

#### 1.2.3 div 和 span

既然有了新语义元素，那么 div 元素是否就多余了呢？不是的。在没有合适的语义元素的情况下，div 仍然是给内容分组的一个不错的选择。有时候，会纯粹出于添加样式的目的而在文档中添加一个元素。比如，为实现居中布局而在整个页面外部包装一个元素。

如果有更具语义的结构化元素，那么务必使用它们，需要添加样式时再给它们一个适当的类名。但是，如果只需要一个无语义的元素作为额外的样式接入点，那就使用 div。

因此，**请确保只在额外提供样式接入的情况下才使用 div**，但也不要因为用了几个 div 就感到难为情。在后面介绍的几个具体的例子中，会看到，额外添加的无语义 div 元素对保证代码的清晰和可维护性非常重要。

与 div 元素类似的还有 span。同样，在无须表示语义、仅需添加样式的情况中，可以使用 span。与 div 不同，span 是文本级元素，可以用于在文本流中建立结构。不过在使用无语义的 span 之前，也一样要确保真的不需要使用任何语义元素。比如，使用 time 标记时间和日期，使用 q 标记引用，使用 em 标记需要强调的内容，使用 strong 标记需要重点强调的内容。

#### 1.2.4 重新定义的表现性文本元素

时至今日，`<b>` 和 `<i>` 可以算是幸存的表现性标记了，它们以前分别用于将文本标记为粗体（bold）和斜体（italic）。因为在旧有 Web 内容中，或者通过低水平 WYSIWYG 编辑器创建的内容中，这两个元素随处可见。HTML5 的编辑最终决定保留它们，但改变了它们的含义。

今天，`<i>` 元素用于标识与周围内容不一样的内容，一般在排版上会显示为斜体。HTML5 规范中给出的例子包括另一种语言中的习语，以及一艘船的名字。

`<b>` 元素的含义和 `<i>` 几乎一样，只是针对习惯上标记为粗体的内容。相关的例子包括商品或品类名。

这样的定义确实不够明确，但关键是要知道，**这两个元素与 `<em>` 及 `<strong>` 的区别在于，它们没有任何强调自己所包含内容的意味**。多数情况下，应该选择 `<em>` 或 `<strong>`，因为它们是用来强调及重点强调内容的语义正确的选择。

#### 1.2.5 扩展 HTML 语义

长时间以来，Web 开发者一直在探索给 HTML 有限的词汇表添加新的语义和结构的方式。为内容添加更丰富的语义，对 Web 和基于其构建的工具而言意义重大。虽然建设语义 Web 王国任重而道远，但不管怎么说，还是有了实质性的进步。利用这些成果，HTML 编写者可以为自己的文档添加更细粒度、更具表达性的语义。

**ARIA 的 role 属性**
很多新的 HTML5 元素都考虑到了无障碍访问的场景。比如，如果屏幕阅读器能够理解页面中的 nav 元素，那么它就可以利用这个元素帮助用户定位到相应的内容，或者在必要时返回导航。

另一种实现这个目标的方式是利用无障碍富因特网应用（ARIA，accessible rich Intermetapplication），它是对 HTML 规范的补充。ARIA 提供了针对辅助访问设备添加更多语义的手段，方式就是为文档中的不同元素指定其包含什么内容，或者说它们提供什么功能。比如，role="navigation" 这个 “地标角色” 属性用于声明一个元素具有导航的角色。其他角色有：

- banner
- form
- main
- search
- complementary
- contentinfo
- application

完整的 ARA 角色及其定义，参见 ARIA 规范。ARIA 还支持让开发人员指定更复杂的内容片段和界面元素。例如，在使用 HTML 创建一个音量滑动条部件时，应该包含值为 slider 的 role 属性：

```html
<div id="volume-label">Volume</div>
<div class="volume-rail">
  <a
    href="#"
    class="volume-handle"
    role="slider"
    aria-labelledby="volume-label"
    aria-valuemin="1"
    aria-valuemax="100"
    aria-valuenow="67"
  ></a>
</div>
```

属性 aria-labelledby、aria-valuemin、aria-valuemax 和 aria-valuenow 也分别提供了额外的信息，辅助阅读技术可以利用它们帮助残障用户使用这个滑动部件。

为 HTML 页面中的不同组件添加这些额外的语义属性，同样有助于为元素添加脚本和样式，是典型的多贏策略。

**微格式**
_目前最广泛采用的扩展 HTML 语义的方式是微格式_。微格式是一组标准的命名约定和标记模式，可用于表示特定的数据类型。微格式的命名约定是基于 vCard 和 iCalendar 等已有的数据格式制定的。比如下面的联系人信息就是以 hCard 格式标记的：

```html
<section class="h-card">
  <p>
    <a class="u-url p-name" href="http://andybudd.com/">Andy Budd</a>
    <span class="p-org">Clearleft Ltd</span>
    <a class="u-email" href="mailto:info@andybudd.com">info@andybudd.com</a>
  </p>
  <p class="p-adr">
    <span class="p-locality">Brighton</span>
    <span class="p-country-name">England</span>
  </p>
</section>
```

以微格式标记的联系人信息便于开发人员编写工具从中提取数据。比如可以编写一个浏览器插件，从你浏览的页面中发现微格式，然后让你把联系人信息下载到通讯录，或者把活动信息添加到你的日历应用。目前微格式支持的数据类型包括联系人、活动、菜谱、博文、简历，等等。

微格式也可以用于表示关系，比如一段内容与链接到该内容的另一个 URL 之间的关系微格式得以流行的原因之一是容易实现，迄今已经被 Yahoo 和 Facebook 等内容平台采用，而且已经直接添加到了 WordPress8 和 Drupal 等内容发布工具中。2012 年一项关于结构化数据实现的研究发现，微格式在 Web 上的应用最为广泛。不过最近微数据异军突起，也不容小觑。

**微数据**
微数据是跟 HTM5 一起，作为给 HTML 添加结构化数据的另一种方式而推出的。它的目标与微格式非常相近，但在把微数据嵌入内容方面则有所不同。下面看一看用微数据标记同样的联系人信息会是什么样：

```html
<section itemscope itemtype="http://schema.org/person">
  <p><a itemprop="name" href="http://thatemil.com/">Emil B</a></p>
  <span itemprop="affiliation" itemscope itemtype="http://schema.org/organization">
    <span itemprop="name">inUse Experience AB</span>
  </span>
  <a itemprop="email" href="mailto:emil@thatemil.com">emil@thatemil.com</a>
  <p itemprop="address" itemscope itemtype="http://schema.org/PostalAddress">
    <span class="addressLocality">Malm?</span>,
    <span class="addressCountry">Sweden</span>
  </p>
</section>
```

通过这个例子可以看出，微数据的语法比微格式要烦琐一些，不过这是有原因的。由于微数据设计的时候考虑到了可扩展性，它可以用来表示任意类型的数据。微数据只定义一些语法来表示数据结构，但自身并未定义任何词汇表。相反，微格式则定义了具体的结构化数据，比如 hCard 和 hCalendar。

微数据把定义特定格式的事交给了使用者或第三方。上述例子中使用的格式就是由 Bing、Google 以及 Yahoo 等搜索引擎共同创建的一个[词汇表](https://schema.org)。这几家搜索引擎使用它来辅助索引和排名页面，当然搜索爬虫也会使用这些词汇表，从你的内容中更高效地提取丰富的信息。

#### 1.2.6 验证

即使经过深思熟虑，标记已经非常语义化了，其中也仍然存在输入或者格式错误的风险。这些隐患会带来无法预料的麻烦。这时候就要使用验证了。

现实中的多数 HTML 文档并不是真正有效的 HTML。用规范编写者的话说，就叫作 “未遵行”（nonconformant）。这些文档中存在的问题有元素嵌套不对、包含未经编码的和号（&），以及缺少必要的属性等。浏览器对这类错误非常宽容，总会尝试猜测作者的意图。事实上，HTML 规范中也包含了如何处理无效 HTML 的规定，以确保浏览器厂商以一致的方式处理错误。

总体来说，浏览器如此大度地处理错误是个好事，但不代表可以因此而放弃自己的职守。都应该尽力写出有效的 HTML 文档，这样有利于更快地查找问题，避免错误泛滥。假如碰到一个渲染或布局上的 bug，时又找不出问题所在，最好先验证一下 HTML，以保证样式应用到了格式正确的文档上。

验证 HTML 的工具有很多。比如，可以使用 W3C 网站上的 [HTML 验证器](http://validator.w3.org/)，或者与之相关的插件。其中的 Web Developer 扩展，Firefox、Opera 和 Chrome 都支持。此外，如果项目有自动构建或测试环节，最好在其中加上 HTML 验证。

CSS 也是可以验证的。W3C 的 [CSS 验证器](http://jigsaw.w3.org/css-validator/)。可能认为验证 CSS 没有验证 HTML 那么重要，毕竟 CSS 中的错误一般不会导致 JS 出错，或者导致屏幕阅读器无法打开页面。但是，还是建议重视 CSS，保证其中没有什么低级错误。

根据 CSS 验证器设置而定，验证结果中可能包含很多关于厂商前缀的警告或错误。这些属性或值是浏览器厂商在实验性地支持某些 CSS 特性时使用的一种临时命名约定。比如，webkit-flex 这个 display 属性的值，就是标准 flex 属性值在 WebKit 浏览器上的实验性版本。这些地方虽然会被验证器标记为警告甚至错误，但文件依然能正常使用。总之，只要明白验证器给出的这些标记的真正含义就行了。

验证并不是最终裁决，很多本身很好的页面也会验证失败，这是由于使用了来自第三方或低水准 CMS 的内容，或者使用了试验性 CSS 特性。此外，验证器本身也可能会跟不上标准更新和浏览器实现的步伐。因此不要过于激进，只要把验证当作事先帮助发现一些低级错误的手段即可。

## 二. 添加样式

### 2.1 CSS 选择符

类型和后代选择符是最基本的选择符。
