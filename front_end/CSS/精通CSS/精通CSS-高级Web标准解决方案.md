---
title: 精通CSS-高级Web标准解决方案
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [精通 CSS-高级 Web 标准解决方案](#精通-css-高级-web-标准解决方案)
  - [一. 基础知识](#一-基础知识)
    - [1.1 组织代码](#11-组织代码)
      - [1.1.1 可维护性](#111-可维护性)
      - [1.1.2 HTML 简史](#112-html-简史)
      - [1.1.3 渐进增强](#113-渐进增强)
    - [1.2 创建结构化、语义化富 HTML](#12-创建结构化-语义化富-html)
      - [1.2.1 ID 和 c1ass 属性](#121-id-和-c1ass-属性)
      - [1.2.2 结构化元素](#122-结构化元素)
      - [1.2.3 div 和 span](#123-div-和-span)
      - [1.2.4 重新定义的表现性文本元素](#124-重新定义的表现性文本元素)
      - [1.2.5 扩展 HTML 语义](#125-扩展-html-语义)
      - [1.2.6 验证](#126-验证)
  - [二. 添加样式](#二-添加样式)
    - [2.1 CSS 选择符](#21-css-选择符)
    - [2.2 层叠](#22-层叠)
    - [2.3 特殊性](#23-特殊性)
      - [2.3.1 利用层叠次序](#231-利用层叠次序)
      - [2.3.2 控制特殊性](#232-控制特殊性)
    - [2.4 继承](#24-继承)
    - [2.5 为文档应用样式](#25-为文档应用样式)
      - [2.5.1 link 与 style 元素](#251-link-与-style-元素)
      - [2.5.2 性能](#252-性能)
  - [三. 可见格式化模型](#三-可见格式化模型)
    - [3.1 盒模型](#31-盒模型)
      - [3.1.1 盒子大小](#311-盒子大小)
      - [3.1.2 最大值和最小值](#312-最大值和最小值)
    - [3.2 可见格式化模型](#32-可见格式化模型)
      - [3.2.1 匿名盒子](#321-匿名盒子)
      - [3.2.2 外边距折叠](#322-外边距折叠)
      - [3.2.3 包含块](#323-包含块)
      - [3.2.4 相对定位](#324-相对定位)
      - [3.2.5 绝对定位](#325-绝对定位)
      - [3.2.6 固定定位](#326-固定定位)
      - [3.2.7 浮动](#327-浮动)
      - [3.2.8 格式化上下文](#328-格式化上下文)
      - [3.2.9 内在大小与外在大小](#329-内在大小与外在大小)
    - [3.3 其他 CSS 布局模块](#33-其他-css-布局模块)
      - [3.3.1 弹性盒布局](#331-弹性盒布局)
      - [3.3.2 网格布局](#332-网格布局)
    - [3.3.3 多栏布局](#333-多栏布局)
    - [3.4 Region](#34-region)
  - [四. 网页排版](#四-网页排版)
    - [4.1 CSS 的基本排版技术](#41-css-的基本排版技术)
      - [4.1.1 文本颜色](#411-文本颜色)
      - [4.1.2 字体族](#412-字体族)
      - [4.1.3 字型大小与行高](#413-字型大小与行高)
      - [4.1.4 行间距、对齐及行盒子的构造](#414-行间距-对齐及行盒子的构造)
    - [4.1.5 文本粗细](#415-文本粗细)
      - [4.1.6 字体样式](#416-字体样式)
      - [4.1.7 大小写变换和小型大写变体](#417-大小写变换和小型大写变体)
      - [4.1.8 控制字母和单词间距](#418-控制字母和单词间距)
    - [4.2 版心宽度、律动和毛边](#42-版心宽度-律动和毛边)
      - [4.2.1 文本缩进与对齐](#421-文本缩进与对齐)
      - [4.2.2 连字符](#422-连字符)
      - [4.2.3 多栏文本](#423-多栏文本)
    - [4.3 Web 字体](#43-web-字体)
      - [4.3.1 许可](#431-许可)
      - [4.3.2 @font-face 规则](#432-font-face-规则)
      - [4.3.3 Web 字体、浏览器与性能](#433-web-字体-浏览器与性能)
      - [4.3.4 使用 JS 加载字体](#434-使用-js-加载字体)
    - [4.4 高级排版特性](#44-高级排版特性)
      - [4.4.1 数字](#441-数字)
      - [4.4.2 字距选项及文本渲染](#442-字距选项及文本渲染)
    - [4.5 文本特效](#45-文本特效)
      - [4.5.1 合理使用文本阴影](#451-合理使用文本阴影)
      - [4.5.2 使用 JS 提升排版品质](#452-使用-js-提升排版品质)
  - [五. 漂亮的盒子](#五-漂亮的盒子)
    - [5.1 背景颜色](#51-背景颜色)
    - [5.2 背景图片](#52-背景图片)
      - [5.2.1 背景图片与内容图片](#521-背景图片与内容图片)
      - [5.2.3 加载图片（以及其他文件）](#523-加载图片以及其他文件)
      - [5.2.4 图片格式](#524-图片格式)
    - [5.3 背景图片语法](#53-背景图片语法)
      - [5.3.1 背景位置](#531-背景位置)
      - [5.3.2 背景裁剪与原点](#532-背景裁剪与原点)
      - [5.3.3 背景附着](#533-背景附着)
      - [5.3.4 背景大小](#534-背景大小)
      - [5.3.5 背景属性简写](#535-背景属性简写)
    - [5.4 多重背景](#54-多重背景)
    - [5.5 边框与圆角](#55-边框与圆角)
      - [5.5.1 边框半径圆角](#551-边框半径圆角)
      - [5.5.2 创建正圆和胶囊形状](#552-创建正圆和胶囊形状)
      - [5.5.3 边框图片](#553-边框图片)
    - [5.6 盒阴影](#56-盒阴影)
      - [5.6.1 扩展半径：调整阴影大小](#561-扩展半径调整阴影大小)
      - [5.6.2 内阴影](#562-内阴影)
      - [5.6.3 多阴影](#563-多阴影)
    - [5.7 渐变](#57-渐变)
      - [5.7.1 浏览器支持与浏览器前缀](#571-浏览器支持与浏览器前缀)
      - [5.7.2 线性渐变](#572-线性渐变)
      - [5.7.3 放射渐变](#573-放射渐变)
      - [5.7.4 重复渐变](#574-重复渐变)
      - [5.7.5 把渐变当作图案](#575-把渐变当作图案)
    - [5.8 为嵌入图片和元素添加样式](#58-为嵌入图片和元素添加样式)
      - [5.8.1 可伸缩的图片模式](#581-可伸缩的图片模式)
      - [5.8.2 控制对象大小的新方法](#582-控制对象大小的新方法)
      - [5.8.3 可保持宽高比的容器](#583-可保持宽高比的容器)
      - [5.8.4 减少图片大小](#584-减少图片大小)
  - [六. 内容布局](#六-内容布局)
    - [6.1 定位](#61-定位)
      - [6.1.1 绝对定位的应用场景](#611-绝对定位的应用场景)
      - [6.1.2 定位与 z-index：堆叠内容的陷阱](#612-定位与-z-index堆叠内容的陷阱)
    - [6.2 水平布局](#62-水平布局)
      - [6.2.1 使用浮动](#621-使用浮动)
      - [6.2.2 行内块布局](#622-行内块布局)
      - [6.2.3 使用表格显示属性实现布局](#623-使用表格显示属性实现布局)
      - [6.2.4 不同技术优缺点比较](#624-不同技术优缺点比较)
    - [6.3 Flexbox](#63-flexbox)
      - [6.3.1 浏览器支持与语法](#631-浏览器支持与语法)
      - [6.3.2 理解 Flex 方向：主轴与辅轴](#632-理解-flex-方向主轴与辅轴)
      - [6.3.3 对齐与空间](#633-对齐与空间)
      - [6.3.4 可伸缩的尺寸](#634-可伸缩的尺寸)
      - [6.3.5 Flexbox 布局](#635-flexbox-布局)
      - [6.3.6 列布局与个别排序](#636-列布局与个别排序)
      - [6.3.7 嵌套的 Flexbox 布局](#637-嵌套的-flexbox-布局)
      - [6.3.8 Flexbox 不可用怎么办](#638-flexbox-不可用怎么办)
      - [6.3.9 Flexbox 的 bug 与提示](#639-flexbox-的-bug-与提示)
  - [七. 页面布局与网格](#七-页面布局与网格)
    - [7.1 布局规划](#71-布局规划)
      - [7.1.1 网格](#711-网格)
      - [7.1.2 布局辅助类](#712-布局辅助类)
      - [7.1.3 使用现成的框架](#713-使用现成的框架)
      - [7.1.4 固定、流动还是弹性](#714-固定-流动还是弹性)
    - [7.2 创建灵活的页面布局](#72-创建灵活的页面布局)
      - [7.2.1 包装元素](#721-包装元素)
      - [7.2.2 行容器](#722-行容器)
      - [7.2.3 创建列](#723-创建列)
      - [7.2.4 流式空距](#724-流式空距)
      - [7.2.5 增强列：包装与等高](#725-增强列包装与等高)
      - [7.2.6 作为网页布局通用工具的 Flexbox](#726-作为网页布局通用工具的-flexbox)
    - [7.3 二维布局：CSS Grid Layout](#73-二维布局css-grid-layout)
      - [7.3.1 网格布局的术语](#731-网格布局的术语)
      - [7.3.2 定义行和列](#732-定义行和列)
      - [7.3.3 添加网格项](#733-添加网格项)
      - [7.3.4 自动网格定位](#734-自动网格定位)
      - [7.3.5 网格模板区](#735-网格模板区)
  - [八. 响应式 Web 设计](#八-响应式-web-设计)
    - [8.1 一个例子](#81-一个例子)
      - [8.1.1 简单上手](#811-简单上手)
      - [8.1.2 媒体查询](#812-媒体查询)
      - [8.1.3 加入更多断点](#813-加入更多断点)
    - [8.2 响应式 Web 设计的起源](#82-响应式-web-设计的起源)
    - [8.3 浏览器视口](#83-浏览器视口)
      - [8.3.1 视口定义的差别](#831-视口定义的差别)
      - [8.3.2 配置视口](#832-配置视口)
    - [8.4 媒体类型与媒体查询](#84-媒体类型与媒体查询)
      - [8.4.1 媒体类型](#841-媒体类型)
      - [8.4.2 媒体查询](#842-媒体查询)
    - [8.5 响应式设计与结构化 CSS](#85-响应式设计与结构化-css)
      - [8.5.1 移动优先的 CSS](#851-移动优先的-css)
      - [8.5.2 媒体查询放在何处](#852-媒体查询放在何处)
    - [8.6 几种响应式设计模式](#86-几种响应式设计模式)
      - [8.6.1 响应式文本列](#861-响应式文本列)
      - [8.6.2 没有媒体查询的响应式 Flexbox](#862-没有媒体查询的响应式-flexbox)
      - [8.6.3 响应式网格与网格模板区](#863-响应式网格与网格模板区)
    - [8.7 响应式布局之外](#87-响应式布局之外)
      - [8.7.1 响应式背景图片](#871-响应式背景图片)
      - [8.7.2 响应式嵌入媒体](#872-响应式嵌入媒体)

<!-- /code_chunk_output -->

# 精通 CSS-高级 Web 标准解决方案

## 一. 基础知识

### 1.1 组织代码

层叠样式表（CSS，cascading style sheets）的技术和概念，必须以结构良好且有效的 HTML 文档为前提。

#### 1.1.1 可维护性

可维护性可以说是所有优秀代码最重要的特点。相对来说，CSS 是随着代码量增加而最难保持可维护性的语言之一。现代编程语言都有内置的变量、函数和命名空间等特性，这些特性都有利于保持代码的结构和格式化。这些特性 CSS 都没有，所以要按照使用这种语言和组织代码的特殊方式来管理它。

#### 1.1.2 HTML 简史

Tim Berners-Lee 在 1990 年发明了 HTML，当时是为了规范科研文档的格式。HTML 是一种简单的标记语言，为文本赋予了基本的结构和意义，比如标题、列表、定义等。这些文档通常没有什么装饰性的元素，可以方便地通过计算机来检索，而人类可以使用文本终端、Web 浏览器，或者必要时使用屏幕阅读器来阅读它们。

然而，人类是视觉发达的生物。随着万维网被越来越多的人所接受，HTML 也逐渐增加了对展示效果的支持。除了用标题元素标记文档标题，还可以使用粗体标签和不同的字体来创建特殊的视觉效果。本来用于展示数据的表格（tab1e），却成了页面布局的手段；块引用（blockquote）也经常被用来缩进文本，而不是只用来标记引文。HTML 很快就偏离了为内容赋予结构和意义的初衷，变成了一堆字体和表格标签。Web 设计者给这种标记起了个名字，叫 “标签汤”。

正当 Web 变得一团糟之际，CSS 作为解决方案面世了。CSS 的初衷是把跟 HTML 混在一起的表现性标记提取出来，使其自成体系，达到结构与表现分离的目的。这就让有意义的标签或者说语义悄悄返回了 HTML 文档。font 之类的表现性标签可以不用了，而表格布局也可以被逐步取代。对大多数网站而言，CSS 都能提升其可访问性和加载速度。不仅如此，CSS 还给 Web 设计和开发人员带来了更多好处：

- 一种专用于控制视觉样式和布局的语言
- 在同一网站中更易于重用的样式
- 通过关注点分离得到了良好的代码结构

---

**关注点分离**
关注点分离（separation of concerns）是软件开发行业的一个常见概念。对 Web 开发而言，关注点分离不仅适用于标记和样式，同样也适用于编写样式的方式。事实上，**关注点分离也是确保代码可维护性的一种主要方法**。

Unix 开发社区有一句话很好地诠释了**关注点分离的思想，即 “分成小块，松散结合”**（small pieces，loosely joined）。其中，每一 “小块” 都是一个模块，专注于做好一件事。而且，因为这个模块跟其他组件是 “松散结合” 的，所以它可以方便地在系统的其他部分中重用。Unix 中的一 “小块” 可能是一个字数统计函数，可以应用于传入的任何文本片段。而在 Web 开发中，这一 “小块” 可能就是一个商品列表组件，如果能做到 “松散结合”，就可以在一个网站的多个页面或者在同一布局的不同区块中重用。

可以把代码中的这些 “小块” 想象成积木。每一块积木都很简单，但把很多块积木以不同方式组装起来，就可以创造出无比复杂的东西。

---

**HTML 和 CSS 的版本**
CSS 有很多版本，或者 “级别”。了解这些版本产生的背景，有助于了解应该或不应该使用哪些 CSS 特性。万维网联盟（W3C，World Wide Web Consortium）是制定 Web 技术标准的组织，该组织制定的每一个规范要经历几个阶段之后才能成为 W3C 推荐标准。CSS1 是在 1996 年底成为 W3C 推荐标准的，当时只包含字体、颜色和外边距等基本的属性。CSS2 在 1998 年成为推荐标准，增加了浮动和定位等高级特性，此外还有子选择符、相邻选择符和通用选择符等新选择符。

相比之下，CSS3 则采用了完全不同的模式。实际上不存在所谓的 CSS3 规范，因为 CSS3 指的是一系列级别独立的模块。如果规范模块是对之前 CSS 概念的改进，那就从 3 级开始命名。如果不是改进，而是一种全新的技术，那就从 1 级开始命名。而 CSS3，则是指所有足够新的 CSS 规范模块，比如 CSS Backgrounds and Borders Level3、Selectors level4 和 CSS Grid Layout Level 1。这种模块化的方式可以让不同的规范有自己的演进速度。有些 3 级规范，比如 CSS Color level3，已经成为推荐标准。而另外一些可能还处于候选推荐阶段，很多甚至还处于工作草案阶段。

虽然 CSS3 的制定工作在 CSS2 发布后就开始了，但这些新规范一开始的制定速度很缓慢。为此，W3C 在 2002 年发布了 CSS2 Revision 1。CSS 2.1 修正了 CSS2 中的一些错误，删掉了支持度不高或者并非所有浏览器都实现了的一些特性，总体来说就是把 CSS 规范做了一番清理，好为浏览器实现提供更精准的蓝图。CSS 2.1 在 2011 年 6 月成为推荐标准，此时距离 CSS3 启动已经有 10 多年了。由此可见，标准制定主体和浏览器开发商为了确保相应的特性得以原原本本地实现，需要花多么长的时间。不过，浏览器开发商经常会在标准还处于草案阶段时，就发布一些实验性的实现。这样，等到了候选推荐阶段，相应的实现就已经非常稳定了。换句话说，很多 CSS 特性早在相应模块成为推荐标准前就可以使用了。

HTML 的历史也很复杂。HTML4.01 在 1999 年成为推荐标准，与此同时 W3C 也把注意力转向了 XHTML1.0。本来接着要发布 XHTML1.1，但其严格程度在实践中暴露了无法落地的问题，最终被 Web 开发社区抛弃。于是，这个 Web 主要语言的发展停滞了。

2004 年，有几家公司共同组建了 Web 超文本应用技术工作组（WHATWG， Web Hypertext Application Technology Working Group），并致力于开发新的规范。2006 年，W3C 肯定了它们工作的必要性，并欣然加人该工作组。2009 年，W3C 完全放弃 XHTML，正式接纳 WHATWG 制定的新标准，这就是后来的 HTML5。起初，WHATWG 和 W3C 都基于标准调整自己的工作，但后来它们的关系又变得复杂起来。今天，它们分别在编辑两份标准。 WHATWG 那份就叫 HTML，而 W3C 那份则称为 HTML5。没错，这种分裂确实不好。但万幸的是，这两份标准的内容相当接近，因此只讲 HTML5 是没有问题的。

**应该使用哪个版本**
设计者和开发者经常问的一个问题就是应该使用 HTML 或 CSS 的哪个版本。这个问题不好回答。虽然规范反映了标准和 Web 技术开发的进度和焦点，但它其实跟设计者和开发者日常的工作关系不大。真正重要的是知道 HTML 和 CSS 的哪些部分已经在浏览器中实现了，以及这些实现是否稳健，有没有 bug。比如，浏览器提供的这些特性是不是实验性特性，使用时需谨慎?或者，这些特性到底靠不靠谱，是不是已经得到了多数浏览器的支持?

今天，使用 CSS 和 HTML 就要了解浏览器对其中特性的支持程度。要了解浏览器支持情况，推荐几个不错的地方。对于 CSS 属性，可以访问 [“Can I use” 网站](https://caniuse.com)。这个网站可以搜索属性或属性组，结果配有统计信息，显示支持它们的浏览器百分比，包括桌面浏览器和移动浏览器。此外，Mozilla 的开发者文档，即 [MDN](https://developer.mozilla.org/zh-CN/docs/Web)，也是个非常好的参考。

说到浏览器支持，关键要明白，并非所有浏览器都一样，实际上从来就没有完全一样的浏览器。某些 CSS3 特性只得到了少数浏览器的支持。比如，IE11 和 Safari6.1 之前的版本都没有正确支持 Flexbox（Flexible Box Layout）。不过，就算需要支持老版本的浏览器，也不意味着不能使用 Flexbox。核心布局上可以不用 Flexbox，但对于某些特定的组件，Flexbox 可能就非常合适。只要为不支持它的浏览器准备好可以接受的后备代码就行了。

#### 1.1.3 渐进增强

平衡向后兼容性与最新的 HTML 和 CSS 特性，涉及一种叫作**渐进增强**（progressive enhancement）的策略。所谓**渐进增强，大意就是 “首先为最小公分母准备可用的内容，然后再为支持新特性的浏览器添加更多交互优化”**。使用渐进增强策略，意味着代码要分层，每一层增强代码都只会在相应特性被支持或被认为适当的情况下应用。听起来有点复杂，而实际上 HTML 和 CSS 的实现已经部分内置了这一策略。

对 HTML 而言，这意味着浏览器在遇到未知元素或属性时并不会报错，而且也不会对页面产生什么影响。比如，可以在页面里使用 HTML5 定义的新 input 元素。假设表单中有一个电子邮件字段的标记如下：

```html
<input type="text" id="field-email" name="field-email" />
```

要使用新的 input 元素，应该把 type 属性改成这样

```html
<input type="email" id="field-email" name="field-email" />
```

尚未实现这个新字段类型的浏览器碰到它只会想：“这是啥意思呀?不明白。” 然后回退为默认的 text 类型，结果和上面的第一行代码一样。而实现了这个类型的新浏览器则知道 email 想让用户在这里填写什么样的数据。而在很多移动设备中，相应的软键盘还会针对输入电子邮件地址调整界面布局。假如还在这里使用了内置的表单验证，那么支持它的新浏览器也会帮你做验证。这样，既渐进增强了页面，也不会对旧版本浏览器产生不好的影响。

另外一个简单的变化就是，HTML5 把文档类型声明更新为新的简短形式。所谓文档类型，就是位于 HTML 文档第一行的代码，供机器识别当前文档使用的标记语言版本。以往的 HTML 和 XHTML 版本中，这行代码很长很复杂，但在 HTML5 中，它已经简化成 `<!DOCTYPE html>`。今后，只要这样声明 HTML 文档类型就好了，因为这个 HTML5 语法的 doctype 是向后兼容的。

CSS 中的渐进增强同样也反映在浏览器如何对待新属性上。任何浏览器无法识别的属性或值都会导致浏览器丢弃相应的声明。因此，只要同时提供合理的后备声明，使用新属性就不会带来不良后果。

举个例子，很多现代浏览器支持以 rgba 函数方式表示的颜色值。这种方式可以分别传入红绿、蓝通道，以及阿尔法（alpha，即透明度）通道的值。可以这样使用它

```css
.overlay {
  background-color: #000;
  background-color: rgba(0, 0, 0, 0.8);
}
```

这条规则定义了类名为 overlay 的元素背景为黑色，但随后又用 rgba 声明背景色应稍微透明。如果浏览器不支持 rgba，那么相应元素的背景色就是不透明的黑色。如果浏览器支持 rgba，那么第二条声明就会覆盖第一条。也就是说，即使并非所有浏览器都支持 rgba，也可以使用它，只是要先为它声明合适的后备代码。

**厂商前缀**
浏览器厂商也基于相同的原理为自家浏览器引入实验性特性。实验性特性的标准名称前面会加上一个特殊字符串，这样他们自己的浏览器就能识别该特性，而其他浏览器则会忽略该特性。有了这个方案，浏览器厂商就可以添加规范中没有或者尚不成熟的新特性，样式表作者也可以安心地试用这些新属性，不用担心浏览器因不认识它们而破坏页面。比如：

```css
.myThing {
  webkit-transform: translate(0, 10px);
  moz-transform: translate(0, 10px);
  ms-transform: translate(0, 10px);
  transform: translate(0, 10px);
}
```

这里使用了几个不同的前缀，给相应的元素应用了变换(<!--TODO-->第 10 章会介绍)：

- 以 -webkit- 开头的适用于基于 WebKit 的浏览器，如 Safari Chrome 和 Opera 都基于 Blink 引擎，而 Blink 最初也是基于 WebKit 开发的，所以 -webkit- 前缀通常也适用于这 3 个浏览器。
- -moz- 前缀适用于基于 Mozilla 的浏览器，如 Firefox。
- -ms-前缀则适用于微软的 IE。

最后又加了一条不带前缀的声明，这样那些支持标准属性名称的浏览器就不会漏网了。

过去经常出现开发人员漏加不带前缀的标准声明的情况。为此，有些浏览器厂商也开始支持竞争对手引擎特定的前缀，以便让流行的网站能在自己的浏览器上打开。但这样做也造成了混乱，于是多数浏览器厂商抛弃了厂商前缀。那实验性特性呢？有的厂商选择把它们隐藏在 chrome://flags 中，有的选择只在特定的预览版中提供。

**条件规则与检测脚本**
如果希望根据浏览器是否支持某个 CSS 特性来提供完全不同的样式，那么可以选择 `@supports` 块。这个特殊的代码块称为条件规则，它会检测括号中的声明，并且仅在浏览器支持该声明的情况下，才会应用块中的规则：

```css
@supports (display: grid) {
  /* 在支持网格布局的浏览器中要应用的规则 */
}
```

条件规则的问题是其自身也很新，只能将它应用于新的浏览器中，因为旧版本浏览器不支持。此外，还可以通过 JS 来检测支持情况，比如使用 Modernize 这个库。Modernize 的原理是为 HTML 添加支持提示信息，然后可以依据这些信息来编写 CSS。

> 这里关键是要知道：渐进增强可以放下对版本号和规范的很多担忧。只要加点小心，就可以在适当的时候使用一些簇新的特性，同时又不会丢掉使用旧版浏览器的用户。

### 1.2 创建结构化、语义化富 HTML

**语义化标记是优秀 HTML 文档的基础。语义就是以系统方式表示的含义**。对于根据一个形式符号的集合人工创造出的语言（比如 HTML 语言，及其元素和属性）来说，语义指的就是通过使用某个符号想要表示的含义。简而言之，语义化标记意味着在正确的地方使用正确的元素，从而得到有意义的文档。

有意义的文档可以确保尽可能多的人都能够使用，无论用的是最新版本的 Chrome，还是 Lynx 这样只能处理文本的浏览器，甚至是屏幕阅读器或盲文点触设备之类的辅助技术。无论将来项目中会增加多么花哨的图形或交互，**文档的基础语义都应该永远—而且必须永远—不打折扣**。

结构良好的标记也意味着内容更对机器的胃口。机器对，特别是 Googlebot 这种搜索引擎爬虫，对它胃口的内容可以让你的页面在 Google 搜索结果中排名更靠前。这是因为，Googlebot 从页面中获得的相关数据越多，它对页面的索引和排名可能就越准确。于是，页面在搜索结果中出现的位置就可能更靠前。对于 CSS 来说更重要的是，有意义的标记本身为添加样式提供了方便。这些标记不仅描述了文档的结构，而且还为继续装扮它提供了底层的框架。

实际上，编写 CSS 的最新实践都建议先给网站一组 “基础” 样式。设立这么一套基础样式的价值非常之大。虽然实际设计和开发中，它们很快会被继承和覆盖，但有了这么一套基础样式，将来的工作就会有条不紊。这套样式也可以作为校准样式来使用。在不断修改 CSS 的过程中，可以时不时对照一下样式指南中的组件，检查自己是否无意中覆盖了某些不该覆盖的样式。

#### 1.2.1 ID 和 c1ass 属性

有意义的元素提供了不错的基础，却没有提供应用视觉效果所必需的全部 “接入点”。几乎总是要根据上下文来调整基础元素的样式。除了元素本身，还需要一种方式把样式 “接入” 到文档上，这就是 `ID` 和 `class` 属性。

为元素添加 ID 和 class 属性不一定能给文档增加含义或结构。这两个属性只是一种让其他因素来操作与解析文档的通用手段，CSS 也可以利用这一手段。

给属性起名字听起来简单，但在写代码时却是极其重要的（常常也是最难的）。“名不正则言不顺”，起什么名字意味着它是什么，或者应该怎么使用它。**写代码的时候，清晰和明确都是至关重要的原则**。下面就以一个链接列表为例，看看怎么给它的 class 属性一个既容易辨识又好用的值：

```html
<ul class="product-list">
  <li><a href="/product/1">Product 1</a></li>
  <li><a href="/product/2">Product 2</a></li>
  <li><a href="/product/3">Product 3</a></li>
</ul>
```

先利用 class 属性在文档中创造一个 product-list 模块。在 CSS 里，用类名来定义一类事物。这里的 product-list 就意味着它可以是任何商品列表换句话说，为 product-list 写好样式后，不仅可以用在这里，还可以用在网站的其他地方，就像蓝图或者模板一样可以重用。

给元素添加类名时，即使类名明确用于样式，也不要体现出其视觉效果（<!--TODO-->第 12 章会详细讨论这一点，包括什么情况下类名可以体现视觉效果）。**正确的做法是让类名表示组件的类型**。

前面的例子只给元素添加了 class 属性，并没有添加 ID 属性。对于添加样式而言，ID 与 class 属性有一些重要的区别，但针对这个例子而言，最主要的区别是一个 ID 只能应用到页面中的一个元素。也就是说，不能像 product-list 那样使用 ID 把页面中的模块定义为可重用的 “模板”。如果使用了 ID，那么相应的 product-list 在每个页面中只能出现一次。提倡使用 ID 来标识特定模块的特定实例。

实际开发中，一般不建议把 ID 属性作为 CSS 的 “接入点”。利用类来添加样式往往能够让代码更简单也更容易维护。ID 可以用于在文档中标识元素，但通常不用于添加样式。

#### 1.2.2 结构化元素

HTML5 新增了一批结构化元素：

- section
- header
- footer
- nav
- article
- aside
- main

**增加这些新元素是为了在 HTML 文档中创建逻辑性区块**。它们可以用于包含独立内容（article）、导航组件（nav）、特定区块的头部（header），等等。其中，main 元素是最新增加的，用于高亮页面中包含主要内容的区域。**除了 main 之外，所有其他新元素都可以在一个文档中多次出现**，以便让机器和人更好地理解文档。关于如何正确使用这些新元素，建议看看[这个网站](http://html5doctor.com)。

div 元素对文档而言并没有语义价值，只是借助类名作为添加样式的 “接入点” 而已。

#### 1.2.3 div 和 span

既然有了新语义元素，那么 div 元素是否就多余了呢？不是的。在没有合适的语义元素的情况下，div 仍然是给内容分组的一个不错的选择。有时候，会纯粹出于添加样式的目的而在文档中添加一个元素。比如，为实现居中布局而在整个页面外部包装一个元素。

如果有更具语义的结构化元素，那么务必使用它们，需要添加样式时再给它们一个适当的类名。但是，如果只需要一个无语义的元素作为额外的样式接入点，那就使用 div。

因此，**请确保只在额外提供样式接入的情况下才使用 div**，但也不要因为用了几个 div 就感到难为情。在后面介绍的几个具体的例子中，会看到，额外添加的无语义 div 元素对保证代码的清晰和可维护性非常重要。

与 div 元素类似的还有 span。同样，在无须表示语义、仅需添加样式的情况中，可以使用 span。与 div 不同，span 是文本级元素，可以用于在文本流中建立结构。不过在使用无语义的 span 之前，也一样要确保真的不需要使用任何语义元素。比如，使用 time 标记时间和日期，使用 q 标记引用，使用 em 标记需要强调的内容，使用 strong 标记需要重点强调的内容。

#### 1.2.4 重新定义的表现性文本元素

时至今日，`<b>` 和 `<i>` 可以算是幸存的表现性标记了，它们以前分别用于将文本标记为粗体（bold）和斜体（italic）。因为在旧有 Web 内容中，或者通过低水平 WYSIWYG 编辑器创建的内容中，这两个元素随处可见。HTML5 的编辑最终决定保留它们，但改变了它们的含义。

今天，`<i>` 元素用于标识与周围内容不一样的内容，一般在排版上会显示为斜体。HTML5 规范中给出的例子包括另一种语言中的习语，以及一艘船的名字。

`<b>` 元素的含义和 `<i>` 几乎一样，只是针对习惯上标记为粗体的内容。相关的例子包括商品或品类名。

这样的定义确实不够明确，但关键是要知道，**这两个元素与 `<em>` 及 `<strong>` 的区别在于，它们没有任何强调自己所包含内容的意味**。多数情况下，应该选择 `<em>` 或 `<strong>`，因为它们是用来强调及重点强调内容的语义正确的选择。

#### 1.2.5 扩展 HTML 语义

长时间以来，Web 开发者一直在探索给 HTML 有限的词汇表添加新的语义和结构的方式。为内容添加更丰富的语义，对 Web 和基于其构建的工具而言意义重大。虽然建设语义 Web 王国任重而道远，但不管怎么说，还是有了实质性的进步。利用这些成果，HTML 编写者可以为自己的文档添加更细粒度、更具表达性的语义。

**ARIA 的 role 属性**
很多新的 HTML5 元素都考虑到了无障碍访问的场景。比如，如果屏幕阅读器能够理解页面中的 nav 元素，那么它就可以利用这个元素帮助用户定位到相应的内容，或者在必要时返回导航。

另一种实现这个目标的方式是利用无障碍富因特网应用（ARIA，accessible rich Intermetapplication），它是对 HTML 规范的补充。ARIA 提供了针对辅助访问设备添加更多语义的手段，方式就是为文档中的不同元素指定其包含什么内容，或者说它们提供什么功能。比如，role="navigation" 这个 “地标角色” 属性用于声明一个元素具有导航的角色。其他角色有：

- banner
- form
- main
- search
- complementary
- contentinfo
- application

完整的 ARA 角色及其定义，参见 ARIA 规范。ARIA 还支持让开发人员指定更复杂的内容片段和界面元素。例如，在使用 HTML 创建一个音量滑动条部件时，应该包含值为 slider 的 role 属性：

```html
<div id="volume-label">Volume</div>
<div class="volume-rail">
  <a
    href="#"
    class="volume-handle"
    role="slider"
    aria-labelledby="volume-label"
    aria-valuemin="1"
    aria-valuemax="100"
    aria-valuenow="67"
  ></a>
</div>
```

属性 aria-labelledby、aria-valuemin、aria-valuemax 和 aria-valuenow 也分别提供了额外的信息，辅助阅读技术可以利用它们帮助残障用户使用这个滑动部件。

为 HTML 页面中的不同组件添加这些额外的语义属性，同样有助于为元素添加脚本和样式，是典型的多贏策略。

**微格式**
_目前最广泛采用的扩展 HTML 语义的方式是微格式_。微格式是一组标准的命名约定和标记模式，可用于表示特定的数据类型。微格式的命名约定是基于 vCard 和 iCalendar 等已有的数据格式制定的。比如下面的联系人信息就是以 hCard 格式标记的：

```html
<section class="h-card">
  <p>
    <a class="u-url p-name" href="http://andybudd.com/">Andy Budd</a>
    <span class="p-org">Clearleft Ltd</span>
    <a class="u-email" href="mailto:info@andybudd.com">info@andybudd.com</a>
  </p>
  <p class="p-adr">
    <span class="p-locality">Brighton</span>
    <span class="p-country-name">England</span>
  </p>
</section>
```

以微格式标记的联系人信息便于开发人员编写工具从中提取数据。比如可以编写一个浏览器插件，从你浏览的页面中发现微格式，然后让你把联系人信息下载到通讯录，或者把活动信息添加到你的日历应用。目前微格式支持的数据类型包括联系人、活动、菜谱、博文、简历，等等。

微格式也可以用于表示关系，比如一段内容与链接到该内容的另一个 URL 之间的关系微格式得以流行的原因之一是容易实现，迄今已经被 Yahoo 和 Facebook 等内容平台采用，而且已经直接添加到了 WordPress8 和 Drupal 等内容发布工具中。2012 年一项关于结构化数据实现的研究发现，微格式在 Web 上的应用最为广泛。不过最近微数据异军突起，也不容小觑。

**微数据**
微数据是跟 HTM5 一起，作为给 HTML 添加结构化数据的另一种方式而推出的。它的目标与微格式非常相近，但在把微数据嵌入内容方面则有所不同。下面看一看用微数据标记同样的联系人信息会是什么样：

```html
<section itemscope itemtype="http://schema.org/person">
  <p><a itemprop="name" href="http://thatemil.com/">Emil B</a></p>
  <span itemprop="affiliation" itemscope itemtype="http://schema.org/organization">
    <span itemprop="name">inUse Experience AB</span>
  </span>
  <a itemprop="email" href="mailto:emil@thatemil.com">emil@thatemil.com</a>
  <p itemprop="address" itemscope itemtype="http://schema.org/PostalAddress">
    <span class="addressLocality">Malm?</span>,
    <span class="addressCountry">Sweden</span>
  </p>
</section>
```

通过这个例子可以看出，微数据的语法比微格式要烦琐一些，不过这是有原因的。由于微数据设计的时候考虑到了可扩展性，它可以用来表示任意类型的数据。微数据只定义一些语法来表示数据结构，但自身并未定义任何词汇表。相反，微格式则定义了具体的结构化数据，比如 hCard 和 hCalendar。

微数据把定义特定格式的事交给了使用者或第三方。上述例子中使用的格式就是由 Bing、Google 以及 Yahoo 等搜索引擎共同创建的一个[词汇表](https://schema.org)。这几家搜索引擎使用它来辅助索引和排名页面，当然搜索爬虫也会使用这些词汇表，从你的内容中更高效地提取丰富的信息。

#### 1.2.6 验证

即使经过深思熟虑，标记已经非常语义化了，其中也仍然存在输入或者格式错误的风险。这些隐患会带来无法预料的麻烦。这时候就要使用验证了。

现实中的多数 HTML 文档并不是真正有效的 HTML。用规范编写者的话说，就叫作 “未遵行”（nonconformant）。这些文档中存在的问题有元素嵌套不对、包含未经编码的和号（&），以及缺少必要的属性等。浏览器对这类错误非常宽容，总会尝试猜测作者的意图。事实上，HTML 规范中也包含了如何处理无效 HTML 的规定，以确保浏览器厂商以一致的方式处理错误。

总体来说，浏览器如此大度地处理错误是个好事，但不代表可以因此而放弃自己的职守。都应该尽力写出有效的 HTML 文档，这样有利于更快地查找问题，避免错误泛滥。假如碰到一个渲染或布局上的 bug，时又找不出问题所在，最好先验证一下 HTML，以保证样式应用到了格式正确的文档上。

验证 HTML 的工具有很多。比如，可以使用 W3C 网站上的 [HTML 验证器](http://validator.w3.org/)，或者与之相关的插件。其中的 Web Developer 扩展，Firefox、Opera 和 Chrome 都支持。此外，如果项目有自动构建或测试环节，最好在其中加上 HTML 验证。

CSS 也是可以验证的。W3C 的 [CSS 验证器](http://jigsaw.w3.org/css-validator/)。可能认为验证 CSS 没有验证 HTML 那么重要，毕竟 CSS 中的错误一般不会导致 JS 出错，或者导致屏幕阅读器无法打开页面。但是，还是建议重视 CSS，保证其中没有什么低级错误。

根据 CSS 验证器设置而定，验证结果中可能包含很多关于厂商前缀的警告或错误。这些属性或值是浏览器厂商在实验性地支持某些 CSS 特性时使用的一种临时命名约定。比如，webkit-flex 这个 display 属性的值，就是标准 flex 属性值在 WebKit 浏览器上的实验性版本。这些地方虽然会被验证器标记为警告甚至错误，但文件依然能正常使用。总之，只要明白验证器给出的这些标记的真正含义就行了。

验证并不是最终裁决，很多本身很好的页面也会验证失败，这是由于使用了来自第三方或低水准 CMS 的内容，或者使用了试验性 CSS 特性。此外，验证器本身也可能会跟不上标准更新和浏览器实现的步伐。因此不要过于激进，只要把验证当作事先帮助发现一些低级错误的手段即可。

## 二. 添加样式

### 2.1 CSS 选择符

1. **基本选择符**

   - 类型选择符：用于选择特定类型的元素，类型选择符有时也被称为元素选择符。

   - 后代选择符：用于选择某个或某组元素的后代。后代选择符的写法是在两个选择符之间添加空格。
     类型选择符与后代选择符非常适合全面应用基础样式。

   - 想要更精确地选择目标元素，可以使用 ID 选择符和类选择符。顾名思义，这两个选择符通过对应 ID 和 class 属性的值来选择元素。ID 选择符由 `#` 号开头，类选择符由 `.` 开头。

2. **高级选择符**

   - 子选择符（`>`）：只选择一个元素的直接后代，也就是子元素。

   - 相邻同辈选择器（`+`）：选择位于某个元素后面，并与该元素拥有相同父元素的**第一个**元素。

   - 一般同辈选择符（`~`）：选择位于某个元素后面，并与该元素拥有相同父元素的元素的**所有元素**。

   `>` 和 `+` 在这里被称为组合子，因为它们描述了自身两侧的选择符组合的方式。

3. **通用选择符**：通用选择符（`*`）可以匹配任何元素。

4. **属性选择符**
   属性选择符基于元素是否有某个元素或属性是否有某个值来选择元素。

   ```css
   abbr[title] {
     cursor: help;
   }

   input[type='submit'] {
     cursor: pointer;
   }
   ```

   还可通过给属性选择符中的等号前面加上特殊字符，来匹配特定模式：

   - 匹配以某些字符开头的属性值（`^`）：`a[href^="http:"]`
   - 匹配以某些字符结尾的属性值（`$`）：`img[src$='.jpg']`
   - 匹配包含某些字符的属性值（`*`）：`a[href*="/about/"]`
   - 匹配以空格分隔的字符串中的属性值（`~`）：`a[rel~=next]`
   - 可以选择开头是指定值或指定值后连着一个短划线的情况（`|`）：`a[lang|=en]`
     上面的规则可以匹配属性值 en 和 en-us，暗示这个选择符很适合选择属性值中的语言代码。

5. **伪元素**
   有时候想选择的页面区域不是通过元素来表示的，又不想为此给页面添加额外的标记。CSS 为这种情况提供了一些特殊选择符，叫伪元素。如：可以使用 `::first-letter` 伪元素来选择一段文本的第一个字符。

   > **注意**：
   >
   > 1. 使用伪元素插入内容要小心！千万不能用他们插入对交互有实质影响的内容，以避免 CSS 不能正确加载。另外，屏幕阅读器也没有统一的方式解释伪元素，有的会直接忽略它们，有的则会读取其中的内容。
   > 2. 伪元素应该使用双冒号语法，这是为了与伪类区别开，伪类使用单冒号语法。

6. **伪类**

   可以使用伪类选择符，来为文档结构以外的情形添加页面样式。伪类选择符的语法是一个冒号开头，用于选择元素的特定状态或关系。

   > **注意**：很多元素都可以使用 `:hover`，但 在触摸屏和键盘等输入方式下不一定有悬停状态。因此，不能再重要的交互功能中使用 `:hover`。

   **目标与反选**
   另一个有用的伪类是 `:target`，它匹配的元素有一个 ID 属性，而且该属性的值出现在当前页面 URL 末尾的 `#` 号后面。如：打开链接 `http://example.com/blog/1/#comment-3`，找到该页面中标记为 `<article class="comment" id="comment-3">...</article>` 的元素，可以为它设置样式：

   ```css
   .comment:target {
     color: #fffec4;
   }
   ```

   反选伪类（`:not()`）专门用于排除某些选择符，它可以配合除了伪元素和它自身的各种选择符使用。

7. **结构化伪类**

   CSS3 新增了一大批与文档结构有关的新伪类，其中最常用的是 `:nth-child` 选择符，它可以接受 odd（奇数）和 even（偶数）作为参数。这个参数还可以是数值或数值表达式（an + b）。

   ```css
   tr:nth-child(3n + 4) {
     background: #ddd;
   }
   ```

   还有一个伪类选择符也支持这种表达式，`:nth-last-child()` 。这个选择符与 `:nth-child` 类似，只不过倒序计算。

   CSS2.1 中有一个选择第一个子元素的伪元素，叫 `:first-child`，相当于 `:nth-child(1)`。CSS3 又添加了一个选择最后一个子元素的伪元素，`:last-child`，对应 `:nth-last-child(1)`。此外，还有 `:only-child` 和 `:only-of-type`、`:only-last-of-type`。其中，`:only-of-type` 和 `:only-last-of-type` 会选择特定类型的唯一子元素。

8. **表单伪类**

   还有很多伪类专门用于选择表单元素。这些为了根据用户与表单控件交互的方式，来反映表单控件的某种状态。

   例如，HTML5 为表单输入框新增了几个属性，表示必填的 `required` 就是其中之一。可以使用 `:required` 伪类来选择带有 `required` 属性的表单元素。还可以使用 `:optional` 伪类，为没有 `required` 属性的控件添加样式。

   此外，还有针对有效和无效控件的伪类。为满足某个输入框要求填写特定类型内容（如电子邮件地址）的需求，可以根据输入框中当前内容的有效性，应用不同样式：

   ```css
   /* 如果输入框包含有效的电子邮件地址 */
   input[type='email']:valid {
     border-color: green;
   }
   /* 如果输入框中的内容不是有效的电子邮件地址 */
   input[type='email']:invalid {
     border-color: red;
   }
   ```

   还有针对 type 值为 number 的 `:in-range`、`:out-of-range`伪类，针对 readonly 属性的 `:read-only`伪类，以及针对没有 readonly 属性的 `:read-write`伪类。[更多信息](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes)

### 2.2 层叠

稍微复杂的样式表中都可能存在两条甚至多条规则同时选择一个元素的情况。CSS 通过一种叫作层叠（cascade）的机制来处理这种冲突。从 CSS 这个名字就可知这种机制有多重要，因为其中的 C 就是 cascade（SS 是 style sheet，即样式表）。

**层叠机制的原理是为规则赋予不同的重要程度**。最重要的是作者样式表，即由网站开发者所写的样式。其次是用户样式表，用户可以通过浏览器的设置选项，为网页应用自己的样式。排在最后的是浏览器（或用户代码）的默认样式表，它们一般都会被作者样式表覆盖掉。

为了给用户更高的优先权，CSS 允许用户使用 `!important`覆盖任何规则，包括网站作者使用 `!important` 标注的规则。`!important` 标注要放在属性声明的后面。

允许用户使用 `!important` 标注来覆盖规则，主要是出于无障碍交互的需要。比如，允许诵读困难的用户使用高对比度的用户样式表。归纳起来，层叠机制的重要性级别从高到底如下所示：

- 标注为 `!important` 的用户样式
- 标注为 `!important` 的作者样式
- 作者样式
- 用户样式
- 浏览器（或用户代理）的默认样式

在此基础上，规则再按选择符的特殊性进行排序。特殊性高的选择符会覆盖特殊性低的选择符。如果两条规则的特殊性相等，则后定义的规则优先。

### 2.3 特殊性

为了量化规则的特殊性，每种选择符都对应着一个数值。这样，一条规则的特殊性就表示为其每个选择符的累加数值。但这里的累加计算使用的并非十进制加法，而是基于位置累加，以保证 10 个类选择符（或者 40 个，甚至更多的类选择符）累加的特殊性不会大于等于 1 个 ID 选择符的特殊性。这是为了避免 ID 这种高特殊性选择符被一堆低特殊性选择符（如类型选择符）的累加值所覆盖。如果某条规则中用到的选择符不足 10 个，为简单起见，也可以使用十进制来计算其特殊性。

任何选择符的特殊性都对应于如下 4 个级别，即 a、b、c、d：

- 行内样式，a 为 1;
- b 等于 ID 选择符的数目;
- c 等于类（class）选择符、伪类选择符及属性选择符的数目;
- d 等于类型（type）选择符和伪元素选择符的数目。

特殊性计算示例：

| 选择符 | 特殊性 | 十进制特殊性 |
| ----------------- | ------- | ------------ |d
| style="" | 1,0,0,0 | 1000 |
| #content .date {} | 0,1,1,0 | 200 |
| p.comment {} | 0,0,1,1 | 11 |

> **注意**：通用选择符（`*`）的特殊性为 0，无论它在规则声明中出现多少次。

#### 2.3.1 利用层叠次序

如果两条规则特殊性相等，则优先应用后定义的规则，这一点非常重要。这意味着在写样式的时候，必须考虑规则在样式中的位置，以及选择符的次序。

对链接元素使用伪类，就是一个利用层叠次序的典型。如果每个选择符的特殊性都一样，那么它们的次序就很重要了。要是把 a:visited 选择符放在 a:hover 选择符后面，那么在访问过链接之后，悬停样式将不会起作用，因为已经被 a:visited 样式给覆盖了。

#### 2.3.2 控制特殊性

**理解特殊性是写好 CSS 的关键，而控制特殊性则是大型网站开发中最难处理的问题**。利用特殊性，可以先为公用元素设置默认样式，然后在更特殊的元素上覆盖这些样式。最好的做法是从一开始就简化选择符，降低特殊性，减少选择符之间的依赖。对样式进行更细粒度的控制。

### 2.4 继承

任何直接应用给元素的样式都会覆盖继承的样式。因为继承的样式没有任何特殊性，连 0 都算不上。继承是很有用的机制，有了它就可以避免给一个元素的所有后代重复应用相同的样式。合理利用继承有助于减少选择符的数量，降低复杂性。

### 2.5 为文档应用样式

为文档应用样式的方式不止一种，各有利弊。

#### 2.5.1 link 与 style 元素

可以把样式放在 style 元素中，直接放在文档的 head 部分。如果样式不多，又希望立刻应用它们，并且不愿意因为浏览器额外下载文件而耽误时间。可以使用这种方式。

不过，为了让样式表能在多个页面中重用，通常最好把它保存到一个外部文件中。如果样式在外部样式表中，那么有两种方式把它们链接到网页上。最常用的方式是使用 link 元素：

```html
<link href="/c/base.css" rel="stylesheet" />
```

除了 link 元素，还可以使用 `@import` 指令加载外部 CSS 文件：

```html
<style>
  @import url('/c/modules.css');
</style>
```

可以在 HTML 文档的 head 部分把 @import 指令放在 style 中，也可以在外部样式表中使用它。后一种用法意味着，如果网页记载外部样式表，那么浏览器后续可能还需要下载更多 CSS 文件。

表面上看，使用 link 和 @import 指令的结果没什么区别。实际上，link 是比 @import 指令更值得推荐的方法，背后有一些[非常重要的原因](#252-性能)。

使用 link 或 style 在 HTML 中添加多个样式表或样式块时，它们声明的次序就是它们在 HTML 源代码中出现的次序。

#### 2.5.2 性能

选择以什么方式把 CSS 加载到页面中，一定程度上决定了浏览器显示页面的速度。度量 Web 性能的一个重要指标就是网页内容实际显示在屏幕上需要多久。这个指标有时候也叫 “渲染时间” 或 “上屏时间”。现代浏览器在屏幕上渲染内容之前，至少需要两样东西：HTML 和 CSS 这意味着让浏览器尽快下载 HTML 和全部 CSS 极其重要。

不要把 CSS 放到 body 里或者放到页面底部，搞什么 “延迟加载”。浏览器只有掌握了布局页面的全部 CSS 信息，才能给出最佳响应。因为只有这样，它们才知道应该把页面渲染成什么样，从而一次性地把页面绘制到屏幕上，而非一边加载新样式一边重新调整页面。

1. **减少 HTTP 请求**
   在链接外部样式表时，保证链接的文件数量最少至关重要，因为每个文件都需要单独发送次 HTTP 请求。相应地，每次从服务器请求文件，浏览器都需要花一定的时间下载，然后还要花时间应用其中的样式。另外，额外的 HTTP 请求也意味着浏览器会向服务器发送多余的数据，比如 cookie 或请求首部。服务器也必须针对每个请求返回响应首部。两个文件要比一个包含相同 CSS 内容的文件在浏览器和服务器间传递的数据更多。

   线上网页最好把需要加载的 CSS 文件数量控制在 1 或 2 个。只用一个 link 元素加载 CSS 文件，然后在其中使用 @import，并不能把请求控制为 1 个，因为这意味着先需要 1 个请求下载链接的文件，此外还要发送额外的请求取得所有导人的文件。因此，在线上网页中尽量不要使用 `@import`。

2. **压缩和缓存内容**
   使用 GZIP 压缩线上资源也非常重要。CSS 压缩的比率很高，因为它的很多属性和值都是重复的。一般来说，CSS 文件压缩后会减少 70%~80%。这样显然可以减少带宽占用，从而为用户节省时间。多数 Web 服务器都会在浏览器支持的情况下启用自动压缩线上资源。

   类似地，让 Web 服务器帮设置一定的 CSS 文件缓存时间也很重要。理想情况下，浏览器应该只下载一次 CSS 文件，除非线上文件有变化。方法就是通过 HTTP 首部告诉浏览器，把文件缓存较长的一段时间，如果文件有修改，则通过文件名来 “清除缓存”。压缩和合理缓存内容是提升网站性能的最重要的两件事。

3. **不让浏览器渲染阻塞 JS**
   如果在 HTML 文档的 head 元素中加入了 script 元素，浏览器必须先把它链接的脚本下载下来，然后再向用户显示网页内容。换句话说，这种情况下的 HTML 和 CSS 解析完全被下载以及执行脚本阻断了，也就是所谓的 “渲染阻塞”。渲染阻塞会明显拖慢网站加载速度。为此，主流的做法是在 HTML 页面底部的结束标签 `</body>` 之前加载 JS。

   比较现代的做法是在 head 中使用 script 标签，但添加 `async` 和 `defer` 属性。给 script 标签加上 `async` 属性，会异步加载脚本，不阻塞 HTML 解析，但会在脚本加载完毕立即执行时阻断 HTML 解析。给 script 标签加上 `defer` 属性，同样会异步加载脚本，不同的是会在 HTML 解析完毕后再执行加载的脚本。这两个属性该用哪一个，还要看脚本本身的具体内容。

   使用以上方法加载 JS，可以确保浏览器首先解析 HTML 和 CSS，不受请求 JS 文件的影响。至于选择哪个方法，很大程度上取决于浏览器的支持情况：`async` 和 `defer` 属性是 HTML 中定义的，因此还比较新。IE10 和更早版本的 IE 并不支持或不完全支持它们。

## 三. 可见格式化模型

浮动、定位和盒模型是学习 CSS 需要掌握的几个最重要的概念。这几个概念决定了元素在页面是排布和显示的方式，是很多布局技术的举出。近年来，Web 标准也引入了专门用于控制布局的新规范。

### 3.1 盒模型

盒模型是 CSS 的核心概念，描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看做一个矩形盒子，这个盒子包含元素的内容、内边距、边框、外边距。

内边距（padding）是内容区周围的空间。给元素应用的背景会作用于元素内容和内边距。因此，内边距通常用于分隔内容，使其不至于散布到背景的边界。边框（border）会在内边距外侧增加一条框线，这条框线可以是实线、虚线或点划线。边框的外侧是外边距（margin），外边距是围绕在盒子可见部分之外的透明区域，用于在页面中控制元素之间的距离。

有一个与边框类似的属性，即轮廓线（outline）。这个属性可以在边框盒子外围画出一条线，但这条线不影响盒子的布局，也就是不影响盒子的宽度和高度。因此，outline 常用于调试复杂布局，或显示布局效果。

对元素盒子而言，内边距、边框和外边距不是必需的，因此它们的默认值都为 0。不过，用户代码样式表通常会给很多元素添加外边距和内边距。比如，标题通常就会带有一定的外边距，但外边距的值会因浏览器而异。

#### 3.1.1 盒子大小

默认情况下，元素盒子的 width 和 height 属性指的是内容盒子，也就是元素可渲染内容区的宽度和高度。这时候添加边框和内边距并不会影响内容盒子的大小，但会导致整个元素盒子变大。如果想给元素盒子的每一边都添加 5 像素的边框和 5 像素的内边距，同时又想让元素盒子的宽度为 100 像素，则应该把内容区宽度设置为 80 像素。如果这个元素盒子外围还有 10 像素的外边距，那么整个盒子占据空间的宽度就是 120 像素。

通过修改 box-sizing 属性可以改变计算盒子大小的方式。box-sizing 的默认值为 content-box，即把宽度值应用给内容区。通过修改 box-sizing 的值，设置元素的 width 和 height 属性，就可以影响元素盒子的不同区域，这对响应式布局非常有用。

如果把 box-sizing 的值修改为 **border-box**，那么 width 和 height 的值将会包含内边距和边框。此时，外边距仍然会影响盒子在页面中占据的整体空间，即它的宽度不会算到 width 中。这种计算盒子大小的方式更加直观。

#### 3.1.2 最大值和最小值

有时候，特别是在响应式布局中，给一个元素应用 min-width 和 max-width 值很有用。因为这样一来，块级盒子就可以默认自动填充父元素的宽度，但不会收缩到比 min-width 指定的值更窄，或者扩展到比 max-width 指定的值更宽。（第 8 章会讨论响应式设计及其与 CSS 的关系<!--TODO-->。）

与此类似的是 min-height 和 max-height 属性。不过在 CSS 中，设置任何高度值的时候都应该慎重。这是因为元素的高度通常应该取决于所包含的内容，不需要明确设定。否则，万一内容增多，或者文本字号变大，内容就可能跑到高度固定的盒子之外去。即使出于种种原因，需要明确设定默认高度，也最好使用 min-height，因为这个属性允许盒子随内容扩展。

### 3.2 可见格式化模型

常说 p、h1 和 article 这些元素都是块级元素。意思就是说，它们作为元素，显示为内容块或块级盒子（block box）的形式。相对而言，strong、span 和 time 被称为行内元素，因为它们的内容会以行内盒子（inline box）的形式显示在行内。

可以使用 `display` 属性改变生成的盒子类型。如果把 display 属性设置为 none，还可以让浏览器不为相应的元素生成盒子。如果不生成盒子，那么元素及其包含的内容就不会显示出来，也不会占用文档中的空间。

CSS 中有几种不同的定位模型，包括浮动、绝对定位和相对定位。除非特别指定，否则所有盒子都会在常规文档流中生成，即 position 属性的默认值为 static。顾名思义，常规文档流中元素盒子的位置，由元素在 HTML 中的位置决定。

- 块级盒子会沿垂直方向堆叠，盒子在垂直方向上的间距由它们的上、下外边距决定。

- 行内盒子是沿文本流水平排列的，也会随文本换行而换行。它们之间的水平间距可以通过水平方向的内边距、边框和外边距来调节。但行内盒子的高度不受其垂直方向上的内边距、边框和外边距的影响。此外，给行内盒子明确设置高度和宽度也不会起作用。

- **由一行文本形成的水平盒子叫行盒子**（line box），而行盒子的高度由所包含的行内盒子决定。修改行盒子大小的唯一途径就是修改行高（line-height），或者给它内部的行内盒子设置水平方向的边框、内边距或外边距。

- 当然，也可以把元素的 display 属性设置为 `inline-block`。这样设置之后，该元素就会像一个行内盒子一样水平排列。但这个盒子的内部仍然像块级元素一样，能够设置宽度、高度、垂直外边距和内边距。

- 使用表格相关的标记（table、tr、th 等）时，表格本身表现为块级元素，但表格的内容会根据生成的行和列排布。还可以通过设置 display 属性让非表格元素采用表格的布局方式。只要正确地应用 table、table-row 和 table-cell 等值，就可以实现表格布局，无须在 HTML 标记中使用表格标签。

后面的 Flexible Box Layout（也称为 Flexbox）和 Grid Layout 等 CSS 模块，又进一步扩展了 display 属性。通常，这些新布局模式会在它们的外部上下文中创建类似块级的盒子，但会为内部显示内容创建新的规则。

#### 3.2.1 匿名盒子

HTML 元素可以嵌套，元素盒子当然也可以嵌套。多数盒子都是基于明确定义的元素生成的。不过有一种情况，就算不明确定义元素也会生成块级盒子。比如，像下面这样，在 section 这个块级元素的开头加人 “some text”。此时，“some text” 就算没有定义为块级元素，也会被当成块级元素。

```html
<section>
  some text
  <p>Some more text</p>
</section>
```

这种情况下，这个盒子被称为**匿名块盒子**（anonymous block box），因为这个盒子并不与任何特定的元素相关。

类似的情况也存在于块级元素内部的文本级行盒子。假设有一个段落中包含三行文本，这三行文本的每一行都构成了一个匿名行盒子（anonymous line box）除了使用 :first-line 伪元素来添加有限的排版和颜色相关的样式之外，不能直接给匿名块盒子或匿名行盒子应用样式。**关键要知道，在屏幕上看到一切，都会从属于某个盒子**。

#### 3.2.2 外边距折叠

常规块盒子有一种机制叫作外边距折叠。外边距折叠的概念很简单，简而言之，**垂直方向上的两个外边距相遇时，会折叠成一个外边距。折叠后外边距的高度等于两者中较大的那一个高度**。当两个元素垂直堆叠时，上方元素的下外边距会与下方元素的上外边距相折叠。

**外边距折叠只发生在文档常规文本流中块级盒子的垂直方向上**。行内盒子、浮动盒子或绝对定位盒子的外边距不会折叠。

#### 3.2.3 包含块

知道什么决定一个元素的包含块非常重要，将内边距和外边距的值设置为百分比，包含块就是这些百分比值的计算依据。

确定元素的包含块，要看元素是如何定位的。如果元素的定位方式是静态定位（即不指定 position 的值）或相对定位，则其包含块的边界就计算到一个最近的父元素，该元素的 display 属性值必须能够提供类似块级的上下文，如 block、inline-block、table-cell、list-item 等。

默认情况下，width、height、margin 和 padding 的值为百分比时，就以该父元素的尺寸为计算依据。如果当前元素的定位模型改成了 absolute 或 fixed，那么计算依据就会发生变化。

#### 3.2.4 相对定位

把一个元素的 position 属性设置为 relative，该元素仍然会呆在原来的地方。但此后，可以通过设置 top、right、bottom 和 left 属性，使该元素相对于初始位置平移一定距离。比如设置 top 属性为 20 像素，该元素就会相对于其初始位置垂直向下平移 20 像素。而设置 left 属性为 20 像素，则会将该元素向右移动 20 像素，其左侧会出现空白。

无论是否位移，相对定位的元素仍然会在文档流中占用初始的空间。因此，这样平移元素会导致它遮挡其他元素。

#### 3.2.5 绝对定位

相对定位事实上是常规文档流定位模型的一部分，因为元素还是相对于它在常规流中的初始位置来定位。绝对定位则会把元素拿出文档流，因此也就不会再占用原来的空间。与此同时，文档流中的其他元素会各自重新定位，仿佛绝对定位的那个元素没有存在过一样。

绝对定位元素的包含块是距离它最近的定位祖先，也就是 position 属性设置为 static 之外任意值的祖先元素。如果没有这么一个定位祖先，那么它就相对于文档的根元素即 html 元素定位。文档的根元素也叫作起始包含块（initial containing block）。

与相对定位的盒子类似，绝对定位的盒子也可以相对于其包含块向上、下、左、右方向平移。平移绝对定位的元素提供了极大的灵活性，因为可以把元素移动到页面的任意位置。

绝对定位的盒子是脱离了常规文档流的，因此可能会遮挡页面上的其他元素。为了控制这些盒子层叠的次序，可以设置一个叫 `z-index` 的属性。[z-index](#612-定位与-z-index堆叠内容的陷阱) 属性值越大，盒子在层叠中的次序就越靠近用户的眼睛。用 z-index 控制盒子的层叠有不少值得探讨之处。

尽管绝对定位对于在页面上任意摆放元素非常有用，但近来已经很少被用来构建整体布局了。绝对定位的盒子脱离了常规文档流，因此很难用它们创建随视口宽度和内容长度变化而变化的自适应或者响应式布局。Web 技术的特点决定了不太可能指定元素在页面上的确切位置和大小。随着对其他 CSS 布局技术掌握得越发熟练，会发现绝对定位在整体布局上几乎没人用了。

#### 3.2.6 固定定位

固定定位是由绝对定位衍生出来的，不同之处在于，固定定位元素的包含块是视口（viewport）。因此，固定定位可用来创建始终停留在窗口相同位置的浮动元素。很多网站都使用这个技术让导航区始终保持可见，有的固定侧栏，有的固定顶栏。这样能确保网站的可用性，因为用户不必再费事寻找了。

#### 3.2.7 浮动

另一种可见形式化模型是浮动模型。浮动盒子可以向左或向右移动，直到其外边沿接触包含块的外边沿，或接触另一个浮动盒子的外边沿。浮动盒子也会脱离常规文档流，因此常规文档流中的其他块级盒子的表现，**几乎**当浮动盒子不存在一样。

**行盒子与清除**
浮动元素会脱离文档流，因此不会再像非浮动元素一样影响其他元素。实际上，严格来讲并非如此。如果浮动元素后面跟着的是常规文档流中的元素，那么这个元素的盒子就会当浮动元素不存在一样。但是，这个元素盒子中的文本内容则会记住浮动元素的大小，并在排布时避开它，为其留出相应的空间。从技术角度来讲，就是跟在浮动元素后面的行盒子会缩短，从而为浮动元素留空，造成文本环绕浮动盒子的效果。事实上，浮动就是为了在网页中实现文本环绕图片的效果而引入的一种布局模型。

要阻止行盒子环绕在浮动盒子外面，需要给包含行盒子的应用 `clear` 属性。clear 属性的值有 left、right、both、none，用于指定盒子的哪一侧不应该紧挨着浮动盒子。清除一个元素时，浏览器会在这个元素上方添加足够大的外边距，从而将元素的上边沿垂直向下推移到浮动元素下方。因此，如果给 “已清除的” 元素添加外边距，那么除非添加的值超过浏览器自动添加的值，否则不会看到效果。

浮动元素除了会导致后面的行盒子缩短，从而造成文本环绕效果之外，不会对周围的元素有任何别的影响，毕竟它已经脱离了文档流。但清除一个元素本质上会为所有前面的浮动元素清理出一块垂直空间。这就为使用浮动布局创造了条件，因为周围的元素可以为浮动的元素腾出地方来。

浮动的元素会被拿出文档流，所以只包含浮动内容的元素，无法在文档流中生成高度。这时，需要在这个元素内部某处应用 clear，在清除的元素上方创造出足够的垂直外边距，从而为包住浮动元素创造出空间，可以使用 :after 伪元素来模拟额外的清除元素：

```css
.block:after {
  content: ' ';
  display: block;
  clear: both;
}
```

#### 3.2.8 格式化上下文

当元素在页面上水平或垂直排布时，它们之间如何相互影响，CSS 有几套不同的规则，其中一套规则叫作格式化上下文（formatting context）。前面已经介绍了行内格式化上下文（inline formatting context）的一些规则。比如，垂直外边距对于行内盒子没有影响。

此外，有些规则规定了页面必须自动包含突出的浮动元素（否则浮动元素中的内容可能会跑到可滚动区域之外），而且所有块级盒子的左边界默认与包含块的左边界对齐（如果文字顺序是从右向左，那么与包含块的右边界对齐）。这组规则就是**块级格式化上下文**（block formatting context）。

还有些规则允许元素建立自己内部的块级格式化上下文，包括：

- display 属性值设置为 inline-block 或 table-cell 之类的元素，可以为内容创建类似块级的上下文

- float 属性值不是 none 的元素

- 绝对定位的元素

- overflow 属性值不是 visible 的元素

前面说过，块边界接触其包含块边界的规则同样适用于前面是浮动元素的内容。浮动元素从页面流中移出后，通过触发其后的元素中行盒子的缩短行为，制造了为自身腾出四周空间的视觉效果。而其后的元素仍然会按照需要，在浮动元素下方拉伸。

当一个元素具备了触发新块级格式化上下文的条件，并且挨着一个浮动元素时，它就会忽略自己的边界必须接触自己的包含块边界的规则。此时，这个元素会收缩到适当大小；不仅行盒子如此，所有盒子都如此。尽量基于简单且可预测的行为来创建布局，这样可以降低代码复杂度，并提高布局稳健性。

#### 3.2.9 内在大小与外在大小

CSS 的 Intrinsic and Extrinsic Sizing Level3 模块定义了一组可以应用给（min- 和 max-）width 和 height 属性的关键字，而非像素或百分比这种长度值。这些关键字代表了明确的长度，要么继承自周围的上下文（外在大小），要么源于元素自身的内容（内在大小），具体数值由浏览器决定。这样可以代替以往使用的隐含值，比如把某个属性设置为 auto，或者使用浮动或块级格式化上下文，在不设置 width 的情况下达到收缩适应的目的。

目前，支持这个模块中定义的关键字的浏览器还很少。但无论如何，这种更稳健的指定尺寸的方式在未来一定非常有用，毕竟可以省掉同时使用多种技术的麻烦。

### 3.3 其他 CSS 布局模块

对于 CSS 这种视觉表现语言来说，稳健又灵活的布局模型无论如何都是必需的。虽然道理显而易见，但这种模型的诞生却并不容易。过去，曾想方设法地利用这门语言中可用的特性来达成自己的目标，哪怕那些特性并不好用。比如最早我们曾使用表格布局，但问题是代码臃肿、语义不当。近来又在使用浮动和绝对定位，但这些技术同样也并非为页面布局而设计。无论是表格还是浮动与定位，都有非常严重的局限性，使用它们只是不得已的选择。

最近出现了一些专门针对创建灵活、稳健页面布局的 CSS 模块。这些模块的进度快慢不一，有的甚至还没有得到较多浏览器支持。后面会详细介绍其中几个模块，此处先概览一下它们的主要功能。

#### 3.3.1 弹性盒布局

弹性盒布局模块（Flexible Box Layout Module），常被称为 Flexbox，是 CSS3 新引入的一种布局模型。Flexbox 支持对子元素水平或垂直布局，以及设置这些子元素的大小、间距和对齐方式。此外，Flexbox 还支持改变元素渲染到页面上的次序，可以跟它们在 HTML 中的次序不同。作为 CSS 常规流模型（行内和块）的升级版，无论是调整内容本身还是适应内容大小，Flexbox 都做到了既精确又灵活。

[Flexbox](#63-flexbox) 已经得到浏览器的广泛支持，只是在旧版本正中缺乏支持或支持不完整。好在可以将 Flexbox 与浮动等其他技术组合使用，以确保跨浏览器布局的稳健。

#### 3.3.2 网格布局

网格布局（grid layout）是 CSS 中最早成熟的高层布局工具，目标是取代浮动和定位元素的布局方式。网格布局实现了源代码次序的完全分离，从内容结构和个别模块的表现中抽象出了网格系统。Flexbox 关注 “微观”，而网格系统关注 “宏观”，二者正好互补，网格布局还未得到广泛支持，但各家浏览器正在争先恐后地实现它。第 7 章将全面介绍网格布局<!--TODO-->。

### 3.3.3 多栏布局

多栏布局模块（Multi-column Layout Module）的用意很明确，就是实现内容的多栏布局。比如，要排成像报纸那样的多栏样式。可以先指定栏数，也可以先指定每一栏的宽度，然后让浏览器根据可用宽度自动确定栏数。当然，还可以控制栏间距，并在其中应用类似边框的视觉效果。因为多栏布局更倾向于排版而布局。

### 3.4 Region

CSS Regions Module Level 1 可以实现内容在不同元素间的灌文接排。可以把一个元素作为内容来源，但它不在常规文档流中，其内容可以灌排到页面中的其他占位元素。这意味着布局不再受 HTML 中元素次序的影响，也就是把布局表现从内容结构中解耦了出来。

使用 CSS Region 排出的板式，在以前是无法只用 CSS 实现的，它为将来在网页中再现印刷品的排版样式奠定了基础。不过，很少有浏览器厂商有兴趣实现 CSS Region，因此可能很长时间内都无法使用它。

## 四. 网页排版

排版是平面设计的基础。同样，排版在网页设计中也扮演着重要角色。

### 4.1 CSS 的基本排版技术

拿到一个页面时，所有设计师都会先考虑从基本的版式着手。从 body 元素开始，逐步细化，从而让整个页面具有基本的可读性、层次性和配色。浏览器有默认样式表，它为网页应用了一些必要的排版规则。

#### 4.1.1 文本颜色

对于网页而言，文本颜色也许是最基本的样式之一，但它的效果却很容易被忽视。默认情况下，浏览器会把绝大部分文本渲染为黑色（链接除外，它们的颜色是 “活力蓝”，白底黑字的对比度极高。足够高的对比度是确保网页阅读无障碍的关键，但也往往会被过分强调。事实上由于屏幕的高对比度，白底黑字会让大段文本显得过分密集，反而影响可读性。

#### 4.1.2 字体族

字体族（font-family）属性的值是一个备选字体的列表，用逗号分隔，按优先级从左到右排列。

这种后备机制是 font-family 属性的重要特性，因为不同的操作系统和移动设备可能安装了不同的字体。何况字体的选择也不仅仅是看某种字体是否存在。如果优先的字体中缺少文本中用到的字形，比如重读符号，浏览器会为缺失的符号向后查找其他字体。

关于什么操作系统中默认安装了哪些字体，有些人已经做过相关的[研究整理](https://www.cssfontstack.com)。

字体列表最后通常有 serif 和 sans-serif 被叫作**通用字体族**，充当没有选择的选择。此外，还有 cursive、fantasy 和 monospace 等通用字体族，只不过 serif 和 sans-serif 应该是最常用的两个。如果网页中要显示代码，应该首选 monospace 字体族，也叫“等宽字体”，因为 monospace 的每个字符的宽度都一样，不同行之间的字符可以完美对齐。fantasy 和 cursive 就没那么常用了，分别对应花式字体和手写字体。

> **注意**：列出包含空格的字体族名称时，引号不是非加不可，但最好加上。规范中只要求与通用字体族重名的字体族要加引号，但同时也建议给包含非标准符号的名称加引号，以防浏览器误判。

**字体与字型**
字型（typeface）、字体族（font-family）和字体（font）这 3 个术语经常有人分不清楚。所谓字型（也叫字体族），就是一组代表字母、数字及其他具有统一外观样式的字形（glyph）的集合字型包含的每种字形，通常有粗体、常规、细体、斜体等变体，能够以不同样式显示数值、连字等，还可能有其他变体。

最初，字体指的是一种字型中的某种特定变体所包含的所有字形的集合，由金属制成。这些选出来的字形会被装上印刷机。而在数字排版领域，字体通常指一个存有某种字型表示的文件。假设有一种字型叫 “CSS Mastery”，那么它可能只有一个字体文件，也可能包含多个字体文件，比如 “CSS Mastery 常规” “CSS Mastery 斜体” 或 “ CSS Mastery 细体” 等。

#### 4.1.3 字型大小与行高

几乎所有浏览器中 font-size 的默认大小都是 16 像素，除非用户修改过偏好设置。

`em` 单位用于 font-size 属性时，实际上是一个相应元素继承的 font-size 缩放因子。比如 h3 元素，字型大小就是 `1.314*16=21px`。虽然可以直接设置 21px，但 em 更灵活一些。多数浏览器都允许用户缩放整个页面，即使像素单位也可以缩放。而使用 em 之后，如果用户修改偏好中的默认 font-size 大小，那么相应元素的大小也会相应调整。

因为 em 单位基于继承的大小缩放，所以可以通过缩放父元素的 font-size 来修改页面局部的继承大小。但这样做也有问题（也是使用 em 经常出错的地方）：可能因为调整了某个元素在标记中的位置而意外改变其字型大小。因此，在使用相对长度值的时候，必须留意最终计算得到的值。

对于 font-size 属性，可用**百分比**代替 em。133.3% 在这里与 1.33em 没有区别，选择哪个完全取决于个人偏好。

而最灵活的方式则是使用 `rem` 单位。与 em 类似，rem 也是一个缩放因子，但它始终基于**根元素**的 em 大小缩放（根元素的 em，就是 root element em，即 rem），也就是基于 html 元素的 font-size 缩放。

当 em 用于计算盒模型的大小时，它不是基于继承的 font-size，而是基于元素自身计算的 font-size。因此，不同级别的标题对应的 font-size 是不一样的。为了得到一致的值（同时又要保证灵活），要么使用 rem，要么对每个标题级别都分别以 em 计算 margin-top 值。

rem 单位相对较新，但已经得到所有现代浏览器的支持。为了兼容 IE8 及更早版本的 IE，可以利用 CSS 的容错机制，在基于 rem 的声明之前再声明一个像素单位的值。

> 长度单位还有 mm、cm、in 和 pt 等**绝对物理长度**，这些主要是给打印样式准备的。网页设计不应该使用这些单位。本章不介绍打印样式表，但会在第 8 章<!--TODO-->介绍如何针对不同的媒体类型应用样式。

**基于比例缩放字型大小**
font-size 到底应该选多大，其实没有硬性要求。总体来说，就是要让文本足够大，让人能轻松地看清楚，同时要保证字型大小在当前上下文中比较合适。有些人相信自己的眼睛，认为看着舒服最重要；有些人则相信缜密的数学计算，处处奉科学原理为圭臬。

下面标题的大小大致符合一个叫做 “纯四度”（perfect fourth）的数学比例，即上一级标题会比下一级标题的字型大自身尺寸的 1/4，这里的数值经过舍入，并保留了 3 位小数：

```css
h1 {
  font-size: 2.315em; /* 37px */
}
h2 {
  font-size: 1.75em; /* 28px */
}
h3 {
  font-size: 1.314em; /* 21px */
}
```

此类比例关系对于初始阶段的网页设计至关重要。即使最终还是凭感觉设置字型大小，尽量位置类似的比例关系也是必要的。可以试一试 [Modular Scale 计算器](https://www.modularscale.com/)。

#### 4.1.4 行间距、对齐及行盒子的构造

深入剖析 CSS 行内格式化模型，同时多理解一些排版术语。下图展示了构成一行文本的各个部分：

![行内格式化模型的构造及相关概念](./image/行内格式化模型的构造及相关概念.jpg)

行内格式化，每行文本都会生成一个行盒子。行盒子还可以进一步拆分成表示行内元素（比如上面例子中的 `<strong>` 元素）的行内盒子，或者连接两个行内元素的匿名行内盒子。

行内盒子中的内容区显示文本。内容区的高度由 font-size 的测量尺度，即上图中 “Moon” 末尾那个 1em 见方的块，以及这个块与字形本身的关系来决定。西方传统排版术语 “em” 对应 CSS 中的 em 单位，这个概念最初指大写字母 “M” 的大小，但在网页排版中这个定义已经不适用了。

小写字母 “x” 的上边界决定了所谓的 “x 高度”。不同字体的 x 高度差异很大，因此很难就字体大小给出一个通用的建议。要想知道精确的字型大小，就必须分别测试。

然后，字形会被摆放在内容区中，每个字形都在垂直方向上不偏不倚，使得每个行内盒子的底边都默认对齐于靠近底部的共同水平线，这条线叫**基线**。内容区也不一定会限制住字形，比如某些字体中的小写字母 “g” 就会向下伸出内容区。

最后，**行高指的是行盒子的总高度。更通俗的叫法是行间距**，排版术语叫铅空，就是排字员用来隔开字符行的铅块。但与传统排版不同，CSS 中的 “铅空” 始终都会同时应用到行盒子的上方和下方。

计算方法如下：行盒子的整体行高减去 font-size，得到的值再平分成两份，也就是**半铅空**。如果 line-height 是 30 像素，而 font-size 是 21 像素，那么半铅空就是 4.5 像素。

> **注意**：如果行盒子中包含多个行高不一的行内盒子，那么这个行盒子的最终高度至少等于其中最高的行内盒子。

1. **设置行高**
   设置行高时，需要考虑当前字体大小。一般来说，行高取值在 1.2~1.5 范围内。关键是行与行之间既不能太密，也不能太疏。对于 x 高度较大的字体，行间距应该稍大一些。文本的长度和 font-size 也要考虑，短文本一般设置较小的 line-height。可以给 line-height 设置无单位数值、像素值、百分比值、rem 或 em 值。

   > **注意**：body 元素的所有子元素都会继承 line-height 的计算值。换句话说，就算 body 用的是百分比或 em，其子元素继承的都是计算后得到的像素值，但无单位的值就不会导致这个结果。因此，如果给 line-height 设置没有单位的值，那么子元素继承的是一个系数，永远与自己的 font-size 成比例。

2. **垂直对齐**
   除了 line-height，行内盒子也会受到 `vertical-align` 属性的影响。它的默认值是 baseline，即子元素的基线与父元素的基线对齐。

   其他关键字值有 sup、super、top、 bottom、text-top、text-bottom 和 middle。这些值或多或少都与内容区和父行盒子有着复杂的关系。仅举一例，text-top 或 text-bottom 会让当前元素的内容区与父行盒子的内容区顶部或底部对齐，但只有在行内盒子的 font-size 或 line-height 与其父元素不同时才会有影响。如前所述，关系复杂。

   或许通过设置长度值—无论是像素值，还是 font-size 的相对值（如 em 或 %）—让元素的基线偏离父元素基线是理解垂直对齐的最直观方式。

   > **注意**：影响文本行间距的值不只是 line-height。如果行盒子中有一个元素使用 vertical-align 调整了位置，那么它可能会扩展行盒子的高度。

> **注意**：与行内文本相比，[行内块和图片的垂直对齐行为](#622-行内块布局)稍有不同，因为它们不一定有自己的唯一基线。

### 4.1.5 文本粗细

使用 `font-weight` 属性来设置标题文本的粗细。有些字体的变体很多，比如 Helvetica Neue Light、Helvetica Neue Bold、Helvetica Neue Black。此时，可以不用给出变体的名字，而只使用关键字：normal、bold、 bolder 和 lighter。也可以直接给出数字值，都是 100 的整数倍：100、200、300、400，等等，最大为 900。

默认值 normal 对应 400，bold 对应 700，这两个粗细值是最常用的。关键字 bolder 和 lighter 的工作机制略有不同，它们的作用是在继承值的基础上把文本变粗或变细。

数字值 100~300 对应的字体名字中通常包含 “Thin” “Hairline” “Ultra Light” 和 “Light” 等字样。反之，数字值 800 或 900 对应的字体名字中可能包含 “Ultra Bold” “Heavy” 或 “Black"。500 或 600 则代表中等粗细。

Avenir Next 和 Segoe UI（都是首选字体）都包含很多粗细的变体。_如果某款字体缺少想要的粗细变体，浏览器会尽量模拟加粗效果，但无论如何不能模拟变细效果。这种模拟的结果往往差强人意_。

#### 4.1.6 字体样式

设置 `font-style: italic` 会从字型中选择斜体显示，前提是存在这个变体。如果不存在，浏览器会通过倾斜字体来模拟，但结果同样也不会太理想。斜体通常用于表示强调，或者表达一种不同的语气。除了 italic 和默认的 normal 以外，也可以给 font-style 设置 `oblique` 关键字（是倾斜文本的另一个变体），但它很少用，因为没有几款字体含有这种变体。

#### 4.1.7 大小写变换和小型大写变体

有时候，设计需要显示与 HTML 源码中不同的大小写。CSS 可以控制英文字母大小写，属性是 `text-transform`。在例子中，h1 元素中的文本是首字母大写的，但通过 CSS 强制把所有字母都显示为大写了：

```css
h1 {
  text-transform: uppercase;
}
```

除了 `uppercase` 这个值，还可以用 `lowercase` 把所有字母变成小写，用 `capitalize` 把每个单词的首字母变成大写，或者使用 `none` 显示 HTML 源码中的默认大小写形式。

**使用 font-variant**
CSS 还有一个属性 `font-variant`，可以通过值 `small-caps` 把英文文本转换成所谓的 “小型大写字母”。“小型大写字母” 也是一种字型的变体，虽然所有字母都大写，但只有首字母是正常大小，其他字母的大小跟原来小写时一样，就像缩小了似的。正确的 small-caps 变体很大程度上会依据字母的字形来变化，而不仅仅是简单地缩小字母。不过能做到这一点的多数是收费字体。浏览器会在没安装这些字体时尝试模拟类似的行为。可以通过 abbr 标签包含的首字母缩写来示范一下浏览器的行为：

```html
<abbr title="National Aeronautics and Space Administration">NASA</abbr>
```

同时还应用了 `text-transform: lowercase`，因为 HTML 源码中的 NASA 本来就大写了。还需要稍微缩小一点 line-height，因为 small-caps 会导致某些浏览器把内容盒子向下移动一点，从而影响整体行盒子的高度：

```css
abbr {
  text-transform: lowercase;
  font-variant: small-caps;
  line-height: 1.25;
}
```

CSS 2.1 只对 font-variant 属性规定了一个有效的值：small-caps。而 CSS Fonts Module Level 3 则大加扩展，增加了很多不同字形的输出选择。浏览器实现相对滞后，但好在有办法支持这些新选择。会在后面介绍高级排版技术时再讲<!--TODO-->。

#### 4.1.8 控制字母和单词间距

一般来说，控制字母和单词间距是字体设计师的事儿。不过 CSS 也提供了一些简陋的工具来控制这些。

首先是 `word-spacing` 属性，功能是控制词间距，很少用。它的值意味着在默认词间距基础上增加或减少一定的量，而默认词间距由当前字体中空白字符的宽度决定。

类似地，可以通过 `letter-spacing` 属性来控制字符间的距离。对于小写英文字母的文本来说，人为改变字母间距并不是好事，因为大多数字型的设计初衷都是让人更容易辨别整个单词，而随意调整字母间距可能导致文本难以辨别。对于大写字母（或小型大写字母）的文本而言，则要视情况而定。比如缩写词，稍微加大一点字母间距有助于阅读。

### 4.2 版心宽度、律动和毛边

接下来探讨一个对阅读体验有着重大影响的因素：行长。用排版的行话说，就是**版心宽度**。过长或过短的文本行会打断人的眼球移动，导致读者无法连续阅读，最后甚至读不下去。

一行文本到底多长才合适，并没有什么终极答案。字体不同、屏幕大小不同、文本内容不同，都会影响行长。只能根据过往的研究和专业人士的建议，在自己设计页面时定义尽量合适的长度。

Robert Bringhurst 的经典图书 _The Elements of Typographic Style_ 提到，主体内容的文本行长通常是 45~75 个字符，平均值为 66 个字符。排版专家 Richard rutter 发现这个建议同样适用于今天的网页，特别是大屏幕中的网页。对于小屏幕（或者远距离观看的大屏幕，如电影或投影）而言，行长至少也应该有 40 个字符。

**要控制行长，可以通过设定包含文本的段落、标题等元素的宽度来实现**。对于页面主体文本而言，Georgia 字体的字母相对较宽（因为其 x 高度较大），因此行长就要考虑使用前述范围的上限。为此，简单地将 article 元素的宽度设置为 36em（平均每个字符 0.5em），并令其在页面上居中。如果视口缩小到比这个值更窄，该元素会自动调整宽度。

```css
article {
  max-width: 36em;
  margin: 0 auto;
}
```

#### 4.2.1 文本缩进与对齐

默认情况下，文本都是左对齐的。文本左对齐有助于找到下一行，保持阅读节奏。对于连续的段落，或者为相邻段落设置 1 行的外边距，或设置段首缩进（`text-index`）。

段落的右边可能参差不齐。这种参差不齐的样式在排版上也有术语，叫做 “毛边”（rag）。在应用文本居中对齐时需要格外小心，除非行长很短。居中文本非常适合小型用户界面元素或短标题的布局，因为两端参差不齐会影响可读性。

`text-align` 属性可以接受下列任意一个关键字值：left、right、center 和 justify。CSS Text Level3 规范还额外定义了几个值，包括 start 和 end。这两个逻辑方向关键字与文本书写模式相对应：多数西方语言都是从左向右书写，因此如果文本语言是英语，那么 start 就代表左对齐，end 代表右对齐。而在从右向左书写的语言中（如阿拉伯语，就正好相反。如果给父元素设置了 dir="rtl" 属性，即从右向左显示，浏览器通常都会自动反转默认的文本方向。

给 `text-align` 属性应用 `justify` 值，可以在单词间平均分布间距，结果就是左右两端对齐消除毛边。这也是印刷业中经常采用的技术，原版包括连字符在内的字体特性都会被修整以适应页面空间。

网页又是另一种媒体，很多因素无法控制。屏幕大小不同、安装的字体不同、浏览器引擎不同，这些都会影响用户最终在页面上看到的结果。如果让文本两端对齐，可能会导致下图的结果，不易认读。由文本空白构成的 “串流”（river of whitespace）会出现，版心宽度越小就越严重。

![文本“串流”现象](./image/文本“串流”现象.jpg)

浏览器处理文本两端对齐时使用的算法挺粗糙的，不如传统出版效果好。虽然可以通过 `text-justify` 属性修改使用的算法，但浏览器对其多个值的支持较弱，基本上只涉及调整非西方语言的字形和单词。

有意思的是，IE 支持这个属性的一个非标准值 newspaper，它好像使用了更聪明的算法。该算法会同时调整字母间距和单词间距。

#### 4.2.2 连字符

如果仍然打算在页面中让文本两端对齐，那么连字符可能会有助于减轻串流问题。为此，可以手工在 HTML 中插入一个表示连字符的实体，即所谓的软连字符 **&shy;**。只有当浏览器需要断词换行时才会显示这个连字符。

![手工插入软连字符](./image/手工插入软连字符.jpg)

对于文章之类的长文本，手动逐个插入连字符并不现实。此时可以使用 `hyphens` 属性，让浏览器帮插入连字符。这个属性相对较新，因此一般要加上浏览器前缀才能生效。IE10 之前的版本、安卓设备中内置的 WebKit 浏览器，甚至连基于 Blink 的 Chrome 和 Opera 都基本不支持 `hyphens`。

要想使用自动连字符功能，需要保证两点：

1. 在网页 html 元素中设置语言代码

   ```html
   <html lang="en"></html>
   ```

2. 通过 CSS 将相关元素的 `hyphens` 属性值设为 auto。

   ```css
   p {
     hyphens: auto;
   }
   ```

要关闭连字符，可以将 `hyphens` 属性值设置为 manual，即手动模式。在手动模式下，软连字符机制会起作用。

#### 4.2.3 多栏文本

把整篇文章的宽度都限制为 36em 可以达到限制版心宽度的目的，但对于大屏幕而言，却又太浪费空间了，留着大片的空白很可惜！有时候，为了有效利用宽屏，可以把文本分成多栏，并对每栏的宽度加以限制。CSS Multi-column Layout Module 定义的属性可以把文本内容切分成多个等宽的栏。

“Multi-column Layout” 这个名字容易让人产生误会，以为使用它定义的属性，就可以在页面上创建带有栏和栏间距控制的网格布局。实际上并不是这样，这个模块定义的属性只是用来把网页中部分内容的版式转换成类似报纸上的分栏效果。当然，利用这些属性创建其他布局效果完全没问题，只是可能并非该模块的初衷罢了。

如果把之前设置的 max-width 增加到 70em，那么可以分成 3 栏。为此，要把 `columns` 属性设置为想要的最小宽度。栏间距通过 `colum-gap` 属性控制：

```css
article {
  max-width: 70em;
  columns: 20em;
  column-gap: 1.5em;
  margin: 0 auto;
}
```

![Multi-column-Layout](./image/Multi-column-Layout.jpg)

这里的 `columns` 属性是 `column-count` 和 `column-width` 属性的简写形式。如果只设置 `column-count` 属性，浏览器会严格生成指定数量的栏，不管宽度如何。如果同时设置了 `column-count` 和 `colum-width`，则前者会作为最大栏数，后者会作为最小栏宽。

```css
article {
  columns: 20em; /* 在保证最小宽度 20em 的前提下，自动设置栏数 */
  column-width: 20em; /* 同上 */

  columns: 3; /* 3栏，自动设置宽度 */
  column-count: 3; /* 同上 */

  columns: 3 20em; /* 至少3栏，每栏宽度至少 20em */
  /* 以下两条声明的組合相当于以上代码的简写形式：*/
  column-count: 3;
  column-width: 20em;
}
```

1. **后备宽度**

   为了在不支持多栏属性的浏览器中确保行长不会超过限度，可以在段落元素上应 max-width 属性。这样一来，旧版本浏览器只会显示一栏，但仍然能保证可读性：

   ```css
   article > p {
     max-width: 36em;
   }
   ```

2. **跨栏**

   在前面的例子中，文章中的所有元素都排在了栏内文本流中。其实可以让某些元素排到该本流之外，强制它们伸长以达到跨栏效果。下图中，文章标题和最后一段（包含来源链接）就横跨了所有栏：

   ```css
   h1,
   source {
     column-span: all; /* 或 column-span: none;，以关闭跨栏特性 */
   }
   ```

   ![column-span跨栏](./image/column-span跨栏.jpg)

   如果让位于文本流中间的一个元素横跨所有栏，那么文本会按照垂直切分后的几栏流动。在下图中，为 h2 元素应用了前面的规则，结果该标题前面后的文本分别灌入了各自的几个分栏。

   ![垂直切分多栏文本流](./image/垂直切分多栏文本流.jpg)

   几乎所有浏览器都支持上述多栏布局属性，IE9 及版本更早的 IE 除外。以下是几条使用建议：

   - 几乎所有浏览器都需要使用合适的开发商前缀。
   - 浏览器对多栏布局属性的实现存在不一致，而且还有一些 bug，其中多数集中于外边距折叠和边框渲染方面。

3. **垂直律动与基线网格**

   在排版时运用一些数学关系很有好处。比如，对于不同标题的大小，采用 “纯四度” 关系（比率约为 1.26）。同时，所有标题都应用了值为 1.5em（相当于一行正文高度）的 margin-top。此外，所有分栏的间距也是统一的。不少设计师非常信奉这种和谐的比例关系，把基本行高作为设计其他部分的基准。

   在印刷设计中，这种律动关系的应用非常普遍，结果就是正文文本都会排进基线网格。即使标题、引用或其他页面部件时不时会打破这种律动，大的格局也不会受影响。这样不仅有助于读者眼球移动时轻松对准文本，还可以在双面印刷时避免背面的文本透过纸面，因为两面都遵循相同的基线。

   在网页设计中，要保证基线准确可是麻烦多了，尤其是在视口会变、允许用户上传图片的情况下。不过在可能的情况下，还是有必要这样做的，比如使用多栏文本布局的时候。

### 4.3 Web 字体

目前为止，在示例中用到的都是用户电脑中安装的字体。Helvetica、Georgia 和 Times New Roman 等网页中常用的英文字体几乎每个电脑都有，因为 Windows 和 macOS X 操作系统多年来一直会预装它们。

多年来，设计师一直梦想着可以在网页中嵌入远程字体，就像在网页中插入图片一样。自 1997 年 IE4 面世以来，相应的技术就已经出现了，只不过到了 2009 年才被 Firefox、Safari 和 Opera 等浏览器普遍支持。

此后，Web 字体有了长足的发展。起初只是个人博客和网站的零星尝试，发展到今天，主流网站乃至政府机关的网站都开始采用定制的 Web 字体。

#### 4.3.1 许可

使用 Web 字体还有一个问题，那就是许可。最开始的时候，字体设计者在授权浏览器下载他们的字体方面非常谨慎，因为担心发生无法控制的侵权问题。这种担忧持续了几年才有所缓解。多数字体设计者都施加了安全限制。比如，只允许从指定的域名下载字体，或者要求定期改字体名，以防止盗链。

**Web 字体托管服务**
尝试 Web 字体最简单的方式，就是使用 Web 字体服务。有一些是收费的，比如 Adobe Typekit、Cloud.typography 以及 Fonts.com，它们会负责相关的一切。还有免费的 Google Fonts，是 Google 汇总并托管的一些免费字体。

这些在线服务会帮用户处理设计者的许可事宜、支持把字体转换为多种格式，确保下载字体包含正确的字符集以及一些优化。然后，通过它们的高速服务器把字体提供给使用者。

使用这些托管服务可以选择一次性许可，也可以选择长期租用。使用字体托管服务的好处是，复杂的事情不用考虑，只要关心如何在网站中使用这些字体就行了。

#### 4.3.2 @font-face 规则

嵌入 Web 字体的关键是 `@font-face` 规则。通过它可以指定浏览器下载 Web 字体的服务器地址，以及如何在样式表中引用该字体。

```css
@font-face {
  font-family: Vollkorn;
  font-weight: bold;
  src: url('fonts/vollkorn/Vollkorn-Bold.woff') format('woff');
}

h1 {
  font-family: Vollkorn, Georgia, serif;
  font-weight: bold;
}
```

前面的 `@font-face` 块声明了在 `font-family` 值为 Vollkorn 且为粗体时应用该规则。之后提供了一个 URL，供浏览器下载包含粗体字体的 Web 开放字体格式（WOFF，Web open font format）文件。

声明了新的字体 Vollkorn 后，就可以在随后的 CSS 中通过 `font-family` 属性正常使用它了。

1. **字体文件格式**
   虽然目前浏览器基本上都已经支持 Web 字体，但它们对字体文件格式的支持却不一致。字体格式的问题很复杂，涉及微软、苹果、Adobe 等公司的发展史。好在所有浏览器开发商都支持标准的 WOFF 格式，有的甚至支持较新的 WOFF2。如果项目需要支持 IE8 及更早版本的 IE、旧版本的 Safari 或早期的安卓设备，那么可能要多写几行代码，补足各种格式的字体文件，比如 SVG、EOT 和 TTF。

   > 如果获得了某款 Web 字体的使用许可，可以通过 Font Squirrel 生成其他格式。

   为了解决旧版本浏览器对字体格式支持的不一致问题，可以在 `@font-face` 规则中声明多个 src 值（与 font-family 很像），包括 `format()` 提示。然后，由浏览器来决定到底使用哪种格式。

   做到这一步，基本上就可以实现 Web 字体的跨浏览器支持了。比如以下的 `@font-face` 规则：

   ```css
   @font-face {
     font-family: Vollkorn;
     src: url('fonts/Vollkorn-Regular.eot#?ie') format('embedded-opentype'), url('fonts/Vollkorn-Regular.woff2') format('woff2'),
       url('fonts/Vollkorn-Regular.woff') format('woff'), url('fonts/Vollkorn-Regular.ttf') format('truetype'),
       url('fonts/Vollkorn-Regular.svg') format('svg');
   }
   ```

   以上例子涵盖了支持 EOT、WOFF（包括 WOFF2）、TTF 和 SVG 的所有浏览器，几乎是现在市面上能见到的所有浏览器了。而且，通过在 src 的值中使用查询字符串，甚至可以满足 IE6~8 的古怪行为。

2. **字体描述符**

   `@font-face` 规则可以接受几个声明，多数是可选的。最常见的列举如下：

   - font-family：必需，字体族的名称。
   - src：必需，URL 或 URL 列表，用于下载字体。
   - font-weight：可选的字体粗细，默认值为 normal。
   - font-style：可选的字体样式，默认值为 normal。

   > **注意**：这些声明与通常规则中的 font 属性不是一回事。这几个都不是属性，而是**字体描述符**（font descriptor）。它们不会改变字体，它们的值只是为了告诉浏览器在什么情况下可以触发使用这个特定的字体文件。

   如果这里的 font-weight 值为 bold，那么就是告诉浏览器：“如果 font-family 中字体的 font-weight 设置成了 bold，那么可以使用这里定义的字体文件。”此处有一个陷阱：假如 Vollkorn 只在这里定义了这么一次，那么其他粗细也可以使用这里的字体文件，无论是否匹配。这是由于标准规定的浏览器加载和选择字体的原则：正确的 font-family 优先于正确的粗细值。

   很多字型包含不同粗细、样式和变体的字体，因此可以在 `@font-face` 块中使用相同的 Vollkorn 名称，但引用不同的字体文件。在下面的例子中，加载了两种不同的字型，声明了具体的粗细值和样式对应的字体文件：

   ```css
   @font-face {
     font-family: AlegreyaSans;
     src: url('fonts/alegreya/AlegreyaSans-Regular.woff2') format('woff2'), url('fonts/alegreya/AlegreyaSans-Regular.woff')
         format('woff');
     /* 字体粗细和样式都为默认值 normal */
   }

   @font-face {
     font-family: Vollkorn;
     src: url('fonts/vollkorn/Vollkorn-Medium.woff2') format('woff2'), url('fonts/vollkorn/Vollkorn-Medium.woff') format('woff');
     font-weight: 500;
   }

   @font-face {
     font-family: Vollkorn;
     font-weight: bold;
     src: url('fonts/vollkorn/Vollkorn-Bold.woff2') format('woff2'), url('fonts/vollkorn/Vollkorn-Bold.woff') format('woff');
   }
   ```

   在随后的样式表中，通过声明不同的粗细值，就可以分别使用不同的字体文件：

   ```css
   body {
     font-family: AlegreyaSans, Helvetica, arial, sans-serif;
   }

   p {
     font-family: Vollkorn, Georgia, Times, 'Times New Roman', serif;
     font-weight: bold; /* 使用 Vollkorn bold 字体 */
   }

   h3 {
     font-weight: 500; /* 使用 Vollkorn Medium 字体 */
   }
   ```

#### 4.3.3 Web 字体、浏览器与性能

Web 字体给网页设计带来了很大的飞跃，但同时也给网页中的实际应用带来了一些麻烦。

首先，浏览器需要下载额外的字体文件，这显然会延长用户等待的时间。使用 Web 字体首先必须注意不要加载过多的字体文件。如果自己托管自己的自定义字体，那么要确保设置适当的缓存首部，以避免不必要的网络开销。除此之外，浏览器在渲染这些字体时也有一些问题。

在下载 Web 字体的时候，浏览器有两种方式处理相应的文本内容：

- 在字体下载完成前暂缓显示文本，术语叫 FOIT（flash of invisible text）。Safari、Chrome 和 IE 默认采用这种方式，问题是用户必须等待字体下载完成才能看到内容。如果用户的网络速度很慢，这个问题会非常明显。

- 在字体下载完成前，浏览器先用一种后备字体显示内容。这样可以避免因网速慢而引起的问题，但也会带来字体切换时的闪动问题。这个闪动有时候也被称为 FOUT（flash of unstyled text）。FOUT 影响用户感知的速度，特别是在后备字体与 Web 字体的大小相差较多的情况下。如果在字体下载完成并应用的瞬间，网页内容跳跃过大，用户可能会失去焦点。

如果想更好地控制浏览器处理 Web 字体的方式，包括如何显示 Web 字体和后备字体，那么可以选择使用 JS 加载字体。

#### 4.3.4 使用 JS 加载字体

最近的 CSS Font Loading 规范定义了一个用于加载字体的实验性 JS API，可惜这个 API 尚未得到浏览器的广泛支持。因此，需要借助第三方库来实现一致的字体加载体验。

Typekit 维护着一个开源 JS 工具，叫 Web Font Loader。这个库体积很小，在浏览器支持的情况下，它会使用原生的字体加载 API；在浏览器不支持的情况下，它会模拟相同的功能。这个库内置支持一些 Web 字体服务，比如 Typekit、Google Fonts 和 Fonts.com，同时也支持自托管的字体。

可以下载这个[库](https://developers.google.com/speed/libraries/#/web-font-loader)，也可以从 Google 的服务器上加载它。Web Font Loader 提供了很多有用的功能，其中最有用的就是确保字体加载的跨浏览器一致性。希望使用它达到的效果是，即使在网速慢的情况下也不会妨碍用户阅读内容。换句话说，想在目标浏览器中实现一致的 FOUT 行为。

Web Font Loader 为以下事件提供了接入点：

- loading：开始加载字体。
- active：字体加载完成。
- inactive：字体加载失败。

在下面例子中，需要把 `@font-face` 块中的所有代码转移到一个独立的样式表 alegreya-vollkorn.css，同时把它放在一个子文件夹 css 中。然后，需要在页面头部添加一小段 JS 代码：

```html
<script type="text/javascript">
  WebFontConfig = {
    custom: {
      families: ['AlegreyaSans:n4,i4', 'Vollkorn:n6,n5,n7'],
      urls: ['css/alegreya-vollkorn.css']
    }
  };

  void (() => {
    let wf = document.createElement('script');
    wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = true;
    let s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>
```

这段代码既负责加载 Web Font loader 脚本，又负责配置后面要使用的字体变体。描述变体的代码在 font-family 名称后面，比如 n4 表示 “normal 样式，400 粗细”，以此类推。在这个样式表中的字体加载后，脚本会自动给 html 元素添加生成的类名。这样，就可以在 CSS 中提前编写加载新字体的规则：

```css
body {
  font-family: Helvetica, arial, sans-serif;
}

.wf-alegreya-n4-active body {
  font-family: Alegreya, Helvetica, arial, sans-serif;
}
```

这两条 CSS 规则的含义是，在 Alegreya 字体加载前，使用准备好的后备字体。而在 Alegreya 字体加载后，脚本会给 html 元素添加 wf-alegreya-n4-active 类，于是浏览器马上启用新下载的字体。这样不仅能保证跨浏览器加载字体的一致性，还有机会为后备字体和 Web 字体分别调整版式。

**匹配后备字体大小**
通过在字体加载期间应用类似的规则，可以控制因 Web 字体与后备字体大小不同带来的版式抖动。希望，在 Web 字体替代后备字体的瞬间，版式抖动尽可能细微且不易被用户察觉。

在下面例子中，Alegreya 字体的 x 高度明显小于 Helvetica 和 Arial（后两个字体的尺寸差不多）。通过微调 font-size 和 line-height，可以让它们的高度尽量接近。同理，还可以通过 word-spacing 来微调字符宽度。这样做的结果是，使用后备字体时的版式与切换为使用 Web 字体时会相差无几。

```css
.wf-alegreyasans-n4-loading p {
  font-size: 0.905em;
  word-spacing: -0.11em;
  line-height: 1.72;
}
```

使用 Web Font loader 要注意的另一件事是在 web 字体加载后设置 `font-size-adjust` 属性。这个属性用于指定 x 高度与 font-size 的比率。在某个字形缺少合适字体的情况下，后备字体会被调整为该比率。这个比率通常是高度的一半（值为 0.5），但也可能不是，有可能导致后备字体与 Web 字体的差异非常明显。在这里用不着测量并设置一个数值，可以直接设置一个关键字 auto，让浏览器替做这件事：

```css
.wf-alegreyasans-n4-active body {
  font-size-adjust: auto;
}
```

### 4.4 高级排版特性

微软和 Adobe 在 20 世纪 90 年代开发的 OpenType 字体格式，支持在字体文件中包含字体的额外设定和特性。如果使用的字体文件（.ttf、.otf 或 .woff/.woff2 都有可能）包含 OpenType 特性，那么在多数现代浏览器中都可以控制更多的 CSS 特性。这些特性包括字距调整（kerning）、连字（ligature）、替代数字（alternative numeral0，以及饰线（swash）等装饰性笔画。

CSS 字体规范中也有许多与 OpenType 对应的属性，比如 font-kerning、font-variant-numeric 和 font-variant-ligatures。浏览器对这些属性的支持并不一致，但可以通过另一个更低级的属性 `font-fearture-settings` 来控制相应的特性。不过最好是两个属性都使用，因为也有浏览器支持上述的对应属性而不支持这个低级属性。

`font-fearture-settings` 接受一些用于切换特性的值，就是 4 个字母的 OpenType 代码，其中也可以带有数值。比如，可以启用下图所示的连字特性。

![font-fearture-settings连字特性](./image/font-fearture-settings连字特性.jpg)

字体设计者可以根据使用目的，为连字特性指定分类。为启用 Vollkorn 中内置的两种连字特性，标准连字（standard ligatures）和任意连字（discretionary ligatures），可以使用以下规则：

```css
p {
  font-variant-ligatures: common-ligatures discretionary-ligatures;
  font-feature-settings: 'liga', 'dlig';
}
```

对支持 OpenType 的浏览器，通过对应的 `font-variant-ligatures` 属性始终可以默认启用标准连字特性，因此前面第一条声明里就没有把标准连字特性写出来。有些浏览器支持 `font-feature-settings` 属性，但语法不一样。另外一些浏览器可能要求在这个属性前面加上开发商前缀。总之，启用常用（common）和任意（discretionary）连字特性的完整规则如下：

```css
p {
  font-variant-ligatures: discretionary-ligatures;
  -webkit-font-feature-settings: 'liga', 'dlig';
  -moz-font-feature-settings: 'liga', 'dlig';
  -moz-font-feature-settings: 'liga=1, dlig=1';
  font-feature-settings: 'liga', 'dlig';
}
```

下面稍微解释一下：

- 影响 OpenType 特性的标准方式是使用加引号的 4 个字符的代码，后接一个关键字 on 或 off（可选），也可以后接一个数字（可选）。代码表示特定的状态，如果不写，则使用默认值 on。

- 以数字 0 表示状态相当于关闭特性。如果特性只有 “开” 和 “关” 两个状态，那么 1 就表示 “开”。有的特性会包含多个 “状态”，可以通过相应的数字来选择，具体数字的含义取决于字体以及想启用的特性。

- 如果想一次性列出多个特性，值之间要用逗号隔开。

- 多数浏览器都以加前缀的属性实现这些特性，因此别忘了加上开发商前缀。

- 针对 Mozilla 浏览器的旧语法稍有不同：多个特性作为一个字符串写在一对引号中，特性之间以逗号隔开；每个特性的状态则以写在等号后面的数字表示。

完整的 OpenType 特性代码，可以在微软的[这个网页](https://docs.microsoft.com/zh-cn/typography/opentype/spec/featurelist)中找到。

#### 4.4.1 数字

有些字体中包含多种数字形式。Georgia 或 Vollkorn 等字体会默认使用老式的数字，也就是数字跟字母一样，有上伸部分（ascender）和下伸部分（descender）。Vollkorn 也包含线性数字，即所有数字都位于基线以上、具有与大写字母一样的高度。通过如下代码分别展示了老式数字和线性数字：

```css
.lining-nums {
  font-variant-numeric: lining-nums;
  font-feature-settings: 'lnum';
}
.old-style {
  font-variant-numeric: oldstyle-nums;
  font-feature-settings: 'onum';
}
```

![线性数字与老式数字](./image/线性数字与老式数字.jpg)

多数字体都有不同宽度的数字（比例数字），跟常规字母一样。如果想在表格或列表中垂直对齐数字，那么可能就需要表列数字。通过如下代码组合使用了下图中的表列数字和线性数字：

```css
table {
  font-variant-numeric: tabular-nums lining-nums;
  font-feature-settings: 'tnum', 'lnum';
}
```

![表列线性数字](./image/表列线性数字.jpg)

#### 4.4.2 字距选项及文本渲染

高品质字体中通常包含用于调整某些字形间距的数据。这种微调间距的过程叫作**字距调整**（kerning）。换句话说，有些字母之间需要加大间隔才不会显得拥挤，而有些字母之间需要缩小间隔才不会显得疏远。

浏览器在渲染文本时通常会基于已知的尺寸自动处理字距，不过也可以手动设置现代浏览器读取字距调整数据。为此，可以设置 `font-kerning` 属性，或者启用 OpenType 的 kern 特性

```css
.kern {
  font-kerning: normal;
  font-feature-settings: 'kern';
}
```

关键字 normal 告诉浏览器从字体中读取字距调整数据（如果有的话）。而 auto 关键字则允许浏览器自作主张，只在它认为合适的时候开启字距调整。比如，在文本很小的情况下，浏览器可能就不会多此一举。最后，如果要明确告诉浏览器不进行字距调整，就使用 none。

> **注意**：在有些浏览器中，启用其他 OpenType 特性（如连字）可能自动触发字距调整。因此，如果希望连字但不调整字距，就需要明确告诉浏览器不进行字距调整。反之，启用 kern 特性也可能触发常见或标准连字特性。

**不要使用 text-rendering 属性**
设置 `text-rendering: optimizeLegibility` 是启用字距调整并同时启用连字的另一种方式。这不是 CSS 标准的方式，而是 SVG 规范中的一个属性，用于告诉浏览器选一种方法来渲染 SVG 中的字母。这个属性的值还有 optimizeSpeed（性能优先）、optimizeGeometricPrecision（更精确）或 optimizeLegibility（可读性）。

这个属性出现时间不短了，也得到了浏览器较好的支持，因此很多网站会采用。在 WebKit 浏览器支持 font-feature-settings 属性以前，这个属性是在旧版浏览器中激活相应特性的唯一方法。然而，这个属性存在一些严重的渲染问题，建议最好不使用它。

### 4.5 文本特效

#### 4.5.1 合理使用文本阴影

CSS 的 `text-shadow` 属性可以用来给文本绘制阴影。给大篇幅的正文文本加阴影不是什么好主意，因为会降低可读性。对于标题或短文本，阴影倒是大有用武之地，非常适合模拟凸版印刷或者喷涂效果。

`text-shadow` 属性的语法非常直观，需要指定相对于源文本 x 轴和 y 轴的偏移量（可正可负）、模糊距离（0 意味着完全不模糊）和颜色值，由空格分隔：

```css
h1 {
  text-shadow: -0.2em 0.4em 2em #ccc;
}
```

除此之外，还可通过用逗号分隔来给文本添加多组阴影。多组阴影会按先后次序堆叠，先定义的在上，后定义的在下。

为同一段文本添加多组阴影可以模拟出压印或浮雕的效果，方法就是在文本上方和下方加上偏暗或偏亮的阴影。偏亮或偏暗阴影的偏移取决于文本相对于背景的明度。暗文本上方加亮阴影且下方加暗阴影就是通常的压印效果，反之亦然。以下代码示例展示了两种不同的效果：

```css
.impressed {
  background-color: #6990e1;
  color: #31446b;
  text-shadow: 0 -1px 1px #b3d6f9, 0 1px 0 #243350;
}
.embossed {
  background-color: #3c5486;
  color: #92b1ef;
  text-shadow: 0 -1px 0 #243350, 0 1px 0 #def2fe;
}
```

进一步发挥想象力，还可以利用多组阴影创造出 3D 效果，比如仿手写广告牌字体。沿对角线每隔 1 像素叠加一个实心阴影就可以创造出这个效果：

```css
h1 {
  font-family: Nunito, 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif;
  color: #d0bb78;
  text-transform: uppercase;
  font-weight: 700;
  /* 以 1px 为单位累加 */
  text-shadow: -1px 1px 0 #743132, -2px 2px 0 #743132, -3px 3px 0 #743132, /* ... */ -22px 22px 0 #743132,
    -23px 23px 0 #743132;
}
```

为了让文字的仿手写体效果更突出。首先，用一批白色阴影给文字加上轮廓。这是因为，广告画工为了在字母油漆未干时就可以继续画阴影，通常会在字母和阴影间留一些空隙。为了把文字边缘包住，得在各个方向上偏移，加上白色阴影。

其次，再运用一个技巧，让阴影颜色沿偏移方向渐变，从而更像 3D 效果。为此，需要亮阴影和暗阴影交错地偏移。这样，利用这些阴影的堆叠，就让一种颜色水平方向比较突出，另种颜色垂直方向比较突出。以下是实现技巧的代码：

```css
h1 {
  /* 省略了一些属性 */
  /* 首先，各个方向上的白色阴影构成轮廓 */
  text-shadow: -2px 2px 0 #fff, 0 -2px 0 #fff, 0 3px 0 #fff, 3px 0 0 #fff, -3px 0 0 #fff, 2px 2px 0 #fff,
    2px -2px 0 #fff, -2px -2px 0 #fff, /* 其次，交错叠加的阴影让颜色沿两个方向凸显 */ -3px 3px 0 #743b34, -4px 3px 0
      #a8564d, -4px 5px 0 #743b34, -5px 4px 0 #a8564d, -5px 6px 0 #743b34, /* 继续叠加 */ -22px 21px 0 #a8564d,
    -22px 23px 0 #743b34, -23px 22px 0 #a8564d, -23px 24px 0 #743b34;
}
```

几乎所有浏览器都支持 text-shadow 属性，只有 IE9 及更早的 IE 不行。对于支持它的浏览器而言，由于绘制阴影开销比较大，请不要滥用。

#### 4.5.2 使用 JS 提升排版品质

也有 CSS 不能完全胜任的情况，比如可以通过 `:first-letter` 伪元素选中一段文本的第一个字母，但没有选择符能单独选择其他字母。假如想让每个字母拥有不同的颜色，那唯一的办法就是把每个字母都单独包装在一个元素中，然后以元素为目标来选择。这个办法也不是十分可靠，特别是在无法手动控制标记的情况下。

好在可以通过 JS 来创建其他字母的接入点。jQuery 插件 lettering.js 可以帮上忙。

除了这个插件，还有海量的其他 JS 解决方案，可以帮助处理文本。下面推荐几个：

- fitText.js：由 Paravel 公司 lettering.js 开发团队开发的另一款 jQuery 插件，可以让文本随页面大小缩放。
- BitText.js：Filament Group 的 Zach Leatherman 写的脚本，可以让一行文本放大到尽可能与包含它的容器一般大。
- Widowtamer：Gridset.com 的 Nathan Ford 写的脚本，通过在一段的末尾每隔一定距离就在单词间插入非换行空白符，来防止出现意外的孤行。

## 五. 漂亮的盒子

HTML 文档中的所有元素都由矩形盒子构成的。

### 5.1 背景颜色

**颜色值与不透明值**
可以使用了十六进制表示法指定颜色。所谓十六进制表示法，就是一个 `#` 后面加上 6 位十六进制数字构成的字符串。这个字符串由 3 组数字（每组各 2 位）构成，每个数字的取值范围是 0-F。十六进制的意思就是每个数字都可能有 16 种不同的值，因此除了 0~9 这 10 个数，还要用 A~F 补足第 11-16 位数。

3 组数字分别表示颜色中的红、绿、蓝（RGB）通道的值。每种颜色通道的值有 256 种可能，也就是 2 位十六进制数所能表示的可能性（16×16=256）。如果 3 组数字中每组的 2 位数字相同，可以简写成 3 位数字，比如 `#aabbcc` 可以简写成 `#abc`。

> 颜色值也可以用预定义的关键字表示，比如 red、black、teal、goldenrod 或 darkseagreen。有些关键字的名字非常古怪，因为它们源自一个古老的图形处理系统，叫 X11。这个系统的开发者从一盒蜡笔的颜色中选取了这些关键字。实际上，除了有助于快速排错，好像没什么理由使用这些关键字。

RGB 值可以用另一种方式表示，即 rgb() 函数式表示法。RGB 的每个值可以是一个十进制数值，取值范围为 0-255；也可以是一个百分比值，取值范围为 0%~100%。用 rgb() 表示法表示 `rgb(186, 218, 85)`。

十六进制及 rgb() 函数表示法从 CSS1 诞生起就有了。CSS 规范之后又提供了新的表示颜色的方法：hsl()、rgba( )和 hsla()。

- **hsl() 函数式表示法**
  十六进制和 RGB 表示法反映的都是计算机如何在显示器上显示颜色，即红、绿、蓝三原色的混合。而 hsl() 函数表示法则反映了另一种描述颜色的方式：**色相-饱和度-亮度**（hue-saturation-lightness），即 HSL 模型。色相的值取自下图所示的色轮，在这个色轮上，颜色的融入关系取决于度数：红色在顶部（0 度），绿色在顺时针方向 1/3 圆的位置（120 度），而蓝色在 2/3 圆的位置（240 度）。

  ![hsl色轮](./image/hsl色轮.jpg)

  使用 hsl() 语法需要传入三个参数，第一个是角度，第二和第三个是百分比值。这两个百分比值分别代表 “颜料” 的量（饱和度）和亮度。以下是 hsl() 表示法的示例：

  ```css
  .box {
    background-color: hsl(74, 64%, 59%);
  }
  ```

  > **注意**：使用哪种表示法来表示颜色没有本质区别，它们只是表示同一事物的不同方法而已。

- **rgba()**
  rgba() 是 RGB 的加强版。其中，末尾的 a 表示 alpha，是用于控制透明度的阿尔法通道。如果想设置同样颜色的背景，但透明度为 50%，可以这样做：

  ```css
  .box {
    background-color: rgba(186, 218, 85, 0.5);
  }
  ```

  第四个参数值表示透明度，取值范围为 0~1.0，1.0 表示完全不透明，0 表示完全透明。

- **hsla() 表示法**
  hsla() 表示法。它与 hsla() 的关系跟 rgba() 与 rgb() 之间的关系一样，都可以接受一个表示透明度的参数，用以设置颜色的透明程度：

  ```css
  .box {
    background-color: hsla(74, 64%, 59%, 0.5);
  }
  ```

知道了如何控制颜色的透明度之后，还应该知道 CSS 也提供另一种方式来控制透明度，那就是 `opacity` 属性：

```css
.box {
  background-color: #bada55;
  opacity: 0.5;
}
```

这样会让 .box 元素拥有和前面的例子相同的颜色和透明度。那么两者有什么不同呢？在前面的例子中，只让背景颜色变得透明；而这里让整个元素都变透明了，包括**元素中包含的内容**。使用 `opacity` 把一个元素设置为透明后，将无法再让其子元素变得不那么透明。

实践中，这意味着带透明度的颜色值非常适合半透明的背景和或文本，而较低的不透明度则会让整个元素有淡出效果。

### 5.2 背景图片

添加背景颜色可以让页面色彩更加丰富。但有时候，也想使用图片作为元素的背景。CSS 为实现这个提供了充足的工具。

#### 5.2.1 背景图片与内容图片

如果图片从网页中去掉之后，网页本身仍然有意义，那么该图片就可以当作背景图片。如果网站的观感完全变了，但图片本身仍然有意义，那么该图片就可以当作内容图片。

背景图片有一个相关属性 `background-repeat` 可以让图片平铺到整个元素盒子。`background-repeat` 属性的默认值为 repeat，意思是背景图片要沿 x 轴和 y 轴重复。这个特性对花纹图案的背景图片非常有用，但对照片可能就不合适了。可以明确声明 repeat-x 或 repeat-y 来限定图片只沿某个轴的方向重复，还可以通过 no-repeat 完全禁止重复。

Level3 Backgrounds and Borders 规范重新定义了这个属性，扩展了语法，并增加了关键字。首先，支持以空格分隔的针对两个方向的关键字声明语法。换句话说，以下声明等价于使用 repeat-x：

```css
.profile-box {
  background-repeat: repeat no-repeat;
}
```

其次，增加了新关键字。在支持的浏览器中，可以单独或一起设置 `space` 和 `round` 关键字：

- `space`的意思是，如果（未经裁剪和缩放的）背景图片可以在元素内部完全重复两次以上，那么它就会重复相应的次数，重复的图片之间填充空白，从而让第一张和最后一张图片都紧挨着元素的边缘。
- `round` 则意味着图片会被缩放，从而恰好能在元素中重复整数次。

说实话，这些新的重复特性没太大用处。如果想用符号或图案作为背景，从而让设计保持某种对称性，它们可能有用，但同时也会带来如何设置图片宽高比的难题。当然，浏览器的支持也参差不齐。

#### 5.2.3 加载图片（以及其他文件）

使用 url() 函数式表示法时，可以使用相对路径，如 url(img/cat.jpg)。浏览器此时会在保存当前样式表的目录的 img 子目标中寻找图片。如果路径以一个斜杠开头，如 /img/cat.jpg，则浏览器会在相对于 CSS 文件所在域的顶级目录的 img 子目录中寻找图片。

这里也可以使用绝对路径，那就要把协议、域名、路径和文件名都写全，比如：`http://example.com/img/my-background.jpg`。

除了相对路径和绝对路径，加载图片（或其他资源）也可以不指向文件，而是在样式表中直接嵌入数据。这时候要用到**数据 URI**（data URI），数据 URI 的值是由文件中二进制编码的数据转换而来的长字符串。有很多工具可以帮助实现这种转换。

拿到转换得到的结果后，可以将其直接粘贴到 url() 函数中，同时也将这些数据保存在样式表里。下面是一个使用数据 URI 的例子：

```css
.egg {
  background-image: url(data:image/png;base64,ivBORWOKGgoAAAANSUhEUgAAAC BAAAAOAQAAAACkhYXAAAAAJElEQVR4AWP/R.,and so on, random (? data for a long time.*/4DWIMtzFJs99p9xkoXfsddZ/hlhiY/AYib1vsSbdn+P9vf/1/hV8//oBIIICRZ///r3sPMqHSPCN9MLvn1s6SfIbbUWF 174HkdTB5rWw/w51nN8VZIbrgJDuI/PMTRP7+ByK//68HkeUg8v3//W]kWwJ5GOR+w5Wyv8P1gsxB2EmwhYAgeerNiRVNy EAAAAASUVORKSCYII-);
}
```

开头的 **data:image/png;base64** 告诉浏览器后面是什么文件的数据，接下来的内容则全部是转换为字符的实际像素数据。

使用嵌入的数据 URI 有好处也有坏处。使用它主要是**为了减少 HTTP 请求**，但与此同时也会增加样式表体积，因此请慎重使用，只使用在一些小图标上。

#### 5.2.4 图片格式

网页中可以使用的图片格式很多，既可以作为内容图片，也可以作为背景图片。以下是简单的列举：

- JPEG：一种位图格式，有损压缩，压缩率越高，损失细节越多，适合照片。不支持透明度设置。
- PNG：一种位图格式，无损压缩，不适合照片（因为文件会很大），适合图标、插图等小尺寸文件。支持阿尔法透明度设置。
- GIF：早期的位图格式，与 PNG 类似，主要用于动图。严格来讲，除动图外，GIF 基本已被 PNG 取代。实际上 PNG 也支持动图，只是浏览器支持落后。GIF 支持透明度设置，但不支持阿尔法分极，因此边缘会有 “锯齿”。
- SVG：一种矢量图形格式，本身也是一种标记语言。SVG 可以直接嵌入到网页中，也可以作为资源引用；可以作为背景图，也可以作为内容图。
- WebP：Google 开发的一种新图片格式，结合了 JPEG 的高压缩率和 PNG 的阿尔法透明特性。目前，浏览器对 WebP 的支持还参差不齐，但应该很快会普及。

以上除了 SVG 都是位图格式的。位图意味着文件会包含每个像素的数据，拥有内在的维度（宽度和高度）。对于细节丰富的图片，比如照片或详细示意图，位图很合适。但很多情况下，真正合适的则是 SVG 图形，其文件中包含的是如何在屏幕上绘制图形的指令。由于包含的是指令，SVG 图形可以任意缩放，也可以在任意像素密度的屏幕上清晰呈现。换句话说，**SVG 图形永远不会丢失细节，也不会出现 “锯齿”**。

### 5.3 背景图片语法

#### 5.3.1 背景位置

背景图片的位置由 `background-position` 属性控制。

```css
/* 把背景图片定位到元素中心 */
.profile-box {
  width: 100%;
  height: 100%;
  background-color: #8da9cf;
  background-image: url(img/big-cat.jpg);
  background-repeat: no-repeat;
  background-position: 50% 50%;
}
```

`background-position` 属性既可以使用关键字，也可以使用像素、em 或百分比。最简单的情况下，可以只给两个值：一个表示相对于左侧的偏移量，一个表示相对于顶部的偏移量。

> **注意**：有些浏览器支持 `background-position-x` 和 `background-position-y` 属性，这两个属性分别用于独立地在每个轴向上定位图片。这两个非标准属性是 IE 最早提出来的，目前正在标准化的过程中。

如果使用像素或 em 单位来设置背景图片的位置，那么图片的左上角会相对于元素的左上角定位，也就是会偏移指定的数值。比如，要是在水平和垂直方向都指定了 20 像素，那么图片左上角就会偏移到距元素左边和上边均为 20 像素的点。如果设置背景图片的位置时使用了百分比，那么情况就不一样了。百分比值不像绝对数值那样会定位背景图片的左上角，而是定位图片中对应的点。如果水平和垂直方向都设置为 20%，那么定位的实际上是距图片左边和上边各 20% 的点，而这个点会与距离父元素左边和上边各 20% 的点重合。

![图片定位](./image/图片定位.jpg)

使用关键字来对齐背景图片，要在 x 轴上用 left、center 或 right，在 y 轴上用 top、center 或 bottom。顺序一般都是先 x 轴后 y 轴。这样既能保持一致，又能一目了然，还能避免错误。在只使用两个关键字的情况下，规范并没有限定顺序（如可以用 top left）但在一个关键字加上一个长度值的情况下，规则本身将无效，比如以下声明：

```css
.box {
  background-position: 50% left; /* 不要这样写 */
}
```

背景图片定位的这一限制一直是很多问题的来源。以下图为例，这里的文本内容长度不定，后面跟着一个图标，图标四周有空白。此时没办法使用像素或 em 来定位图标，因为不知道它距左边缘有多远。

![文本加靠右图标](./image/文本加靠右图标.jpg)

以前的解决方案有两种：

- 给这个图标一个包装元素，然后定位该元素；
- 使用背景图片，把 x 轴定位设为 100%，而图片右侧以透明像素形式加入空白区。

其中使用 CSS 的后一个方案并不完美，因为不能通过 CSS 控制空白区。好在 Level3 Backgrounds and Borders 规范给出了新方案。新语法允许给 `background-position` 添加外边空声明，先写边界关键字，再写长度值。代码如下：

```html
<p>
  <a href="/activate" class="link-with-icon">Activate flux capacitor</a>
</p>

<style>
  .link-with-icon {
    padding-right: 2em;
    background-image: url(img/icon.png);
    background-repeat: no-repeat;
    background-position: right 1em top 50%;
  }
</style>
```

这个例子意味着把图片定位在距离右边缘 1em、距离上边缘 50% 的位置。问题解决了！在 IE8 或 Safari7 及更早的版本不支持这个新语法。可以根据自己的情况，在可用的时候使用这个语法。

**calc() 函数**
使用另一个 CSS 特性，可以实现与前面示例相同的效果，但支持度可能更高一些。这个特性就是 `calc()` 函数式表示法。使用 calc() 可以让浏览器代替计算任何数值（角度、像素、百分比，等等），甚至还支持动态计算的混合单位。换句话说，可以让浏览器计算 “100% + x 像素”，而这非常适合某元素以百分比缩放或定位时与使用 em 或像素单位冲突的情况。

对于前面讨论的 “背景图片右侧定位” 问题，可以使用 calc() 表示法像下面这样表达同样的 x 轴定位：

```css
.link-with-icon {
  /* 为简洁起见，省略了其他属性 */
  background-position: calc(100%- 1em) 50%;
}
```

> **注意**：IE9 也支持 calc() 表示法，可惜与 background-position 一起使用时存在严重 bug，会导致浏览器崩渍。不过 calc() 的应用范围其实非常广泛，可用于计算元素大小、字体大小，等等。

calc() 函数表示法可以与 4 个操作符一起使用：加（+）、减（-）、乘（`*`）、除（/）。可以给 calc 传人多个值。

> **注意**：使用 calc() 时，需要在加号和减号两侧加空格。这是为了让浏览器把操作符与数值中的符号（如 -10px 中的负号）区分开来。

#### 5.3.2 背景裁剪与原点

默认情况下，背景图片是绘制在元素边框以内的。如果（使用下面介绍的 `background-origin`）把背景图片定位到边框下方，而边框又被设置为半透明，那么图片边缘就会出现半透明的边框。

使用 `background-clip` 属性可以改变这个行为。这个属性的默认值为 border-box，将其改为 padding-box 就可以把图片裁剪到内边距盒子以内。而 content-box 值则会把图片位于内边距及其之外的部分裁剪掉。

即使 background-clip 属性的值改变了，**背景定位默认的原点（开始定位背景图片的参照点）仍然在代码中声明的内边距盒子（padding-box）的左上角**。换句话说，定位值从元素边框内开始计算。

也可以使用 `background-origin` 属性控制原点的位置。这个属性与 `background-clip` 一样，也接受盒模型相关的几个值：border-box、padding-box、content-box。

`background-clip` 和 `background-origin` 都是 Level3 Backgrounds and Borders 规范定义的。

#### 5.3.3 背景附着

背景会附着在指定元素的后面，如果滚动页面，那么背景也会随着元素移动而移动。可以通过 `background-attachment` 属性改变这种行为。如果想让背景图在页面滚动时 “粘” 在页面上，可以使用以下代码：

```css
.protile {
  background-attachment: fixed;
}
```

除了 fixed 和默认值 scroll，还可以把 `background-attachment` 设为 local。这个属性值的效果不太容易通过纸面来展示。它与 scroll 的区别在于，scroll 会让背景图片相对于元素本身固定，而 local 则会让背景图片相对于元素中的内容固定。换句话说，如果元素设置了固定的大小，且 overflow 属性设置为 auto 或 scroll，因而其中的内容在超出元素范围时会出现滚动条，那么这种情况下，在元素内部滚动显示更多内容时，背景图片会随着内容移动。

桌面浏览器对 local 值的支持相对比较好，但相应的移动端浏览器则表现欠佳。当然，移动浏览器忽略这个属性（以及 fixed 值）是可以理解的。毕竟在触摸滚动的小屏幕上，元素内容滚动会造成可用性障碍。事实上，规范本身也允许在确实不合适的情况下忽略 `background-attachment` 属性。

#### 5.3.4 背景大小

如果使用了一张大图覆盖了整个元素。那么在小屏幕上，那么图片会被剪切掉。反之，如果屏幕特别大，那么元素边缘可能出现空白。要避免上述情况，不管页面如何缩放，都让内容保持自己的宽高比，就要使用 `background-size` 属性。

给 `background-size` 明确指定一个值，可以重新设置图片大小，也可以让它随元素大小缩放而缩放。要让图片随元素缩放而缩放，则必须使用百分比值。

> **注意**：百分比值并不是相对于图片固有大小，而是相对于容器大小。因此，简单地把图片宽度和高度都设置成百分比值，可能会因容器高度变化而导致图片变形。更好的做法是**只给一个维度设置百分比值**，另一个维度设置关键字值 auto。

百分比值赋予了控制的灵活度，但也不是任何情况下都适用。有时候，会希望背景图片的任何一边都不要被切掉。还有一种情况，希望背景图片始终都能完全覆盖元素。CSS 为此也提供了一些关键字值：

- **contain**
  可以把背景大小设置为 `contain`。这个值可以让浏览器尽可能保持图片最大化，同时不改变图片的宽高比。但浏览器会自动决定哪一边使用 auto 值，哪一边使用 100%。在高而窄的元素中，方形背景最多 100% 宽，因此垂直方向会出现空白；而在较宽的元素中，背景最多 100% 高，因此水平方向会出现空白。

- **cover**
  第二个关键字是 `cover`，意思是图片会缩放以保证覆盖元素的每一个像素，同时不会变形。在一个高而窄的元素中，元素高度会被填满，但图片左右两边会被切掉；而在一个较宽的元素中，元素宽度会被填满，但图片上下两边会被切掉。

#### 5.3.5 背景属性简写

CSS 背景有一个 `background` 简写属性，可以同时设置一堆背景相关的属性。通常，通过这个简写属性指定的具体属性值的顺序可以随意，浏览器会自己弄明白写的关键字和语法的含义。不过也有两点需要注意：

1. 因为两个长度值既可以用于 `background-position`，也可以用于 `background-size`，所以两个都需要声明，而且要先声明 background-position，后声明 background-size，值之间以斜杠（/）分隔。

2. 因为 `*-box` 关键字（border-box padding-box 或 content-box）既可以用于 background-origin，也可以用于 background-clip，所以有如下规则

   - 如果只存在一个 `*-box` 关键字，则 background-origin 和 background-clip 都取这个关键字值。
   - 如果存在两个 `*-box` 关键字，则第一个设置 background-origin，第二设置 background-clip。

下面是一个综合了各种背景属性的例子：

```css
.profile-box {
  background: url(img/cat.jpg) 50% 50% / cover no-repeat padding-box content-box #bada55;
}
```

> **注意**：使用 background 这个简写属性，它会把所有没有明确指出的属性都重置为其默认值。因此，如果要使用它，应该把它放在声明的第一位，然后再根据需要来覆盖特定的属性值。虽说使用简写属性可以少敲几下键盘，但一般而言，明确的代码更不容易出错，而且也更容易让人理解。

### 5.4 多重背景

一般来说只使用一张图片作为背景，但 Level3 Backgrounds and Borders 规范现在支持一个元素设置多个背景图片。因此，每个背景属性也就有了相应的多值语法，多个值由逗号分隔。下面就是一个例子，效果如下图所示：

```css
.multi-bg {
  background-image: url(img/spades.png), url(img/hearts.png), url(img/diamonds.png), url(img/clubs.png);
  background-position: left top, right top, left bottom, right bottom;
  background-repeat: no-repeat, no-repeat, no-repeat, no-repeat;
  background-color: pink;
}
```

![多重背景](./image/多重背景.jpg)

多重背景按声明的先后次序自上而下堆叠，最先声明的在最上面，最后声明的在最下面。背景颜色层在所有背景图片下面。

![多重背景上下堆叠](./image/多重背景上下堆叠.jpg)

也可以使用简写属性来声明多个背景图片：

```css
.multi-bg-shorthand {
  background: url(img/spades.png) left top no-repeat, url(img/hearts.png) right top no-repeat,
    url(img/diamonds.png) left bottom no-repeat, url(img/clubs.png) right bottom no-repeat, pink;
}
```

但这种语法只能在最后一个背景层声明一种颜色。如果随后的背景属性值少于背景图片的个数，那么相应的值会循环使用。这就意味着，如果所有背景图片的当前属性值都一样，那么只需要声明一个；如果是两个值交替，那么只需要声明两个。因此，前面例子中重复出现的 no-repeat 值，就可以写成下面这样了：

```css
.multi-bg-shorthand {
  background: url(img/spades.png) left top, url(img/hearts.png) right top, url(img/diamonds.png) left bottom, url(img/clubs.png)
      right bottom, pink;

  background-repeat: no-repeat; /* 用于 4 张图片 */
}
```

因为上述多值语法是在 Level3 规范中定义的所以一些旧版本浏览器不支持。多数情况下，通过添加一个单背景声明，可以实现还算不错的后备效果：

```css
.multi-fallback {
  background-image: url(simple.jpg);
  background-image: url(modern.png), url(snazzy.png), url(wow.png);
}
```

此时旧版本浏览器只会显示一个背景图片，忽略第二条声明，而新版本浏览器则会忽略第一条声明，因为第二条会覆盖它。

### 5.5 边框与圆角

现代浏览器对盒模型的边框都提供了一定的控制，包括插入图片和圆角，让边框不再是简单的矩形：

- 可以分别为盒子的各边设置边框，也可以一次性为四边设置边框。
- 可以使用 `border-width` 一次性设置所有边框的宽度，也可以使用 `border-top-width` 这样的方位属性设置某条边框的宽度。除非明确指定 `box-sizing` 属性，否则边框宽度会影响盒子的尺寸。
- 同理，可以使用 `border-color` 设置所有边框的颜色，也可以使用 `border-left-color`这样的方位属性设置某条边框的颜色。
- 边框的样式可以使用 `border-style`（或 `border-right-style` 这样的方位属性设置），取值中最常用的是 solid、dashed 或 dotted 等关键字。当然也有不太常用的，比如 double（在 border-width 指定的宽度表面绘制两条平行线）、groove 和 inset。这几个很少有人用。一是它们看起来让人觉得怪模怪样，二是这样一来就只能靠浏览器来决定边框的模样了。因为这几个关键字到底解释成什么样，规范里也没说。另外，可以通过 `border-style:none` 删除全部边框。
- 可以使用 border 简写属性来设置所有边框属性。具体来说，可以把所有边设置成相同的宽度、样式、颜色，比如 `border:2px solid #006;`。

#### 5.5.1 边框半径圆角

1. **边框半径简写**
   给 `border-radius` 属性一个长度值，就可以一次性设置盒子四个角的半径。

2. **更复杂的圆角语法**
   也可以使用简写语法分别设置每个圆角的半径，即从左上角开始，按顺时针方向依次列出各个值：

   ```css
   .box {
     border-radius: 0.5em 2em 0.5em 2em;
   }
   ```

   以上声明中每个值本身其实也是简写，它们各自表示相应圆角水平和垂直方向拥有相同的半径。如果想把每个角设置成非对称的，也可以用两组值分别指定两个方向的半径，先水平再垂直，两组值以斜杠分隔：

   ```css
   .box {
     border-radius: 2em 0.5em 1em 0.5em / 0.5em 2em 0.5em 1em;
   }
   ```

   如果对角的值相同，那就可以省略右下和左下角的值，因为在只有两个或三个值的情况下，其他值会自动填入：

   ```css
   .box {
     border-radius: 2em 3em; /* 右下角和左下角重用前面的值  */
   }
   ```

3. **设置一个角的半径**

   也可以使用 `border-top-left-radius`、`border-top-right-radius` 等属性设置某个角的半径。可以像前面一样，给这些针对个别角的属性指定一个值，从而得到一个对称的角。或者指定两个值，以斜杠分隔，分别控制水平和垂直两个方向的半径。

#### 5.5.2 创建正圆和胶囊形状

设置圆角半径，实际上还可以使用百分比值。在给 `border-radius` 指定百分比值时，x 轴和 y 轴分别相对于元素的宽度和高度来计算实际值。换句话说，可以很容易地把一个正方形的元素变成圆形，只要把圆角半径设置成至少 50% 就好。

实际上确实没理由给任何一个角设置超过 50% 的值。不过，应该知道：如果两个圆角的弧线相交，那么两个轴向就会分别缩小半径，直到圆弧不再相交。对于方形元素的对称圆角而言，任何大于 50% 的值都会得到圆形。对于圆角半径相同的一个矩形元素而言，结果可能是一个椭圆形，因为圆角在两个方向上是按照宽度或长度比例缩小的。

圆形是比较常见的界面元素，但椭圆形就不那么受欢迎了。有时候，更希望看到 “胶囊形”，即一个矩形的两端各带一个半圆形。这种形状在工程上称为 “长圆形”（obround）。百分比值和绝对值都无法直接实现这种形状，除非知道元素的大小，而这在网页设计中并不常见。

不过，可以利用 `border-radius` 计算上的一个特性来达到目的。圆角弧线为保证不相交会自动缩小半径。而在使用长度值(而非百分比值)时，半径并不相对于元素大小而缩小，最终会得到对称的效果。因此，在创建胶囊两头的半圆形时，可以故意指定一个比所需半径大的值，以得到半圆形：

```css
.obround {
  border-radius: 999em; /* 任意非常大的值 */
}
```

首先，矩形的方角变成圆角后，元素对布局的影响跟没变成圆角前一样，这是没有改变的。其次，改变的是变成圆角后元素的可点击（或“可触摸”）区域，会以变化之后的圆角为准。因此，在使用圆角矩形按钮时，需要保证可点击的面积不要太小。

#### 5.5.3 边框图片

Level3 Backgrounds and Borders 规范还允许开发者为元素指定一张图片作为边框。`border-image` 属性支持把一张图片切成 9 块，只管定义切图规则，浏览器会自动把每一块应用到指定的边框位置。而且通过运用所谓的 “九宫格缩放” 技术，边框图片不会在图片缩放时发生变形。

演示边框图片的典型示例，非相框莫属了。构成相框的图片是正方形的，边长为 120 像素。从上、右、下、左各方向内推 40 像素画一条虚线，就把它分成了 9 块。

![边框图片](./image/边框图片.png)

`border-image` 属性会自动把每一块中的图片作为背景应用到边框的相应位置：左上角的图片应用到元素左上角，上中部的图片应用到元素上方，右上角的图片应用到元素右上角，以此类推。默认情况下，中间那 1/9 会被忽略，也可以改变这个行为。

此外，也可以告诉浏览器让上、右、下、左方位的图片如何覆盖边框。比如，可以拉伸、重复或补白（即只重复能够完整显示的次数余下的空间以空白填充跟最新的 background-repeat 关键字很像）。默认情况下，每边中段的图片会拉伸。为了展示边框图片，必须设置适当的边框宽度，进而拉伸各个边框对应的图片。

```css
.motto {
  border: 40px solid #f9b256;
  border-image: url(picture-frame.png) 40;
  /* 与 border-image: url(picture-frame.png) 40 40 40 40 stretch; 效果相同 */
}
```

前面的代码会加载图片 picture-frame.png，在每边向内 40 像素的位置切开，拉伸上、右、下、左边中段的图片。

> **注意**：
>
> 1. 指定切片参考线位置的 “40 像素” 没有 px 单位，这是为了同时适应 SVG 和位图而使用的小技巧。
> 2. 必须把 border 简写（如果使用的话）放在 `border-image` 属性前面。这是因为规范规定简写语法会重置所有边框属性，不仅限于其自身指定的属性。

除了 border-image，还有针对每一边的边框图片属性。事实上，还有一堆属性可以用来控制边框图片。但开发者曾经非常期盼浏览器支持边框图片。究其原因，主要是可以借助它来创建圆角边框。既然已经有了 `border-radius`，那又何必舍近求远呢。

### 5.6 盒阴影

讲完了背景图片和边框，接下来再看一种给页面添加视觉效果的方式：阴影。CSS 属性 `box-shadow· 可以给元素添加阴影，而且这个属性浏览器基本都支持，

`box-shadow` 属性的语法与 `text-shadow` 类似，但有一些新东西。

比如，下面的代码给用户头像加了一个阴影：

```css
.profile-photo {
  box-shadow: 0.25em 0.25em 0.5em rgba(0, 0, 0.3);
}
```

这个例子中代码的语法跟 text-shadow 完全一样：头两个值表示 x 轴和 y 轴的偏移；第三个值表示模糊半径（阴影边界的模糊程度）；最后是颜色，使用 rgba()。而且阴影的形状跟盒子的圆角也是一致的。

#### 5.6.1 扩展半径：调整阴影大小

box-shadow 比 text-shadow 稍微灵活一点。比如，可以在模糊半径的值后面再加一个表示扩展半径，用于扩展阴影的大小。这个值默认为，即阴影与所属元素一样大。增大这个值阴影相应增大，负值导致阴影缩小。

```css
.larger-shadow {
  box-shadow: 1em 1em 0.5em 0.5em rgba(0, 0, 0, 0.3);
}
.smaller-shadow {
  box-shadow: 1em 1em. 5em -0.5em rgba(0, 0, 0, 0.3);
}
```

#### 5.6.2 内阴影

box-shadow 的另一个比 text-shadow 更为灵活之处是可以使用 `inset` 关键字。这个关键字可以为元素应用内阴影，即把元素当成投影表面，可以创造一种背景被 “镂空” 的效果。比如，可以给个人页面顶部背景应用内阴影，制造一种在页面上凹陷或者被头像及其他页面内容并遮住的感觉。相应的代码如下

```css
.profile-box {
  box-shadow: inset 0 -0.5em 0.5 em rgba(0, 0, 0, 0.3);
}
```

#### 5.6.3 多阴影

与 text-shadow 类似，也可以给一个元素应用多个阴影，以逗号分隔多组值。下面这个例子中的阴影应用 “平铺” 技术，完全没有模糊半径。

如果省略模糊半径或者把它设置为 0，那么得到的阴影边界是清晰的。这样就可以摆脱原先伪装阴影的局限，把阴影当成不影响布局的 “额外盒子”，用于实现各种效果。

比如，考虑到 border 只能给元素添加一个边框（不算 double 关键字），可以利用这个技术给元素添加更多 “边框”。通过给阴影一个值为 0 的模糊半径，就可以通过不同的扩展半径值来生成多个类似边框的区域。由于阴影不影响布局，这个效果又类似 outline 属性。

```css
.profile-photo {
  box-shadow: 0 0 0 10px #1c318d, 0 0 0 20px #3955c7, 0 0 0 30px #546dc7, 0 0 0 40px #7284d8;
}
```

### 5.7 渐变

在背景上使用渐变色是一种常见设计，能给页面增加一种纵深感。要实现这种效果，可以使用带渐变的图片，但 CSS 也提供了一种绘制渐变图的机制。这个机制包含多种渐变方案，可以与任何接受图片的属性联合使用，包括 background-image。假设有一个个人主页，用户尚未上传背景图片，此时希望显示一个渐变背景：

```css
.profile-box {
  background-image: linear-gradient(to bottom, #cfdeee 0%, #8da9cf 100%);
}
```

#### 5.7.1 浏览器支持与浏览器前缀

现代浏览器都支持 CSS 渐变，但 IE9（及更早版本的 IE）和 Opera Mini 是例外。有些旧版本的 WebKit 浏览器只支持线性渐变。

> **注意**：自从被 Safari 作为非标准属性引入至今，渐变的语法也经历了几次变化。视需要支持的浏览器而定，可能需要同时用到 3 种不同的渐变语法，还有各种前缀。

#### 5.7.2 线性渐变

前面的例子使用了 `linear-gradient()` 函数，沿一条假想线，从元素顶部到底部绘制了一个渐变背景。这条线的角度由这个函数的第一对关键字（to bottom）表示，其后是由逗号分隔的色标。色标用于在渐变线上标出颜色发生变化的位置，在这个例子中，位置 0% 处的颜色是浅蓝灰色，而位置 100% 也就是元素底部的颜色是深蓝色。

渐变线的方向可以使用关键字 to，再加上一个表示边（top、right、bottom、left）或表示角（top left、top right、bottom left、bottom right）的关键字来指定，后者指定的是对角线。渐变线总是始于元素的一个边或一个角，然后穿过元素的中心区域。此外，还可以使用 deg 单位指定渐变线的角度，0deg 表示垂直向上，增大角度值就意味着沿顺时针方向旋转，直到 360 度，跟 HSL 色轮类似。此时，度数表示绘制渐变的方向，因此起点就在指定的相反方向。比如下面就是一个 45 度角的渐变：

```css
.profile-box {
  background-image: linear-gradient(45deg, #cfdfee, #4164aa);
}
```

此时，渐变线的起点并不是背景图片区域的边，而是自动延长到区域的角，即 0% 和 100% 恰好是背景图片区域的两个角的位置。

**默认值及色标位置**
线性渐变的默认方向是自上而下（to bottom），而 0% 和 100% 别表示第一个和最后一个色标的位置，因此前面第一个例子实际上可以简写如下：

```css
.profile-box {
  background-image: linear-gradient(#cfdfee, #8da9cf);
}
```

新增色标若未指定位置，则在 0% 100% 范围内取均值。比如，有 5 个未指定位置的色标那么它们的位置分别为 0%、25%、50%、75% 和 100%：

```css
.profile-box {
  background-image: linear-gradient(red, green, blue, yellow, purple);
}
```

除了百分比，还可以使用绝对值指定色标位置，比如：

```css
.profile-box {
  background-image: linear-gradient(#cfdfee, #8da9cf 100px);
}
```

这行代码生成的渐变是顶部从浅蓝色开始，往下到 100 像素位置时过渡到深蓝色，然后一直到背景图片区域底部都是同样的深蓝色。

#### 5.7.3 放射渐变

放射渐变从一个中心点开始向四周扩散，覆盖的范围可以是圆形或椭圆形。放射渐变的语法稍微复杂一些，涉及如下属性：

- 放射渐变的类型：圆形（circle）或椭圆形（ellipse）

- 射线半径决定渐变范围大小。圆形只接受一个半径值，而椭圆形接受 x 轴和 y 轴两个方向的半径值。椭圆形可以接受任意长度或百分比值，百分比值相对于对应轴向的背景图片大小。圆形只接受长度值，不接受百分比值。此外，还可以使用关键字，关键字代表渐变区域结束的位置：`closest-side` 和 `farthest-side` 分别表示渐变区域延伸至最近边还是最远边，`closest-corner` 和 `farthest-corner` 分别表示渐变区域边缘接触最近角还是最远角。

- 渐变区域中心的位置使用类似 background-position 属性的相对值，但前面要加 `at` 关键字，以说明它们不表示大小。

- 色标沿渐变扩展方向指定，以逗号分隔。

下面就是一个放射渐变的例子：

```css
.profile-box {
  background-image: radial-gradient(circle closest-corner at 20% 30%, #cfdfee, #2c56a1);
}
```

这样就会得到一个圆形放射渐变，中心点为 x 轴方向 20%、y 轴方向 30%，圆周范围到与最邻近的角接触为止。在圆周外部，由终点色标颜色覆盖整个背景图片区域(见图 5-28)。

![圆形放射渐变](./image/圆形放射渐变.jpg)

下面是一个居中的椭圆形放射渐变：

```css
.profile-box {
  background-image: radial-gradient(#cfdfee, #2c56a1, #cfdfee, #2c56a1, #cfdfee, #2c56a);
}
```

代码中并没出现声明椭圆、居中和覆盖整个元素（扩展至最远角）的关键字，因此使用的都是它们的默认值。但即便如此，重复多次的渐变色标也很冗余，于是就有了接下来要讲的重复渐变。

#### 5.7.4 重复渐变

重复渐变函数可以沿渐变直线（或射线）重复某个渐变色标组合，重复次数视其大小（由 background-size 决定）及允许的大小（元素大小）而定。以下代码是重复的线性渐变：

```css
.linear-repeat {
  background-image: repeating-linear-gradient (#cfdfee, #2c56a1 20px);
}
```

以下代码是重复的放射渐变：

```css
.radial-repeat {
  background-image: repeating-radial-gradient(#cfdfee, #2c56a1 20px);
}
```

#### 5.7.5 把渐变当作图案

渐变不一定需要很多像素来过渡，它也可以是突然的变化，从而形成锐利的线条或圆环。再搭配可以相互叠加的多重背景，就可以通过声明语法创造出简单的背景图案，甚至都无须打开图形处理软件。

创造边缘锐利的图案，关键在于正确地放置色标。比如，要绘制一条垂直线，就要把相邻的两个色标重叠在一起，让渐变无从发生。

```css
body {
  background-color: #fff;
  background-image: linear-gradient(transparent, transparent 50%, rgba(55, 118, 176, 0.3) 50%);
  background-size: 40px 40px;
}
```

在有些浏览器中，图案边缘也不是绝对锐利，而是每一侧都有 1 像素的模糊。随着浏览器渐变渲染性能的提升，这种现象也会有所改进，改进之后对追求细节的图案会有很大提升。

![颜色突变](./image/颜色突变.jpg)

没有在整个元素上使用多个线性渐变，而是只使用了一个，然后通过背景相关的属性控制其大小和重复。这样不仅能控制线条的多少，还不影响色标。然后再添加一个类似的水平方向的渐变，就完成了一张 “桌布” 似的花格图案。

```css
.body {
  margin: 0;
  background-color: #fff;
  background-image: linear-gradient(transparent, transparent 50%, rgba(55, 110, 176, 0.3) 50%), linear-gradient(to right, transparent, transparent
        50%, rgba(55, 110, 176, 0.3) 50%);
  background-size: 40px 40px;
}
```

不难想象，通过组合线、角（填充了一半对角线的线性渐变）圆、椭圆等简单图形，就可以得到各种各样的图案。渐变图案、盒阴影以及伪元素，这些加起来完全可以代替图片来实现各种创意。

> **注意**：虽然渐变可以代替外部图片，但其本身也可能影响性能，特别是在资源有限的设备上，比如手机。放射性渐变尽量少用为妙。

### 5.8 为嵌入图片和元素添加样式

文档中的图片与其他元素不同，它本身是有像素宽度和高度的，而且宽度和高度的比例固定。在可伸缩的设计中，元素宽度要随浏览器窗口宽度变化而变化，此时也需要 CSS 来控制图片及其他嵌入的元素。

> **注意**：根据需要把图片渲染成不同大小（所谓的响应式图片）对性能影响很大。第 8 章在讨论响应式技术时会重新提起<!--TODO-->。

#### 5.8.1 可伸缩的图片模式

怎么做到让图片伸缩的同时，既不会超出其固有尺寸，又不会破坏其宽高比例?可以使用 Richard Rutter 最早提出的[方案](http://clagnut.com/blog/268)，该方案的核心如下所示：

```css
.img {
  max-width: 100%;
}
```

max-width 属性意味着图片会随着包含它的容器缩小而缩小，但在容器变大时，它不会大到超过自身的固有尺寸。在上述代码基础上稍加扩展，就可以涵盖更多的情况：

```css
img {
  width: auto;
  max-width: 100%;
  height: auto;
}
```

为什么要增加两条属性声明呢?这是因为有时候某些设计者或内容管理系统，会在 HTML 源代码中给图片添加 width 和 height 属性。这里把 width 和 height 设置为 auto，某种程度上可以覆盖之前的声明，同时也可以解决
IE8 在不声明 width 时无法正确缩放图片的问题。

#### 5.8.2 控制对象大小的新方法

有时候，可能需要根据显示容器设置 img 或其他嵌入对象（video 或 object 元素）的大小。举例来说，有一个矩形的图片，但希望通过 CSS 将其设置为方形。这时候可以使用一些最近标准化并被浏览器实现的新属性，这些新属性支持对上述类型元素更灵活的控制。比如使用 `object-fit` 属性，可以像使用 `background-size` 属性一样，保持元素的宽高比：

```css
img {
  width: 200px;
  height: 200px;
}
img.contain {
  object-fit: contain;
}
img.cover {
  object-fit: cover;
}
img.none {
  object-fit: none;
}
img.scaledown {
  object-fit: scale-down;
}
```

下图展示了 `object-fit` 属性的几个关键字对不能按固有大小显示的图片所产生的效果。

![object-fit属性的不同关键字对图片产生的不同影响](./image/object-fit属性的不同关键字对图片产生的不同影响.jpg)

`object-fit` 属性的默认值为 fill，意味着图片内容会在必要时拉伸以填满容器，因此可能破坏宽高比。

cover 和 contain 则与 background-size 属性中对应的关键字作用相同。none 会采用图片固有大小，不管容器有多大。最后，scale-down 会自动从 none 和 contain 中选一个，哪个结果尺寸小就用哪一个。最终的图片会居中，但可以通过 `object-position` 重新设置，与定位背景图片时类似。

#### 5.8.3 可保持宽高比的容器

对于具有固定宽高比的位图，把高度设置为 auto，只改变宽度，或者把宽度设置为 auto，只改变高度，都是可以的。

但如果是没有固定宽高比的元素呢?如何使其在可伸缩的同时保持固定宽高比?iframe 和 object 元素就属于这种情形，某些情况下的 SVG 内容也是。常见的例子是在页面中通过 iframe 嵌入一段视频：

```html
<iframe
  width="420"
  height="315"
  src="https://www.youtube.com/embed/dqw4w9wgxce"
  frameborder="0"
  allowfullscreen
></iframe>
```

如果像这样给它设置一个可伸缩的宽度：

```css
iframe {
  width: 100%; /* 或者其他任何比例 */
}
```

就会导致 iframe 宽度为 100%，而高度始终是 315 像素。因为视频本身也有宽高比，所以希望这里的高度也可以自适应。

此时无论把 iframe 的高度设置为 auto 还是删除 height 属性都不管用，因为 iframe 本身没有固定的宽高比。此外，这样做很可能导致 iframe 的高度变成 150 像素。为什么是 150 像素?CSS 规范指出，对于没有指定大小的可替代内容（如 iframe、img、 object），最终的默认大小为 300 像素宽或 150 像素高。

要解决这个问题，需要借助一些巧妙的 CSS 技术。首先，把 iframe 包在一个元素里：

```html
<div class="object-wrapper">
  <iframe
    width="420"
    height="315"
    src="https:////www.youtube.com/embed/dqw4w9wgxcq"
    frameborder="0"
    allowfullscreen
  ></iframe>
</div>
```

然后，让这个包装元素的尺寸与要嵌入的对象具有相同的宽高比。简单计算一下，用原始高度 315 像素除以原始宽度 420 像素，结果是 0.75。换句话说，高度是宽度的 75%。

接下来，将包装元素的高度设置为 θ，但把 padding-bottom 设置为 75%：

```css
.object-wrapper {
  width: 100%;
  height: 0;
  padding-bottom: 75%;
}
```

内边距和外边距如果使用百分比值来设置，那它们的实际值是基于包含块的宽度来计算的。这里的宽度是 100%（与包含块宽度相等），因此内边距就是包含块的 75%。于是就创建了一个具有宽高比的元素。

最后，在这个包装元素中绝对定位嵌入对象。尽管包装元素的高度是 0，仍然可以通过绝对定位把嵌入对象放到一个 “可保持宽高比” 的内边距盒子里：

```css
.object-wrapper {
  width: 100%;
  height: 0;
  position: relative;
  padding-bottom: 75%;
}
.object-wrapper iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
```

这样就可以在页面中包含可伸缩的嵌入对象了。下边通过 3 张图解释了整个过程。

![创建可保持宽高比的容器](./image/创建可保持宽高比的容器.jpg)

如果后来又不想让包装容器的宽度是 100%了，那么必须重新计算 padding-bottom。为此，再嵌套一层包装容器，就可以避免这种情况，进一步提升灵活性。这是因为只需要设置最外层的容器宽度即可，内部的包装容器还是 100%宽，不用改。

前面的技术是由 Thierry Koblentz 推而广之的，详细的技术分析请移步这个[链接](https://alistapart.com/article/creating-intrinsic-ratios-for-video)。

#### 5.8.4 减少图片大小

如果网页中要用到图片，一定要确保图片不会超出必要大小。没错，CSS 可以帮助缩放或裁剪，但每个多余的像素都会影响性能：下载时间会加长，电池消耗会增加，CPU 也会因缩放图片而浪费时间。

减少图片大小的第一步是优化图片。图片文件中经常包含一些元数据，它们对浏览器显示图片没有用处。有一些程序和服务可以帮剔除这些数据。Addy Osmani 对此写过一篇评测文章 Tools for Image Optimization。他在文章中提到的很多工具都可以作为任务自动执行，第 12 章会再讨论任务执行工作流<!--TODO-->。

对于内容比较简单的 PNG 图片，可以通过减少图片中用到的色彩数量来有效压缩图片大小。如果图片中使用了半透明通道，那么多数图形处理软件都只允许导出为 PNG24 格式。实际上，更简单（也更小的）PNG8 格式也可以包含半透明通道，所以把 PNG24 转换成 PNG8 可以实现压缩效果。有一些在线服务，如 [TinyPNG](https://tinypng.com)，可以转换 PNG，还有支持不同操作系统的软件可以选择。Photoshop 的新版本也已内置这个转换功能。

如果使用 SVG 图形，那应该知道多数处理 SVG 的图形编辑器都会输出很多不必要的数据。Jake Archibald 的 OMGSVG 可以优化 SVG，通过调整一系列参数让文件瘦身，这个工具甚至离线也可以用!

## 六. 内容布局

网页是由不同内容块构成的：标题、段落、链接、列表、图片、视频，等等。这些元素可以按照主题组织起来，比如一个标题，几段文本，外加一张图片就是一篇新闻报道。通过控制每个组件内部元素的位置、大小、顺序，就可以更好地传达它们的功能与含义。所有内容块会进一步组织成整个页面的布局。本章仍然聚焦于个别的内容块，从而深入理解如何对每个内容块进行布局。

前几章也大致讲过使用定位和浮动来实现布局，这两种手段各有千秋。此外，也可以使用表格显示模式和行内块来实现布局，当然也各有各的优缺点 CSS 新增的 Flexible Box Layout Module（或 Flexbox）为内容块布局提供了一大批顺序、方向、对齐及尺寸相关的属性。Flexbox 是非常强大的布局功能。

### 6.1 定位

定位并不适合总体布局，因为它会把元素拉出页面的正常流。反过来看，这也正是定位在 CSS 中之所以重要的原因。本节将简单讨论一下定位在哪些情况下最合适。以下是第 3 章中相关内容的简单总结：

- 元素的初始定位方式为**静态定位**（static），意思是块级元素垂直堆叠。
- 可以把元素设置为**相对定位**（relative），然后可以相对于其原始位置控制该元素的偏移量，同时又不影响其周围的元素。与此同时，这也为该元素的后代元素创造了定位上下文。这一点也是相对定位真正的用处。
- **绝对定位**（absolute）支持精确定位元素，相对于其最近的定位上下文:或者是其非静态定位的祖先元素，或者是 html 元素。绝对定位的元素会脱离页面流，然后再相对于其定位上下文进行定位。默认情况下，它们会被浏览器定位于之前静态定位时所处的位置，但不会影响周围的元素。然后，可以相对于定位上下文来改变它们的位置。
- **固定定位**（fixed）与绝对定位基本类似，只不过定位上下文被自动设置为浏览器视口。

#### 6.1.1 绝对定位的应用场景

绝对定位非常适合创建弹出层、提示和对话框这类覆盖于其他内容之上的组件。它们的位置以通过 top、right、bottom 和 left 属性控制。关于绝对定位，了解以下知识可以写出更高效的代码：

1. 利用初始位置
   比如有一篇介绍太空飞船的文章，想添加一些行内的评注。这些评注最好以气泡图的样式显示在文章外部的空白区域。

   ![在文章旁边显示评注](./image/在文章旁边显示评注.jpg)

   每个评注组件都是一个 aside 组件，实际位置在它们指向的段落后面：

   ```html
   <p>This is a fake article[...]</p>
   <aside class="comment">Ive never done this，Is that really true?</aside>
   <p>You may think[...]</p>
   ```

   为了让评注显示在段落之后，需要使其绝对定位。不必为了在垂直方向上准确地定位它们而给出确切的上偏移量。绝对定位的元素默认会待在自已静态定位时的地方，因此第一步是让评注显示在其初始位置。

   接下来需要把评注向左和向上偏移，把它定位到之前段落的旁边。这听起来像是要使用相对定位，但元素不能同时既是绝对定位又是相对定位。如果此时使用方向性偏移属性（top、right、left 和 bottom），那就既要用到定位上下文，又要设置确定的偏移量。但在这里完全可以通过负外边距来移动元素：

   ```css
   .comment {
     position: absolute;
     margin-left: -9.5em;
     margin-top: -2.5em;
   }
   ```

   在 CSS 中，负外边距是完全有效的，它们有如下有趣的行为：

   - 左边或上边的负外边距会把元素向左或向上拉，盖住其旁边的元素。
   - 右边或下边的负外边距会把相邻元素向左或向上拉，盖住设置了负外边距的元素
   - 在浮动的元素上，与浮动方向相反的负外边距会导致浮动区域缩小，使得相邻元素盖住浮动的元素。而与浮动方向相同的负外边距会在该方向上把浮动的元素向外拉。
   - 给未声明宽度的非浮动元素应用负外边距时，左、右负外边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素。

   对评注气泡组件而言，使用左和上负外边距把元素拉到位的做法，与使用相对定位很相似。

2. 创建三角形

   在评注气泡组件中，指向前面段落的小三角形又相对于评注气泡进行了绝对定位。它是通过伪元素创建的，使用了一种很古老的基于边框的技巧。

   ```css
   .comment:after {
     position: absolute;
     content: '';
     display: block;
     width: 0;
     height: 0;
     border: 0.5em solid #dcf0ff;
     border-bottom-color: transparent;
     border-right-color: transparent;
     right: -1em;
     top: 0.5em;
   }
   ```

   这里创建了一个 0 像素的块，其边框是 0.5em，而且边框也只显示左、上边框。结果浏览器就只渲染出一个三角形。然后再把三角形定位到评注气泡的右上角位置。

3. 利用偏移实现自动大小

   从另一个角度看，也有必要知道：在绝对定位的情况下，如果声明了多个或所有偏移值，那么结果会怎样。如果没有显式声明元素大小，那么绝对定位元素的大小由自身包含内容的多少来决定。如果相对于定位上下文的各个边声明偏移值，那么元素会被拉伸以满足设定的规则。

   比如，希望让某元素总是与其外部元素保持一定距离，但又不给任何元素设定大小。如下图所示，一张图片上有一个包含文本的元素。

   ```html
   <header class="photo-header">
     <img src="images/big_spaceship.jpg" alt="An artist's mockup of the “Dragon” spaceship" />

     <div class="photo-header-plate">
       <h1>SpaceX unveil the Crew Dragon</h1>
       <p>photo from SpaceX on<a href="https://www.flickr.com/photos/spacexphotos/16787988882/">Flickr</a></p>
     </div>
   </header>
   ```

   ![图片上方半透明的盒子相对于右、下、左边绝对定位，上空距离由内容决定](./image/图片上方半透明的盒子相对于右、下、左边绝对定位，上空距离由内容决定.jpg)

   假设不想给这个包含标题的盒子设定明确的宽度，那么可以只指定其右、下、左边的偏移，让它自己去计算上空距离：

   ```css
   .photo-header {
     position: relative;
   }
   .photo-header-plate {
     position: absolute;
     right: 4em;
     bottom: 4em;
     left: 4em;
     background-color: #fff;
     background-color: rgba(255, 255, 255, 0.7);
     padding: 2em;
   }
   ```

   无论图片多大，标题区始终都会位于距离底边及左、右两边 4em 的地方，而且会在标题折行的情况下自动调整高度，从而适应不同的屏幕大小。

#### 6.1.2 定位与 z-index：堆叠内容的陷阱

要用好定位，还有一个重点技术必须掌握，那就是 `z-index`，也就是堆叠元素的次序。[可见格式化模型](#三-可见格式化模型)介绍过基本原理：静态定位（static）以外的元素会根据它们在代码树中的深度依次叠放，就像打扑克发牌一样，后发的牌会压在先发的牌上面。它们的次序可以通过 z-index 来调整。

设置了 z-index 的元素，只要值是正值，就会出现在没有设置 z-index 的元素上方。尚未设置 z-index 的元素在 z-index 值为负的元素上方。

除了 z-index，还有其他影响元素堆叠次序的因素。这里也有一个概念，叫**堆叠上下文**。就像一盒扑克牌，每张牌本身也是一个上下文（牌盒），而牌只能相对当前的牌盒排定次序。有一个根堆叠上下文，所有 z-index 不是 auto 的定位元素都会在这个上下文中排序。随着其他上下文的建立，就会出现堆叠层级。

堆叠上下文是由特定属性和值创建的。比如，任何设定了 `position: absolute` 及值不是 auto 的 z-index 属性的元素，都会创建一个自己后代元素的堆叠上下文。

在一个堆叠上下文内部，无论 z-index 值多大或多小，都不会影响其他堆叠上下文，毕竟不能相对于别的堆叠上下文重新排序。

![opacity值触发新的堆叠上下文](./image/opacity值触发新的堆叠上下文.jpg)

设置小于 1 的 opacity 值也可以触发新的堆叠上下文。opacity 小于 1 的元素需要独立渲染（包括它的所有后代元素），然后再放到页面上。这样就可以保证在把它们放到页面上时，原有的元素不会与半透明的元素发生交错。另外比如 transform 和 filter 属性，也会触发创建新的堆叠上下文。

### 6.2 水平布局

通常，页面会随内容增加沿垂直方向扩展。后来添加的任何块容器（div、article、h1~h6，等等）都会垂直堆放起来，因为块级元素的宽度是自动计算的。因此，在需要给内容块设置明确宽度，并让它们水平排列时，就会出现问题。

[可见格式化模型](#三-可见格式化模型)曾介绍过一个使用浮动来实现小型 “媒体组件” 布局的例子。这是一种基础的组件模式，即组件一边是图片（或其他媒体），另一边是文本，“左边是这个，右边是那个，二者相互关
联”。很多网站都在使用这种模式。

除此之外，还有很多通用模式的组件，可见于各类网站。其中很多都涉及水平布局。为此，CSS 引入了 Flexbox 来专门解决水平布局问题（以及其他问题），但在得到浏览器完全支持之前，可能还要借助浮动、inline-block 显示，或者表格显示模式，才能完美实现水平布局。

#### 6.2.1 使用浮动

在太空飞船那篇文章中，有一个使用浮动的例子。figure 浮动到了右侧，让行盒子对其四周环绕。同时通过 margin-right 的负外边距把图片向外推出去一点，以便与文本保持一些间距。

```html
<p>You may think[...]</p>
<figure>
  <img src="images/spaceship.jpg" alt="The Dragon spaceship in orbit around Earth." />
  <figcaption>
    The "dragon" spaceship, created by SpaceX.image from
    <a href="https://www.flickr.com/photos/spacexphotos16787988882/">Flickr.com</a>
  </figcaption>
</figure>
<p>There's various [...]</p>

<style>
  figure {
    background-color: #eee;
    margin: 0;
    padding: 1em;
    float: right;
    max-width: 17em;
    margin-right: -8em; /* 向右推出 */
    margin-left: 1em;
  }
</style>
```

删除这个负外边距，并把插图宽度设置为文章宽度的一半，而且还增加了第二幅插图。此时，两幅插图会并肩而立。

```css
figure {
  float: right;
  width: 50%;
}
```

这种布局方式是很多 CSS 布局会用到的一种基本技术，即让浮动的元素构成一行中的列。浮动也会有一些问题。浮动的元素并不在页面流中，因此需要一个元素来包含浮动元素。为此，可以给容器内部的一个（伪）元素应用 clear，也可以通过规则让容器成为一个新的块级格式化上下文（BFC，block formating context）。必要时，浮动也可以包含多行，但如果上面的行有浮动元素，也可能会被卡住。

浮动也可以对有限的水平内容进行独立于源码次序的排序。比如，通过分别向左和向右浮动两个元素，可以调整两幅插图的次序。

因为浏览器对浮动的支持极为普遍，所以浮动也成为了各种水平布局中的常用技术。第 7 章<!--TODO-->在构建用于页面整体布局的小型网格系统时，还会再用到浮动。除了浮动，实际上还有其他技术可以用来创建水平布局，虽然这些技术各有利弊。

#### 6.2.2 行内块布局

文本行自身就是水平布局的，至少在从左往右和从右往左书写的语言中是如此。使用行内元素（如 span、time 或 a）时，它们会与文本沿相同方向水平对齐。也可以把行内块加入到文本流中，创造出水平对齐的元素，从视觉上看又是一个块。

比如，为太空飞船的文章末尾添加一些元数据，包括作者姓名、照片和电子邮件地址。为了添加样式，还使用了两个额外的 span 元素:

```html
<p class="author-meta">
  <img class="author-image" src="images/author.jpg" alt="Arthur C.Lark" />
  <span class="author-info">
    <span class="author-name">Written by Arthur C. Lark</span>
    <a class="author-email" href="mailto:arthur.c.lark@example.com">arthur.c.lark@example.com</a>
  </span>
</p>
```

现在， author-meta 段落的底部会与图片底部及文本基线对齐。段落中的所有空白字符，包括图片和作者信息之间的换行符都被渲染为空格。这些空格的宽度取决于字体及其大小。

接下来，把图片和作者信息转换为行内块：

```css
.author-image,
.author-info {
  display: inline-block;
}
```

渲染之后，其实并没有什么可见的差别。差别只在于现在图片和作者信息都是块了。比如：可以把作者信息中包含的姓名和电子邮件地址分别列为两行，只要把它们修改为块级元素即可：

现在已经比较接近想要的水平布局了：左边是浮动的图片，右边是一个文本块，但还有一点，此时作者信息块最后一行的基线与图片底部是对齐的。可以通过 `vertical-align` 属性相对于图片来对齐作者信息。

1. 行内块的垂直居中

   假设设计是让作者信息块相对于图片垂直居中。可能会这么写：

   ```css
   .author-info {
     vertical-align: middle;
   }
   ```

   然而，结果可能并非你想要的。这里有一点需要澄清。关键字 `middle` 在应用给行内块时，其含义是 “将这个行内块的垂直中心点与这行文本 x 高度的中心点对齐”。例子中没有行内文本，（行内最高的）图片就成为决定行盒子高度以及基线位置的元素。而此时 x 高度的中心点就在图片底部（基线）靠上一点。

   要想将作者信息与图片一块垂直居中，需要让这两个元素都参照同一个 “中心点”：

   ```css
   .author-image,
   .author-info {
     vertical-align: middle;
   }
   ```

   因为图片此时也是行内块，所以它就与作者信息在同一个垂直点上居中对齐了，从而得到了想要的布局。

   如何确定行盒子的基线，以及这些规则如何影响行内及行内块元素，论述起来是比较复杂的。对于利用行内块创建水平布局而言，如果需要垂直对齐，有以下两个要点：

   - 要让行内块沿上方对齐（很像浮动），设置：`vertical-align:top;`
   - 要让两个元素的内容垂直对齐，先把它们都转换成行内块，再对它们应用 `vertical-algin: middle`。

2. 在容器元素中垂直居中

   前面的第二个要点告诉：可以在任意高度的容器内垂直居中内容。其实也不完全对。唯一的前提是把容器的高度设置为确切的高度。比如，假设想把作者元数据块设置为 10em 高，然后在其中居中放置作者图片和信息。首先，给 .author-meta 块应用这个高度。

   但作者信息和图片并没有相对于容器块垂直居中对齐，而是仍然沿原来那条假想的文本行对齐。为了实现与容器垂直对齐，还需要增加一个行内块元素，让它占据 100%的容器高度。这个元素会让 `middle` 关键字认为容器的垂直中点是对齐点。为此，可以借助伪元素。在引入了这个 “幽灵元素” 后，假想的基线就以它为准了。

   ```css
   .author-meta:before {
     content: '';
     display: inline-block;
     vertical-align: middle;
     height: 100%;
   }
   ```

   ![利用伪元素让middle代表容器的垂直中心点](./image/利用伪元素让middle代表容器的垂直中心点.jpg)

   此时，就好像整个 .author-meta 容器中只有一行文本，且高度与容器高度相同。因为这个

   伪元素是一个行内块，且其垂直对齐方式设置为 middle，所以其他行内块也就与容器的中心垂直对齐了。接下来要做的就是水平居中内容。因为行内块像文本一样对齐，所以这里使用 text-align。

   ```css
   .author-meta {
     height: 10em;
     text-align: center;
     border: 1px solid #ccc;
   }
   .author-info {
     text-align: left;
   }
   ```

   结果就是 .author-meta 既水平居中又垂直居中。确切来讲，这里的水平居中并不准确。这是因为行盒子内的任何空白符都会被渲染为一个空格。伪元素就会创建这么一个空格，导致内容向右偏移几个像素。通过给伪元素应用负外边距，可以抵消空格的宽度。

   ```css
   .author-info:before {
     margin-right: -0.25em;
   }
   ```

   > 为什么是 -0.25em？因为它就是当前字体中空格的宽度。这个值可能因字体不同而不同。因此，这个方案并不普适，也不推荐在任何系统性的布局工具中采用。

3. 追究细节：与空白战斗到底

   对于每个块都占据确切宽度的水平布局而言，空白是一个突出的问题。下面以另一个常见的组件为例，介绍在使用行内块的情况下如何解决这个问题，尽量不用具体数值。创建一个导航条，包含 4 个链接项，每一项都占据宽度的 1/4：

   ```html
   <nav class="navbar">
     <ul>
       <li><a href="/home">Home</a></li>
       <li><a href="/spaceships">Spaceships</a></li>
       <li><a href="/planets">Planets</a></li>
       <li><a href="/stars">Stars</a></li>
     </ul>
   </nav>
   ```

   以下 CSS 标记为导航条添加了基本的颜色及字体样式，并通过轮廓线突出了链接项的边界。这里将每一项设置为占据 25 %的宽度，4 项正好占据全部宽度。

   ```css
   .navbar ul {
     font-family: Avenir Next, Avenir, Century Gothic, sans-serif;
     list-style: none;
     padding: 0;
     background-color: #486a8e;
   }
   .navbar li {
     text-transform: uppercase;
     display: inline-block;
     text-align: center;
     box-sizing: border-box;
     width: 25%;
     background-color: #12459e;
     outline: 1px solid #fff;
   }
   .navbar li a {
     display: block;
     text-decoration: none;
     line-height: 1.75em;
     padding: 1em;
     color: #fff;
   }
   ```

   通过使用 `box-sizing: border-box;` 确保每一项的边框及内边距都包含在各自 25% 的宽度以内。导航条本身的背景颜色是蓝灰色，链接项的颜色是深蓝色，链接文本颜色是白色。

   HTML 源代码中的换行符被渲染成了空白符，再加上每一项 25% 的宽度，就导致了折行。要消灭这些空白符，可以尝试把所有 `<li>` 标签都排到一行，但这种要求显示不友好。解决问题的方法也很简单粗暴，就是把包含元素的 font-size 设置为 0（从而让每个空格的宽度为 0），然后在每一项上重新设置大小：

   ```css
   .navbar ul {
     font-size: 0;
   }
   .navbar li {
     font-size: 16px;
     font-size: 1rem;
   }
   ```

   这样就如期解决了空白问题，每一项都相互靠拢，只占据了一行。但这个技术也有缺点。首先与可以继承的 font-size 有关。假设在导航条上设置的是 16 像素的 font-size，那么就不能再使用 em 单位或比例，让每一项继承一个可伸缩的大小了。它会变成与 0 相乘。不过，可以通过使用 rem 单位，相对于根字体大小来保持可伸缩性。对于不支持 rem 单位的浏览器（主要是 IE8 及更早版本的 IE），还有一个像素值作为后备。

   其次，稍微早一点的 WebKit 浏览器不一定支持 font-size 值为 0。比如 Android4 早期版本中的 WebKit 浏览器。通常只把行内块作为兼容旧版本浏览器的后备手段，在此之上则会采用更现代的 Flexbox。随着这些浏览器慢慢开始支持 Flexbox，空白问题很可能就不再是问题了。

#### 6.2.3 使用表格显示属性实现布局

表格中的行恰好具有导航条例子中想要的特质：一组单元格恰好占满一行，而且永远不会折行。这也正是 HTML 表格在 Web 发展早期成为页面布局垄断技术的缘由。今天，可以通过 CSS 来借用表格的显示模式，不必求诸 HTML 表格标记。

如果将前面导航条的例子改为对 ul 元素使用的一种表格显示模式，并将其中的每一项设置为表格单元，那么也会得到与使用行内块一样的效果：

```css
.navbar ul {
  /* 为简洁起见，省略了部分属性 */
  width: 100%;
  display: table;
  table-layout: fixed;
}
.navbar li {
  width: 25%;
  display: table-cell;
}
```

> **注意**：这里将 ul 元素的宽度设置为 100%，是为了保证导航条能扩展到与父元素同宽。与常规块不同，不设置宽度的表格会 “收缩适应” 内容宽度，除非包含内容的单元把它撑开，让它的宽度足以填充父容器。

表格行中每一列的宽度有两种算法：

- 默认情况下，浏览器会使用 “自动” 算法。这是一种没有明确规定，但某种程度上又是事实标准的算法，基本上就是根据自身单元格内容所需的宽度来决定整个表格的宽度。
- 另一种算法是 “固定” 表格布局，即使用 `table-layout: fixed`。这种算法下的列宽由表格第一行的列决定。第一行中声明的列宽具有决定性，后续行如果遇到内容较多的情况，只能折行或者溢出。

在利用表格显示模式来创建布局时，必须清楚这样也会引入表格的问题。比如，渲染为表格单元的元素无法应用外边距，给表格单元应用定位时的行为也无法预料。本书还会在第 9 章<!--TODO-->再讨论 HTML 表格与 CSS 表格显示模式。

**表格单元中的垂直对齐**
使用表格显示模式时，表格单元中的垂直对齐效果无须借助任何额外的技术。只要给显示为 table-cell 的元素应用 `vertical-align: middle`，就可以令其中的内容在单元格中垂直居中，给表格显示模式下的列表设定高度后，只需一条声明就能让列表项垂直居中：

```css
.navbar ul {
  display: table;
  height: 100px;
}
.navbar li {
  display: table-cell;
  vertical-align: middle;
}
```

#### 6.2.4 不同技术优缺点比较

在实现水平布局以及垂直对齐时，浮动、行内块，以及表格显示模式，到底该用哪一个呢？以下总结了它们各自的优缺点：

- **浮动**与行内块一样，可以包装多行文本。浮动也会基于自己的内容来 “收缩适应”，有时候这种行为很有用。说到缺点，浮动的包含或清除，以及在被之前更高的浮动元素卡住时，可能会很头疼。另一方面，浮动某种程度上可以不依赖元素在代码中的次序，因为可以让一行中的某些元素向左浮动，其他元素则向右浮动。

- **行内块**有空白符问题，但可以解决，尽管有点黑科技的色彩。从好的方面来说，行内块也可能包含多行文本，而且支持控制垂直对齐。它们具有和浮动一样的 “收缩适应” 大小的特性。

- 使用**表格显示**模式进行水平布局同样很便捷，但仅支持不会发生折行的内容。表格有的问题，这种方案同样也有。比如，无法给它们应用外边距，内部的元素无法重新排序。但实现表格内容的垂直居中确实简便。

### 6.3 Flexbox

Flexbox，也就是 Flexible Box Layout 模块，是 CSS 提供的用于布局的一套新属性。这套属性包含针对容器（弹性容器，flex container）和针对其直接子元素（弹性项，flex item）的两类属性。Flexbox 可以控制弹性项的如下方面：

- 大小，基于内容及可用空间;
- 流动方向，水平还是垂直，正向还是反向;
- 两个轴向上的对齐与分布;
- 顺序，与源代码中的顺序无关。

#### 6.3.1 浏览器支持与语法

Flexbox 已经得到主流浏览器较新版本的广泛支持。对于某些需要兼容的旧版本浏览器，要调整一下语法或提供商前缀，基本上也没问题。具体而言，要支持 IE10 及更早版本的 WebKit 浏览器，需要在本章标准代码基础上补充提供商前缀属性和一些不同的属性，因为 Flexbox 规范本身在发展过程中也经过几次修改。

#### 6.3.2 理解 Flex 方向：主轴与辅轴

Flexbox 可以针对页面中某一区域，控制其中元素的顺序、大小、分布及对齐。这个区域内的盒子可以沿两个方向排列：默认水平排列（成一行），也可以垂直排列（成一列）。这个排列方向称为**主轴**（main axis）。

**与主轴垂直的方向称为辅轴**（cross axis），区域内的盒子可以沿辅轴发生位移或伸缩，如下图所示。**通常，Flexbox 布局中最重要的尺寸就是主轴方向的尺寸：水平布局时的宽度或垂直布局时的高度。称主轴方向的这个尺寸为主尺寸（main size）**。

![水平与垂直布局时的主轴与辅轴以及相应的主尺寸](./image/水平与垂直布局时的主轴与辅轴以及相应的主尺寸.jpg)

回头再看看导航条（包含链接的无序列表和容器），它很容易转换成 Flex 容器。假设其他样式（颜色、字体、链接、边框）都一样，那么只要一行 CSS 代码即可。至于列表项，无须声明任何属性，而且也不必给每一项指明宽度：

```css
.navbar ul {
  display: flex;
  /* 除非另有声明，否则这行代码也相当于声明了 flex-direction: row; */
}
```

链接项是水平排列的，而且根据各自的内容进行了收缩适应。结果就好像是块级文档流被旋转了 90 度一样。所有链接项集中在左侧，是从左到右书写的语言环境下的默认行为。如果把 `flex-direction` 改成 `row-reverse`，那么所有链接项就会集中到右侧，而且变成从右向左排。

如果不指定大小，Flex 容器内的项目会自动收缩。也就是说，一行中的各项会收缩到各自的最小宽度，或者一列中的各项会收缩到各自的最小高度，以恰好可以容纳自身内容为限。

#### 6.3.3 对齐与空间

Flexbox 对子项的排列有多种方式。**沿主轴的排列叫排布**（justification），**沿辅轴的排列则叫对齐**（alignment）。

用于指定排布方式的属性是 `justify-content`，其默认值是 `flex-start`，表示按照当前文本方向排布（也就向左对齐）。如果改成 `flex-end`，所有项就都会挤到右侧（变成向右对齐）但顺序不变。还有另外 3 个关键字：center、space-between 和 space-around。

Flexbox 不允许通过以上这些关键字指定个别项的排布方式。然而，对 Flexbox 的子项指定值为 auto 的外边距在这里却有不同的含义。因此，可以利用这一点。具体来说，如果指定某项一侧的外边距值为 auto，而且在容器里那一侧还有空间，那么该外边距就会扩展占据可用空间。利用这一点，可以创造让一项位于一侧，其他项位于另一侧的布局。下图展示了第一项在左侧，其他项在右侧的布局。

```css
.navbar li:first-child {
  margin-right: auto;
}
```

![flex的margin的auto](./image/flex的margin的auto.jpg)

本质上来说，像这样使用自动外边距抵消了其他项的排布效果，因为之后就没有多余空间可分了。尽管如此，对其他项仍然可以应用外边距。

1. 辅轴对齐

   前面通过 Flexbox 轻松解决了水平布局的基本问题。实际上，Flexbox 还支持对另一轴向的控制。如果增加 Flex 容器自身或其中一项的高度，会发现控制另一轴向属性的默认值会产生有趣的效果（默认情况下，Flex 子项会沿辅轴方向填满 Flex 容器）。

   实际上，控制辅轴对齐的属性 `align-items`，其默认值是 `stretch`（拉伸）。也就是说，子项默认拉伸，以填满可用空间。其他的关键字还有 flex-start、center 和 flex-end。这 3 个关键字都会把子项收
   缩成原有大小，然后再沿辅轴进行上、中、下对齐。

   最后，还可以使用 `baseline` 关键字，将子项中文本的基线与容器基线对齐，效果与行内块的默认行为类似。如果子项大小不一，而希望它们在辅轴上虽然位置不同，但本身对齐，那么就可以采用这种方法。

   添加一个类名表示当前活动的项：

   ```html
   <ul>
     <li><a href="/home">Home</a></li>
     <li class="navbar-active"><a href="/spaceships">Spaceships</a></li>
     <li><a href="/planets">Planets</a></li>
     <li><a href="/stars">Stars</a></li>
   </ul>
   ```

   这个活动项的 font-size 稍大一点，而且 z-index 值为 1：

   ```css
   .navbar.navbar-active {
     font-size: 1.25em;
   }
   ```

   现在，容器的基线由较大活动项的基线决定，其他项都自动与之对齐。

2. 对齐个别项

   除了同时对齐所有项，还可以在辅轴上指定个别项的对齐方式。比如，可以让第一项对齐到左上角，让其他项对齐到右下角：

   ```css
   .navbar ul {
     min-height: 100px;
     align-items: flex-end;
   }
   .navbar li:first-child {
     align-self: flex-start;
     margin-right: auto;
   }
   ```

   ![使用align-self对齐个别项](./image/使用align-self对齐个别项.jpg)

3. Flexbox 中的垂直对齐

   Flexbox 可以轻松解决垂直对齐问题。在容器里面只有一个元素时，只要将容器设置为 flex，再将需要居中的元素的外边距设置为 auto 就行了。这是因为 Flexbox 中各项的自动外边距会扩展 “填充” 相应方向的空间。

   ```html
   <div class="flex-container">
     <div class="flex-item">
       <h2>Not so lost in space</h2>
       <p>This item sits right in the middle of its container...</p>
     </div>
   </div>
   ```

   想要水平并且垂直居中，flex-item，仅需以下 CSS 代码，无论容器或其中元素有多大。在这个例子中，让容器与视口一样高（在 html、body 和 .flex-container 元素上都设置了 height:100%），就是为了让效果更明显：

   ```css
   html,
   body {
     height: 100%;
   }
   .flex-container {
     height: 100%;
     display: flex;
   }
   .flex-item {
     margin: auto;
   }
   ```

   如果 Flex 容器中有多个元素，就像前面作者元素数据的例子一样，那么可以使用对齐属性把它们聚拢到水平和垂直中心上。为此，把排布和对齐都设置为 center。（当然这也适用于单个元素的情况，只不过 margin:auto 的代码更少）。

   ```css
   .author-meta {
     display: flex;
     justify-content: center;
     align-items: center;
   }
   ```

#### 6.3.4 可伸缩的尺寸

Flexbox 支持对元素大小的灵活控制。这一点既是实现精确内容布局的关键，也是迄今为止 Flexbox 中最复杂的环节。可伸缩的尺寸在实现之前，确实是很难预测的。

1. **相关属性**

   Flex 的意思是 “可伸缩”，这体现在以下 3 个属性中：`flex-basis`、`flex-grow` 和 `flex-shrink`。这 3 个属性应用给每个可伸缩项，而不是容器。

   - **flex-basis**：控制项目在主轴方向上、经过修正之前的 “首选” 大小（width 或 height）。可以是长度值（如 18em）、百分比（相对于容器的主轴而言），也可以是关键字 auto（默认值）。

     关键字 auto 的意思好像是把 width 或 height 设置为自动，但实际上并不是那么回事。这里 auto 值的意思是这个项目可以从对应的属性（width 或 height）那里获得主尺寸，如果设置了相应属性的话。如果没有设置主尺寸，那么该项目就根据其内容确定大小，有点类似浮动元素或行内块。

     也可以设置 `content` 值，意思也是根据项目内容确定大小，但是会忽略通过 width 或 height 设置的主轴尺寸（与 auto 不同了）。

     > **注意**：content 关键字是后来才加入 Flexbox 的，支持程度可能不一致。

   - **flex-grow**：一个弹性系数（flex factor）。在通过 `flex-basis` 为每一项设置了首选大小之后，如果还有剩余空间，该系数表示该如何处理。其值是一个数值，表示剩余空间的一个比值。这个比值怎么算，稍后会解释。默认值是 θ，表示从 `flex-basis` 取得尺寸后就不再扩展。

   - **flex-shrink**：也是一个弹性系数，与 flex-grow 类似，但作用相反。换句话说，如果空间不够，该项如何收缩？增加了 `flex-shrink` 这个因素之后，计算过程更加复杂了，默认值是 1，表示如果空间不够，所有项都会以自己的首选尺寸为基准等比例收缩。

   Flexbox 使用了相当复杂的算法来计算各伸缩项的大小。但是，如果将计算过程简化为以下两个步骤，那么理解起来就容易多了：

   1. 检查 flex-basis，确定假想的主尺寸。
   2. 确定实际的主尺寸。如果按照假想的主尺寸把各项排布好之后，容器内还有剩余空间，那么它们可以伸展。伸展多少由 flex-grow 系数决定。相应地，如果容器装不下那么多项，则根据 flex-shrink 系数决定各项如何收缩。

   为了理解这些属性，来举一个例子。在这个例子中，假设容器宽度是 1000 像素。标记中，这个容器包含两个子元素。其中一个包含一个短单词（用 “Short” 表示），另一个包含一个长单词（用 “Looooooong” 表示）。因此，前者要占据 200 像素宽度，后者要占据 400 像素宽度。此时项目还没有放到容器中。

   如果这两项的 `flex-basis` 值都是默认的 auto，而且都没有设置 width 属性，那么当它们放到容器中时，它们会各自依据自身内容确定宽度，因此一共会占据 600 像素。这是 flex-basis 默认值的结果，与前面导航条中的例子一致。

   因为有剩余空间可分配，所以可以考虑 flex-grow 了。默认情况下，flex-grow 的值为 0，对各项的大小没有影响。假如此时把 flex-grow 的值设置成 1 会怎么样呢?

   默认的 0 和现在的 1 都代表什么？它们并不表示特定的大小，而**表示占整体的 “几份”**。这个例子里有两项，结果是两项会伸展相同的距离。它们的 “1 份” 表示各自分得剩余空间的一半，也就是 200 像素。换句话说，第一项最终的宽度是 400 像素，第二项最终的宽度是 600 像素。加在一起，正好是容器的宽度。

   假如给它们分别设置不同的 flex-grow，类似这样：

   ```css
   .navbar li:first-child {
     flex-grow: 3;
   }
   .navbar li:last-child {
     flex-grow: 1;
   }
   ```

   这会导致第一项分得剩余空间的 3/4，第二项分得 1/4。结果就是，两项各占 500 像素的宽度。

2. **纯粹按伸缩系数计算大小**

   在上一节用到的 “简化版 Flexbox 布局算法” 的第一个步骤中，是根据内容宽度来确定项目宽度的，因为 flex-basis 的值是默认的 auto，而且也没有给项目设定明确的宽度。假如第步中 flex-basis 的值是 0，那在这一步就不会给项目分配空间了。这种情况下，容器内部的全部空间都会留到第二步再分配，就是根据伸缩系数切分，然后将最终尺寸指定给具体的项目。

   在下图中，两个项目的 flex-basis 值为 0，flex-grow 值为 1。这意味着容器的全部空间要分成两部分，从而每个项目恰好占据可分配空间的一半。这个效果很接近使用百分比计算的布局，无论有多少项目，Flexbox 都会自动伸缩以适应整个宽度。

   ![纯粹按伸缩系数计算大小](./image/纯粹按伸缩系数计算大小.jpg)

   接下来要使用 flex 这个简写属性一次性设置 flex-grow、flex-shrink 和 flex-basis 属性，顺序就是这样，值以空格分隔：

   ```css
   .navbar li {
     flex: 1 0 0%;
   }
   ```

   > **注意**：最后一个 flex-basis 值加了百分号。这是因为简写法中的 flex-basis 必须带单位，因此这里要么加百分号，要么就写成 px。

   如果想让第一个项目占据的空间是其他项目的 2 倍，就把其 flex-grow 值设置为 2：

   ```css
   .navbar li {
     flex: 1 0 0%;
   }

   .navbar li:first-child {
     flex-grow: 2;
   }
   ```

   将以上规则应用给包含 4 项的导航条标记后，第一项占据 2/5（40%）的宽度，后三项各占 1/5（20%）的宽度。

3. **收缩项目**

   当项目宽度总和超过容器宽度时，Flexbox 会按照 flex-shrink 属性来决定如何收缩它们。此时的收缩机制比 flex-grow 稍微麻烦一点。麻烦的根源在于，不能因为某个大项目导致总体宽度超出，就把小项目压缩得不可见了。让项目占据更多空间（比如前面的 flex-grow）比较容易理解，不过是按比例分配而已。但收缩的时候，情况就不一样了。

   再以之前 1000 像素宽的导航条为例，假设这一次两个子项目都通过 flex-basis 预先设置了宽度。两项宽度的总和超出了容器宽度 300 像素。

   ```css
   .navbar li:first-child {
     flex: 1 1 800px;
   }
   .navbar li:last-child {
     flex: 1 1 500px;
   }
   ```

   加在一起的首选宽度（800px + 500px = 1300px）超出了容器宽度 300 像素。而且两个项目的 flex-shrink 值都是 1。可能以为此时两个项目会分别收缩 150 像素，以便适应容器宽度。然而事实并非如此。它们会根据自己 flex-shrink 系数和 flex-basis 的值来按比例收缩。具体来说，每个项目先用自己的 flex-shrink 乘以自己的 flex-basis，然后再用乘积除以每一项的 flex-shrink 与 flex-basis 的乘积之和，最后再拿得到的比例系数去乘以超出的宽度（负空间），从而得到该项目要收缩的空间数量。

   再简化一下表达：首选尺寸大的项目比首选尺寸小的项目收缩得更多（相对于 flex-shrink 系数而言）。因此就算这里两个项目的 flex-shrink 系数都是 1，它们收缩的量也是不一样的。以下是求第一个项目要收缩的量的过程：`((800 * 1)/((800 * 1) + (500 * 1))) * 300 = 184.6`，第一项要收缩 184.6 像素。

   用同一个公式计算第二项的收缩量：`((500 * 1) / ((800 * 1) + (500 * 1))) * 30 = 115.4`，第二项要收缩 115.4 像素。两者相加，正好是为适应容器宽度而必须减少的 300 像素。

#### 6.3.5 Flexbox 布局

前面导航条和作者元数据的例子只涉及一行内容。与行内块和浮动类似，Flexbox 也支持让内容排布到多行（列），但具有更强的可控性。

这次来设计一组标签，表示星球的种类。这些标签是包含链接的一个无序列表，跟导航条例子中类似。但这里的列表项目可要多出好几倍，因此不可能让它们都挤在一行中。会给标签设置统一的背景颜色，并使用前面评注气泡中用到的伪元素技术，给它们应用实际标签的外观。

```html
<ul class="tags">
  <li><a href="/Binary planet">Binary planet</a></li>
  <li><a href="/Carbon_ _planet">Carbon planet</a></li>
  <!-- 还有更多 -->
</ul>
```

标签的样式有点多，但都是之前学过的：

```css
.tags {
  border: 1px solid #c9e1f4;
  margin: 0;
  padding: 1em;
  list-style: none;
}
.tags li {
  display: inline-block;
  margin: 0.5em;
}
.tags a {
  position: relative;
  display: block;
  padding: 0.25em 0.5em 0.25em 0.25em;
  background-color: #c9e1f4;
  color: #28448f;
  border-radius: 0 0.25em. 25em 0;
  line-height: 1.5;
  text-decoration: none;
  text-align: center;
}
.tags a:before {
  position: absolute;
  content: '';
  width: 0;
  height: 0;
  border: 1em solid transparent;
  border-right-width: 0.5em;
  border-right-color: #c9e1f4;
  left: -1.5em;
  top: 0;
}
```

应用前面的样式之后，标签都成了行内块，可以随时折行。接下来该 Flexbox 上场了。首先，把列表元素转换为 Flex 容器，再通过 `flex-wrap` 属性的 wrap 值告诉它允许子元素折行：

```css
.tags {
  display: flex;
  flex-wrap: wrap;
  margin: 0;
  padding: 0;
  list-style: none;
}
```

结果跟刚才差不多。但现在我们可以用 Flexbox 来控制方向、大小和行的对齐了。

1. **折行与方向**
   首先，可以反转行中标签的排布方向（跟导航条例子中一样）把 `flex-direction` 的值改为 row-reverse，所有标签一下子就变成了从右上角起从右向左排布，每一行都变成了右对齐。也可以反转垂直排布的方向，让第一行从底部开头，然后向上折行。`flex-direction` 还是 row-reverse，而 flex-wrap 设置成了 wrap-reverse。

   > **注意**：Flexbox 的方向是逻辑方向，即以文本方向决定哪里是边界的开头和末尾。如果在一个从右向左排版的阿拉伯语网站，水平方向将是相反的（假设在标记中设置了 dir 属性），但垂直方向还是从上向下。

2. **多行布局中可伸缩的大小**
   Flexbox 对多行布局的另一个好处就是，可以利用可伸缩的大小均匀填充每一行。flex-grow 的计算是以行为单位的，因此项目的可扩展空间以行的宽度为限。

   ```css
   .tags li {
     flex: 1 0 auto;
   }
   ```

   此时，稍微缩小一点浏览器窗口，就会导致最后一个标签折行，从而创建一个新行。然而，多行 Flexbox 布局中没有办法控制特定的某一行。换句话说，无法告诉这些项目，让它们到了最后一行就不再扩展了。要解决当前这个问题，可以给所有标签设置 max-width，限制可伸缩的范围。

   总体来说，**可以填充多余空间是 Flexbox 的核心优势**。通过综合使用 flex-grow 及 min-width 和 max-width，就能实现非常智能的多行 Flexbox 布局。无论屏幕多大，或者容器里项目有多少，所有项目都会有合理的大小。第 8 章<!--TODO-->讲解响应式 Wb 设计时还会深入讨论这项技术，以及如何让布局适应不同的环境。

3. **对齐所有行**
   在前面介绍辅轴对齐属性（`align-items` 和 `align-self`）时，知道 Flexbox 允许相对于一行的 flex-start、center、baseline 和 flex-end 这几个点来对齐项目。而在多行布局中，则可以相对于容器来对齐行或列。

   如果在标签列表容器中，设置了 min-height: 300px，就可以知道相对于容器对齐行或列的 `align-content` 属性的效果了。默认情况下，这个属性的值是 `stretch`，意思是每一行都会拉伸以填充自己应占的容器高度。如果通过浏览器右键菜单中 “检查” 来看一看标签，会发现每一个 li 元素都拉伸为容器高度的 1/3。

   ```css
   .tags {
     display: flex;
     flex-wrap: wrap;
     min-height: 300px;
     /* align-content: stretch; 在这里是默认值 */
   }
   ```

   `align-content` 对容器中多行的作用，与 `justify-content` 对主轴内容排布的作用非常相似。换句话说，通过 `align-content` 还可把多行排布到 flex-start（容器顶部）、flex-end（容器底部）、center（容器中部），还可以通过 `space-between` 或 `space-around` 让多行分隔开。

#### 6.3.6 列布局与个别排序

使用 Flexbox 的 `order` 属性，可以完全摆脱项目在源代码中顺序的约束。只要告诉浏览器这项目排第几就行了。默认情况下，每个项目的 order 值都为 0，意味着按照它们在源代码中的顺序出现。

通过 Flexbox 可以任意摆放项目顺序。在接下来的例子中，先放下水平布局技术，来创建一个小小的 “文章导读” 组件，其中包含飞船文章的节选，有标题、图片，还有一个阅读全文的链接。这个组件会以一列的形式出现。

首先从标记开始，组件内容的次序按照它们的重要性来排定：

1. 以文章标题为内容的标题;
2. 导读正文;
3. 与文本主题相关的插图;
4. 指向文章的链接。

```html
<div class="article-teaser">
  <h2>The Dragon and other spaceships</h2>
  <div class="article-teaser-text">
    <p>There are actual spaceships.</p>
  </div>
  <img src="images/medium_spaceship.jpg" alt="The Dragon spaceship in orbit around Earth." />
  <p class="article-teaser-more">
    <a href="/spaceships">Read the whole Spaceship article</a>
  </p>
</div>
```

从设计上说，把图片放在最前头可以抓住读者的眼球。但在标记中，把图片放在第一位不定合适。这是因为对屏幕阅读器而言，最好是一上来就拿到文章标题，然后播报给读者。

为了能让图片排在最前头，需要把 .article-teaser 容器转换成一个 Flexbox 列：

```css
.article-teaser {
  display: flex;
  flex-direction: column;
}
```

然后，给图片一个比默认值 0 小的 order 值，让它第一个出现。

如果仍然希望标题在前头，可以像这样设置它们的 order 值：

```css
.article-teaser h2 {
  order: -2;
}
.article-teaser img {
  order: -1;
}
```

其他项目的位置不会变，它们的 order 值仍然是 0。order 的值不一定要连续（标题和图片可以分别是 -99 和 -6），而且正、负值都可以。只要是可以比较大小的数值，相应的项就会调整次序。记住默认值为 0 即可。

> **注意**：通过 Flexbox 重排次序只影响呈现的结果。按 Tab 键切换键盘焦点和屏幕阅读器并不会受 `order` 属性的影响。

#### 6.3.7 嵌套的 Flexbox 布局

最后一个例子会展示可嵌套的 Flexbox 布局，以及一种非常实用的技术。重用文章导读组件的例子，但这次有两个组件，并排在一起。为此，给它们加一个包装元素，将 Flexbox 方向设置为 row：

```html
<div class="article-teaser-group">
  <div class="article-teaser">
    <!-- 第一个组件的内容 -->
  </div>
  <div class="article-teaser">
    <!--第二个组件的内容-->
  </div>
</div>
```

将包装元素设置为一个 Flexbox 行：

```css
.article-teaser-group {
  display: flex;
}
```

可以在下图中看见，两个可伸缩项在辅轴方向拉伸的熟悉效果：两个组件的高度相同。

![flex可伸缩项](./image/flex可伸缩项.jpg)

之前也看到过等高的 Flexbox 可伸缩项。但在可伸缩项本身又是 Flexbox 容器时，比如本例的情况，还得再祭出一个 “终极大法”。因为两个组件虽然一样高，但它们的内容却不是。第二个组件明显短一截，“阅读详情” 按钮一个高一个低，视觉上明显不平衡。Flexbox 可以解决这个问题。只要在 “阅读详情” 元素上设置 `margin-top: auto`，就可以把它推到列的底部，让两个组件的元素在视觉上对齐。

如果使用之前的老技术，比如浮动、行内块和定位，那么实现这种动态内容布局肯定会相当麻烦。但如果 Flexbox 不可用呢？那么这两个组件会回退为更简单但绝对可用的设计。

#### 6.3.8 Flexbox 不可用怎么办

虽然 Flexbox 确实已经得到了浏览器的广泛支持，但难免也会有需要通过浮动或行内块来以防万一的时候。比如要支持旧版本的 IE（即 10 之前的版本），或者浏览器 bug 影响 Flexbox 功能，或者要保证 Web 设计在旧版本安卓机上也能表现一致。

实现 Flexbox 的后备方案，不少人已经总结过了。

首先，因为 Flexbox 只是一种显示模式，所以不理解 flex 关键字的浏览器会忽略它。也就是说，不支持 Flexbox 的浏览器仍然会按照一个常规块元素来显示原来的容器。

其次，给可伸缩项加上 float 声明，或者将其设置为 `display: inline-block`，都不会影响 Flexbox 布局。float 和 clear 关键字对可伸缩项没有影响，而设置不同的 display 值也不影响元素布局。这样的话，在水平布局中使用 Flexbox 就安全多了。首先写一个适合任何场景的布局，然后再通过 Flexbox 来增强外观。比如加入自动外边距、垂直对齐，以及其他锦上添花的改进。

有时候，可能需要明确区分支持和不支持 Flexbox 的浏览器。此时，推荐使用 Modernizr 这个 JS 库，它会检测浏览器的能力，为 HTML 标记加上相应的类名，作为应用样式的依据。第 7 章还会具体讨论 Modernizr 的应用<!--TODO-->。

如果只关心新版浏览器对该规范最新特性的实现，可以使用 `@supports` 注解，从而基于浏览器支持情况设计差异化的样式。

```css
@supports (flex-wrap: wrap) {
  /* 这里写 Flexbox 规则 */
}
```

这里仅限于那些理解条件规则语法和 `flex-wrap: wrap` 声明的浏览器。应该有不少浏览器支持 Flexbox 但不支持 `@supports`，反之亦然。这类声明特别适合只应用某些新的 Flexbox 特性或者绕过早期实现的 bug。

至于 Flexbox 的后备方案，关键是先有一个基准，然后是在这个基准之上的增强。

#### 6.3.9 Flexbox 的 bug 与提示

Flexbox 总体来说还是一个新技术，但经过多次迭代，bug 或不一致问题已经不多了。要跟进 Flexbox 在旧版本浏览器中的 bug，可以参考 Philip Walton 的社区合作的 [Flexbugs 仓库](https://github.com/philipwalton/flexbugs)，其中既有 bug 也有解决方案。

除了纯粹的 bug，还有以下提示：

- 图片、视频，以及其他带有固定宽高比的对象，在作为可伸缩项时可能会有问题。这方面的规范也在不断改进，但最保险的方案是给这些对象加个包装元素，让包装元素作为可伸缩项。

- Flex 的可伸缩项也具有所谓的 “隐性最小宽度”（implied minimun width）。换句话说，即便通过属性指定可伸缩项要收缩，但它们可能也不会收缩到可容纳内容的大小之下。为此，可以覆盖 `min-width` 属性，明确指定一个主尺寸。

- `order` 属性的值决定了可伸缩项的绘制次序，但这个值可能会影响这些项的叠加次序，与 `z-index` 类似。

- 而且，与常规块不同，不用将可伸缩项设置为非 static 的定位值，也可以直接给它们一个 z-index 属性。如果给了 z-index 属性，它的值会覆盖堆叠次序。带 z-index 属性的可伸缩项也会创建一个新的堆叠上下文。

- 某些元素的渲染模型会与常规渲染模型有出入。比如，button 和 fieldset 元素的默认渲染并不会完全遵从 CSS 指定的常规模式。如果让这些元素成为可伸缩容器，会遇到非常多的麻烦。

## 七. 页面布局与网格

本章介绍页面布局的系统性方法。上一章主要探讨的是个别页面组件的布局方式。了解页面布局最好先从个别组件开始。但与此同时，也会发现总体结构中有重复出现的模式。本章主要讨论如何以可重用的方式实现这些结构，也就是能够盛放内容的容器。

创建容器的时候，一般都需要一个包含预置尺寸和比例的网格系统。本章会介绍用 CSS 创建该系统的几种方法，首先介绍相对传统的方法，然后演进到使用 Flexbox。后半章还会介绍面向未来的 CSS Grid Layout 规范。

- 页面布局的系统手段
- 与页面网格相关的术语
- 通过浮动和行内块创建页面布局，再通过 Flexbox 增强
- 使用 Grid Layout 模块

### 7.1 布局规划

规划阶段的关键在于从设计方案中找出重复的模式，并识别出一些本质的东西。

#### 7.1.1 网格

说到一个网站的整体布局，经常会想到网格系统。网格系统是设计师在切分布局时作为参照的一组行和列。**行和列之间的空白叫作空距**（gutter）无论是设计师还是开发者对他们说 “一个元素占三列，左右各有一个空距”，谁都能明白。于是，网格系统就成为了页面布局常用的参照系。当然，也可以撇开网格系统来做非对称设计，但这不是主流。

**网格相关术语**
早在 Web 设计出现的几百年之前，网格系统就已经在图形设计领域广泛使用了。在 Web 设计中，常用的概念就是行、列、空距，而在传统的平面设计中，网格系统的概念更为丰富。

按照最传统的说法，行和列指的是网格中的横条或竖条，分别撑满网格的宽度或高度。**行与列相交的一个单元格，称为单元（unit）或模块**（module）。**多个单元按照某个比例可以构成更大的区块，比如三行两列。这些单元组合构成的区块，或水平或垂直，过去被称为区域（field）或范围**（region）。

每一维度的单元数量，常常与可以创建的比例相关。比如，24 列网格可以进一步分成 4 栏，每栏 6 列，或者 3 栏，每栏 8 列。

这些传统的术语对 Web 设计可能没啥用。但从另一方面来看，了解这些背景也没什么坏处，可能还有助于在编写代码时命名。一开始就有一套常用的命名方案，对编写结构化的代码非常有好处，比如可以参考它们命名一些辅助类。

#### 7.1.2 布局辅助类

类名用于为布局添加样式。对于简单的网站，几个类名就够用了。比如，用于控制两栏博客布局的类名大概这样就可以了：

```css
.main-content {
}
.secondary-content {
}
```

随着网站的复杂度提高，会发现一些规律：由于某些部分从属于特定的内容层级，类名无法清晰地传达其意图。这时候类名重用就成了一个问题。为了让样式可以重用，很多人尝试 “可视化” 的命名方式，比如：

```css
.column {
  /* 一般列的样式 */
}
.column-half {
  /* 占行宽的一半 */
}
.row {
  /* 一般行的样式 */
}
```

这几个类名严格来说是表现性的，也就是在 HTML 中要加入表现性信息。另外，这样命名目了然，方便重用，可以一次到位地解决布局问题。

另一种做法是把具有共用样式的选择符集中到一起：

```css
.thing,
.other-thing,
.third-thing,
.fourth-thing {
  /* 这里共用的样式 */
}
```

这样做的好处是不必为了应用这些样式而专门搞一个类名，只需要在这一个地方添加或删除即可。但如此一来，选择符可能会越来越多，变得难以维护。这也会给代码组织带来问题。而且像这样根据共用样式而非可重用组件来分割样式，还会让修改网站中特定部分的样式变得非常麻烦，因为不得不在很多样式块之间跳来跳去。

命名规范是高质量代码的重要组成部分，把表现与标记混在一起也是权衡的结果。本章将走条中间路线，一方面会使用一些辅助类，另一方面会尽可能少地与表现绑定起来。这是创建布局系统的简便方式，可以快速实现原型，同时还能保持样式的一致性。第 12 章<!--TODO-->会继续探讨模块化及可重用的 CSS。

无论是自己设计，还是实现别人的设计，都要三思而后行，做出可靠的实现。另外，给布局中的各个部分起个合适的名字也很重要，这样有助于跟设计师和开发团队沟通。如果设计很复杂，那么最好选择一个现成的 CSS 布局框架。

#### 7.1.3 使用现成的框架

CSS 布局需要考虑很多因素，而设计中用到的东西，很多别的网站中可能也有。因此，出现了一些现成的 CSS 框架或者库，能够提供某种网格系统。

很多 CSS 框架都非常可靠，通过它们能迅速做出一个原型，而且能兼容很多浏览器。这当然很好，因为可以节省大量的时间。特别是涉及尺寸关系复杂的布局时，Gridset 等工具能帮助生成 CSS。

使用现成框架的问题在于，很多大型的 CSS 框架会包含一整套布局规则，而其中很多都用不到。这意味着网站会包含占用带宽的无用代码。到底是该选择现成的框架还是自己写呢？视情况而定。如果要快速做一个原型以验证某
想法，当然要选现成的框架。如果网站复杂到要修改已有框架的很多代码，那自己写可能更好。

#### 7.1.4 固定、流动还是弹性

可能也看到过 “固定布局” “流动布局” 或 “弹性布局” 的说法。这些说法指的是在某种布局下如何约束元素的尺寸：

- **固定布局**：指页面具有特定的宽度，比如 960 像素。固定布局已经流行很长时间了，因为这样设计师和开发者会轻松很多。但是，也有设计师质疑到底什么尺寸才是最好的。

- **弹性布局**：指布局元素的尺寸使用 em 单位。这样，即使用户缩放文本大小，布局的比例也不会变。再与最小和最大宽度结合使用，还能使页面更好地适应屏幕大小。虽然弹性布局在今天有点过时了，但其利用最大宽度限制 em 单位的思想是创建流动布局的关键。

- **流动布局**：也称为 “流式布局”，指页面元素会按比例缩放，但元素与元素之间的比率（有时候连元素之间的距离也）保持不变。这其实是 Web 的默认模式，即块级元素没有预置的宽度，其尺寸会随可用空间大小而变化。

固定布局现在仍然被广泛使用，因为设计师容易控制其中的元素。但是这种固定布局对网站访问者而言并不友好，同时也无法适应多种设备和屏幕尺寸。**建议尽量不要使用固定布局，最好使用流式布局，使其适应不同的设备。这种让设计能响应环境的设计方法叫作响应式 Web 设计**（responsive Web design）。

> **注意**：响应式布局需要用到更多 CSS 特性，具体将在第 8 章介绍<!--TODO-->。

### 7.2 创建灵活的页面布局

本节会介绍几种实用的布局方法，可以用来创建可靠、灵活、可重用的页面布局。这里用到的很多技术和 CSS 属性都是[内容布局](#六-内容布局)学习过的相应属性的变化，只不过应用视角变成了页面布局级别。

创建一个如下图所示的页面布局，这个布局会随屏幕大小变化而展示不同的列数，同时水平的分节也会变化。

![页面布局包含不同的列数和不同大小的区块](./image/页面布局包含不同的列数和不同大小的区块.jpg)

把这个页面的布局简化成线框图，可以得到下图所示的样子。本节后面就来讨论如何实现这个布局。

![不同列数的线框图](./image/不同列数的线框图.jpg)

这个线框图中没有表现出布局整体是居中的，有一个最大宽度限制。就从这个限制宽度包装元素开始。

#### 7.2.1 包装元素

包装元素是页面布局中常用的一个盛放内容的元素，比如：

```html
<body>
  <div class="wrapper">
    <h1>My page content</h1>
  </div>
</body>
```

为什么不使用 body 作为包装元素呢。这是因为很多时候需要的不仅仅是一个包装元素。比如，包装元素外面可能会有一个宽度不同的网站级的导航条，或者几个跟屏幕一样宽的区块中分别包含一个居中的包装元素。

下面为这个包装元素添加一些样式。这些样式通过自动外边距，将包装元素设置为在页面上居中，同时使用了最大宽度。对于流动布局而言，使用百分比来设置一个稍微小于 100% 的宽度是很常见的。最大宽度则相对于文本大小来设置，单位是 em：

```css
.wrapper {
  width: 95%;
  max-width: 76em;
  margin: 0 auto;
}
```

body 元素默认是有外边距的，为避免不必要的干扰，得去掉它。推荐使用 Eric Meyer 的 CSS Reset 或 Nicolas Gallagher 的 Normalize.css 来重置浏览器默认样式，以提供一致的样式基准。

以上寥寥几行 CSS 样式反映了如下几个布局抉择：

- 主包装元素正常情况下应该是视口宽度的 95%。

- 通过简写的 `margin: 0 auto`，去掉了它的上下外边距，然后将水平剩余空间平均分配给左、右外边距（每一侧是 2.5%），这样就让它在页面上居中了。

- 但是，这个包装元素最宽不会超过 76em。按照每 em 默认为 16 像素计算，相当于 1216 像素。不过，如果用户通过浏览器缩放文本大小，包装元素的宽度也会同比例缩放。76em 不是谁规定的，只是觉得它比较适合当前的布局。

这里屏蔽了一些不可控因素，比如屏幕大小及用户的字体设置，因为不希望布局的宽度值固定。但应该知道，一个居中的布局两侧应该留出一些空白区域，这跟屏幕大小无关。而且希望布局的宽度有一个上限，以防止文本行的长度超出可读范围。假如用户的浏览器有不同的默认文本大小，那么布局的最大宽度应该也能自动缩放。

由于设计不同，选择的度量方式也可能不同，但原理都是一样的：首先大体上确定内容包装元素的限制条件，但又不能把它们的值写死。要让布局能随机应变。

“随机应变” 是软件设计的各种领域中经常能听到的一句话。在整体布局时不使用特定的像素值，就可以实现这一点。而这些样式一且写完，就可以应用给任何包装元素，只要给它们添加相应的类即可。

换句话说，现在只要应用 wrapper 类就行了。以下代码中有 3 个地方应用这个类。首先是页头部分，然后是导航条。这两个元素本身是与浏览器视口一样宽的，但通过在它们内部包含一个包装元素，就可以实现内容在布局层面上居中。这两个块之后的 main 元素也是包装元素，用于盛放特定于页面的内容：

```html
<header class="masthead">
  <div class="wrapper">
    <h1>Important News</h1>
  </div>
</header>
<nav role="navigation" class="navbar">
  <div class="wrapper">
    <ul class="navlist">
      <li><a href="/">Home</a></li>
      <!--还有更多-->
    </ul>
  </div>
</nav>
<main class="wrapper">
  <!--这里是主体内容-->
</main>
```

#### 7.2.2 行容器

接下来看看内容在水平方向上的分组。此时，唯一想让行组件做的事就是可以包含浮动元素。只要创建一个块级格式化上下文，就可以通过 overflow 属性来包含浮动元素。虽然对于较小的组件来说，使用 overflow 会比较容易实现包含，但这里使用的是一个设置了清除的伪元素。因为比较大的区块很可能会有定位内容被摆放到行容器之外，所以使用 overflow 可能不利。

```css
.row:after {
  content: '';
  display: block;
  clear: both;
  height: 0;
}
```

#### 7.2.3 创建列

行容器的样式写好了，下面就该把行分成列了。此时最重要的是确定使用哪种水平布局的方法。上一章介绍过水平布局的几种方法，其中浮动是最常用的，也是浏览器支持最好的技术。因此，这里用浮动创建列。对于从左到右书写的语言，默认的向左浮动应该是最佳选择。

考虑到将来可能会在不影响列宽度的前提下，直接给列容器添加边框和内边距，还应该把 box-sizing 属性设置为 border-box：

```css
.col {
float: left;
box-sizing: border-box;
```

下面又该确定如何设置列宽了。很多 CSS 库都使用直接表示宽度的类来指定列宽，比如：

```css
.col-1of4 {
  width: 25%;
}
.col-1of2 {
  width: 50%;
  /* 省略更多 */
}
```

这种方式非常适合面向台式电脑或笔记本电脑的快速原型。根据前面定义的规则，很容易在 HTML 中定义一个 3 列的、最左列占一半宽度的布局：

```html
<div class="row">
  <div class="col col-lof2"></div>
  <div class="col col-lof4"></div>
  <div class="col col-lof4"></div>
</div>
```

这种方式的缺点是过分强调某种布局。如果将来需要根据屏幕大小动态调整布局，那么这种命名方式就不太合适了。如果想通过可重用的类名来控制尺寸，就必须让标记与表现有一个结合点。可以给这个结合点换个名字，不使用特定的宽度或者比率，让它更加普适。用音乐来比喻的话，可以创建一条规则，让行容器在正常情况下包含 4 个宽度相等的部分（quartet，四重奏）：

```css
.row-quartet > * {
  width: 25%;
}
```

然后使用通用选择符，直接针对行容器的子元素，同时可以降低这条通用规则的特殊性。因为通用选择符的特殊性为 0，所以后面可以用一个特殊的类名来覆盖这个宽度。此时通过以下标记就可以创建一个包含 4 个等宽列的行：

```html
<div class="row row-quartet">
  <div class="col"></div>
  <div class="col"></div>
  <div class="col"></div>
  <div class="col"></div>
</div>
```

这样，.row- quartet 中的列如果想改变宽度，就可以应用覆盖宽度的一个类名，但这个类名并不与布局相关。于是前面的 3 列布局就可以这样来写：

```html
<div class="row row-quartet">
  <div class="col my-special-column"></div>
  <div class="col"></div>
  <div class="col"></div>
</div>

<style>
  .my-special-column {
    width: 50%;
  }
</style>
```

在前面的线框图中，两个子分类都有一个标题区，占布局区的 1/5，内容区占剩下的 4/5。而在第一个子分类中，还有一个更大的文章列，占内容区的 50%：

```css
.subcategory-content {
  width: 80%;
}
.subcategory-header {
  width: 20%;
}
.subcategory-featured {
  width: 50%;
}
```

HTML 代码如下：

```html
<section class="subcategory">
  <div class="row">
    <header class="col subcategory-header">
      <h2>Sub-section 1</h2>
    </header>
    <div class="col subcategory-content">
      <div class="row row-quartet">
        <div class="col subcategory-featured"></div>
        <div class="col"></div>
        <div class="col"></div>
      </div>
      <div class="row row-quartet">
        <div class="col"></div>
        <div class="col"></div>
        <div class="col"></div>
        <div class="col"></div>
      </div>
    </div>
  </div>
</section>
<section class="subcategory">
  <div class="row">
    <header class="col subcategory-header"></header>
    <div class="col subcategory-content">
      <div class="row row-trio"></div>
      <div class="col"></div>
      <div class="col"></div>
      <div class="col"></div>
    </div>
  </div>
</section>
```

**使用额外的包装元素**
在这个例子中，使用了额外的嵌套元素，即类名为 row 的元素，对 “内部” 列进行分组。为了让标记简洁，这里也可以将 row 类应用给 col 元素。但由于少了一层标记，万一规则发生冲突，也就会失去回旋余地。额外的元素可以降低冲突发生的可能性，当然代价就是标记会多一点。

#### 7.2.4 流式空距

现在显然该给列间添加一些空白了，这样布局才不会看起来紧绷绷的。没错，意思就是要添加空距（gutter）。

在流动布局中，空距可以是百分比，也可以是相对于字体大小的固定宽度。不管采用哪种方式，列元素两边的宽度都应该相等。换句话说，每一边的空距宽度都应该是预期空距宽度的一半。

**如果想给列添加背景颜色或图片，而且希望背景和图片也保持间距，那就应该以外边距作为空距**。这样，兼容不支持 box-sizing 的古老浏览器也是没问题的。对于流动布局，应该使用百分比定义外边距。这是因为，如果没有 calc()，那么百分比和其他长度单位混合使用会让调试变得很麻烦，而且旧版本浏览器也不支持 calc()。

但不管怎么样，都应该知道如何计算百分比外边距的实际值，这样才能保证空距与列宽相协调。在前面的例子中，文本大小为 16 像素，行高为 1.375em，即 22 像素。假设希望在一般的屏幕尺寸中，空距等于文本的行高，从而将排版与布局联系起来。先从布局的最宽点开始，即 76em 或 1216 像素。

因为外边距相对包含块来计算，所以计算空距与总宽度的比例与计算相对文本大小是一样的：预期的宽度除以总宽度。22 除以 1216 等于 0.018092105。也就是说，一个空距大约是总宽度的 1.8%。最后，这个百分比再除以 2，就是每一列的每侧的外边距，即 0.9%：

```css
.col {
  float: left;
  box-sizing: border-box;
  margin: 0 0.9% 1.375em;
}
```

这里也添加了一个下外边距，让两个内容行之间的距离等于行高。

> **注意**：这里的垂直空间用 em 设置，而不是百分比。这是因为行高和屏幕尺寸无关，既然以行高为依据，就应该沿用计算行高的参照物（即文本大小）。

此时看一下布局，会发现它乱了。这是给列添加了外边距所导致的。就算设置了 `box-sizing: border-box`，对外边距也是无能为力。因此，接下来需要重新定义列宽。

因为给每一列加了 1.8% 的空距，所以只要从原先的列宽中减去它就可以了：

```css
.row-trio > * {
  width: 31.53333%;
}
.row-quartet > * {
  width: 23.2%;
}
.subcategory-featured {
  width: 48.2%;
}
.subcategory-header {
  width: 18.2%;
}
.subcategory-content {
  width: 78.2%;
}
```

稍微拖窄了一点浏览器窗口，空距也会随之缩小。

1. **抵消最外侧的空距**
   现在，有了一个网格系统，可以表示行、流动的列和流式空距。接下来要做的是处理细节，尽量避免视觉效果冲突。

   首先，用于创建空距的外边距导致了外层容器左边和右边额外的缩进，这不是想要的。在内部行中嵌套的列也出现了同样的问题。应该去掉第一项的左外边距和最后一项的右外边距。但这样会导致列宽和空距的计算复杂化。运用另一个技巧来解决这个问题。**没有特定宽度的非浮动块级元素，会在左、右负外边距都设置的情况下扩展其宽度**。

2. **设置空距的替代方案**

   要想进一步简化列宽的计算，可以利用 `box-sizing` 属性，并使用内边距来设置空距。如果想继续使用流式空距，那么只要把外边距改成内边距即可。这样就可以重新以整个宽度的适当百分比来表示列宽，而不必考虑空距了：

   ```css
   .col {
     float: left;
     box-sizing: border-box;
     padding: 0.9% 1.375em;
   }
   .row-trio > * {
     width: 33.33333%;
   }
   .subcategory-featured {
     width: 50%;
   }
   /* 省略更多 */
   ```

   这样一来就可以使用排版的基准来设置空距了。换句话说，可以使用 em 来设置空距，而不用基于网格宽度的百分比。在下面的例子中，空距的大小与行高相同，在列之间创建了相同的垂直与水平间距，而这与网格的宽度无关：

   ```css
   .col {
     float: left;
     box-sizing: border-box;
     /* 左、右内边距各为行高的一半 */
     padding: 0.6875em 1.375em;
   }
   ```

#### 7.2.5 增强列：包装与等高

前面创建布局主要使用了浮动。除了浮动以外，还有很多其他布局方案。下面分别展示用其他方案创建同样布局的例子。掌握这些方法之后，可创造出更灵活的布局。

1. **用行内块包装行与列**

   仔细看一看图，会发现最多订阅区域的底部有两行是标题。在当前的布局中，只有一行稍微大一些的新闻预览。使用浮动块来包装这些行可能会有问题。比如，某个新闻的标题很长，导致该列非常高，就会出现难看的 “锯齿” 效果。

   为此，可以创建一个通用的类名，预期的应用场景就是包装多行。对添加了这个类名的容器，应用基于文本大小技术的 inline-block。此时，由于 font-size 是 0，在设置行容器的负外边距时要使用 rem 单位。考虑到向后兼容，这里还增加了像素单位的后备规则：

   ```css
   .row-wrapping {
     font-size: 0;
     margin: 0 -11px;
     margin: 0 -0.6875rem;
   }
   .row-wrapping > * {
     float: none;
     vertical-align: top;
     display: inline-block;
     font-size: 16px;
     font-size: 1rem;
   }
   ```

   有了这两条规则，就可以添加任意多个新闻预览，这些新闻预览会在填满一行四列后自动折行。在验证结果之前，先用 Flexbox 再打磨一下细节。

2. **使用 Flexbox 实现等高的列**

   Flexbox 可以用来创建等高的列。在创建一整套布局时，希望有些规则只在浏览器支持 Flexbox 时应用。为检测浏览器是否支持 Flexbox，要在页面上方引入一小段脚本。这里使用 Modernize，这个库会根据浏览器支持的特性，给 html 元素添加相应的类。可以在这个[网站](https://modernize.com/)定制需要的检测脚本。本例所需的定制脚本只包含检测各种 Flexbox 特性的代码，以保持其最小化。

   创建完检测脚本，把它复制到一个 JS 文件里，然后在 `<head>` 元素中引入，但次序定要先于所有引人 CSS 文件的元素。加载次序很重要，因为检测要在一开始加载时就进行，而此时还不能应用样式。然后就可以基于带前缀的类名来编写样式了。只有支持 Flexbox 的浏览器才会解析它们。

   flexbox 类表示浏览器支持 Flexbox，而 flexwrap 表示可伸缩项会折成多行或多列。在完整的示例代码中，会看到还使用了 flexboxtweener 类，这个类表示浏览器支持 IE10 中的 Flexbox。

   首先，把标准行转换成 Flexbox 行：

   ```css
   .flexbox .row {
     display: flex;
   }
   ```

   这样，就已经创建了等高的列，其实这也是可伸缩项会拉伸以填充父元素的默认行为。因为针对每一列的内容都使用了包装元素，所以需要对这些列应用更多的 Flexbox 属性，使其中的内容能均匀地填充这些列。这里每一列都会变身为一个列状的可伸缩容器，其子元素按照规则会均匀填充可分配的剩余空间：

   ```css
   .flexbox .col {
     display: flex;
     flex-direction: column;
   }
   .flexbox .col > * {
     flex: 1;
   }
   ```

   简写的 `flex: 1` 代表 flex-grow:1、flex-shrink:1、flex-basis: 0。最后，再对包装行进行增强，让它们也能利用 Flexbox 的等高机制。

   ```css
   .flexwrap .row-wrapping {
     display: flex;
     flex-wrap: wrap;
   }
   ```

   我们有了一组创建页面布局的规则。利用这组规则，只要组合运用一些类名，就可以控制行、列和空距。理解了这组规则，也就理解了 Bootstrap 和 Foundation 等 CSS 框架中的网格系统（当然，它们的类名是表现性的）根据本章介绍的布局思路，可以创建出适合自己项目的网格规则。同时，还可以做到代码最少和容易维护。

#### 7.2.6 作为网页布局通用工具的 Flexbox

[内容布局](#六-内容布局)中详细解说了 Flexbox，它是一种强大的设计工具，可以实现精细而又灵活的内容布局。本章在基于浮动的布局基础上又应用了 Flexbox，做到了最大限度的向后兼容。这种做法是非常靠谱的。

[内容布局](#六-内容布局)中也解释了为什么这种 “在浮动之上应用 Flexbox” 的策略非常重要。由于 Flexbox 夲身会忽略可伸缩项的浮动（float）和显示（display）属性，使用它能够轻松打磨基于浮动布局。可伸缩项从已经设置的属性中获取宽度、外边距、内边距等。但这就意味着 Flexbox 是用于创建整页布局以及类似网格结构的正确工具吗?

当然，没人能阻止你使用 Flexbox 进行页面布局（除非旧版本的浏览器不支持）。但 Flexbox 并非为此而创造出来的。浮动也不是！因此使用 Flexbox 作为整体布局工具同样有其利弊。

1. **利弊**

   **利**

   - Flexbox 性能出色，至少在实现最新规范的浏览器中是如此。现代 Flexbox 性能一般都比浮动要优越。早期 Flexbox 的实现性能并不好，因此在相应的旧版本浏览器中使用时要特别注意。

   - Flexbox 让页面布局变得非常简单，只需几行代码，就可以把元素切分成可伸缩的区块，而且可以通过扩展和收缩因子来控制。这种不用考虑组件数目就可以快速分布内容的能力，自然可以用于创建类似网格的布局。

   **弊**
   从不利的方面来看，Flexbox 会随着其中内容的加载而重新计算尺寸，因此在页面首次加载时会跳一下，体验不太好。比如，可伸缩项中的图片在加载完成后，会把其他项向四周推开。前面的例子中，因为使用基于 Flexbox 按行分布的默认值（元素不会自动扩展）和显式声明的宽度，所以将跳动最小化了。

2. **一维和二维布局**

   迄今为止，介绍的所有布局技术，包括 Flexbox 在内，都是基于把项目排成行或列的思路。虽然有的技术支持内容折行（从而在垂直方向上显示为堆叠），但本质上它们都是一维布局技术，即内容排列要么从左向右，要么从右向左，要么从上到下(见图 7-17)，却不能跨行或跨列。这就意味着必须借用包装元素来进一步切分布局。

   ![一维布局](./image/一维布局.jpg)

   在 Web 发展早期可用的布局技术很少，其中一项就是 HTML 表格。在 CSS 出现很久之后大家还一直 “坚持” 使用表格布局的一个重要原因就是，表格可以实现二维布局。换句话说，就是表格中的单元可通过 colspan 和 rowspan 实现复杂的布局。

   ![二维布局](./image/二维布局.png)

   从使用 CSS 实现页面布局至今，都默默地接受了一个事：布局中任何嵌套的区块都需要一个自己的包装元素，而布局其实是分别控制单个元素得到的结果。现在，CSS Grid Layout 模块有望颠覆以往所有的做法。

### 7.3 二维布局：CSS Grid Layout

说到整体的页面布局，之前学习的任何技术都不是一个全面的解决方案，不能在二维空间里控制元素的顺序、位置和大小。不过，CSS Grid Layout 模块专门为此定义了一组 CSS 属性。

使用 Grid Layout 模块，可以抛开之前用到的很多辅助控制元素，从而大幅精简 HTML 标记。与此同时，这个模块也把基于元素本身来设置水平和垂直维度的负担，转移到了在页面中表示网格的一个包含元素上。

#### 7.3.1 网格布局的术语

下图展示了 CSS 规范中定义的网格。

![网格容器及其组件](./image/网格容器及其组件.jpg)

下面来解释：

- 被设置为 `display: grid;` 的元素叫**网格容器**（grid container），即图中的粗线框区域。

- 容器进一步被**网格线**（grid line）划分为不同的区域，叫**网格单元**（grid cell）。

- 网格线之间的水平或垂直路径叫**网格轨道**（grid track）。具体来说，水平方向的网格轨道叫**网格行**（grid row），垂直方向网格轨道叫**网格列**（grid column）。

- 由相邻网格单元组合起来的矩形区块叫**网格区**（grid area）。

- 网格容器的直接子元素叫**网格项**（grid item），网格项可以放在网格区内。

本章开头提到的传统平面设计中的网格系统的术语，跟这里的术语概念几乎一样，但名字不同。规范的编写者认为，使用与电子表格和 HTML 表格有关的名字更容易得到开发者的认同。无论如何，都得接受这些术语。

#### 7.3.2 定义行和列

创建网格需要告诉浏览器网格行与网格列的数量和行为。要实现上图所示的 4×2 的网格，仍以 div 作为包装元素，需要将其显示模式设置为 grid。同时，再通过网格模板（grid template）指定行和列的数量及大小。

```css
.wrapper {
  display: grid;
  grid-template-rows: 300px 300px;
  grid-template-columns: 1fr 1fr 1fr 1fr;
}
```

前面的代码定义了一个 2 行 4 列的网格，行高 300 像素，4 列等宽。而且该网格中每行和每列的边缘都会生成网格线，后面会用到。

这里用于表示列宽的单位是 **fr，意思是可用空间中的部分**（fraction of available space）。这个单位跟 Flexbox 中的扩展系数（flex-grow）非常相似，只不过这里有特定的单位符号，应该是为了避免跟其他没有单位的值发生冲突。可用空间就是网格轨道（通过明确指定的长度值或根据自己的内容）确定尺寸后的剩余空间。

每个 fr 单位在这里都表示网格可用空间的 1/4。假如再添加一个 1fr，那么每个 fr 单位表示的就是可用空间的 1/5。

指定行和列的数量及大小时，可以混用不同的长度单位。比如，声明列时可以这样写：`200x 20% 1fr 200px`。这就是说，靠两边的两列宽度固定为 200 像素，左起第二列的宽度是总空间的 20%，而第三列则占据剩下的全部空间。换句话说，**fr 单位的大小会在计算完其他长度值之后再确定**，跟 Flexbox 一样。

**生成页面子区块的网格**
看一看前面例子中的页面布局，会发现每个子区块都可以转换为网格。每一个子区块对应的最简单网格应该是 3 行 5 列。每一列是总宽度的 15，而行的高度可以自动调整，完全取决于内容。

![示例页面的第一个子区块切分成网格](./image/示例页面的第一个子区块切分成网格.jpg)

组织内容的标记瞬间就变得极其简单了。当然，为了分隔不同的子区块，最外层还是需要一个包装元素。而在包装元素内部，每篇新闻就可以直接用一个子元素来表示了。

```html
<section class="subcategory">
  <div class="grid-a">
    <header class="subcategory-header">
      <h2>Lorem ipsum</h2>
    </header>
    <article class="story story-featured">
      <!-- 此处是较大的 article -->
    </article>
    <article class="story">[...]</article>
    <article class="story">[...]</article>
    <!-- 此处是所有的 article，以下省略-->
  </div>
</section>
```

接下来定义这个网格的 CSS。从前面的切分图来看，3 行的高度应该是自动的，而 5 列则分别占 1/5 的宽度：

```css
.grid-a {
  display: grid;
  grid-template-rows: auto auto auto;
  grid-template-columns: repeat(5, 1fr);
  margin: 0 -0.6875em;
}
```

这里使用了网格布局模块提供的函数 repeat，可以用它为网格轨道指定重复的行或列声明，省去重复书写的麻烦。

因为网格轨道在 DOM 中并没有特定的元素表示，所以不能通过 max-width 或 min-width 之类的属性来为它们指定大小。如果想在声明网格轨道时使用同样的功能，可以使用 `minmax()` 函数。比如，可以声明最后两行至少 4em 高，除此之外还要占据相等的可用空间。

```css
.grid-a {
  display: grid;
  grid-template-rows: auto minmax(4em, 1fr) minmax(4em, 1fr);
  grid-template-columns: repeat(5, 1fr);
  margin: 0 -0.6875em;
}
```

此外，使用 `grid-template` 属性还可以把行和列的声明都放在一行上，前面是行的定义，后面是列的定义，中间以斜杠（`/`）分隔：

```css
.grid-a {
display: grid;
grid-template: auto minmax(4em, 1fr) minmax(4em, 1fr) / repeat(5, 1fr);
margin: 0 -.6875em;
```

#### 7.3.3 添加网格项

添加网格项要以其起止处的网格线作为参考。例如，子区块的标题区要占据左侧一整列。而添加相应网格项的最麻烦的方式，就是同时指定两个维度上起止的网格线编号：

```css
.subsection-header {
  grid-row-start: 1;
  grid-column-start: 1;
  grid-row-end: 4;
  grid-column-end: 2;
}
```

![使用网格线编号添加标题区的网格项](./image/使用网格线编号添加标题区的网格项.jpg)

当然也可以简化为 `grid-row` 和 `grow-column` 属性，把行和列的起止网格线声明放在一行。起止网格线的编号以斜杠（`/`）分隔。

```css
.subsection-header {
  grid-row: 1/4;
  grid-column: 1/2;
}
```

假如只知道这个网格项应该跨所有行，但并不知道会有多少行，那么就需要一种方式来表示最后一行。Grid Layout 支持使用负值来反向表示行号。换句话说，-1 就是最后一个网格轨道的终止网格线的编号。另外，默认的跨度是一个网格单元，也就是说这里可以省略 `grid-colum` 值的最后一部分。

```css
.subsection-header {
  grid-row: 1/-1;
  grid-column: 1; /* 等价于 grid-colum:1/2 */
}
```

最后，还有一个终极的 `grid-area` 属性，可以进一步简化网格项的声明。这个属性的值最多 4 个，由斜杠分隔。4 个值全给出的话，分别表示 `grid-row-start`、`grid-column-start`、`grid-row-end` 和 `grid-column-end`。

```css
.subsection-header {
  grid-area: 1/1/-1;
}
```

这段代码里省略了第四个参数，也就是表示列方向终止位置的值。实际上，两个方向上的终止参数都是可以省略的。省略的话，网格定位时生成的网格项在两个方向上会默认跨一个网格轨道。

1. **对齐网格项**
   添加完网格项后，它们会自动撑满相应的网格区。这里的高度自动扩展与 Flexbox 中的可伸缩项非常相似。这并非巧合。

   Flexbox 和 Grid Layout 都是根据 CSS Box Alignment 规范确定其子项行为的。CSS Box Alignment 负责规范几种 CSS 上下文中元素的对齐与分布。

   与 Flexbox 中的行一样，网格项的垂直对齐也是通过 `align-items` 和 `align-self` 来控制的。这两个属性的默认值都是 `stretch`，也就是让网格项在垂直方向上扩展以填满相应网格区。其他关键字值也跟 Flexbox 的行一样，只不过没有 flex-前缀：start、end 和 center。下图解释了这几个值的差异。

   网格项与块级元素类似，会自动填充自己所在网格区的宽度，除非明确设置它的宽度。百分比值相对于网格项所在网格区（而非网格容器）的宽度来计算。

   如果网格项没有在水平方向填满网格区，可以通过 `justify-items` 和 `justify-self` 属性指定它的左、中、右分布。

   与 Flexbox 类似，`align-self` 和 `justify-self` 用于个别网格项。`align-items` 和 `justify-items` 则用于在网格容器上设置所有网格项的默认对齐。

   ![控制网格项对齐的属性和值](./image/控制网格项对齐的属性和值.jpg)

2. **对齐网格轨道**
   在网格区没有占满的情况下可以对齐网格；同理，也可以在网格容器中对齐网格轨道。只要网格轨道的总和没有覆盖整个网格容器，就可以使用 `align-content`（垂直方向）和 `justify-content`（水平方向）来移动轨道。

   比如，下面这个网格中的列总和小于容器的尺寸：

   ```css
   .grid {
     width: 1000px;
     grid-template-columns: repeat(8, 10px); /* 共 800 像素 */
   }
   ```

   此时，可以控制剩余空间在容器里如何分配。默认情况下，`justify-content` 的计算结果是 start。下图展示了这个属性可能的值及效果。

   ![通过justify-content移动网格轨道](./image/通过justify-content移动网格轨道.jpg)

   类似地，也可以在垂直方向上对齐（`align-content`）轨道（如果容器的高度是固定的），关键字一样。

3. **网格布局中的空距**

   在网格中创建空距的方法有很多。比如，给网格项声明外边距，利用网格轨道的不同对齐方式（如前面的 `space-between`），或者创建空的网格轨道来充当空距。

   如果希望所有轨道间的空距都是一个固定的值，那么最简单的方法是使用如下的 `grid-column-gap` 和 `grid-row-gap` 属性。通过它们可以创建固定宽度的空距，就好像网格线有了宽度一样。这其实就相当于多栏布局中的 `column-gap` 或表格中的 `border-spacing`：

   ```css
   .grid {
     display: grid;
     grid-template-columns: repeat(5, 1fr);
     grid-column-gap: 1.5em;
     grid-row-gap: 1.5em;
   }
   ```

#### 7.3.4 自动网格定位

在示例新闻网站的子区块中，最左边的列是为标题保留的，其他空间则全部由 .story 元素填充。如果像下面这样使用 `:nth-of-type()` 选择符来明确地定义它们的网格位置，那就太麻烦了。

```css
.story-featured {
  grid-area: 1/2/2/4;
}
.story:nth-of-type(2) {
  grid-area: 1/4/2/5;
}
/* ……还有更多 */
```

好在 Grid Layout 规范提供了一种自动定位（automatic placement）的机制。这种机制是 Grid Layout 中默认的，不会改变网格项的源代码次序。所有网格项自动从第一行第一个可用的网格单元开始，逐列填充。一行填满后，网格会自动开启一行并继续填充。

这就意味着，只要指定以下几点，Grid Layout 就会自动完成网格项的定位：

- 网格定义
- 标题区域
- 重点文章跨两列

剩下的元素会依序填充。实现之前基于浮动的布局的所有代码就这些：

```css
.grid-a {
  display: grid;
  grid-template-rows: auto auto auto;
  grid-template-columns: repeat(5, 1fr);
}
.subcategory-header {
  grid-row: 1/-1;
}
.story-featured {
  grid-column: span 2;
}
```

只有 5 条声明！完整的代码还会更多一些，因为还要设置网格项的间距什么的，但区区这几行代码就实现了之前基于浮动实现的布局。下图展示了 .story 元素填充网格的过程。

![自动填充网格](./image/自动填充网格.jpg)

1. **自动定位的次序**

   自动定位机制就可以满足需求。在此之上，还可以控制一些东西，同时也不必明确指定网格项的起止位置。

   当前的例子中，网格项的次序与源代码次序一致。就像 Flexbox 一样，也可以使用 `order` 属性来控制摆放网格项的位置。每个网格项的默认次序是 0。整数值，包括负值在内，都是有效的。

   ```css
   .story:nth-of-type(2),
   .story:nth-of-type(3) {
     order: -2;
   }
   .story-featured {
     order: -1;
   }
   ```

   这样就把重点文章放到了第三项，原来的第二项和第三项（在网格容器中带有 .story 类名的第二个和第三个 article 元素）跑到了前头。此后，所有文章都按默认的 `order:0;` 排列。

   > **注意**：同一网格区可以放多个重叠的元素。此时, order 属性也会影响它们的绘制次序。而且与 Flexbox 中一样,可以通过 z- index 控制网格项的堆叠顺序,而无须设置任何定位属性。每个网格项分别构成自己的堆叠上下文。

2. **切换自动定位算法**

   默认的自动定位算法是逐行地填充网格项，也可以设置为逐列填充，通过 `grid-auto-flow` 属性来控制这一顺序：

   ```css
   .my-row-grid {
     grid-auto-flow: row; /* 默认值 */
   }
   .my-columnar-grid {
     grid-auto-flow: column;
   }
   ```

   这个默认定位算法很简单：从头开始，只跑一遍，逐个寻找要放置网格项的网格单元。如果网格项跨多个网格单元，那么网格中就会出现空洞。

   ![自动定位算法](./image/自动定位算法.jpg)

   如果改成使用稠密模式（默认为稀疏模式），自动定位算法会跑多遍，每次都从头开始，尽力找到最前面的空位置。结果就是网格会更稠密。

   ```css
   .grid {
     grid-auto-flow: row dense;
   }
   ```

#### 7.3.5 网格模板区

CSS Grid Layout 的 “命名模板区”（named template area）也许是其最不可思议的特性之一。通过这个特性，能够以可视化方式来指定如何排布项目。因为这个特性更适合简单的网格，所以以之前示例中的第二个子区块为例。假设想在这个区块中放两篇新闻和两个广告：

在标记中，按照内容的重要程度来排序，标题、新闻，最后是广告：

```html
<section class="subcategory">
  <div class="grid-b">
    <header class="subcategory-header"></header>
    <article class="story"></article>
    <article class="story"></article>
    <div class="ad ad1"></div>
    <div class="ad ad2"></div>
  </div>
</section>
```

然后使用 `grid-template-areas` 属性来声明网格布局：

```css
.grid-b {
  display: grid;
  grid-template-columns: 20% 1fr 1fr 1fr;
  grid-template-areas: 'hd st1 . st2' 'hd st1 . st2';
}
```

`grid-template-areas` 属性的值是以空格分隔的字符串列表，每个字符串本身是空格分隔的**自定义标识符**，表示网格中的一行，其中每个标识符表示一列。标签符的名字随便起，只要不跟 CSS 关键字冲突即可。

跨行或跨列相邻的同名网格单元构成所谓的命名网格区。命名网格区必须是矩形。用点号表示的区域是匿名单元，没有名字。

如下图所示的网格区中，使用了类似 ASCII 字符图的方式，可视化地声明了网格行如何从上往下排列（当然两行字符串写成一行也可以，不过写成两行更形象）。

![命名网格区](./image/命名网格区.jpg)

列模板指定第一列宽度为 20%，其他列各占剩余宽度的 1/3。为了把网格项放到网格中，仍然使用 `grid-area` 属性，但这次使用自定义的网格区名。

```css
.grid-b .subcategory-header {
  grid-area: hd;
}
.grid-b .story:nth-child(2) {
  grid-area: st1;
}
.grid-b .story:nth-child(3) {
  grid-area: st2;
}
```

之所以没给广告指定命名网格区或具体位置，是因为对这个例子来说没必要。默认的自动定位算法就可以把它们放到剩余的空单元中。

如果现在在新闻的上头和下头再插入 5 条广告，只要把广告追加到标记末尾，然后像下面这样改一改 `grid-template-areas` 就行了：

```css
.grid-b {
  display: grid;
  grid-auto-columns: 1fr;
  grid-template-areas: 'hd ... ... ...' 'hd st1 ... st2' 'hd ... ... ...';
}
```

这个例子也展示了另一种表示未命名单元的点模式。规范允许用连续多个点表示一个匿名单元，因为这样更方便对齐多行模板字符串。

> 前面基本把 Grid Layout 模块最重要的特性都介绍完了，但还有更多内容没有。这个模块支持以多种方式表达网格结构，所以本身挺庞大也挺复杂的。

## 八. 响应式 Web 设计

iPhone 在 2007 年的首次亮相，标志着移动设备上网体验的巨大进步。于是人们争先恐后地针对手机和触屏分别设计独立的网站，由此造成了 “移动 Web” 和 “桌面 web” 的分野。

时至今日，浏览器的身影可谓无处不在。手机、平板电脑、台式电脑、智能电视、智能手表，以及各式各样的游戏机和游戏终端里，都可以看到它们。

专为这些设备和终端分别建立网站终究不现实，而且它们之间的界限其实也很模糊。于是，只创建一个能适配多种设备的网站，或者响应式网站，成为一种常规的套路。

响应式 Web 设计原理很简单，主要难在细节上。本章就来介绍相关的 CSS 和 HTML 技术：

- 响应式 Web 设计的历史和起源
- 视口、媒体类型及媒体査询的原理
- 响应式网站设计的 “移动优先” 法则
- 何时以及在何处创建断点
- 使用 Flexbox、网格布局及多列布局的响应式设计
- 响应式排版和响应式媒体内容

### 8.1 一个例子

从 CSS 的角度来看，响应式 Web 设计最核心的一点，就是可以适配不同视口大小的流式布局。本章就从改造上章中的新闻站点开始，目标是将其改造成响应式布局。

#### 8.1.1 简单上手

对于较窄的视口，比如手机屏幕，一个简单的布局通常就行了。这个布局只有一列，按照内容重要程度排列（也就是 HTML 源代码中的顺序），如图 8-1 所示。

![窄屏幕下的单列布局](./image/窄屏幕下的单列布局.jpg)

第 7 章的示例代码则需要删除一部分。所有指定宽度的代码基本都得去掉，只保留行和列设置内、外边距的代码。同时，还要把列设置为浮动和 100% 宽度，以保证行可以包含浮动的子元素。

```css
.row {
  padding: 0;
  margin: 0 -0.6875em;
}
.row:after {
  content: '';
  display: block;
  clear: both;
  box-sizing: border-box;
  padding: 0 0.6875em 1.375em;
  float: left;
  width: 100%;
}
```

#### 8.1.2 媒体查询

如果视口更宽一些，那就有可能在一屏之内显示更多内容。比如，可以让第二篇和第三篇报道各占容器的一半。

![稍宽屏幕两则报道并列显示](./image/稍宽屏幕两则报道并列显示.jpg)

通过缩放窗口来确定在什么情况下并排展示两篇报道，发现合适的最小宽度是 560 像素或 35em。这里需要添加所谓的**媒体查询**，让其中的规则只在满足最小宽度条件时才触发：

```css
@media only screen and (min-width: 35em) {
  .row-quartet > * {
    width: 50%;
  }
  .subcategory-featured {
    width: 100%;
  }
}
```

如果条件为真，就执行这些代码。媒体查询使用的 `@media` 规则与 `@supports` 规则相似，都是 CSS 中的 “if” 语句，针对的是显示网页的环境的能力。在这个例子中，条件就是浏览器视口至少 35em 宽。而像这样引入媒体查询的宽度值，就叫作**断点**。

> **注意**：断点相关的规则与设备类型无关，无论是手机还是其他什么设备都可以。换句话说，

对于这个断点，只要关心在这么大的空间里该如何有效地展示内容就行了。不建议基于特定的设备宽度来设置断点，因为新设备层出不穷。也不能通过更多的断点来区分 “移动 Web” 和 “桌面 Web”。

#### 8.1.3 加入更多断点

继续增大浏览器窗口，随着空间增大，可以找出更高效地利用空间的方式。在宽度约 800 像素（50em）的时候，可以并排放 4 篇报道，此时让重点报道占总宽度的一半。此时的布局就有点类似刚开始时 “非响应式的” 例子了，除了子分类的标签还在报道上方：

```css
@media only screen and (min-width: 50em) {
  .row-quartet > * {
    width: 25%;
  }
  .subcategory-featured {
    width: 50%;
  }
}
```

![较大内容区](./image/较大内容区.jpg)

最后，发现在宽度约 70em 或 1120 像素时，可以把子分类标题放到一侧：

```css
@media only screen and(min-width: 70em) {
  .subcategory-header {
    width: 20%;
  }
  .subcategory-content {
    width: 80%;
  }
}
```

![最宽布局](./image/最宽布局.jpg)

到现在为止，就完成了这个例子的响应式版本，涵盖了 4 种不同的布局。

前面的代码并不多，但是封装并体现了一些有用的技术和原理。首先，从一个纯粹的单列布局开始，然后使用媒体查询限定布局改变的条件，而这正是响应式 Web 设计的基础。在进一步探讨新内容之前，先来回顾一下响应式 Web 设计的起源。

### 8.2 响应式 Web 设计的起源

发明 “响应式 Web 设计” 一词的人叫 Ethan Marcotte，他是一位设计师兼开发者。2010 年他在 “A List Apart” 网站上写过一篇文章，名称就是《[响应式 web 设计](https://alistapart.com/article/responsive-web-design)》。文中使用 “响应式 Web 设计” 这一概念，描述综合了流动网格、弹性嵌入对象（图片或视频）及媒体查询适配，从而不受屏幕大小限制的布局模式。这篇文章后来被他扩展成一本小书，从此响应式 Web 设计就流行起来了。

虽然响应式 Web 设计作为一种设计思潮相对较新，但一套设计适配不同设备的想法则很早就有了。

从技术角度来看，响应式 Web 设计的构成要素其实早就存在了。媒体查询（及其前身，媒体类型）正是在有些人呼吁适配浏览器布局技术的背景下才得以成为标准的。事实上，Ethan 的文章也受到了 John Allsopp 在 2000 年表的文章 _A Dao of Web Design_ 的影响在这篇文章中，John 主张优秀的 Web 设计应该更多地迎合用户，而不是追求像素级控制。这个转变需要时间，但转变确实已经发生了。

到了 2010 年，媒体査询得到了浏览器的广泛支持。而且那时移动设备也开始普及，通过手机浏览器查看网页也变得习以为常。通过综合几种已有的技术并创造 “响应式 Web 设计” 的概念，Ethan 让这个 Web 设计期待已久的发展方向有了自己的名字。

响应式 Web 设计正在迅速成为网页设计约定俗成的方式，并可能在将来成为 “优秀 web 设计” 的代名词。不过在那之前，响应式 Web 设计一般指适配多种设备和多种屏幕尺寸的 web 设计。

**CSS 之外的响应性**
今天，响应式技术广泛应用于各种大大小小的网站。Ethan 响应式技术的 “三驾马车” 仍然是响应式 Web 设计的基础，但也得到了长足的发展和补充。其中最常见的就是通过 JS 根据不同设备为页面添加交互功能或改变展示外观。

比如现今已司空见惯的 “三明治菜单”。通常在大屏幕上，全局导航菜单会扩展开来，而在小屏幕上，它们会隐藏到 “三明治” 按钮后面。这里一般会用 JS 根据视口大小来切换显示方式。但关键在于，原本的内容和 HTML 标记没有变化，与设备无关。这种 “核心体验” 可以通过编程方式进行任意转换。

这里的模式想必大家都熟悉：先加载核心资源，之后再根据设备的能力决定是否加载更多资源。没错，响应式 web 设计也是渐进增强的一个例子。

本章侧重讲解 CSS 与响应式 Web 设计的关系，稍带讲一下响应式图片。如果希望深入了解更多响应式网站的高级模式，推荐看一下 Brad Frost 的 [This is Responsive](https://bradfrost.github.io/this-is-responsive/)，其中汇集了大量使用模式和案例。

掌握响应式 CSS 的第一步就是理解呈现网页的这块画布：视口。

### 8.3 浏览器视口

视口就是浏览器显示网页的矩形区域。这个区域对布局的影响，用 CSS 的话来说，就是 “有多少空间可用”。要恰当地使用视口进行响应式设计，需要理解视口的原理，以及如何操纵它。在桌面浏览器上，视口的概念很直观，就是通过 CSS 像素来合理利用视口中的空间。

> 这里有一点需要特别说明，那就是何为 CSS 像素。CSS 像素跟屏幕的物理像素不是一回事。**CSS 中说的像素与屏幕物理像素之间存在一种灵活的对应关系。这个关系取决于硬件、操作系统和浏览器，以及用户是否缩放了页面**。

如果页面的 body 元素中有两个 div。如果将第一个 div 设置为 width: 100%，第二个 div 设置为以像素为单位的宽度，那么这里设置为多少像素才能让两个 div 宽度相等?答案是当前视口的 CSS 像素数，而这与屏幕当前有多少物理像素无关。

来看一个具体的例子，iPhone5 的物理像素宽度为 640 像素，但在 CSS 中的视口宽度是 320 像素。这里有一个比例系数，也就是每个 CSS 像素相当于 2×2 个物理像素。

“虚拟的” CSS 像素与实际的硬件像素之间的比例系数，范围从 1（1 个 CSS 像素 = 1 个物理像素）到 4（1 个 CSS 像素 = 4×4 个物理像素）不等，视设备屏幕的分辨率不同而不同。

好消息是，对于响应式布局，要关心的只有 CSS 像素；至于它跟物理像素的比例，不用关心。坏消息是，必须就此深入理解视口的工作机制，以便让两者协调，来满足需求。

#### 8.3.1 视口定义的差别

触屏手机和其他移动设备把事情搞得有点复杂。在这些设备上，频繁缩放并不是査看网页的最佳方式。这就导致了设备制造商发明了一个新概念来影响视口。移动平台策略专家 Peter Paul Koch 深入研究过这些不同视口的差异，也曾试图给它们起一个好理解的名字。

1. **默认视口和理想视口**

   智能手机浏览器刚出现时，还没多少网站专门针对小屏幕做过优化。于是，多数移动设备（包括平板电脑）上的浏览器都会硬性呈现桌面大小的视口，从而让未经优化的网站能够显示。通常的做法是模拟一个大约 1000 像素宽的视口，然后在其中显示缩小后的页面。这种视口称为 “默认视口”，它是实现响应式设计的第一道 “关卡”。

   既然默认视口是一个模拟的视口，那就意味着还有一个与设备自身尺寸接近的视口。没错，这个视口就称为 “理想视口”。理想视口的大小因设备、操作系统和浏览器而异，但一般对手机而言，宽度大约在 300~500 CSS 像素之间；对平板电脑而言，宽度大约在 800~1400 CSS 像素之间。以 iPhone5 为例，其理想视口的宽度就是 320 像素。在响应式设计中，这才是设计要用的视口。

2. **可见视口和布局视口**

   明确了移动设备中默认视口和理想视口的差别，就可以从视口实际工作机制的角度来给它们一个共同的、直观的定义了。首先，显示网页的这个矩形区域，称其为 “可见视口”。这个视口等于浏览器窗口减去所有按钮、工作条、滚动条等组件之后，实际包含网页内容的空间（也称为 “浏览器骨架”，browser chrome）。

   放大网页时，网页的某些部分会跑到可见视口之外。此时，看到的仍然是可见视口，而假想的那个约束 “整个页面” 的矩形区域，称其为 “布局视口”。可见视口与布局视口的工作机制在桌面浏览器和移动浏览器中是一样的。

   视口并不简单。不过，对于响应式 Web 设计而言，只会基于每个设备的 “理想视口” 来适配页面。桌面浏览器不需要任何特殊对待，因为桌面浏览器的理想视口就是其默认视口。但在智能手机和平板电脑中，就需要拆解模拟的默认视口，令其等于理想视口。这需要通过 HTML 中的 meta 元素来做到。

#### 8.3.2 配置视口

要让具有不同默认视口的设备都使用各自的理想视口，只要在页面的头部元素中添加一个小小的视口 meta 标签即可。这个标签如下：

```html
<meta name="viewport" content="width=device-width, initial-scale=1" />
```

这行代码告诉浏览器，希望使用当前设备的理想尺寸（即 device-width）作为视口宽度的基准。这里同时还设置了 initial-scale=1，其作用是设置与理想视口匹配的缩放级别。这个配置也能帮避免 IOS 中一些奇怪的缩放行为。虽然在多数设备中，只要设置缩放级别，它们就会将视口宽度默认设置为 device-width，但为了确保跨设备和跨操作系统兼容，还是需要同时把这两项都设置上。

initial-scale 的值大于 1，表示要放大布局，实际会导致布局视口缩小，因为能显示的像素少了。相反，小于 1 的值会缩小布局，实际会导致布局视口中可容纳的 CSS 像素增多。

**其他可配置的值**
这里也可以将 width 设置为具体的像素值，而不是 device-width 关键字，这样实际上将布局视口设置为指定的宽度。如果此时还设置了 initial-scale 值，那么移动浏览器会选择应用其中较大的。

**不要禁用缩放！**
可以通过在视口 meta 标签中设置 maximum-scale 和 minimum-scale 属性（为数值）锁定缩放范围。通过设置 user-scalable=no 也可以完全禁用缩放。如下视口 meta 标签并不少见：

```html
<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
```

这样用户在移动设备上就不能缩放网页了，因此网页的适应性会变差。即使在设计网页时会考虑给文本和可操作的部分（如链接和按钮）应用较大和较明显的样式，视力或行动有障碍的用户可能仍然会感到不便。

有些开发者喜欢禁用缩放，以便让自己的 Web 应用看起来更像原生的移动应用。而且，这样也能在老平台上避免一些因缩放导致的奇怪问题，但随着平台发展，这些问题其实都已不复存在。

在响应式设计中禁用缩放，无异于把洗澡水和孩子一起倒掉。毕竟，通用、无障碍的访问才是 Web 最突出的优点之一。

### 8.4 媒体类型与媒体查询

#### 8.4.1 媒体类型

依据设备能力来分离样式的能力，始于媒体类型。HTML 4.01 和 CSS 2.1 定义了媒体类型，用于针对特定的环境应用样式，包括屏幕显示、打印和电视等。

通过给 link 元素添加 `media` 属性，可以指定在哪些设备上应用相关样式，比如：

```html
<link rel="stylesheet" href="main.css" media="screen, print" />
```

这段代码的意思是将相关的样式应用于（任意）屏幕显示和打印。如果不关心媒体类型，可以在这里使用 all 关键字，或者干脆不写 media 属性。逗号分隔的有效类型关键字列表，意味着只要其中一个匹配即可。如果一个都不匹配，则不应用该样式表。

除了在 HTML 中指定媒体类型，还可以在 CSS 文件中指定。最常见的方式就是使用 `@media` 语法，比如：

```css
@media print {
  /* 针对打印机的选择符和规则 */
  .smallprint {
    font-size: 11pt;
  }
}
```

除了 screen 和 print，还有一些常用的媒体类型，包括 handheld 和 tv。这两个貌似可以在响应式设计中使用，但其实不行。由于种种原因，浏览器开发商都不会明确给出某设备所属的媒体类型，因此用得上的类型就只剩 screen、print 和 all 了。

#### 8.4.2 媒体查询

因为不仅要指定设备类型，还要指定设备的能力，所以 CSS3 的 Media Queries 规范应运而生。

这个规范扩展了媒体类型，而且语法也是媒体类型加（包含在括号中指定媒体特性的）媒体条件。此外，在媒体选择语法中，也增加了新关键字，用于支持更复杂的逻辑。

在 link 元素中，媒体查询可以这样写：

```html
<link rel="stylesheet" href="main.css" media="screen and (min-width: 600px)" />
```

这样就声明了 main.css 应该用于屏幕媒体，而且媒体条件是视口至少 600 CSS 像素宽。

> **注意**：在媒体查询并不匹配的情况下，很多浏览器仍然会下载 CSS 文件。因此，不要过度使用带媒体查询的 link 标签，否则可能导致下载过多不必要的数据，影响性能。

同样的声明可以在 CSS 文件中通过 `@media` 规则写成如下格式：

```css
@media screen and(min-width: 600px) {
  /* 这里写规则 */
}
```

这里的 `and` 关键字负责把媒体类型与要测试的条件连接起来，因此可以同时测试多个条件：

```css
@media screen and (min-width: 600px) and (max-width: 1000px) {
}
```

多个媒体查询可以写成一连串，用逗号分隔，逗号相当于 “或”。此时，大括号中的规则会在任意媒体查询结果为真时应用。如果所有媒体查询结果均为假，则跳过。

也可以完全忽略媒体类型，只保留括号中的媒体条件：

```css
@media (min-width: 30em) {
  /* ... */
}
/* 这相当于: */
@media all and (min-width: 30em) {
  /* ...*/
}
```

另外，使用 `not` 关键字可以对媒体査询取反。比如下面的媒体査询匹配除屏幕媒体之外的任何媒体：

```css
@media not screen {
  /* 针对非屏幕媒体的样式 */
}
```

还有一个 `only` 关键字，其目的在于避免旧版本浏览器误解媒体查询。

正常情况下，不支持媒体查询的浏览器看到 `screen and (min-width:...` 时，会认为它是语法错误的媒体类型声明，从而忽略它。但是，有些旧版本浏览器可能会在读取完 screen 时停下来，认为它是一个有效的媒体类型，然后为所有屏幕媒体应用样式。

为此，Media Queries 规范特意引人了 only 关键字。这样，当前面提到的旧版本浏览器看到 only 时，就会跳过整个 @media 块，因为媒体类型中从未有过 only 这个关键字。所有支持媒体查询的浏览器则必须忽略掉 only 关键字，仿佛它不存在。

为防止旧版浏览器错误地应用样式，应该像下面这样声明只针对特定媒体类型的样式：

```css
@media only screen and(min-width: 30em) {
  /* ... */
}
```

如果不关心媒体类型，可以简化为：

```css
@media (min-width: 30em) {
  /* ... */
}
```

1. **尺度查询**

   在 width 和 height 中，width（以及 min-width 和 max-width）是响应式 Web 设计的主打属性。QuirksMode.org 的 Peter-Paul Koch 曾做过一次调查（Media Query/RWD/Viewport Survey Results），结果显示，与宽度相关的媒体查询占绝大多数。

   宽度之所以如此重要，是因为创建网页的默认方式就是水平布局最多只能跟视口一样宽。而在垂直方向上，可以让内容自动扩展，用户可以垂直滚动页面。因此，知道什么时候有多少水平空间可用于布局是非常必要的。

   **不要使用设备相关的尺寸**
   也可以让浏览器去比对 device-width 和 device-height，但这两个属性并不总能代表视口，其本质还是屏幕的尺寸。

   实际应用中，很多人混用 width 和 device-width，导致移动浏览器厂商跟风，以便让网站在他们的浏览器中正常展示。未来的 Media Queries 规范中也会废弃设备相关的关键字。无论如何， device- width 和 device- height 的含义很模糊，除非真的必要，否则不要使用它们。

2. **更多尺度：分辨率、宽高比和方向**

   虽然查询视口的尺寸占据了媒体查询的绝大多数，但还可以查询其他设备特性。比如，可以仅在设备的宽度小于高度时，也就是方向改变时，改变布局：

   ```css
   @media (orientation: portrait) {
     /* 竖向屏幕时的样式 */
   }
   ```

   类似地，可以只在视口匹配最小宽高比时应用规则：

   ```css
   @media (min-aspect-ratio: 16/9) {
     /* 宽高比至少为 16:9 时应用 */
   }
   ```

   前面说过，设备的像素比很大程度上并不重要。对于布局来说，这是没问题的。本章后面会使用 `min-resolution` 媒体査询来适配要加载的图片，那时候像素比就很重要了。媒体查询很可能在未来会被扩展，能够检测用户设备和环境的其他方面。

3. **浏览器对媒体查询的支持**

   几乎所有浏览器都已经支持了基本的媒体查询。可惜很多其他的 “CSS3” 特性，IE8 及更早版本的浏览器都不支持。因此，可以使用一些策略。对这些旧浏览器，要么提供一个固定宽度的布局，要么使用腻子脚本，也就是让这些浏览器假装支持新特性的脚本。

   比如 Scott Jehl 的 Respond.js。在不支持媒体查询的浏览器中，这个脚本会从链接的所有 CSS 文件中搜索媒体查询语法，然后根据屏幕大小应用或删除相应的样式，模拟原生媒体查询的机制。

   使用 Respond.js 有两个问题。比如，这个脚本对直接写在页面 style 元素中的媒体查询无效。此外，还有一些边界情况需要避免，因此在使用这个脚本前，需要仔细阅读一下其网站的说明。

   如果使用 JS 不能满足要求，那么可以通过条件注释包含特定的样式表，在旧版本 IE 中将其固定为特定的 “桌面” 宽度。

   条件注释是直至（但不含）IE10 都存在的一组特殊语法。在非 IE 浏览器中，条件注释就像正常的 HTML 注释一样，会被忽略掉。相应版本的却可以识别其中包含的机关。总之，这是能够针对特定版本或某组版本的引入资源的特殊语法。

   针对桌面 IE 应用宽屏样式的条件注释需要考虑旧版本 IE，同时不能针对旧版本 Windows Phone 中的 IE。写出来就像下面这样：

   ```css
    <!--[if (lt IE 9) & (!IEMobile)]>
    <link rel="stylesheet" href="oldIE.css" media="all">
    <![endif]-->
   ```

   这个策略的前提是，已经把其他样式放到了另一个样式表中，而且针对小屏幕的样式是 “默认样式”，针对宽屏的样式通过媒体查询来单独应用。这是一种推荐做法。

### 8.5 响应式设计与结构化 CSS

在本章开始时举的例子中，代码中删除了宽度和布局规则，又将它们添加到了 min-width 媒体查询块中。这种方式不仅有助于减少代码量，也是一个重要策略的一部分。

#### 8.5.1 移动优先的 CSS

“移动优先” 这是一种关于如何分配设计与开发资源的策略。移动设备的屏幕小，输入不便，通常处理器和内存等硬件配置比台式电脑要低一些。但这些设备也是很多人随身携带的。

通过在设计和开发中首先聚焦于这些设备，一开始就要考虑很多限制因素，从而能够着眼于数字产品的核心。而在面向其他设备开发更大型的网站或应用时，可以再引入扩展的能力。

如果采取相反的路线，那就要考虑怎么把已有的功能塞进一个有限的平台，难度会更大。同样的思考方式也适用于 CSS，即使在重构一个 “桌面” 网站。

CSS 文件中的第一批规则，既针对最小的屏幕，也针对那些不支持媒体查询的测览器。

- **基本的版式**：大小、颜色、行高、标题、段落、列表、链接，等等。
- **基本的 “盒子”**：特定的边框样式、内边距、弹性图片、背景颜色和一些背景图片。
- **基本的跳转和浏览组件**：导航、表单和按钮。

接下来在移动设备和各种浏览器中测试，通过调节窗口大小，会发现这些样式在某个点上需要调整:行的长度变得过长，内容之间离得太远，等等。这时就可以考虑添加媒体查询了，这个点就叫**断点**。重申一下，断点可以使用任何度量方式表达，但重点是让代码适应内容，而不是某个设备的像素尺寸。

```css
/* 开始时先写基本样式和小屏幕的样式 */
.myThing {
  font-size: 1em;
}
/* 然后在 min-width 媒体查询中调整 */
@media only screen and(min-width: 23.75em) {
  .meThing {
    width: 50%;
    float: left;
  }
}
/* 进一步调整 */
@media only screen and (min-width: 38 75em) {
  .myThing {
    width: 33.333%;
  }
}
```

看一看本章开始时那个例子的代码，就会发现也在使用这种方法。这是把 “移动优先” 策略落实到代码的结果。而且，这种方法也反映了移动优先、响应式 Web 设计及渐进增强等设计理念的相互融合。代码尽可能少，而适用的设备却尽可能多，这就说明方法对。

**媒体查询与 em 单位**
在媒体查询中使用 em 单位可以进一步强化设计，使其更能适应变化的环境。多数桌面浏览器会在用户放大页面时，基于像素单位的查询来缩放，但用户也可以不缩放网页，而是修改浏览器的基准字号。

使用 em 单位可以让布局在后一种情况下正常伸缩，因为 em 就是以文档的基准字号为参照的。

> **注意**：在媒体查询中使用的 em 始终相对于浏览器偏好中的基准字号，而不是可以通过调整的 html 元素的字号（1rem）。

**最大宽度查询与小屏幕样式**
以 `min-width` 查询作为主要工具，可以基于视口宽度渐进地应用调整。但是也不能忽略 `max-width` 查询。有时候可能会应用一些适合小屏幕，但不见得适合大屏幕的样式。此时如果使用 `min-width`，就要先写出样式，再对选择条件取反。使用 `max-width` 查询可以省点事。

比如，可能希望在小屏幕中给标题应用窄一点的字体，从而避免过多折行。使用 min-width 并应用 “移动优先” 策略，可以像下面这样写：

```css
body {
  font-family: 'Open Sans', Helvetica Neue, Arial, sans-serif;
}
h1,
h2,
h3 {
  font-family: 'Open Sans Condensed', 'Arial Narrow', Arial, sans-serif;
}
@media only screen and (min-width: 37.5em) {
  h1,
  h2,
  h3 {
    font-family: 'Open Sans,Helvetica Neue', Arial, sans-serif;
  }
}
```

由于小屏幕样式中要对窄字体标题取反，font-family 声明在这里不得不重复出现。如果在这里换成使用 max width，那么代码量会减少，维护也更方便：

```css
body {
  font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif;
}
@media only screen and (max-width: 37.5em) {
  h1,
  h2,
  h3 {
    font-family: 'Open Sans Condensed', 'Arial Narrow', Arial, sans-serif;
  }
}
```

当然，还有一些可用的媒体查询可以改变网站设计。具体使用什么条件，要根据情况而定。但不管怎样，使用 `min-width` 作为主打属性，可以很好地将媒体查询作为渐进增强的一种方式。

#### 8.5.2 媒体查询放在何处

示例中的样式表，前头是基本的 “不限定范围” 样式，后头是 min-width 查询，可以看作包含媒体查询的样式表的简单范例。

媒体查询也可用于不同的目的：调整细节或重排布局。通常这两类媒体查询的条件也不太一样，因此有必要区别对待。

样式表的结构并没有硬性规定。不过，把不同用途的媒体查询分门别类会比较清晰。

- 影响整个页面布局的媒体查询通常涉及一堆类名，这些类名代表的是网站中的主要组件，另外会涵盖几种不同的屏幕尺寸。这类媒体查询一般建议放在与布局相关的规则附近。

- 如果有调整网站组件中某些细节的媒体查询，可以把它们放在定义该组件样式的规则旁边。

- 如果出现了在相同断点下对布局的很多修改，以及对个别组件的小修小补，那么把它们统一放到样式表最后可能比较好。这样做体现了先通用后具体的设计模式。

最重要的一点是，媒体查询放在哪里，并没有固定位置。这也意味着，可以按照自己团队和项目的需要来组织 CSS 代码。

> **注意**：媒体查询不会增加其选择符的特殊性，因此代码结构和顺序要确保它们不会在别处被覆盖。另外，把它们放在最后也不能保证它们可以覆盖前面的声明，它们仍然遵循正常的层叠规则。

### 8.6 几种响应式设计模式

“移动优先” 的 CSS 编写方式体现了响应式设计的一种基本模式。除此之外，还有很多模式可以让设计更灵活、适配性更强。而且随着新技术的出现，还会涌现出更多更好的模式。本节介绍几种值得推荐的模式。

#### 8.6.1 响应式文本列

第 4 章介绍的 CSS3 Multi-column Layout 规范是 CSS 中很早就以响应式设计为目标的一个规范，只不过当时还没有 “响应式” 这个词而已。这个规范使用列宽而不是列数，让内容能够在容器中分布到尽可能多的列中：

```html
<div class="multicol">
  <p>Lorem ipsum [...]</p>
  <!--省略其他代码-->
</div>
```

实现这个响应式文本列的 CSS 只有一行，用不着媒体查询：

```css
.multicol {
  column-width: 16em;
}
```

> 多栏文本在网页中应该尽量少用。这种模式的用武之地，就是文本内容本身不是特别长，无须让用户在很宽的屏幕上滚动很多的情况。此时，利用多列文本既可以避免声明过宽的容器，也可以有效利用水平空间。

#### 8.6.2 没有媒体查询的响应式 Flexbox

Flexbox 也是 CSS 中具有某种响应式特质的规范。无须使用媒体查询，Flexbox 本身就可以创建出能够有效利用空间的适配布局。

假设要创建一个购物工具，通过它来为时光机购买零件，只要单击按钮就可以增加或减少购物车中的零件数量：

这个零件列表是无序列表，每一项都有如下结构：

```html
<ul class="ordering-widget">
  <li class="item">
    <span class="item-name">Flux capacitor regulator</span>
    <span class="item-controls">
      <button class="item-control item-increase" aria-label="Increase">+</button>
      <button class="item-control item-decrease" aria-label="Decrease">-</button>
    </span>
  </li>
  <!-- 省略其他代码 -->
</ul>
```

给名称和按钮应用灵活的尺寸，这样在整个组件在一行里放不下时，便能够自动改变布局。

首先，给列表应用一些重置样式，以及一些基本的排版规则：

```css
.ordering-widget {
  list-style: none;
  margin: 0;
  padding: 0;
  font-family: 'Avenir Next', Avenir, SegoeUI, sans-serif;
}
```

然后把每一个列表项转换成一个 Flexbox 行：

```css
.item {
  color: #fff;
  background-color: #129490;
  display: flex;
  flex-wrap: wrap;
  font-size: 1.5em;
  padding: 0;
  margin-bottom: 0.25em;
}
```

为容纳最长的零件名，每一项至少 13em 宽，而超出的空间可以自动填充：

```css
.item-name {
  padding: 0.25em;
  flex: 1 0 13em;
}
```

然后，包含两个按钮的 span 也应该自动填充可用空间，且最少为 4em 宽。同时它们也作为按钮的 Flexbox 容器：

```css
.item-controls {
  flex: 1 0 4em;
  display: flex;
}
```

每个按钮都转换成 Flex 项，占据相同宽度。其他样式主要用于调整按钮的默认样式：

```css
.item-control {
  flex: 1;
  text-align: center;
  padding: 0.25em;
  cursor: pointer;
  width: 100%;
  margin: 0;
  border: 0;
  color: #fff;
  font-size: inherit;
}
```

最后就是按钮本身的背景颜色：

```css
.item-increase {
  background-color: #1e6f6d;
}
.item-decrease {
  background-color: #1c5453;
}
```

这些就是响应式购物界面的所有样式！其中最有意思的地方是，如果加减按钮控件（.item-controls 元素）不能跟固定宽度的 .item-name 元素共处一行，它们就会自动折行，共同占据第二行。因为 .item-controls 元素的 flex-grow 属性值默认为 1，所以它们会扩展并占据一整行，即每个按钮占半行。

**容器相关的响应式组件**
在前面的例子中，没有使用媒体查询，却也创建了一个响应式的组件，降低了 CSS 的复杂度。这种包装行为虽然简单，却是使用浮动或行内块无法实现的。

另外，这种基于 Flexbox 的组件并不能根据视口大小而变化，只能基于包含它们的容器中的可用空间而变化。这通常正是想要实现的效果。

媒体查询虽然是基于视口的创建响应式布局的主打方式，但它们并没考虑特定组件出现在多个可能的位置，以及渲染为不同宽度的情况。换句话说，如果一个组件出现在很窄的侧栏中，希望它能以匹配这种狹窄环境的方式来显示，而不是根据视口大小进行调整。在某种形式的 “容器查询”（已经有了[相关提议](https://github.com/WICG/cq-usecases)）出现之前，可以先使用 Flexbox。

#### 8.6.3 响应式网格与网格模板区

Grid Layout 提供的属性可以把之前属性承担的布局任务转移到网格容器。下面这个模式使用了[第 7 章](#七-页面布局与网格)介绍的命名模板区域语法，可以极大简化页面布局响应式的创建。

看看第 7 章新闻网站示例中的第二个子标题区，其实只要修改几个地方，就可以把它变成响应式布局。不过，先看看它的 HTML 代码：

```html
<section class="subcategory">
  <div class="grid-b">
    <header class="subcategory-header"></header>
    <article class="story"></article>
    <article class="story"></article>
    <div class="ad"></div>
    <div class="ad"></div>
  </div>
</section>
```

HTML 代码中包含这个区域的标题、两篇文章和两个广告。如果不应用任何布局样式（网格布局或其他布局样式），那么这几个块会垂直堆叠并填满页面。这在小视口中效果很不错。

代码中元素的顺序是按重要程度排列的，因此新闻报道在最前头，最后才是广告。如果广告销售团队担心广告都放在页面底部可能会被忽略掉，希望在移动设备上把广告插到新闻中间呢?

这可以通过网格布局属性来实现。首先，需要给标题和新闻定义网格区域名称：

```css
.grid-b .subcategory-header {
  grid-area: hd;
}
.grid-b .story:nth-of-type(1) {
  grid-area: st1;
}
.grid-b .story:nth-of-type(2) {
  grid-area: st2;
}
```

不用写媒体查询，只要定义网格容器以及其中行的顺序就行了。这样，网格模板就能自动摆好单列内容区中各个项目的次序。现在，广告自动跑到了未命名的区域（由一个点号表示），位于两篇报道中间：

```css
.grid-b {
  display: grid;
  grid-template-columns: 1fr;
  grid-template-areas: 'hd' 'st1' '.' 'st2' '.';
}
```

如果视口再宽一些，那就可以把新闻区修改为 2×2 的网格，只要通过媒体查询添加一个新模板即可：

```css
@media only screen and (min-width: 37.5em) {
  .grid-b {
    grid-template-columns: 1fr 1fr;
    grid-template-areas: 'hd hd ' 'st1 ...', '... st2';
  }
}
```

可以使用任意数量连续的点表示匿名网格区域，从而让代码中的值上下对齐。在更宽一些的视口中，标题还是在内容上方，但新闻和广告可以构成与第 7 章的示例相同的布局：

```css
@media only screen and( min-width: 55em) {
  .grid-b {
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-areas: 'hd hd hd' 'st1 .. st2', 'st2 .. st2';
  }
}
```

最后，再切换到侧边标题加三列布局：

```css
@media only screen and (min-width: 70em) {
  .grid-b {
    grid-template-columns: 20% 1fr 1fr 1fr;
    grid-template-areas: 'hd st1 . st2', 'hd st1 . st2';
  }
}
```

由此可见，使用 Grid Layout 属性可以在某些断点重新定义整个布局，同时又不必去碰个别组件。当然，也可以使用其他网格定位方法来实现响应式布局，但网格模板区域在这里特别适合。只是要记住，不支持它的浏览器会回退为只有一列的布局，因此使用它之前要衡量项目的情况。

### 8.7 响应式布局之外

现在，已经学习了视口和媒体查询的机制，也通过例子展示了响应式布局技术。但响应式网站还有很多细节需要处理。本节就来介绍一些技术，以便网站的其他方面也能具有响应能力。从媒体开始，先介绍背景图片，再介绍嵌入式页面内容。

#### 8.7.1 响应式背景图片

在 CSS 中，让背景图片适配屏幕大小很简单，因为可以使用媒体查询。

```html
<header class="profile-box" role="banner"></header>
```

这里要使用两个图片文件来当背景。小图宽度为 600 像素，剪切为一个正方形。大图宽度为 1200 像素，剪切方式是矩形。

在小视口中，使用小图的背景图片：

```css
.profile-box {
  height: 300px;
  background-size: cover;
  background-image: url(img/small-cat.jpg);
}
```

而在视口变大时，背景图片会自动变大（因为设置了 `background-size: cover`），不过如果尺寸过大，图片就会模糊了。此时，就要切换到大图：

```css
@media only screen and (min-width: 600px) {
  .profile-box {
    height: 600px;
    background-image: url(img/big-cat.jpg);
  }
}
```

这个简单的例子说明了两点。首先，可以使用媒体查询来应用最适合视口的图片。其次，不仅可以通过响应式背景加载不同大小的图片资源，还能基于视口对背景图片应用不同的剪切方式，产生更具艺术性的效果。

**使用分辨率查询切换图片**
在前面的例子中，基于视口的大小来改变图片。而有时候虽然视口大小相同，但希望能基于设备的像素比来加载不同分辨率的图片。对图片来说，其实际像素需要与 CSS 像素对应起来。如果一张固有大小为 400 像素 × 400 像素的图片，在高分辨率的屏幕上也显示为 400 CSS 像素 × 400 CSS 像素，就会导致图片被放大，从而失真、模糊。此时为保持清晰，就需要根据分辨率查询来加载一张更大、分辨率更高的图片。

假设想针对最小的屏幕加载一张叫 medium-cat.jpg 的图片，条件是像素比至少为 1.5。这个 medium-cat.jpg 也是正方形，不过大小为 800 像素 × 800 像素。1.5 这个数多少有点拍脑袋决定的意思，但它可以保证在高分辨率手机和平板上加载更大的图片，这些设备的像素比最低都是 1.5。当然也可以再继续针对更高的分辨率添加更多媒体查询（以及更多高分辨率图片），只要控制好图片的大小。

基于像素比改变图片，需要测试的标准媒体特性叫 `resolution`，因此这里检测的是 `min-resolution`，单位是 dppx（device-pixels per pixel，每像素的设备像素）。并非所有设备都支持这个标准的查询，因此这里还添加了 `-webkit-mindevice-pixel-ratio`，主要针对 Safari 它只有值，没有单位。

```css
@media (-webkit-min-device-pixel-ratio: 1.5), (min-resolution: 1.5dppx) {
  .profile-box {
    background-image: url(medium-cat.jpg);
  }
}
```

结合使用尺度及分辨率査询，就可以实现针对不同设备加载不同图片的优化策略。

**老式分辨率查询语法**
关于分辨率查询，之前还有几种不同的语法，包括最早的 Firefox 中使用的 `min--moz-device-pixel-ratio` 以及使用 dpi 为单位的 `min-resolution`。

只有一些老版本的实现才支持 dpi 为单位的 `min-resolution`，基本上就是 IE9~IE11。可是 IE 的实现把 dpi 的值搞错了，会导致在某些环境下错误地加载高分辨率图片。

像前面例子一样只使用 `-webkit-min-device-pixel-ratio` 和 `min-resolution`（及 dppx 单位），基本就可以涵盖大部分辨率设备了，代码也不多。虽然旧版本正并不支持，但还是推荐的。要了解这方面更多的信息，可以参考 W3C 的 Elika Etemad 的[文章](https://www.w3.org/blog/CSS/2012/06/14/unprefix-webkit-device-pixel-ratio/)。

#### 8.7.2 响应式嵌入媒体

恰当处理内容图片、视频及其他嵌入对象的可伸缩性，是响应式 Web 设计的难点之一。对于 CSS 背景图片，可以用媒体查询实现很多控制。但对于嵌入页面中的对象，CSS 有时候会显得力不从心。

这方面有些内容超出了 CSS 的技术范畴，但它们可能会影响网站性能，因此掌握它们也很重要。

1. 响应式媒体基础

   第 5 章介绍过实现图片、视频及其他对象弹性化的基本技术。通过设置 `max-width` 属性为 100% 让元素变得可以伸缩，同时又不会超过其固有大小：

   ```css
   img,
   object,
   video,
   embed {
     width: auto;
   }
   ```
