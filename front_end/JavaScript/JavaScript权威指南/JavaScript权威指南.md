---
title: JavaScript权威指南
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [JavaScript 权威指南](#javascript-权威指南)
  - [一. 基础](#一-基础)
    - [1.1 方法与函数的区别](#11-方法与函数的区别)
    - [1.2 JS 支持面向对象的编程风格](#12-js-支持面向对象的编程风格)
    - [1.3. 使用 JS 分析文件中的字符频率](#13-使用-js-分析文件中的字符频率)
  - [二. 词法结构](#二-词法结构)
    - [2.1 字面量含义](#21-字面量含义)
    - [2.2 JS 标识符命名规则](#22-js-标识符命名规则)
    - [2.3 Unicode 转义序列](#23-unicode-转义序列)
    - [2.4 箭头函数的 `=>` 必须跟参数列表在同一行](#24-箭头函数的-必须跟参数列表在同一行)
  - [三. 类型、值和变量](#三-类型-值和变量)
    - [3.1 数值](#31-数值)
      - [3.1.1 整数字面量支持的进制表示](#311-整数字面量支持的进制表示)
      - [3.1.2 数值字面量中的分隔符](#312-数值字面量中的分隔符)
      - [3.1.3 JS 通过 Math 对象提供了一组函数和常量，以支持更复杂的数学计算](#313-js-通过-math-对象提供了一组函数和常量以支持更复杂的数学计算)
      - [3.1.4 Number ES6 新增属性](#314-number-es6-新增属性)
      - [3.1.5 通过 BigInt 表示任意精度整数](#315-通过-bigint-表示任意精度整数)
    - [3.2 文本](#32-文本)
      - [3.2.1 使用字符串](#321-使用字符串)
      - [3.2.2 模板字符串](#322-模板字符串)
    - [3.3 null 与 undefined](#33-null-与-undefined)
    - [3.4 Symbol](#34-symbol)
    - [3.5 类型转换](#35-类型转换)
      - [3.4.1 显式转换](#341-显式转换)
      - [3.4.2 对象到原始值转换](#342-对象到原始值转换)
    - [3.6 变量声明与赋值](#36-变量声明与赋值)
    - [3.7 解构赋值](#37-解构赋值)
  - [四. 表达式与操作符](#四-表达式与操作符)
    - [4.1 表达式](#41-表达式)
    - [4.2 操作符](#42-操作符)
      - [4.2.1 操作符优先级](#421-操作符优先级)
      - [4.2.2 求值顺序](#422-求值顺序)
    - [4.3 算术表达式](#43-算术表达式)
      - [4.3.1 + 操作符](#431-操作符)
      - [4.3.2 一元算术操作符](#432-一元算术操作符)
    - [4.4 关系表达式](#44-关系表达式)
      - [4.4.1 严格相等](#441-严格相等)
      - [4.4.2 比较操作符](#442-比较操作符)
      - [4.4.3 in 操作符](#443-in-操作符)
      - [4.4.4 instanceof 操作符](#444-instanceof-操作符)
    - [4.5 逻辑表达式](#45-逻辑表达式)
      - [4.5.1 逻辑与 (&&)](#451-逻辑与)
      - [4.5.2 逻辑或 (||)](#452-逻辑或)
      - [4.5.3 逻辑非 (!)](#453-逻辑非)
    - [4.6 赋值表达式](#46-赋值表达式)
    - [4.7 其他操作符](#47-其他操作符)
      - [4.7.1 空值合并运算符 (??)](#471-空值合并运算符)
      - [4.7.2 typeof 操作符](#472-typeof-操作符)
      - [4.7.3 delete 操作符](#473-delete-操作符)
      - [4.7.4 await 操作符](#474-await-操作符)
  - [五. 语句](#五-语句)
  - [六. 对象](#六-对象)
    - [6.1 对象简介](#61-对象简介)
    - [6.2 创建对象](#62-创建对象)
      - [6.2.1 对象字面量](#621-对象字面量)
      - [6.2.2 使用 new 创建对象](#622-使用-new-创建对象)
      - [6.2.3 原型](#623-原型)
      - [6.2.4 `Object.create()`](#624-objectcreate)
    - [6.3 查询和设置属性](#63-查询和设置属性)
      - [6.3.1 作为关联数组的对象](#631-作为关联数组的对象)
      - [6.3.2 继承](#632-继承)
      - [6.3.3 属性访问错误](#633-属性访问错误)
    - [6.4 删除属性](#64-删除属性)
    - [6.5 测试属性](#65-测试属性)
    - [6.6 枚举属性](#66-枚举属性)
      - [6.6.1 属性枚举顺序](#661-属性枚举顺序)
    - [6.7 扩展对象](#67-扩展对象)
    - [6.8 序列化对象](#68-序列化对象)
    - [6.9 对象方法](#69-对象方法)
      - [6.9.1 toString() 方法](#691-tostring-方法)
      - [6.9.2 toLocaleString() 方法](#692-tolocalestring-方法)
      - [6.9.3 valueOf() 方法](#693-valueof-方法)
      - [6.9.4 toJSON() 方法](#694-tojson-方法)
    - [6.10 对象字面量扩展语法](#610-对象字面量扩展语法)
      - [6.10.1 简写属性](#6101-简写属性)
      - [6.10.2 计算的属性名](#6102-计算的属性名)
      - [6.10.3 符号作为属性名](#6103-符号作为属性名)
      - [6.10.4 扩展操作符](#6104-扩展操作符)
      - [6.10.5 简写方法](#6105-简写方法)
      - [6.10.6 属性的获取方法与设置方法（访问器属性）](#6106-属性的获取方法与设置方法访问器属性)
  - [七. 数组](#七-数组)
    - [7.1 创建数组](#71-创建数组)
      - [7.1.1 数组字面量](#711-数组字面量)
      - [7.1.2 扩展操作符](#712-扩展操作符)
      - [7.1.3 Array() 构造函数](#713-array-构造函数)
      - [7.1.4 Array.of()](#714-arrayof)
      - [7.1.5 Array.from()](#715-arrayfrom)
    - [7.2 读写数组元素](#72-读写数组元素)
    - [7.3 稀疏数组](#73-稀疏数组)
    - [7.4 数组长度](#74-数组长度)
    - [7.5 添加和删除数组元素](#75-添加和删除数组元素)
    - [7.6 迭代数组](#76-迭代数组)
    - [7.7 多维数组](#77-多维数组)
    - [7.8 数组方法](#78-数组方法)
      - [7.8.1 数组迭代器方法](#781-数组迭代器方法)
      - [7.8.2 使用 `flat()` 和 `flatMap()` 打平数组](#782-使用-flat-和-flatmap-打平数组)
      - [7.8.3 使用 `concat()` 添加数组](#783-使用-concat-添加数组)
      - [7.8.4 通过 `push()`、`pop()`、`shift()` 和 `unshift()` 实现栈和队列操作](#784-通过-push-pop-shift-和-unshift-实现栈和队列操作)
      - [7.8.5 使用 `slice()`、`splice()`、`fill()` 和 `copyWithin()`](#785-使用-slice-splice-fill-和-copywithin)
      - [7.8.6 数组索引与排序方法](#786-数组索引与排序方法)
      - [7.8.7 数组到字符串的转换](#787-数组到字符串的转换)
      - [7.8.8 静态数组函数](#788-静态数组函数)
    - [7.9 类数组对象](#79-类数组对象)
    - [7.10 作为数组的字符串](#710-作为数组的字符串)
  - [八. 函数](#八-函数)
    - [8.1 定义函数](#81-定义函数)
      - [8.1.1 函数声明](#811-函数声明)
      - [8.1.2 函数表达式](#812-函数表达式)
      - [8.1.3 箭头函数](#813-箭头函数)
      - [8.1.4 嵌套函数](#814-嵌套函数)
    - [8.2 调用函数](#82-调用函数)
      - [8.2.1 函数调用](#821-函数调用)
      - [8.2.2 方法调用](#822-方法调用)
      - [8.2.3 构造函数调用](#823-构造函数调用)
      - [8.2.4 间接调用](#824-间接调用)
      - [8.2.5 隐式函数调用](#825-隐式函数调用)
    - [8.3 函数实参与形参](#83-函数实参与形参)
      - [8.3.1 可选形参与默认值](#831-可选形参与默认值)
      - [8.3.2 剩余形参与可变长度实参列表](#832-剩余形参与可变长度实参列表)
      - [8.3.3 Arguments 对象](#833-arguments-对象)
      - [8.3.4 在函数调用中使用扩展操作符](#834-在函数调用中使用扩展操作符)
      - [8.3.5 把函数实参解构为形参](#835-把函数实参解构为形参)
      - [8.3.6 参数类型](#836-参数类型)
    - [8.4 函数作为值](#84-函数作为值)
      - [8.4.1 定义自己的函数属性](#841-定义自己的函数属性)
    - [8.5 函数作为命名空间](#85-函数作为命名空间)
    - [8.6 闭包](#86-闭包)
    - [8.7 函数属性、方法与构造函数](#87-函数属性-方法与构造函数)
      - [8.7.1 length 属性](#871-length-属性)
      - [8.7.2 name 属性](#872-name-属性)
      - [8.7.3 prototype 属性](#873-prototype-属性)
      - [8.7.4 call() 和 apply() 方法](#874-call-和-apply-方法)
      - [8.7.5 bind() 方法](#875-bind-方法)
      - [8.7.6 tostring()方法](#876-tostring方法)
      - [8.7.7 Function() 构造函数](#877-function-构造函数)
    - [8.8 函数式编程](#88-函数式编程)
      - [8.8.1 使用函数处理数组](#881-使用函数处理数组)
      - [8.8.2 高阶函数](#882-高阶函数)
      - [8.8.3 函数的部分应用](#883-函数的部分应用)
      - [8.8.4 函数记忆](#884-函数记忆)
  - [九. 类](#九-类)
    - [9.1 类和原形](#91-类和原形)
    - [9.2 类和构造函数](#92-类和构造函数)
      - [9.2.1 构造函数、类标识和 instanceof](#921-构造函数-类标识和-instanceof)
      - [9.2.2 constructor 属性](#922-constructor-属性)
    - [9.3 使用 class 关键字的类](#93-使用-class-关键字的类)
      - [9.3.1 静态方法](#931-静态方法)
      - [9.3.2 获取方法、设置方法及其他形式的方法](#932-获取方法-设置方法及其他形式的方法)
      - [9.3.3 公有、私有和静态字段](#933-公有-私有和静态字段)
      - [9.3.4 示例:复数类](#934-示例复数类)
    - [9.4 为已有类添加方法](#94-为已有类添加方法)
    - [9.5 子类](#95-子类)
      - [9.5.1 子类与原型](#951-子类与原型)
      - [9.5.2 通过 extends 和 super 创建子类](#952-通过-extends-和-super-创建子类)
      - [9.5.3 委托而不是继承](#953-委托而不是继承)
      - [9.5.4 类层次与抽象类](#954-类层次与抽象类)
  - [十. 模块](#十-模块)
    - [10.1 基于类、对象和闭包的模块](#101-基于类-对象和闭包的模块)
      - [10.1.1 基于闭包的自动模块化](#1011-基于闭包的自动模块化)
    - [10.2 Node 中的模块](#102-node-中的模块)
      - [10.2.1 Node 的导出](#1021-node-的导出)
      - [10.2.2 Node 的导入](#1022-node-的导入)
    - [10.3 ES6 中的模块](#103-es6-中的模块)
      - [10.3.1 ES6 的导出](#1031-es6-的导出)
      - [10.3.2 ES6 的导入](#1032-es6-的导入)
      - [10.3.3 导入和导出时重命名](#1033-导入和导出时重命名)

<!-- /code_chunk_output -->

# JavaScript 权威指南

## 一. 基础

### 1.1 方法与函数的区别

**通过对象使用函数时，称其为方法**，所有的 JS 对象都有方法。

### 1.2 JS 支持面向对象的编程风格

JS 支持面向对象的编程风格，但与“经典的”面向对象编程语言非常不一样。

```js
// 定义 Point 类以表示几何平面上的一个点，作为这个类的实例的对象有一个方法，叫做 distance()，用于计算该点与原点的距离
// 按惯例，类名需要首字母大写
class Point {
  // 构造函数用于初始化新实例
  constructor(x, y) {
    this.x = x; // this 关键字代表要初始化的新对象
    this.y = y; // 将函数参数保存为对象属性
  } // 构造函数中不需要 return 语句

  distance() {
    // 计算从原点到当前点的距离的方法
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
}

// 使用 Point() 构造函数和 new 创建 Point 对象
let p = new Point(1, 1); // 几何平面上的点

// 调用 Point 对象 p 的方法
p.distance(); // Math.SQRT2
```

### 1.3. 使用 JS 分析文件中的字符频率

这个 [Node 程序](./examples/charFreq.js) 使用标准输入读取文本，计算该文本的 _字符频率柱形图_ 和 _总字符数_，然后打印出来。

```js
node charFreq.js < ../JavaScript权威指南.md
```

## 二. 词法结构

编程语言的词法结构是一套基本规则，规定了如何使用这门编程语言编写程序。词法结构是一门语言最低级的语法，规定了变量如何命名、注释的界定符，以及如何分隔程序的语句。

### 2.1 字面量含义

字面量（literal）是一种直接出现在程序中的数据值。

### 2.2 JS 标识符命名规则

JS 标识符必须以字母、下划线`_` 或美元符号`$`开头。后续字符可以是字母、数字、`_` 或 `$`（**数字不能作为第一个字符，以便 JS 区分标识符和数值**）。

### 2.3 Unicode 转义序列

为了方便程序员编码和支持老技术的系统，JS 定义了转义序列，从而可以仅使用 ASCII 字符来表示 Unicode 字符。有两种方式来表示：

- 已 `\u` 开头，后跟 4 位十六进制数字（包括大小写的 A~F）

- 包含在一对花括号中内的 1~6 位十六进制数字。ES6 新增，为了更好的支持大于 16 位的 Unicode 码点，比如表情符号

  ```js
  console.log('\u{1F600}'); // 打印一个笑脸符号
  ```

### 2.4 箭头函数的 `=>` 必须跟参数列表在同一行

## 三. 类型、值和变量

### 3.1 数值

#### 3.1.1 整数字面量支持的进制表示

1. 以 `0x` 或 `0X` 开头，后跟一个十六进制数字字符串。
2. ES6 及以后的版本中，也可以通过二进制或八进制表示整数分别使用前缀 `0b` 和 `0o`。

#### 3.1.2 数值字面量中的分隔符

可以使用下划线将数值字面量分隔为容易看清的数字段。

```js
let billion = 1_000_000_000; // 以下划线作为千分位分隔符
let bytes = 0x89_ab_cd_ef; // 作为字节分隔符
let bits = 0b0001_1101_0111; // 作为半字节分隔符
let fraction = 0.123_456_789; // 也可以使用小数部分
```

> 这个特性暂时没有成为 JS 标准，但已经进入标准化流程的后期，而且已经被所有主流浏览器以及 Node 实现了。

#### 3.1.3 JS 通过 Math 对象提供了一组函数和常量，以支持更复杂的数学计算

```js
// 9007199254740992: 2的53次方
Math.pow(2, 53);
// 1.0: 舍入到最接近的整数
Math.round(0.6);
// 1.0: 向上舍入到一个整数
Math.ceil(0.6);
// 0.0: 向下舍入到一个整数
Math.floor(0.6);
// 5: 绝对值
Math.abs(-5);
// 返回最大的参数
Math.max(x, y, z);
// 返回最小的参数
Math.min(x, y, z);
// 伪随机数 x,范围 0 <= x < 1.0
Math.random();
// π 圆周率
Math.PI;
// 自然对数的底数
Math.E;
// 3**0.5: 3的平方根
Math.sqrt(3);
// 3**(1/3): 3的立方根
Math.pow(3, 1 / 3);
// 三角函数，还有 Math.cos、Math.atan 等
Math.sin(0);
// 10 的自然对数
Math.log(10);
// 以 10 为底 100 的对数
Math.log(100) / Math.LN10;
// 以 2 为底 512 的对数
Math.log(512) / Math.LN2;
// Math.E 的立方
Math.exp(3);
```

ES6 在 Math 对象上又定义了一批函数

```js
// 3: 立方根
Math.cbrt(27);
// 5: 所有参数平方和的平方根
Math.hypot(3, 4);
// 2: 以 10 为底的对数
Math.log10(100);
// 10：以 2 为底的对数
Math.log2(1024);
// (1+x) 的自然对数；精确到非常小的x
Math.log1p(x);
// Math.exp(x)-1; Math.log1p() 的逆运算
Math.expm1(1);
// 对 <、== 或 >0 的参数返回 -1、0 或 1
Math.sign(x);
// 6：优化的32位整数乘法
Math.imul(2, 3);
// 28: 32位整数中前导 0 的位数
Math.clz32(0xf);
// 3: 减掉小数部分得到整数
Math.trunc(3.9);
// 舍入到最接近的 32 位浮点数
Math.fround(x);
// 双曲线正弦，还有 Math.cosh() 和 Math.tanh()
Math.sinh(x);
// 双曲线反正弦，还有 Math.acosh() 和 Math.atanh()
Math.asinh(x);
```

#### 3.1.4 Number ES6 新增属性

```js
// 同全局 parseInt() 函数
Number.parseInt();
// 同全局 parseFloat() 函数
Number.parseFloat();
Number.isNaN(x);
Number.isFinite(x);
// 判断 x 是不是整数
Number.isInteger(x);
// -(2**53 - 1)
Number.MIN_SAFE_INTEGER;
// 2**53 -1
Number.MAX_SAFE_INTEGER;
// 数值与数值之间最小的差
Number.EPSILON;
```

#### 3.1.5 通过 BigInt 表示任意精度整数

ES2020 为 JS 定义了一种新的数值类型 BigInt。之所以增加了这个类型，**主要是为了表示 64 位整数，这对于兼容很多其他语言和 API 是必需的**。

BigInt 字面量写作一串数字后跟小写字母 `n`。默认情况下，进制是 10，但也可以通过前缀 `0b`、`0o`、`0x` 来表示二进制、八进制和十六进制 BigInt。

```js
1234n;
0b11241n; // 二进制 BigInt
0o777n; // 八进制 BigInt
```

可以使用 `BigInt()` 函数把常规 JS 数值或字符串转换为 BigInt 值。

```js
BigInt(123); // 123n
let string = '1' + '0'.repeat(100);
BigInt(string); // 10n**100n: 一个天文数字
```

> 注意：
>
> 1. 算术操作符不能 混用 BigInt 操作数和常规数值操作数。
> 2. 比较操作符允许混用操作数类型。
> 3. 位操作符通常可以用于 BigInt 操作数。
> 4. Math 对象的任何函数都不接受 BigInt 操作数。

### 3.2 文本

JS 中表示文本的类型是 String，即字符串。字符串是 16 位值的不可修改的有序序列，其中每个值都表示一个 Unicode 字符。

#### 3.2.1 使用字符串

```js
let s = 'Hello，world';

// 取得字符串的一部分
s.substring(1, 4); // "ell": 第 2~4 个字符
s.slice(1, 4); // "ell": 同上
s.slice(-3); // rld: 最后 3 个字符
s.split(', '); // ["hello", "world"]: 从界定符处拆开

// 搜索字符串
s.indexOf('l'); // 2: 第一个字母 l 的位置
s.indexOf('l', 3); // 3: 位置3后面第一个 "l" 的位置
s.indexOf('zz'); // -1: s 并不包含子串 "zz"
s.lastIndexOf('l'); // 10: 最后一个字母 "l" 的位置

// ES6 及之后版本中的布尔值搜索函数
s.startsWith('Hell'); // true：字符串是以这些字符开头的
s.endWith('!'); // false：s 不是以它结尾的
s.includes('or'); // true: s 包含子串 "or"

// 创建字符串的修改版本
s.replace('llo', 'ya'); // "Heya, world"
s.toLowerCase(); // "hello，world"
s.toUpperCase(); // "HELLO，WORLD"
s.normalize(); // Unicode NFC 归一化：ES6 新增
s.normalize('NFD'); // NFD 归一化。还有 "NFKC" "NFKD"

// 访问字符串中的个别（16位值）字符
s.charAt(0); // "H": 第一个儿字符
s.charAt(s.length - 1); // "d"：最后一个字符
s.charCodeAt(0); // 72：指定位置的16位数值
s.codePointAt(0); // 72: ES6，适用于码点大于 16 位的情况

// ES2017 新增的字符串填充函数
'x'.padStart(3); // "  x"：在左侧添加空格，让字符串长度变成 3
'x'.padEnd(3); // "x  ": 在右侧添加空格，让字符串长度变成 3
'x'.padStart(3, '*'); // "**x"：在左侧添加星号，让字符串长度变成 3
'x'.padEnd(3, '-'); // "x--"：在右侧添加破折号，让字符串长度变成 3

// 删除空格函数，trim() 是 ES5 就有的，其他是 ES2019 增加的
' test'.trim(); // "test"：删除开头和结尾的空格
' test'.trimStart(); // "test "：删除左侧空格。也叫 trimLeft
' test '.trimEnd(); // " test"：删除右侧空额。也叫 trimRight

// 未分类字符串方法
s.concat('!'); // "Hello，world!"：可以用 + 操作符代替
'<>'.repeat(3); // "<><><>"：拼接 n 次，ES6 新增
```

> **注意**：JS 中的字符串是不可修改的，像 `replace()` 这样的方法都是返回的新字符串，它们并不会修改调用它们的字符串。

#### 3.2.2 模板字符串

**标签化模板字面量**
模板字面量有一个强大但不太常用的特性，如果在开头的反引号前面有一个函数名（标签），那么模板字面量中的文本和表达式的值将作为参数传给这个函数。这个特性可以用于先对某些值进行 HTML 或 SQL 转义，然后在把它们插入文本中。

ES6 提供了一个内置的标签函数：`String.row()`。这个函数返回反引号中未经处理的文本，即不会处理任何反斜杠转义。

```js
`\n`.length; // 1: 字符串中只包含一个换行符
String.raw`\n`.length; // 2: 一个反写杠字符和一个字母 n
```

> **注意**：即使标签化模板字面量的标签部分是函数，在调用这个函数时也没有圆括号。在这种特殊的情况下，反引号字符充当开头和结尾的圆括号。

### 3.3 null 与 undefined

- `undefined` 可以表示一种系统级别、意料之外或类似错误的没有值。
- `null` 可以表示程序级别，正常或意料之外的没有值。

### 3.4 Symbol

**符号（Symbol）是 ES6 新增的一种原始类型。用作非字符串的属性名**。要理解 Symbol，需要了解 JS 的基础类型 Object 是一个属性的无序集合，其中每一个属性都有一个名字和一个值。属性名通常是字符串。但在 ES6 及之后的版本中，Symbol 也可以作为属性名：

```js
let strname = 'string name'; // 可以用作属性名的字符串
let symname = Symbol('propname'); // 可以用作属性名的符号
typeof strname; // string：strname 是字符串
typeof symname; // Symbol：symname 是符号
let o = {}; // 创建一个新对象
// 使用字符串名顶一个属性
o[strname] = 1;
// 使用符号名定义一个属性
o[symname] = 2;
o[strname]; // 1
o[symname]; // 2
```

Symbol 类型没有字面量语法。要获取一个 Symbol 值，需要调用 `Symbol()` 函数。这个函数永远不会返回相同的值，即使每次传入的参数都一样。这意味着可以将调用 `Symbol()` 取得的符号值安全地用于为对象添加属性，而无需担心可能重写已有的同名属性。

如果定义了 Symbol 属性但没有共享相关 Symbol，也可以确信程序中的其他代码不会意外重写这个属性。

实践中，Symbol 通常作为一种语言扩展机制。ES6 新增了 [for/of 循环](../JavaScript.md#4354-forof-循环)和 可迭代对象<!--TODO 第12章-->，为此就需要定义一种标准的机制让类可以实现，从而把自身变得可迭代。但选择任何特定的字符串作为这个迭代器方法的名字都有可能破坏已有的代码。

为此，Symbol 应运而生，`Symbol.iterator` 是一个符号值，可以作一个方法名，让对象变得可迭代。

`Symbol()` 函数可选地接收一个字符串参数，返回唯一的符号值。如果提供了字符串参数，那么调用返回符号值的 `toString()` 方法得到的结果中会包含该字符串。

为了定义一些可以与其他代码共享的 Symbol 值，JS 定义了一个全局符号注册表。`Symbol.for()` 函数接收一个字符串参数，返回一个与该字符串关联的符号值。如果没有 Symbol 与该字符串关联，则会创建并返回一个新 Symbol；否则，会返回已有的 Symbol。

`Symbol.for()` 与 `Symbol()` 完全不同：`Symbol()` 永远不会返回相同的值。而在以相同字符串调用 `Symbol.for()` 时始终返回相同的值。传给 `Symbol.for()` 的字符串会出现在 `toString()` 的输出中。而且，这个字符串也可以通过将返回的符号传给 `Symbol.keyFor()` 来得到：

```js
let s = Symbol.for('shared');
let t = Symbol.for('shared');
s === t; // true
s.toString(); // "Symbol(shared)"
Symbol.keyFor(t); // "shared"
```

### 3.5 类型转换

| 值                 | 转换为字符串                              | 转换为数值                                | 转换为布尔值 |
| ------------------ | ----------------------------------------- | ----------------------------------------- | ------------ |
| undefined          | "undefined"                               | NaN                                       | false        |
| null               | "null"                                    | 0                                         | false        |
| true               | "true"                                    | 1                                         | -            |
| false              | "false"                                   | 0                                         | -            |
| ""(空字符串)       | -                                         | 0                                         | false        |
| "1.2"(非空,数值)   | -                                         | 1.2                                       | true         |
| "one"(非空,非数值) | -                                         | NaN                                       | true         |
| 0                  | "0"                                       | -                                         | false        |
| -0                 | "0"                                       | -                                         | false        |
| 1(有限,非零)       | "1"                                       | -                                         | true         |
| Infinit            | "Infinity"                                | -                                         | true         |
| -Infinity          | "-Infinity""                              | -                                         | true         |
| NaN                | "NaN"                                     | -                                         | false        |
| {}(任何对象)       | [对象到原始值转换](#342-对象到原始值转换) | [对象到原始值转换](#342-对象到原始值转换) | true         |
| [](空数组)         | ""                                        | 0                                         | true         |
| [9]                | "9"                                       | 9                                         | true         |
| ["a"]              | 使用 `join()` 方法                        | NaN                                       | true         |
| Function(){}       | [对象到原始值转换](#342-对象到原始值转换) | NaN                                       | true         |

#### 3.4.1 显式转换

除了 `null` 和 `undefined` 之外的所有值都有 `toString()` 方法。

在使用金融或科学数据时，可能需要控制转换后得到的字符串的小数位的个数或者有效数字的个数，或者需要控制是否采用指数记数法。Number 类为这些数值到字符串的转换定义了 3 种方法：

- `toFixed()`：把数值转换为字符串时可以指定小数点后面的位数。这个方法不使用指数记数法。
- `toExponential()`：使用指数记数法将数值转换为字符串，结果是小数点前 1 位，小数点后为指定位数（意味着有效数字个数比指定的值多 1 位）。
- `toPrecision()`：按照指定的有效数字个数将数值转换为字符串。如果有效数字个数不足以显示数值的整数部分，它会使用指数记数法。

> **注意**：这三种方法必要时都会舍去末尾的数字或者补零。

```js
let n = 123456.789;
n.toFixed(o); // "123457"
n.toFixed(2); // "123456.79"
n.toFixed(5); // "123456.78900"

n.toExponential(1); // "1.2e+5"
n.toExponential(3); // "1.235e+5"

n.toPrecision(4); // "1.235e+5"
n.toPrecision(7); // "123456.8"
n.toPrecision(10); // "123456.789"
```

除了这里介绍的数值格式化方法，`Intl.NumberFormat` 类定义了一个更通用、更国际化的数值格式化方法,详见 11.7.1<!--TODO--> 节。

#### 3.4.2 对象到原始值转换

JS 对象到原始值转换的复杂性，主要原因在于某些对象类型有不止一种原始值的表示。比如，Date 对象可以用字符串表示，也可以用时间戳表示。JS 规范定义了对象到原始值转换的 3 种基本算法。

_偏字符_
: 该算法返回原始值，而且只要可能就返回字符串

_偏数值_
: 该算法返回原始值，而且只要可能就返回数值

_无偏好_
: 该算法不倾向于任何原始值类型，而是由类定义自己的转换规则。**JS 内置类型除了 Date 类都实现了偏数值算法。Date 类实现了偏字符串算法**。

- **对象转换为布尔值**
  对象到布尔值的转换很简单: 所有对象都转换为 true。

  > **注意**：这个转换不需要使用对象到原始值的转换算法，而是直接适用于所有对象。包括空数组，甚至包括 `new Boolean(false)` 这样的包装对象。

- **对象转换为字符串**
  在将对象转换为字符串时，JS 首先使用偏字符串算法将它转换为一个原始值，然后将得到的原始值再转换为字符串。
  这种转换会发生在把对象传给一个接收字符串参数的内置函数时，比如将 `String()` 作为转换函数，或者将对象插入模板字面量中时就会发生这种转换。

- **对象转换为数值**
  当需要把对象转换为数值时，JS 首先使用偏数值算法将它转换为一个原始值，然后将得到的原始值再转换为数值。
  接收数值参数的内置 JS 函数和方法都以这种方式将对象转换为数值，而除数值操作符之外的多数（参见下面的例外情况）JS 操作符也按照这种方式把对象转换为数值。

**操作符转换特例**
在此，只介绍那些不遵循上述基本的对象到字符串或对象到数值转换规则的操作符特例：

- JS 中的 `+` 操作符执行数值加法和字符串拼接。

  - 如果一个操作数是对象，那 JS 会使用无偏好算法将对象转换为原始值。
  - 如果两个操作数都是原始值，则会先检查它们的类型。如果有一个参数是字符串，则把另一个原始值也转换为字符串并拼接两个字符串。否则，把两个参数都转换为数值并把它们相加。

- `==` 和 `!=` 操作符以允许类型转换的宽松方式执行相等和不相等测试。
  如果一个操作数是对象，另一个操作数是原始值，则这两个操作符会使用无偏好算法将对象转换为原始值，然后再比较两个原始值。

- 关系操作符 `<`、`<=`、`>` 和 `>=` 比较操作数的顺序，既可以比较数值，也可以比较字符串。如果操作数中有一个是对象，则会使用偏数值算法将对象转换为原始值。

  > **注意**：与对象到数值转换不同，这个偏数值算法返回的原始值不会再被转换为数值。

> **注意**：Date 对象的数值表示是可以使用 `<` 和 `>` 进行有意义的比较的，但它的字符串表示则不行。对于 Date 对象，无偏好算法会将其转换为字符串，而 JS 中这两个操作符会使用偏数值算法的事实意味着可以比较两个 Date 对象的顺序。

**`toString()` 和 `valueOf()` 方法**

所有对象都会继承两个在对象到原始值转换时使用的方法，在接下来解释偏字符串、偏数值和无偏好转换算法前，必须先解释这两个方法。

- `tostring()`
  返回对象的字符串表示。默认情况下，`tostring()` 方法不会返回特别的值:

  ```js
  ({ x: 1, y: 23 }.toString()); // [object Object]
  ```

  很多类都定义了自己特有的 `toString()` 版本。比如：

  - Array 类的 `toString()` 方法会将数组的每个元素转换为字符串，然后再使用逗号作为分隔符将它们拼接起来。
  - Function 类的 `tostring()` 方法会将用户定义的函数转换为 JS 源代码的字符串。
  - Date 类定义的 `toString()` 方法返回一个人类友好（且 JS 可解析）的日期和时间字符串。
  - RegExp 类定义的 `toString()` 方法会将 RegExp 对象转换为一个看起来像 RegExp 字面量的字符串。

  ```js
  [1, 2, 3].toString(); // "1,2,3"

  (function (x) {
    f(x);
  }.toString()); // "function(x) { f(x); }"

  /\d+/g.toString(); // "/\\d+/g"

  let d = new Date(2020, 0, 1);
  d.toString(); // "Wed Jan 01 2020 00:00:00 GMT+0800 (GMT+08:00)"
  ```

- `valueOf()`
  这个方法的任务并没有太明确的定义，大体上可为认为它是把对象转换为代表对象的原始值（如果存在这样一个原始值）。
  对象是复合值且多数对象不能真正通过一个原始值来表示，因此 `valueOf()` 方法默认情况下只返回对象本身，而非返回原始值。

  - String、Number 和 Boolean 这样的包装类定义的 `valueOf()`方法也只是简单地返回被包装的原始值。
  - Array、Function 和 RegExp 简单地继承默认方法。在这些类型的实例上调用 `valueOf()` 会返回对象本身。
  - Date 对象定义的 `valueOf()` 方法返回日期的内部表示形式: 自 1970 年 1 月 1 日至今的毫秒数:

    ```js
    Let d = new Date(2010, 0, 1);// January 1, 2010,(Pacific time)
    d.valueOf(); // 1262332800000
    ```

**对象到原始值转换算法**
解释完 `toString()` 和 `valueOf()` 方法后，现在可以大致地解释前面三个对象到原的始值转换算法的实现了（完整的细节见 14.4.7<!--TODO--> 节）。

- **偏字符串算法**

  - 首先尝试 `toString()` 方法。如果这个方法有定义且返回原始值，则 JS 使用该原始值（即使这个值不是字符串）。
  - 如果 `toString()` 不存在，或者存在但返回对象，则 JS 尝试 `valueOf()` 方法。
  - 如果这个方法存在且返回原始值，则 JS 使用该值。否则，转换失败，报 TypeError。

- **偏数值算法**
  与偏字符串算法类似，只不过是先尝试 `valueOf()` 方法，再尝试 `toString()` 方法。

- **无偏好算法**
  取决于被转换对象的类，如果是一个 Date 对象，则使用偏字符串算法。如果是其他类型的对象，则使用偏数值算法。

以上规则适用于所有内置 JS 类型，也是所有自定义类的默认规则。14.4.7 <!--TODO--> 解释了如何在自定义类中定义自己的对象到原始值转换算法。

### 3.6 变量声明与赋值

1. `const` 必须在声明时初始化常量。

2. 如果声明位于顶级，且在任何代码块外部，则称其为**全局变量或常量**，具有全局作用域。

   - 在 Node 和客户端 JS 模块中(参见第 10 章<!--TODO-->)，全局变量的作用域是定义它们的文件。
   - 在传统客户端 JS 中，全局变量的作用域是定义它们的 HTML 文档。
     如果有 `<script>` 标签声明了一个全局变量或常量，则该变量或常量在同一个文档的任何 `<script>` 元素中（或者至少在 `let` 和 `const` 语句执行之后执行的所有脚本中都有定义）。

3. `var` 与 `let` 的区别

   - 使用 `var` 声明的变量不具有块作用域。这种变量的作用城仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。

   - 如果在函数体外部使用 `var`，会声明一个全局变量。但通过 `var` 声明的全局变量与通过 `let` 声明的全局变量有一个重要区别。
     通过 `var` 声明的全局变量被实现为全局对象的属性。全局对象可以通过 `globalThis` 引用。
     通过全局 `var` 创建的这个属性不能使用 [delete 操作符](#473-delete-操作符)删除。

     > 通过 `let` 和 `const` 声明的全局变量和常量不是全局对象的属性。

   - 与通过 `let` 声明的变量不同，使用 `var` 多次声明同名变量是合法的。而且由于 `var` 变量具有函数作用域而不是块作用域，这种重新声明实际上是很常见的。
     变量 i 经常用于保存整数值，特别是经常用作 for 循环的索引变量。在有多个 for 循环的函数中,每个循环通常都以 `for(var i=0;...` 开头。因为 `var` 并不会把这些变量的作用域限定在循环体内，每次循环都会（无害地）重新声明和重新初始化同一个变量。

   - `var` 声明的一个**最不同寻常的特性**是作用域提升（hoisting）。
     在使用 `var` 声明变量时，该声明会被提高到包含函数的顶部。但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。因此对使用 `var` 声明的变量，可以在包含函数内部的任何地方使用而不会报错。

     如果初始化代码尚未运行，则变量的值可能是 undefined，但在初始化之前是可以使用变量而不报错的，这会成为一个 bug 来源，也是 **`let` 要纠正的一个最重要的错误特性**。如果使用 `let` 声明了一个变量，但试图在 `let` 语句运行前使用该变量则会导致错误，而不是得到 undefined 值。

### 3.7 解构赋值

ES6 实现了一种复合声明与赋值语法，叫作**解构赋值**（destructuring assignment）。

在解构赋值中，等号右手端的值是数组或对象（“结构化”的值）左手端通过模拟数组或对象字面量语法指定一个或多个变量。在解构赋值发生时，会从右侧的值中提取（解构）出一个或多个值，并保存到左侧列出的变量中。

解构赋值可能最常用于在 `const`、`let` 或 `var` 声明语句中初始化变量，但也可以在**常规赋值表达式**中使用(给已声明的变量赋值)。解构也可以在**定义函数参数**时使用。

```js
let [x, y] = [1, 2]; // 相当于 let x=1, y=2
[x, y] = [x + 1, y + 1]; // 相当于 x = x + 1, y = y + 1
[x, y] = [y, x]; // 交换两个变量的值
[x, y]; // [3,2]: 递增和交换后的值
```

解构赋值让**使用返回数组的函数变得异常便捷**:

```js
// 将 [x,y] 坐标转换为 [r, theta] 极坐标
function toPoLar(x, y) {
  return [Math.sqrt(x*x+y*y), Math.atan2(y, x)];
}

// 将极坐标转换为笛卡儿坐标
function toCartesian(r, theta) {
  return [r*Math.cos(theta), r*Math.sin(theta)];
}

let [r, theta] = toPolar(1.0, 1.0); // r == Math. sqrt(2); theta == Math PI/4
let [x,y] = toCartesian(, theta); // [x, y] == [1.0,1,0]
```

可以在 JS 的各种 for 循环中声明变量和常量。同样也可以**在这个上下文中使用变量解构赋值**。下面这段代码循环遍历了一个对象所有属性的名/值，并使用解构赋值将两个元素的数组转换为单个变量:

```js
let o = { x: 1, y: 2 }; // 要遍历的对象

for (const [name, value] of object.entries(o)) {
  console.Log(name, value); // 打印"x 1"和"y 2"
}
```

> 解构赋值左侧变量的个数不一定与右侧数组中元素的个数相同。左侧多余的变量会被设置为 undefined，而右侧多余的值会被忽略。

**左侧的变量列表可以包含额外的逗号，以跳过右侧的某些值**:

```js
let [x, y] = [1] // x == 1; y == undefined
[x, y] = [1,2,3] // x == 1; y == 2
[,x,y] = [1,2,3,4] // x == 2; y == 3
```

在解构赋值时，如果想把所有未使用或剩余的值收集到一个变量中，可以在左侧最后一个变量名前面加上 3 个点（...）：

```js
let [x, ...y] = [1, 2, 3, 4]; // y == [2,3,4]
```

**解构赋值可用于嵌套数组**。此时，赋值的左侧看起来也应该像一个嵌套的数组字面量:

```js
let [a, [b, c]] = [1, [2, 2.5], 3]; // a == 1; b == 2; c == 2.5
```

**数组解构的一个强大特性是它并不要求必须是数组**！实际上，赋值的右侧可以是任何可迭代对象(参见第 12 章<!--TODO-->)，任何可以在 [fo/of 循环](../JavaScript.md#4354-forof-循环)中使用的对象也可以被解构：

```js
let [first, ...rest] = 'Hello'; // first == "H"; rest == ["e", "l", "l", "o"]
```

解构赋值在右侧是对象值的情况下也可以执行。此时，赋值的左侧看起来就像一个对象字面量，即一个包含在花括号内的逗号分隔的变量名列表：

```js
let transparent = { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }; //一个 RGBA 颜色对象
let { r, g, b } = transparent; // r == 0.0; g == 0.0; b == 0.0
```

下面这个例子展示了如何把 Math 对象的全局函数复制到变量中，这样可以简化需要大量三角计算的代码:

```js
// 相当于 const sin = Math.sin, cos=Math.cos, tan=Math.tan
const { sin, cos, tan } = Math;
```

> **注意**：代码中 Math 对象的属性远远不止解构赋值给个别变量的这 3 个。那些没有提到名字的属性都被忽略了。如果赋值的左侧包含一个不是 Math 属性的变量名，该变量将被赋值 undefined。

在上面每个对象解构的例子中，都选择了与要解构对象的属性一致的变量名。这可以保持语法简单且容易理解，但这并不是必需的。对象解构赋值左侧的每个标识符都可以是一个冒号分隔的标识符对，其中第一个标识符是要解构其值的属性名，第二个标识符是要把值赋给它的变量名：

```js
// 相当于 const cosine= Math.cos, tangent=Math.tan
const { cos: cosine, tan: tangent } = Math;
```

> **如果变量名和属性名不一样，对象解构语法会变得过于复杂，反而导致用处不大。建议不使用这种形式**。如果选择使用，要记住属性名一定是在冒号左侧，无论是在对象字面量中，还是在对象解构赋值的左侧。

在使用嵌套对象、对象的数组，或数组的对象时，解构赋值甚至会变得更复杂，但都是合法的:

```js
let points = [
  { x: 1, y: 2 },
  { x: 3, y: 4 }
]; // 两个坐标点对象的数组
let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = points; //解构到 4 个变量中
x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4; //=>true
```

如果不是解构对象的数组，也可以解构数组的对象：

```js
let points={p1: [1,2],p2: [3,4]}; // 有两个数组属性的对象
let {p1: [x1, y1], p2:[x2,y2]} = points; //解构到 4 个变量中
(×1 === 1 && y1 === 2 && x2 === 3 && y2 === 4) // true
```

类似这样的复杂解构语法既难写又难理解，甚至还不如使用类似 `let x1 = points.p1[0];` 这样的传统代码更简单易懂。

## 四. 表达式与操作符

### 4.1 表达式

[JavaScript#-表达式语句](../JavaScript.md#44-表达式语句)

### 4.2 操作符

下表总结了所有操作符,可以作为一个参考。

> **注意**：多数操作符都以 `+` 和 `=` 这样的标点符号表示。不过，有一些也以 `delete` 和 `instanceof` 这样的关键字表示。关键字操作符也是常规操作符，与标点符号表示的操作符一样，只不过它们的语法没那么简短而已。

下表按操作符优先级组织：

- 表格前面的操作符比后面的操作符优先级更高。
- “结合性”中的“左”表示“从左到右执行”，“右”表示“从右到左执行”。
- “操作数”表示操作数的个数。
- “类型”表示操作数的类型，以及操作符的结果类型（`→` 后面）。

| 操作符                                                      | 操作                                           | 结合性 | 操作数 | 类型                 |
| ----------------------------------------------------------- | ---------------------------------------------- | ------ | ------ | -------------------- |
| ++                                                          | 先或后递增                                     | 右     | 1      | lval → num           |
| --                                                          | 先或后递减                                     | 右     | 1      | lval → num           |
| -                                                           | 负值                                           | 右     | 1      | num → num            |
| +                                                           | 转换为数值                                     | 右     | 1      | any → num            |
| ~                                                           | 反转二进制位                                   | 右     | 1      | int → int            |
| !                                                           | 反转布尔值                                     | 右     | 1      | bool → bool          |
| delete                                                      | 删除属性                                       | 右     | 1      | lval → bool          |
| typeof                                                      | 确定操作数类型                                 | 右     | 1      | any → str            |
| void                                                        | 返回 undefined                                 | 右     | 1      | any → undef          |
| \*\*                                                        | 幂                                             | 右     | 2      | num,num → num        |
| \*、/、%                                                    | 乘、除、取余                                   | 左     | 2      | num,num → num        |
| +、-                                                        | 加、减                                         | 左     | 2      | num,num → num        |
| +                                                           | 拼接字符串                                     | 左     | 2      | str, str → str       |
| <<                                                          | 左移位                                         | 左     | 2      | int,int → int        |
| >>                                                          | 右移位以符号填充                               | 左     | 2      | int,int → int        |
| >>>                                                         | 右移位以零填充                                 | 左     | 2      | int,int → int        |
| <、<=、>、>=                                                | 按数值顺序比较                                 | 左     | 2      | num,num → bool       |
| <、<=、>、>=                                                | 按字母表顺序比较                               | 左     | 2      | str,str → bool       |
| instanceof                                                  | 测试对象类                                     | 左     | 2      | obi,func → bool      |
| in                                                          | 测试属性是否存在                               | 左     | 2      | any,obj → bool       |
| ==                                                          | 非严格相等测试                                 | 左     | 2      | any,any → bool       |
| !=                                                          | 非严格不相等测试                               | 左     | 2      | any,any → bool       |
| ===                                                         | 严格相等测试                                   | 左     | 2      | any,any → bool       |
| !==                                                         | 严格不相等测试                                 | 左     | 2      | any,any → bool       |
| &                                                           | 计算按位与                                     | 左     | 2      | int,int → int        |
| ^                                                           | 计算按位异或                                   | 左     | 2      | int,int → int        |
| 竖杠                                                        | 计算按位或                                     | 左     | 2      | int,int → int        |
| &&                                                          | 计算逻辑与                                     | 左     | 2      | any,any → any        |
| 双竖杠                                                      | 计算逻辑或                                     | 左     | 2      | any,any → any        |
| ??                                                          | 选择第一个有定义的操作数，非 null 或 undefined | 左     | 2      | any, any → any       |
| ? :                                                         | 选择第二或第三个操作数                         | 右     | 3      | bool, any, any → any |
| =                                                           | 为变量或属性赋值                               | 右     | 2      | lval,any → any       |
| \*_=、_=、/=、%=、+=、-=、&=、^=、 竖杠等于、<<=、>>=、>>>= | 操作并赋值                                     | 右     | 2      | lval,any → any       |
| ,                                                           | 丢弃第一个操作数，返回第二个                   | 左     | 2      | any, any → any       |

> **注意**：表中列出的赋值操作符和少数其他操作符期待操作数类型为 `lval`。`lval` 即 lvalue（左值），是一个历史悠久的术语，意思是“一个可以合法地出现在赋值表法式左侧的表达式”。在 JS 中，变量、对象属性和数组元素都是“左值”。

#### 4.2.1 操作符优先级

**JS 新增的操作符并不总是符合上表这个优先级模式**。比如在表中 [`??` 操作符](#471-空值合并运算符) `||` 和 `&&` 优先级低，而实际上它相对于这两个操作符的优先级并没有定义。

ES2020 要求在混用 `??`和 `||` 或 `&&` 时使用必须使用圆括号。类似地，新的幂操作符 `**` 相对于一元负值操作符的优先级也没有明确定义，因此在同时求负值和求幂时也必须使用圆括号。

#### 4.2.2 求值顺序

操作符的优先级和结合性规定了复杂表达式中操作的执行顺序，但它们没有规定子表达式的求值顺序。**JS 始终严格按照从左到右的顺序对表达式求值**。

例如，在表达式 `w = x + y * z` 中，子表达式 w 首先被求值，再对 x、y 和 z 求值。然后将 y 和 z 相乘，加到 x 上，再把结果赋值给表达式 w 表示的变量或属性。在表达式中使用圆括号改变乘法、加法和赋值的相对顺序，但不会改变从左到右的求值顺序。

**求值顺序只在一种情况下会造成差异，即被求值的表达式具有副效应**，这会影响其他表达式的求值。比如，表达式 x 递增一个变量，而表达式 z 会使用这个变量，此时保证 x 先于 z 被求值就很重要了。

### 4.3 算术表达式

基本的算术操作符是 `**`(幂)、`*`(乘)、`/`(除)、`%`(模：除后的取余)、`+`(加) 和 `-`(减)。

#### 4.3.1 + 操作符

严格来讲，`+` 操作符的行为如下所示：

- 如果有一个**操作数是对象**，则 `+` 操作符使用[对象到原始值](#342-对象到原始值转换)的算法把该操作数转换为原始值。Date 对象用 `toString()` 方法来转换，其他所有对象通过 `valueOf()` 转换（如果这个方法返回原始值）。不过，多数对象并没有 `valueOf()` 方法，因此它们也会通过 `toString()` 方法转换。

- 完成对象到原始值的转换后，如果有操作数是字符串，另一个操作数也会被转换为字符串进行拼接。

- 否则，两个操作数都被转换为数值（或 NaN），计算加法。

#### 4.3.2 一元算术操作符

一元操作符有： `+`、`-`、`++`、`--`。在 JS 中，**一元操作符全部具有高优先级和右结合性**。

> **注意**：`+` 和 `-`，既是一元操作符，也是二元操作符。

### 4.4 关系表达式

#### 4.4.1 严格相等

严格相等操作符 `===` 求值其操作数，然后按下列步骤比较两个值，不做类型转换：

- 如果两个值类型不同，则不相等。

- 如果两个值都是 null 或都是 undefined，则相等。

- 如果两个值都是布尔值 true 或都是布尔值 false，则相等。

- 如果一个或两个值是 NaN，则不相等（NaN 确实不等于任何值，也包括 NaN 自身！要检查某个值 ⅹ 是不是 NaN，使用 `x !== x` 或全局 `isNaN()` 函数）。

- 如果两个值都是数值且值相同，则相等。如果一个值是 0 而另一个是 -0，则也相等。

- 如果两个值都是字符串且相同位置包含完全相同的 16 位值，则相等。
  如果两个字符串长度或内容不同，则不相等。两个字符串有可能看起来相同，也表示同样的意思，但底层编码却使用不同的 16 位值序列。JS 不会执行 Unicode 归一化操作，像这样的两个字符串用 `===` 或 `==` 操作符都不会判定相等。

- 如果两个值引用同一个对象、数组或函数，则相等。如果它们引用不同的对象，即使两个对象有完全相同的属性，也不相等。

#### 4.4.2 比较操作符

比较和转换规则如下：

- 如果有操作数求值为对象，该对象会按照[对象到原始值转换](#342-对象到原始值转换)的算法被转换为原始值。即如果它的 `valueOf()` 方法返回原始值，就使用这个值，否则就使用它的 `toString()` 方法返回的值。

- 如果在完成对象到原始值的转换后两个操作数都是字符串，则使用字母表顺序比较这两个字符串，其中“字母表顺序”就是组成字符串的 16 位 Unicode 值的数值顺序。

- 如果在完成对象到原始值的转换后至少有一个操作数不是字符串，则两个操作数都会被转换为数值并按照数值顺序来比较。
  0 和 -0 被认为相等。Infinity 比它本身之外的任何数都大，-Infinity 比它本身之外的任何数都小。如果有一个操作数是（或转换后是）NaN，则这些比较操作符都返回 false。

  > 虽然算术操作符不允许 BigInt 值与常规数值混用，但比较操作符允许数值与 BigInt 进行比较。

JS 字符串是 16 位整数值的序列，而字符串比较就是比较两个字符串的数值序列。Unicode 定义的这个数值编码顺序不一定与特定语言或地区使用的传统校正顺序（collation order）匹配。

> **注意**：字符串比较是区分大小写的，而**所有大写 ASCII 字母比所有小写 ASCII 字母都小**。如果不留意，这条规则很可能导致令人不解的结果。例如，根据 `<` 操作符，字符串 “Zoo” 会排在字符串 “aardvark” 前面。

如果需要**更可靠的字符串比较算法，可以用 `String.localeCompare()` 方法**，这个方法也会考虑特定地区的字母表顺序。

要执行不区分大小写的比较，可以使用 `String.toLowerCase()` 或 `String.toUpperCase()` 先把字符串转换为全小写或全大写。

如果需要更通用和更好的本地化字符串比较工具，可以使用 11.7.3 节介绍的 `Intl.Collator`<!--TODO Intl.ColLator--> 类。

`+` **操作符和比较操作符同样都会对数值和字符串操作数区别对待**：

- `+` 偏向字符串，即只要有一个操作数是字符串，它就会执行拼接操作。

- 比较操作符偏向数值，只有两个操作数均为字符串时才按字符串处理。

> **注意**：
>
> 1. `<=`（小于或等于）和 `>=`（大于或等于）操作符不依赖相等或严格相等操作符确定两个值是否“相等”。其中，小于或等于操作符只是简单地定义为“不大于”，而大于或等于操作符则定义为“不小于”。
> 2. 还有例外情形，即只要有操作数是（或可以转换为）NaN，则全部 4 个比较操作符都返回 false。

#### 4.4.3 in 操作符

如果指定的属性在指定的对象或其原型链中，则 `in` 运算符返回 true。

`in` 操作符期待左侧操作数是字符串、符号或可以转换为字符串的值，期待右侧操作数是对象。

```js
let point = { x: 1, y: 1 };
'x' in point; // true：对象有名为 "x" 的属性
'z' in point; // false：对象没有名为 "z" 的属性
'toString' in point; // true：对象的继承了 toString 方法

let data = [8, 0, 1];
'0' in data; // true
1 in data; // true
5 in data; // false：没有元素 5
```

#### 4.4.4 instanceof 操作符

**`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上**。

`instanceof` 操作符期待左侧操作数是对象，右侧操作数是对象类的标识。这个操作符在左侧对象是右侧类的实例时求值为 true，否则求值为 false。

第 9 章<!--TODO 对象类-->解释了，在 JS 中，对象类是通过初始化它们的构造函数定义的。因而，`instanceof` 的右侧操作数应该是一个函数。

```js
let d = new Date(); // 通过 Date() 构造函数创建一个新对象
d instanceof Date; // true: d 是通过 Date() 创建的
d instanceof Object; // true: 所有对象都是 Object 的实例
d instanceof Number; // false: d 不是 Number 对象

let a = [1, 2, 3]; // 通过数组字面量语法创建一个数组
a instanceof Array; // true: a 是个数组
a instanceof Object; // true: 所有数组都是对象
a instanceof RegExp; // false: 数组不是正则表达式
```

> **注意**：
>
> 1. 所有对象都是 Object 的实例。`instanceof` 在确定对象是不是某个类的实例时会考虑“超类”。
> 2. 如果 `instanceof` 的左侧操作数不是对象，它会返回 false。如果右侧操作数不是对象的类，它会抛出 TypeError。

要理解 `instanceof` 的工作原理，必须理解“原型链”。[原型链](#632-继承)是 JS 的继承机制。

为了对表达式 `o instanceof f` 求值，JS 会求值 `f.prototype`，然后在 `o` 的原型链上查找这个值。如果找到了，则 o 是 f（或 f 的子类）的实例，`instanceof` 返回 true。如果 `f.prototype` 不是 o 原型链上的一个值，则 o 不是 f 的实例，`instanceof` 返回 false。

### 4.5 逻辑表达式

#### 4.5.1 逻辑与 (&&)

`&&` 操作符首先对它左边的表达式求值，如果左边的值是假值，则整个表达式的值也一定是假值，因此 `&&` 返回它左侧的值，不再求值它右侧的表达式。

另一方面，如果 `&&` 左侧的值是真值，则整个表达式的值取决于右侧的值。如果右侧的值是真值，则整个表达式的值一定是真值;如果右侧的值是假值，则整个表达式的值一定是假值。因此，在左侧的值为真值时，`&&`操作符求值并返回它右侧的值:

```js
let o = { x: 1 };
let p = null;
o && o.x; // 1: o 是真值，因此返回 o.x 的值
p && p.x; // null: p是假值，因此返回它，不对p，x求值
```

#### 4.5.2 逻辑或 (||)

`||` 的习惯用法是在一系列备选项中选择第一个真值：

```js
let max = maxWidth || preferences.maxWidth || 500;
```

> **注意**：如果 `0` 是 maxWidth 的有效值，则以上代码可能有问题，因为 0 是一个假值。此时可以使用 [`??` 操作符](#471-空值合并运算符)。

#### 4.5.3 逻辑非 (!)

作为一元操作符，`!` 操作符优先级较高。如果想反转表达式 `p && q` 的值，需要使用圆括号：`!(p && q)`。

可以通过如下 JS 语法来表达布尔代数的两个法则：

```js
// 德摩根定律
!(p && q) === (!p || !q); // true：p 和 q 可以是任何值
!(p || q) === (!p && !q); // true
```

### 4.6 赋值表达式

`=` 操作符期待其左侧操作数是一个左值，即变量或对象属性或数组元素。它期待右侧操作数是任意类型的任意值。赋值表达式的值是右侧操作数的值。

可以像下面这样在同一个表达式中赋值并测试这个值：

```js
(a = b) === 0;
```

> **注意**：**`=` 的优先级很低**，在较大的表达式中使用赋值的值通常需要使用圆括号。

赋值操作符**具有右结合性**，这意味着如果一个表达式中出现多个赋值操作符，它们会从右向左求值。因此，可以通过如下代码将一个值赋给多个变量:

```js
i = j = k = 0; // 把 3 个变量都初始化为 0
```

### 4.7 其他操作符

#### 4.7.1 空值合并运算符 (??)

`??` 求值其先定义的操作数，如果其左操作数不是 null 或 undefined，就返回该值。否则，它会返回右操作数的值。

与 `&&` 或 `||` 操作符类似，`??` 是短路的: 它只在第一个操作数求值为 null 或 undefined 时才会求值二个操作数。表达式 `a ?? b` 等价于:

```js
a !== null && a !== undefined ? a : b;
```

`??` 是对 `||` 的一个有用的替代，适合选择先定义的操作数，而不是第一个为真值的操作数。

`??` 操作符与 `&&` 和 `||` 操作符类似，但优先级并不比它们更高或更低。如果表达中混用了 `??` 和它们中的任何一个，必须使用圆括号说明先执行哪个操作。

#### 4.7.2 typeof 操作符

`typeof` 是个一元操作符，放在自己的操作数前面，这个操作数可以是任意类型。typeof 操作符的值是一个字符串，表明操作数的类型。

下表列出了所有 JS 值在应用 typeof 操作符后得到的值：

| x              | typeof x    |
| -------------- | ----------- |
| undefined      | "undefined" |
| null           | "object"    |
| true 或 false  | "boolean"   |
| 任意数值或 NaN | "number"    |
| 任意 BigInt    | "bigint"    |
| 任意字符串     | "string"    |
| 任意符号       | "symbol"    |
| 任意函数       | "function"  |
| 任意非函数对象 | "object"    |

可以像下面这样在表达式中使用 typeof 操作符:

```js
// 如果 value 是字符串，把它包含在引号中，否则把它转换为字符串
typeof value === 'string' ? "'" + value + "'" : value.toString();
```

> **注意**：
>
> 1. 如果操作数的值是 null，typeof 返回 “object”。如果想区分 null 和对象，必项显式测试这个特殊值。
> 2. 尽管 JS 函数是一种对象，typeof 操作符也认为函数不一样，因为它们有自己的返回值。
> 3. 因为对除函数之外的所有对象和数组值，typeof 都求值为 “object"，所以**可以只用它来区分对象和其他原始类型。而要区分不同对象的类，必须使用其他方法**，例如 [instanceof 操作符](#444-instanceof-操作符)、class 特性(参见 <!--TODO 14.4.3 节)，或者 constructor 属性(参见 9.22 节和 14.3 节)-->。

#### 4.7.3 delete 操作符

delete 是一元操作符，尝试删除其操作数指定的对象属性或数组元素。

```js
let o = { x: 1, y: 2 }; //先定义一个对象
delete o.x; // 删除它的属性
"x" in o // false: 这个属性不存在了

let a = [1,2,3]; // 定义一个数组
delete a[2]: // 删除数组的最后一个元素
2 in a // false: 数组元素 2 不存在了
a.length // 5: 但要注意,数组长度没有变化
```

> **注意**：被删除的属性或数组元素不仅会被设置为 undefined 值。当删除一个属性时，这个属性就不复存在了。尝试读取不存在的属性会返回 undefined，但可以通过 [`in` 操作符](#443-in-操作符)测试某个属性是否存在。删除某个数组元素会在数组中留下一个“坑”，并不改变数组的长度。结果数组是一个[稀疏数组](#73-稀疏数组)。

delete 期待它的操作数是个左值。如果操作数不是左值，delete 什么也不做，且返回 true。否则，delete 尝试删除指定的左值。如果删除成功则返回 true。但是并非所有属性都是可以删除的: 不可配置属性(参见 <!--TODO 14.1 节-->)就无法删除。

在严格模式下，delete 的操作数如果是未限定标识符，比如变量、函数或函数参数，就会导致 Syntax Error。此时，delete 操作符只能作用于属性访问表达式。

严格模式也会在 delete 尝试删除不可配置（即不可删除）属性时抛出 TypeError。但在严格模式之外，这两种情况都不会发生异常，delete 只是简单地返回 false，表示不能删除操作数。

下面是几个使用 delete 操作符的例子：

```js
let o = { x: 1, y: 2 };
delete o.x; // 删除对象的一个属性: 返回 true
typeof o.x; // 属性不存在: 返回 "undefined"
delete o.x; // 删除不存在的属性: 返回 true
delete 1; // 这样做毫无意义,但会返回 true

// 不能删除变量，返回 false,或在严格模式下报 SyntaxError
delete o;
// 不可删除的属性: 返回 false，或在严格模式下报 TypeError
delete Object.prototype;
```

#### 4.7.4 await 操作符

`await` 是 ES2017 增加的，**用于让 JS 中的异步编程更自然**。

简单来说，`await` 期待一个 Promise 对象（表示异步计算）作为其唯一操作数，可以让代码看起来像是在等待异步计算完成（但实际上它不会阻塞主线程，不会妨碍其他异步操作进行）。

`await` 操作符的值是 Promise 对象的兑现值。关键在于，**`await` 只能出现在已经通过 `async` 关键字声明为异步的函数中**。要了解完整的细节，参见第 <!--TODO 13 --> 章。

## 五. 语句

[JavaScript#-表达式语句](../JavaScript.md#424-语句)

## 六. 对象

### 6.1 对象简介

对象是一种复合值，它汇聚多个值（原始值或其他对象）并允许按名字存储和获取这些值。对象是一个属性的无序集合，每个属性都有名字和值。属性名通常是字符串（也可以是[符号](#6103-符号作为属性名)），因此可以说对象把字符串映射为值。

这种字符串到值的映射曾经有很多种叫法，包括 “散列” “散列表” “字典” 或 “关联数组” 等熟悉的基本数据结构。不过，对象不仅仅是简单的字符串到值的映射。除了维持自己的属性之外，JS 对象也可以从其他对象继承属性，这个其他对象称为其“原型”。

**对象的方法通常是继承来的属性，而这种“原型式继承”也是 JS 的主要特性**。

JS 对象是动态的，即可以动态添加和删除属性。不过，可以用对象来模拟静态类型语言中的静态对象和“结构体”。对象也可以用于表示一组字符串（忽略字符串到值的映射中的值）。

> 在 JS 中，任何不是字符串、数值、符号或 true、false、null、undefined 的值都是对象。即使字符串、数值和布尔值不是对象，它们的行为也类似不可修改的对象。

对象是可修改的，是按引用操作而不是按值操作的。如果变量 x 指向一个对象，则代码 `let y = x;` 执行后，变量 y 保存的是同一个对象的引用，而不是该对象的副本。通过变量 y 对这个对象所做的任何修改，在变量 x 上都是可见的。

有时候，区分直接定义在对象上的属性和那些从原型对象上继承的属性很重要。JS 使用术语“自有属性”指代非继承属性。

除了名字和值之外，每个属性还有 3 个属性特性（property attribute）

- **writable**（可写）：指定是否可以设置属性的值。
- **enumerable**（可枚举）：指定是否可以在 for/in 循环中返回属性的名字。
- **configurable**（可配置）：指定是否可以删除属性，以及是否可修改其特性。

很多 JS 内置对象拥有只读、不可枚举或不可配置的属性。不过，默认情况下，所创建对象的所有属性都是可写、可枚举和可配置的。

### 6.2 创建对象

对象可以通过：

- 对象字面量
- `new` 关键字
- `Object.create()` 函数来创建

#### 6.2.1 对象字面量

创建对象最简单的方式是在 JS 代码中直接包含对象字面量。对象字面量的最简单形式是包含在一对花括号中的一组逗号分隔的 “name:value” 对。属性名是 JS 标识符或字符串字面量（**允许空字符串**）。属性值是任何 JS 表达式，这个表达式的值（可以是原始值或对象值）会变成属性的值。

```js
let empty = {}; // 没有属性的对象
let point = { x: 0, y: 0 }; // 包含两个数值属性
let p2 = { x: point.x, y: point.y + 1 }; // 值比较复杂
let book = {
  'main title': 'JavaScript', // 属性名包含空格
  'sub-title': 'The Definitive Guide', // 和连字符,因此使用字符串字面量对象
  for: 'all audiences', // for 是保留字，但没有引号
  // 这个属性的值本身是一个对象
  author: {
    firstname: 'David',
    surname: 'Flanagan'
  }
};
```

对象字面量是一个表达式，每次求值都会创建并初始化一个新的、不一样的对象。字面量每次被求值的时候，它的每个属性的值也会被求值。这意味着同一个对象字面量如果出现在循环体中，或出现在被重复调用的函数体丙，可以创建很多新对象，且这些对象属性的值可能不同。

#### 6.2.2 使用 new 创建对象

`new` 操作符用于创建和初始化一个新对象。**new 关键字后面必须跟一个函数调用。以这种方式使用的函数被称为构造函数**（constructor），目的是初始化新创建的对象。JS 为内置的类型提供了构造函数。例如:

```js
let o = new Object(); // 创建一个空对象，与 {} 相同
let a = new Array(); // 创建一个空数组，与 [] 相同
let d = new Date(); // 创建一个表示当前时间的日期对象
let r = new Map(); // 创建一个映射对象，用于存储键/值映射
```

除了内置的构造函数，实践中经常需要定义自己的构造函数来初始化新创建的对象。相关内容将在第 9 章<!--TODO-->介绍。

#### 6.2.3 原型

在学习 `Object.create()` 函数前，必须先了解原型。**几乎每个 JS 对象都有另一个与之关联的对象。这另一个对象被称为原型（prototype）**，第一个对象从这个原型继承属性。

通过对象字面量创建的所有对象都有相同的原型对象，在 JS 代码中可以通过 `Object.prototype` 引用这个原型对象。

`new` 关键字和构造函数调用创建的对象使用构造函数 `prototype` 属性的值作为它们的原型。换句话说，使用 `new Object()` 创建的对象继承自 `Object.prototype`，与通过 `{}` 创建的对象一样。

> 几乎所有对象都有原型,但只有少数对象有 `prototype` 属性。正是这些有 `prototype` 属性的对象为所有其他对象定义了原型。

`Object.prototype` 是为数不多的没有原型的对象，因为它不继承任何属性。其他原型对象都是常规对象，都有自己的原型。多数内置构造函数（和多数用户定义的构造函数）的原型都继承自 `Object.prototype`。

`Date.prototype` 从 `Object.prototype` [继承](#632-继承)属性，因此通过 `new Date()` 创建的日期对象从 `Date.prototype` 和 `Object.prototype`继承属性。**这种原型对象链接起来的序列被称为原型链**。

第 9 章会更详细地解释原型与构造函数之间的联系，将展示如何定义新的对象类，包括编写构造函数以及将其 `prototype` 属性设置为一个原型对象，让通过该构造函数创建的“实例”继承这个原型对象的属性。另外，14.3 节还将介绍如何查询(甚至修改)一个对象的原型。<!--TODO-->

#### 6.2.4 `Object.create()`

- `Object.create()` 用于创建一个新对象，使用其第一个参数作为新对象的原型:

  ```js
  let o1 = Object.create({ x: 1, y: 2 }); // o1 继承属性 x 和 y
  o1.x + o1.y; // 3
  ```

- 传入 `null` 可以创建一个没有原型的新对象。不过，这样创建的新对象不会继承任何东西，连 `toString()` 这种基本方法都没有（意味着不能对该对象应用 `+` 操作符）:

  ```js
  let o2 = Object.create(null); // 不继承任何属性或方法
  ```

- 如果想创建一个普通的空对象（类似或 `new Object()` 返回的对象），传入 `Object.prototype`:

  ```js
  let o3 = Object.create(object.prototype); // o3 与 {} 或 new Object() 类似
  ```

- `Object.create()` 还可接收可选的第二个参数，用于描述新对象的属性。这个参数属于高级特性，将在 14.1 节介绍<!--TODO-->。

**防止意外修改**
`Object.create()` 的一个用途是防止对象被某个第三方库函数意外修改。这种情况下，不要直接把对象传给库函数，而要传入一个继承自它的对象。如果函数读取这个对象的属性，可以读到继承的值。而如果它设置这对象的属性，则修改不会影响原始对象。

```js
let o = { x: 'todo list' };
library.function(Object.create(o)); // 防止意外修改
```

> 要理解其中的原理需要知道 JS 中属性查询和设置的过程。

### 6.3 查询和设置属性

要获得一个属性的值，可以使用 点（`.`）或方括号（`[]`）操作符。左边应该是一个表达式，其值为一个对象。

- 如果使用点操作符，右边必须是一个命名属性的简单标识符。

- 如果使用方括号，方括号中的值必须是一个表达式，其结果为包含目的属性名的字符串或一个可以转换为字符串或符号的值。

```js
let author = book.author;
let surname = book['surname'];
```

要创建或设置属性，与查询属性一样，可以使用点或方括号，只是要把它们放到赋值表达式的左边：

```js
book.edition = 7;
book['author'] = 'tom';
```

#### 6.3.1 作为关联数组的对象

下面两个 JS 表达式的值相同：

```js
object.property;
object['property'];
```

第一种语法使用点和标识符，与在 C 或 Java 中访问结构体或对象的静态字段的语法类似。

第二种语法使用方括号和字符串，看起来像访问数组，只不过是以字符串而非数值作为索引的数组。这种数组也被称为关联数组（或散列、映射、字典）。**JS 对象是关联数组**。

在使用点（`.`）操作符访问对象的属性时，属性名是通过标识符来表示的。标识符必须直接书写在 JS 程序中，它们不是一种数据类型，因此不能被程序操作。

在通过方括号（`[]`）这种数组表示法访问对象属性时，属性名是通过字符串来表示的。字符串是一种 JS 数据类型，因此可以在程序运行期间修改和创建，例如：

```js
let addr = '';
for (let i = 0; i < 4; i++) {
  addr += customer[`address${i}`] + '\n';
}
```

#### 6.3.2 继承

JS 对象有一组“自有属性”，同时也从它们的原型对象继承一组属性。要理解这一点，必须更详细地分析属性存取。

可以使用 `Object.create()` 函数以指定原型来创建对象。也可以通过 new 创建一个类的实例（第 九 章<!--TODO-->），这两个都会创建从某个原型对象继承属性的对象。

假设要从对象 `o` 中查询属性 `x`。如果 `o` 没有 `x` 这个自有属性，则会从 `o` 的原型对象查询属性 `x`。如果原型对象也没有叫这个名字的自有属性，但它有自己的原型，则会继续查询这个原型的原型。这个过程一直持续，直至找到属性 `x` 或者查询到一个原型为 null 的对象。可见，对象通过其 `prototype` 属性创建了一个用于继承属性的链条或链表。

> 几乎所有对象都有原型，但大多数对象没有 `prototype` 属性。即便不能通过代码直接访对象的原型，JS 继承机制仍然照常运作。要了解背后的细节，可以参考 14.3 节<!--TODO-->。

```js
let o = {}; // o 从 Object.prototype 继承对象方法
o.x = 1; // 现在有自有属性 x

let p = Object.create(o); // p 从 o 和 Object.prototype 继承属性
p.y = 2; // 而且有一个自有属性 y

let q = Objet.create(p); // q 从 p、o 和 Object.prototype 继承属性
q.z = 3; // 且有一个自有属性 z

let f = q.toString(); // toString 继承自 Object.prototype
q.x + q.y; // 3: x 和 y 分别继承自 o 和 p
```

现在为对象 `o` 的 `y` 属性赋值。如果 `o` 有一个名为 `x` 的自有属性，这次赋值就会修改已有 `x` 属性的值。否则，这次赋值会在对象 `o` 上创建一个名为 `x` 的新属性。

如果 `o` 之前继承了属性 `x`，那么现在这个**继承的属性会被新创建的同名属性隐藏**。

**属性赋值査询原型链只为确定是否允许赋值**。如果 `o` 继承了一个名为 `x` 的只读属性，则不允许赋值。不过，如果允许赋值则只会在原始对象上创建或设置属性，而**不会修改原型链中的对象**。

**查询属性时会用到原型链，而设置属性时不影响原型链是一个重要的 JS 特性**，利用这一点，可以选择性地覆盖继承的属性:

```js
let unitcircle = { r: 1 }; // c 继承的对象
let c = Object.create(unitcircle); // c 继承了属性
c.x = 1;
c.y = 1; // c 定义了两个自有属性

c.r = 2; // c 覆盖了它继承的属性

unitcircle.r; // 1: 原型不受影响
```

属性赋值要么失败要么在原始对象上创建或设置属性的规则有一个**例外**：

如果 `o` 继承了属性 `x`，而该属性是一个通过设置方法定义的[访问器属性](#6106-属性的获取方法与设置方法访问器属性)，那么就会调用该设置方法而不会在 `o` 上创建新属性 `x`。

要注意，此时会在对象 `o` 上而不是在定义该属性的原型对象上调用设置方法。因此如果这个设置方法定义了别的属性，那也会在定义同样的属性，但仍然不会修改原型链。

#### 6.3.3 属性访问错误

属性访问表达式并不总是会返回或设置值。査询不存在的属性不是错误。如果在 `o` 的自有属性和继承属性中都没找到属性 `x`，则属性访问表达式 `o.x` 的求值结果为 `undefined`。

例如，book 对象有一个 "sub-title" 属性，没有 "subtitle" 属性：

```js
book.subtitle; // undefined: 属性不存在
```

然而，查询不存在对象的属性则是错误。因为 null 和 undefined 值没有属性，查询这两个值的属性是错误。继续前面的示例：

```js
let len = book.subtitle.length; // TypeError: undefined 没有 length 属性
```

如果 `.` 的左边是 `null` 或 `undefined`，则属性访问表达式会失败。因此在写类似 `book.author.surname` 这样的表达式时，要确保 book 和 book.author 是有定义的。以下是两种防止这类问题的写法:

```js
// 简单但麻烦的技术
let surname = undefined;
if (book) {
  if (book.author) {
    surname = book.author.surname;
  }
}

// 取得 surname、null 或 undefined 的简洁的惯用技术
surname = book && book.author && book.author.surname;
```

ES2020 还可以通过 `?.` 支持条件式属性访问，用它可以把前面的赋值表达式改写成:

```js
let surname = book?.author?.surname;
```

尝试在 null 或 undefined 上设置属性也会导致 TypeError。而且，尝试在其他值上设置属性也不总是会成功，因为有些属性是只读的，不能设置，而有些对象不允许添加新属性。在严格模式下，只要尝试设置属性失败就会抛出 TypeError。在非严格模式下，这些失败通常是静默失败。

尝试在对象 `o` 上设置属性 p 在以下情况下会失败：

- `o` 有一个只读自有属性 p: **不可能设置只读属性**。
- `o` 有一个只读继承属性 p: **不可能用同名自有属性隐藏只读继承属性**。
- `o` 没有自有属性 `p`，`o` 没有继承通过设置方法定义的属性 `p`,`o` 的 `extensible` 特性(参见 14.2 节<!--TODO-->)是 false。因为 `p` 在 `o` 上并不存在，如果没有要调用的设置方法，那么 `p` 必须要添加到 `o` 上。但如果 `o` 不可扩展(`extensible` 为 false)，则不能在它上面定义新属性。

### 6.4 删除属性

delete 操作符用于从对象中移除属性。它唯一的操作数应该是属性访问表达式。**delete 并不操作属性的值，而是操作属性本身**:

```js
delete book.author; // book 对象现在没有 author 属性了
delete book['main title']; // book 对象也没有 "main title" 属性了
```

**delete 操作符只删除自有属性，不删除继承属性**（要删除继承属性，必须从定义属性的原型对象上删除。这样做会影响继承该原型的所有对象）。

如果 delete 操作成功或没有影响（如删除不存在的属性），则 delete 表达式求值为 true。对非属性访问表达式（无意义地）使用 delete，同样也会求值为 true：

```js
let o = { x: 1 }; // o 有自有属性 x 和继承属性 toString
delete o.x; // true: 删除属性 x
delete o.x; // true: 什么也不做(x 不存在)但仍然返回 true
delete o.toString; // true: 什么也不做（toString 不是自有属性）
delete 1; // true：无意义，但仍然返回 true
```

delete 不会删除 `configurable` 特性为 false 的属性。与通过变量声明或函数声明创建的全局对象的属性一样，某些内置对象的属性也是不可配置的。在严格模式下，尝试删除不可配置的属性会导致 TypeError。在非严格模式下, delete 直接求值为 false:

```js
// 在严格模式下，以下所有删除操作都会抛出 TypeError，而不是返回 false
delete Object.prototype; // false: 属性不可配置
var x = 1; // 声明一个全局变量
delete globalThis.x; // false: 不能删除这个属性
function f() {} // 声明一个全局函数
delete globalThis.f; // false: 不能删除这个属性
```

**删除全局对象可配置的属性**:

- 在非严格模式下，可以省略对全局对象的引用，只在 delete 操作符后面加上属性名:

  ```js
  globalThis.x = 1; // 创建可配置的全局属性(没有 let 或 var)
  delete x; // true: 这个属性可以删除
  ```

- 在严格模式下，如果操作数是一个像 x 这样的非限定标识符，delete 会抛出 Syntax Error，即必须写出完整的属性访问表达式:

  ```js
  delete x; //在严格模式下报 SyntaxError
  delete globalThis.x; //这样可以
  ```

### 6.5 测试属性

JS 对象可以被想象成一组属性，实际开发中经常需要测试这组属性的成员关系，即检查对象是否有一个给定名字的属性。为此，可以使用:

- `in` 操作符
- `hasOwnProperty()`
- `propertyIsEnumerable()`
- 直接查询相应属性

下面的示例都使用字符串作为属性名，这些示例也适用于[符号属性](#6103-符号作为属性名)。

- `in` 操作符要求左边是一个属性名，右边是一个对象。如果**对象有包含相应名字的自有属性或继承属性，将返回 true**:

  ```js
  let o = { x: 1 };
  'x' in o; // true: o 有自有属性 "x"
  'y' in o; // false: o 没有属性"y"
  'toString' in o; //=>true: o 继承了 toString 属性
  ```

- 对象的 `hasOwnProperty()` 方法**用于测试对象是否有给定名字的属性。对继承的属性，它返回 false**:

  ```js
  let o = { x: 1 };
  o.hasOwnProperty('x'); // true: o 有自有属性 X
  o hasOwnProperty('y'); // false: o 没有属性 y
  o.hasOwnProperty('toString'); // false: toString 是继承属性
  ```

- `propertyIsEnumerable()` 方法细化了 `hasOwnProperty()` 测试。如果**传入的命名属性是自有属性且这个属性的 `enumerable` 特性为 true，这个方法会返回 true**。某些内置属性是不可枚举的。

  > 使用常规 JS 代码创建的属性都是可枚举的，除非使用 14.1 节的技术将它们限制为不可枚举。<!--TODO-->

  ```js
  let o = { x: 1 };
  o.propertyIsEnumerable('x'); // true: o 有一个可枚举属性 x
  o.propertyIsEnumerable('toString'); // false: toString不是自有属性
  Object.prototype.propertyIsEnumerable('toString'); // false: toString 不可枚举
  ```

- 除了使用 `in` 操作符，通常简单的属性查询配合 `!==` 确保其不是未定义的就可以了：

  ```js
  let o = { x: 1 };
  o.x !== undefined; // true: o 有属性 x
  o.y !== undefined; // false: o 没有属性 y
  o.toString !== undefined; // true: o 继承了 tostring 属性
  ```

但有一件事 `in` 操作符可以做，而简单的属性访问技术做不到。**`in` 可以区分不存在的属性和存在但被设置为 undefined 的属性**。来看下面的代码:

```js
let o = { x: undefined }; // 把属性显式设置为 undefined
o.x !== undefined; // false: 属性 x 存在但值是 undefined
o.y !== undefined; // false: 属性 y 不存在
'x' in o; // true: 属性 x 存在
'y' in o; // false: 属性 y 不存在
delete o.x; // 删除属性 ⅹ
'x' in o; // false: 属性 x 不存在
```

### 6.6 枚举属性

除了测试属性是否存在，有时候也需要遍历或获取对象的所有属性。为此有几种不同的实现方式。

**`for/in` 循环对指定对象的每个可枚举（自有或继承）属性都会运行一次循环体，将属性的名字赋给循环变量**。对象继承的内置方法是不可枚举的，但 JS 代码添加给对象的属性默认是可枚举的。例如:

```js
let o = { x: 1, y: 2, z: 3 }; // 3 个可枚举自有属性
o.propertyIsEnumerable('toString'); // false: toString 不可枚举也不是自有属性
for (let p in o) {
  console.log(p); // 打印 x、y、z，但没有 toString
}
```

为防止通过 `for/in` 枚举继承的属性，可以在循环体内添加一个显式测试:

```js
for (let p in o) {
  if (!o.hasOwnProperty(p)) continue; // 跳过继承属性
}

for (let p in o) {
  if (typeof o[p] === 'function') continue; // 跳过所有方法
}
```

除了使用 `for/in` 循环，有时候可以先获取对象所有属性名的数组，然后再通过 `for/of` 循环遍历该数组。有 4 个函数可以用来取得属性名数组:

- `Object.keys()` 返回对象可枚举自有属性名的数组。不包含不可枚举属性、继承属性或[符号属性](#6103-符号作为属性名)。
- `Object.getOwnProperNames()` 与 `Object.keys()` 类似，但也会返回不可枚举自有属性名的数组，只要它们的名字是字符串。
- `Object.getOwnPropertySymbols()` 返回名字是符号的自有属性，无论是否可枚举。
- `Reflect.ownKeys()` 返回所有属性名，包括可枚举和不可枚举属性，以及字符串属性和符号属性(参见 14.6 节)<!--TODO-->。

#### 6.6.1 属性枚举顺序

ES6 正式定义了枚举对象自有属性的顺序。`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnProperSymbols()`、`Reflect.ownKeys()`及 `JSON.stringify()` 等相关方法都按照下面的顺序列出属性，另外也受限于它们要列出不可枚举属性还是列出字符串属性或符号属性:

1. 先列出名字为非负整数的字符串属性，按照数值顺序从最小到最大。这条规则意味着数组和类数组对象的属性会按照顺序被枚举。

2. 在列出类数组索引的所有属性之后，再列出所有剩下的字符串名字（包括看起来像负数或浮点数的名字）的属性。这些属性按照它们添加到对象的先后顺序列出。对于在对象字面量中定义的属性，按照它们在字面量中出现的顺序列出。

3. 最后，名字为符号对象的属性按照它们添加到对象的先后顺序列出。

`for/in` 循环的枚举顺序并不像上述枚举函数那么严格，但实现通常会按照上面描述的顺序枚举自有属性，然后再沿原型链上溯，以同样的顺序枚举每个原型对象的属性。

> **注意**：如果已经有同名属性被枚举过了，甚至如果有一个同名属性是不可枚举的，那这个属性就不会枚举了。

### 6.7 扩展对象

在 JS 程序中，把一个对象的属性复制到另一个对象上是很常见的。使用下面的代码很容易做到:

```js
let target = { x: 1 },
  source = { y: 2, z: 3 };
for (let key of Object.keys(source)) {
  target[key] = source[key];
}
```

**`Object.assign()`**
因为这是个常见操作，所以在 ES6 中，这个能力以 `Object.assign()` 的形式进入了核心 JS 语言。**`Object.assign()` 接收两个或多个对象作为其参数。它会修改并返回第一个参数，第一个参数是目标对象，但不会修改第二个及后续参数，那些都是来源对象**。

对于每个来源对象，它会把该对象的可枚举自有属性（包括名字为符号的属性）复制到目标对象。它按照参数列表顺序逐个处理来源对象，第一个来源对象的属性会覆盖目标对象的同名属性，而第二个来源对象（如果有）的属性会覆盖第一个来源对象的同名属性。

`Object.assign()` 以普通的属性获取和设置方式复制属性，因此如果一个来源对象有获取方法或目标对象有设置方法，则它们会在复制期间被调用，但这些方法本身不会被复制。

将属性从一个对象分配到另一个对象的一个原因是，如果有一个默认对象为很多属性定义了默认值，并且如果该对象中不存在同名属性，可以将这些默认属性复制到另一个对象中。但是，像下面这样简单地使用 `Object.assign()` 不会达到目的:

```js
Object.assign(o, defaults); // 用 defaults 覆盖 o 的所有属性
```

此时，需要创建一个新对象，先把默认值复制到新对象中，然后再使用 `o` 的属性覆盖那些默认值

```js
o = Object.assign({}, defaults, o);
```

使用扩展操作符 `...` 也可以表达这种对象复制和覆盖操作:

```js
o = { ...defaults, ...o };
```

为了避免额外的对象创建和复制，也可以重写一版 `Object.assign()`，只复制那些不存在的属性:

```js
// 与 Object.assign() 类似，但不覆盖已经存在的属性
// （同时也不处理符号属性）
function merge(target, ...sources) {
  for (let source of sources) {
    for (let key of Object.keys(source)) {
      // 这里跟 Object.assign() 不同
      if (!(key in target)) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
Object.assign({ x: 1 }, { x: 2, y: 3 }, { y: 3, z: 4 }); // {x:2, y:3, z:4}
merge({ x: 1 }, { x: 2, y: 2 }, { y: 3, z: 4 }); // {x:1, y:2, z:4}
```

### 6.8 序列化对象

**对象序列化（serialization）是把对象的状态转换为字符串的过程，之后可以从中恢复对象的状态**。

函数 `JSON.stringify()` 和 `JSON.parse()` 用于序列化和恢复 JS 对象。这两个函数使用 JSON 数据交换格式。JSON 表示 JavaScript Object Notation（JavaScript 对象表示法），其语法与 JS 对象和数组字面量非常类似：

```js
let o = { x: 1, y: { z: [false, null, ''] } }; // 定义一个测试对象
let s = JSON.stringify(o); // s == '{"x":1,"y":{"z":[false,null,""]}}}'
let p = JSON.parse(s); // p == { x: 1, y: { z: [false, null, ''] } }
```

JSON 语法是 JS 语法的子集，不能表示所有 JS 的值。**可以序列化和恢复的值包括对象、数组、字符串、有限数值、true、 false 和 null**。

**JSON 无法序列化和恢复的值**：

- `NaN`、`Infinity` 和 `-Infinity` 会被序列化为 `null`。
- 日期对象会被序列化为 ISO 格式的日期字符串，但 `JSON.parse()` 会保持其字符串形式，不会恢复原始的日期对象。
- 函数、RegExp 和 Error 对象以及 undefined 值不能被序列化或恢复。
- **`JSON.stringify()` 只序列化对象的可枚举自有属性**。如果属性值无法序列化，则该属性会从输出的字符串中删除。

`JSON.stringify()` 和 `JSON.parse()` 都接收可选的第二个参数，用于自定义序列化及恢复操作。例如，可以通过这个参数指定要序列化哪些属性，或者在序列化或字符串化过程中如何转换某些值。11.6 节包含这两个函数的完整介绍。<!--TODO-->

### 6.9 对象方法

**所有 JS 对象（除了那些显式创建为没有原型的）都从 `Object.prototype` 继承属性。这些继承的属性主要是方法**，因为它们几乎无处不在，所以对 JS 程序而言特别重要。例如，`hasOwnProperty()` 和 `propertyIsEnumerable()` 方法。

下面是几个 `Object.prototype` 上的通用方法，但这些方法很有可能被更特定的实现取代。

#### 6.9.1 toString() 方法

**`toString()` 方法不接收参数，返回表示调用它的对象的值的字符串**。每当需要把一个对象转换为字符串时，JS 就会调用该对象的这个方法。例如，在使用 `+` 操作符拼接一个字符串和一个对象时，或者把一个对象传入期望字符串参数的方法时。

默认的 `toString()` 方法并不能提供太多信息（但可以用于确定对象的类）。例如，下面这行代码只会得到字符串 "[object Object]":

```js
let s = { x: 1, y: 1 }.toString(); // s == "[object Object]
```

由于这个默认方法不会显示太有用的信息，很多类都会重新定义自己的 `toString()` 方法。例如，在把数组转换为字符串时，可以得到数组元素的一个列表，每个元素也都转换为字符串。而把函数转换为字符串时，可以得到函数的源代码。可以像下面这样定义自己的 `toString()` 方法:

```js
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  }
};
String(point); // "(1, 2)": toString() 用于转换为字符串
```

#### 6.9.2 toLocaleString() 方法

除了基本的 `toString()` 方法之外，对象也都有一个 **`toLocaleString()` 方法。这个方法的用途是返回对象的本地化字符串表示**。

- Object 定义的默认 `toLocaleString()` 方法本身没有实现任何本地化，而是简单地调用 `toString()` 并返回该值。
- Date 和 Number 定义了自己的 `toLocaleString()` 方法，尝试根据本地惯例格式化数值、日期和时闻。
- 数组也定义了一个与 `toString()` 类似的 `toLocaleString()` 方法，只不过它会调用每个数组元素的 `toLocaleString()` 方法，而不是调用它们的 `toString()` 方法。

对于前面的 point 对象，也可以如法炮制:

```js
let point = {
  X: 1000,
  y: 2000,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  },
  toLocaleString: function () {
    return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`;
  }
};

point.toString(); // "(1000, 2000)"
point.toLocaleString(); // "(1,000, 2,000)": 千分位分隔符
```

#### 6.9.3 valueOf() 方法

`valueOf()` 方法与 `toString()` 方法很相似，但**会在 JS 需要把对象转换为某些非字符串原始值（通常是数值）时被调用**。如果在需要原始值的上下文中使用了对象，JS 会自动调用这个对象的 `valueOf()` 方法。

默认的 `valueOf()` 方法并没有做什么，因此一些内置类定义了自己的 `valueOf()` 方法。Date 类定义的 `valueOf()` 方法可以将日期转换为数值，这样就让日期对象可以通过 `<` 和 `>` 操作符来进行比较。类似地，对于 point 对象，也可以定义一个返回原点与当前点之间距离的 `valueOf()`:

```js
let point = {
  x: 3,
  y: 4,
  valueOf: function () {
    return Math.hypot(this.x, this.y);
  }
};

Number(point); // 5: valueOf() 用于转换为数值
point > 4;
point > 5; // false
point < 6; // true
```

#### 6.9.4 toJSON() 方法

`Object.prototype` 实际上并未定义 `toJSON()` 方法，但 `JSON.stringify()` 方法会从要序列化的对象上寻找 `toJSON()` 方法。如果要序列化的对象上存在这个方法，就会调用它，然后序列化该方法的返回值，而不是原始对象。

Date 类(参见 11.4 <!--TODO-->节)定义了自己的 `toJSON()` 方法，返回一个表示日期的序列化字符串。同样，也可以给 point 对象定义这个方法:

```js
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return `(${this.x}, ${this.y});`;
  },
  toJSON: function () {
    return this.toString();
  }
};

JSON.stringify([point]); // '["(1, 2)"]'
```

### 6.10 对象字面量扩展语法

最近的 JS 版本从几个方面扩展了对象字面量语法。

#### 6.10.1 简写属性

假设变量 x 和 y 中保存着值，想创建一个具有属性 x 和 y 且值分别为相应变量值的对象。如果使用基本的对象字面量语法，需要把每个标识符重复两次:

```js
let x = 1,
  y = 2;
let o = {
  x: x,
  y: y
};
```

在 ES6 及之后，可以删掉其中的分号和一份标识符，得到非常简洁的代码:

```js
let x = 1,
  y = 2;
let o = { x, y };
o.x + o.y; // 3
```

#### 6.10.2 计算的属性名

有时候，需要创建一个具有特定属性的对象，但该属性的名字不是编译时可以直接写在源代码中的常量。相反，需要的这个属性名保存在一个变量里，或者是调用的某个函数的返回值。不能对这种属性使用基本对象字面量。为此，必须先创建一个对象然后再为它添加想要的属性:

```js
const PROPERTY_NAME = 'p1';
function computePropertyName() {
  return 'p' + 2;
}

let o = {};
o[PROPERTY_NAME] = 1;
o[computePropertyName()] = 2;
```

而使用 ES6 称为计算属性的特性可以更简单地创建类似对象，这个特性可以直接把前面代码中的方括号放在对象字面量中:

```js
const PROPERTY_NAME = 'p1';
function computePropertyName() {
  return 'p' + 2;
}

let p = {
  [PROPERTY_NAME]: 1,
  [computePropertyName()]: 2
};

p.p1 + p.p2; // 3
```

有了这个语法，就可以在方括号中加入任意 JS 表达式。对这个表达式求值得到的结果（必要时转换为字符串）会用作属性的名字。

#### 6.10.3 符号作为属性名

计算属性语法也让另一个非常重要的对象字面量特性成为可能。**在 ES6 及之后，属性名可以是字符串或符号。如果把符号赋值给一个变量或常量，那么可以使用计算属性语法将该符号作为属性名**：

```js
const extension = Symbol('my extension symbol');
let o = {
  [extension]: {
    /*这个对象中存储扩展数据*/
  }
};
o[extension].x = 0; // 这个属性不会与 o 的其他属性冲突
```

符号是不透明值。除了用作属性名之外，不能用它们做任何事情。不过，每个符号都与其他符号不同，这意味着符号非常适合用于创建唯一属性名。创建新符号需要调用 `Symbol()` 工厂函数（符号是原始值，不是对象，因此 `Symbol()` 不是构造函数，不能使用 new 调用）。

`Symbol()` 返回的值不等于任何其他符号或其他值。可以给 `Symbol()` 传一个字符串，在把符号转换为字符串时会用到这个字符串。但这个字符串的作用仅限于辅助调试，使用相同字符串参数创建的两个符号依旧是不同的符号。

> 使用符号不是为了安全，而是为 JS 对象定义安全的扩展机制。如果从不受控的第三方代码得到一个对象，然后需要为该对象添加一些自己的属性，但又不希望添加的属性与该对象原有的任何属性冲突，那就可以放心地使用符号作为属性名。而且，这样一来，也不必担心第三方代码会意外修改以符号命名的属性（当然，第三方代码可以使用 `Object.getOwnPropertySymbols()` 找到使用的符号，然后修改或删除属性。这也是符号不是一种安全机制的原因）。

#### 6.10.4 扩展操作符

在 ES2018 及之后，可以在对象字面量中使用“扩展操作符” `...` 把已有对象的属性复制到新对象中:

```js
let position = { x: 0, y: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ...position, ...dimensions };
rect.x + rect.y + rect.width + rect.height; // 175
```

如果扩展对象和被扩展对象有一个同名属性，那么这个属性的值由后面的对象决定:

```js
let o = { x: 1 };
let p = { x: 0, ...o };
p.x; // 1：对象 o 的值覆盖了初始值
let q = { ...o, x: 2 };
q.x; // 2: 值 2 覆盖了前面对象 o 的值
```

> **注意**：
>
> 1. `...` 语法经常被称为扩展操作符，但却不是真正意义上的 JS 操作符。实际上，**它是仅在对象字面量中有效的一种特殊语法**（在其他 JS 上下文中，三个点有其他用途。只有在对象字面量中三个点才会产生这种把一个对象的属性复制到另一个对象中的插值行为）。
> 2. 扩展操作符只扩展对象的自有属性，不扩展任何继承属性。
> 3. 虽然扩展操作符在代码中只是三个小圆点，但它可能给 JS 解释器带来巨大的工作量。如果对象有 n 个属性，把这个属性扩展到另一个对象可能是一种 O(n) 操作。这意味着，如果在循环或递归函数中通过.向一个大对象不断追加属性，则很可能是在写一个低效的 O(n2) 算法。随着 n 越来越大，这个算法可能会成为性能瓶颈。

#### 6.10.5 简写方法

**在把函数定义为对象属性时，称该函数为方法**。在 ES6 以前，需要像定义对象的其他属性一样，通过函数定义表达式在对象字面量中定义一个方法:

```js
let square = {
  area: function () {
    return this.side * this.side;
  },
  side: 10
};
square.area(); // 100
```

但在 ES6 中，对象字面量语法经过扩展，允许一种省略 `function` 关键字和冒号的简写方法，结果代码如下

```js
let square = {
  area() {
    return this.side * this.side;
  },
  side: 10
};
square.area(); // 100
```

这两段代码是等价的，都会给对象字面量添加一个名为 area 的属性，都会把该属性的值设置为指定函数。这种简写语法让人一看便知 `area()` 是方法，而不是像 side 一样的数据属性。

在使用这种简写语法来写方法时，属性名可以是对象字面量允许的任何形式。除了像上面的 area 一样的常规 JS 标识符之外，也可以使用字符串字面量和计算的属性名，包括符号属性名：

```js
const METHOD_NAME = 'm';
const symbol = Symbol();
let weirdMethods = {
  'method with Spaces'(x) {
    return x + 1;
  },
  [METHOD_NAME](x) {
    return x + 2;
  },
  [symbol](x) {
    return x + 3;
  }
};
weirdMethods['method With Spaces'](1); //2
weirdMethods[METHOD_NAME](1); // 3
weirdMethods[symbol](1); // 4
```

#### 6.10.6 属性的获取方法与设置方法（访问器属性）

除了数据属性（有一个名字和一个普通的值）之外，**JS 还支持为对象定义访问器属性（accessor property），这种属性不是一个值，而是一个或两个访问器方法:一个获取方法（getter）和一个设置方法（setter）**。

- 当程序查询一个访问器属性的值时，JS 会调用获取方法（不传参数）。这个方法的返回值就是属性访问表达式的值。

- 当程序设置一个访问器属性的值时，JS 会调用设置方法，传入赋值语句右边的值。从某种意义上说，这个方法负责“设置”属性的值。设置方法的返回值会被忽略。

如果一个属性既有获取方法也有设置方法，则该属性是一个可读写属性。如果只有一个获取方法，那它就是只读属性。如果只有一个设置方法，那它就是只写属性（这种属性通过数据属性是无法实现的），读取这种属性始终会得到 undefined。

访问器属性可以通过对象字面量的一个扩展语法来定义（获取方法和设置方法是在 ES5 中引入的）：

```js
let o = {
  // 一个普通的数据属性
  dataProp: value,
  // 通过一对函数定义的一个访问器属性
  get accessorProp() {
    return this.dataProp;
  },
  set accessorProp(value) {
    this.dataProp = value;
  }
};
```

**访问器属性是通过一个或两个方法来定义的，方法名就是属性名**。除了前缀是 `get` 和 `set` 之外，这两个方法看起来就像用 ES6 简写语法定义的普通方法一样（在 ES6 中，也可以使用计算的属性名来定义获取方法和设置方法。只要把替换为用方括号包含的表达式即可）。

上面定义的访问器方法只是简单地获取和设置了一个数据属性的值，这种情况使用数据属性或访问器属性都是可以的。例如，下面这个表示 2D 笛卡儿坐标点的对象。这个对象用普通数据属性保存点的 x 和 y 坐标，用访问器属性给出与这个点等价的极坐标：

```js
let p = {
  // x 和 y 是常规的可读写数据属性
  x: 1.0,
  y: 1.0,
  // r 是由获取方法和设置方法定义的可读写访问器属性
  // 不要忘了访问器方法后面的逗号
  get r() {
    return Math.hypot(this.x, this.y);
  },
  set r(newValue) {
    let oldValue = Math.hypot(this.x, this.y);
    let ratio = newValue / oldValue;
    this.x *= ratio;
    this.y *= ratio;
  },
  // theta 是一个只定义了获取方法的只读访问器属性
  get theat() {
    return Math.atan2(this.y, this.x);
  }
};

p.r; // Math.SQRT2
p.theat; // Math.PI/4
```

> **注意**：这个示例的获取和设置方法中使用了关键字 `this`。JS 会将这些函数作为定义它们的对象的方法来调用。这意味着在这些函数体内，this 引用的是表示坐标点的对象 p。因此访问器属性 r 的获取方法可以通过 `this.x` 和 `this.y` 来引用坐标点的 x 和 y 属性。

**与数据属性一样，访问器属性也是可以继承的**。因此，可以把上面义的对象 p 作为其它点的原形。可以给新对象定义自己的 x 和 y 属性，而它们将继承 r 和 theat 属性。

```js
let q = Object.create(p); // 一个继承获取和设置方法的新对象
q.x = 3;
q.y = 4; // 创建 q 的自有数据属性
q.r; // 5: 可以使用继承的访问器属性
q.theta; // Math.atan2(4, 3)
```

以上代码使用访问器属性定义了一个 AP1，提供了一个数据集的两种表示（笛卡儿坐标和极坐标）。使用访问器属性的其他场景还有写入属性时进行合理性检查，以及每次读取属性时返回不同的值:

```js
// 这个对象保证序号严格递增
const serialnum = {
  // 这个数据属性保存下一个序号
  // 属性名中的 _ 提示它仅在内部使用
  _n: 0,
  // 返回当前值并递增
  get next() {
    return this._n++;
  },
  // 把新值设置为 n，但 n 必须大于当前值
  set next(n) {
    if (n > this._n) this._n = n;
    else throw new Error('serial number can only be set to a Larger value');
  }
};

serialnum.next = 10; // 设置起始序号
serialnum.next; // 10
sertalnum.next; // 11: 每次读取 next 都得到不同的值
```

最后，再看一个通过获取方法实现“魔法”属性的示例：

```js
// 这个对象的访问器属性返回随机数值
// 例如，表达式 "random.octet" 在被求值时
// 会给出一个 0 和 255 之间的随机值
const random = {
  get octet() {
    return Math.floor(Math.random() * 256);
  },
  get uint16() {
    return Math.floor(Math.random() * 65536);
  },
  get int16() {
    return Math.floor(Math.random() * 65536) - 32768;
  }
};
```

## 七. 数组

**数组是值的有序集合，其中的值叫作元素，每个元素有一个数值表示的位置，叫作索引**。

**JS 数组有以下特点**：

- JS 数组是无类型限制的，即数组中的元素可以是任意类型，同一数组的不同元素也可以是不同的类型。

- JS 数组是基于零且使用 32 位数值索引的，第一个元素的索引为 0，最大可能的索引值是 4294967294(2^32^-2)，即数组最大包含 4294967295 个元素。

- JS 数组是动态的，它们会按需增大或缩小，因此创建数组时无须声明一个固定大小，也无须在大小变化时重新为它们分配空间。

- JS 数组可以是稀疏的，即元素不一定具有连续的索引，中间可能有间隙。每个 JS 数组都有 length 属性。对于非稀疏数组，这个属性保存数组中元素的个数。对于稀疏数组，length 大于所有元素的最高索引。

- JS 数组是一种特殊的 JS 对象，因此数组索引更像是属性名，只不过碰巧是整数而已。数组的这种特殊性，通常可以实现对数组的特别优化，从而让访问数值索引的数组元素明显快于访问常规的对象属性。

- 数组从 `Array.prototype` 继承属性，这个原型上定义了很多[数组操作方法](#78-数组方法)。其中很多方法都是泛型的，这意味着它们不仅可以用于真正的数组，也可以用于任何[“类数组对象”](#79-类数组对象)。最后，JS 字符串的行为类似[字母数组](#710-作为数组的字符串)。

**ES6 增加了一批新的数组类，统称为“定型数组”（typed array）。与常规 JS 数组不同，定型数组具有固定长度和固定的数值元素类型。定型数组具有极高的性能，支持对二进制数据的字节级访问**，将在 11.2 <!--TODO--> 节介绍。

### 7.1 创建数组

创建数组有以下几种方式：

- 数组字面量
- 对可迭代对象使用 `...` 扩展操作符
- `Array()` 构造函数
- 工厂方法 `Array.of()` 和 `Array.from()`

#### 7.1.1 数组字面量

数组字面量其实就是一对方括号中逗号分隔的数组元素的列表。例如:

```js
let empty = []; // 没有元素的数组
let primes = [2, 3, 5, 7, 11]; // 有 5 个数值元素的数组
let misc = [1.1, true, 'a']; // 3 种不同类型的元素，最后还有一个逗号
```

数组字面量中的值不需要是常量，可以是任意表达式：

```js
let base = 1024;
let table = [base, base + 1, base + 2, base + 3];
```

数组字面量可以包含对象字面量或其他数组字面量：

```js
let b = [
  [1, { x: 1, y: 2 }],
  [2, { x: 3, y: 4 }]
];
```

**如果数组字面量中连续包含多个逗号，且逗号之间没有值，则这个[数组就是稀疏的](#73-稀疏数组)**。这些省略了值的数组元素并不存在，但按照索引查询它们时又会返回 `undefined`。

```js
let count = [1, , 3]; // 索引 0 和 2 有元素，索引 1 没有元素
let undefs = [, ,]; // 这个数组没有元素但长度为 2
```

**数组字面量语法允许末尾出现逗号**，因此 `[,,]` 的长度是 2 不是 3。

#### 7.1.2 扩展操作符

在 ES6 及之后的版本中,可以使用扩展操作符 `...` 在一个数组字面量中包含另一个数组的元素：

```js
let a = [1, 2, 3];
let b = [0, ...a, 4]; // b == [0,1,2,3,4]
```

**扩展操作符是创建数组（浅）副本的一种便捷方式**：

```js
let original = [1, 2, 3];
let copy = [...original];
copy[0] = 0; // 修改 copy 不会影响 original
original[0]; // 1
```

扩展操作符适用于任何可迭代对象（可迭代对象可以使用 `for/of` 循环遍历）。**字符串是可迭代对象，因此可以使用扩展操作符把任意字符串转换为单个字符的数组**：

```js
let digits = [...'0123456789ABCDEF'];
digits; // ["0","1","2","3", "4", "5", "6", "7", "8", "9", "A","B","C","D","E","F"]
```

集合对象（参见 11.1.1 节<!--TODO-->）是可迭代的，因此要去除数组中的重复元素，一种便捷方式就是先把数组转换为集合，然后再使用扩展操作符把这个集合转换回数组:

```js
let letters = [...'hello world'];
[...new Set(letters)]; //=>[h","e","l", "o", " ", "w", "r", "d"]
```

#### 7.1.3 Array() 构造函数

另一种创建数组的方式是使用 `Array()` 构造函数。有三种方式可以调用这个构造函数:

- 不传参数调用

  ```js
  let a = new Array(); // 等价于数组字面量 `[]`
  ```

- 传入一个数组参数，指定长度:

  ```js
  let a = new Array(10);
  ```

  这样会创建一个指定长度的数组。如果提前知道需要多少个数组元素，可以像这样调用 `Array()` 构造函数来预先为数组分配空间。

  > **注意**：这时的数组中不会存储任何值，数组索引属性 “0”、“1” 等都没有定义。

- 传入两个或更多个数组元素，或传入一个非数值元素:

  ```js
  let a = new Array(5, 4, 3, 2, 1, 'testing');
  ```

  构造函数参数会成为新数组的元素。

#### 7.1.4 Array.of()

在使用数值参数调用 `Array()` 构造函数时，这个参数指定的是数组长度。但在使用一个以上的数值参数时，这些参数则会成为新数组的元素。这意味着**使用 `Array()` 构造函无法创建只包含一个数值元素的数组**。

在 ES6 中，`Array.of()` 函数可以解决这个问题。这是个工厂方法，可以使用其参数值（无论多少个）作为数组元素来创建并返回新数组：

```js
Array.of(); // 返回没有参数的空数组
Array.of(10); // 可以创建只有一个数值元素的数组
Array.of(1, 2, 3); // [1,2,3]
```

#### 7.1.5 Array.from()

`Array.from()` 是 ES6 新增的另一个工厂方法。**这个方法期待一个可迭代对象或类数组对象作为其第一个参数，并返回包含该对象元素的新数组。如果传入可迭代对象，`Array.from(iterable)` 与使用扩展操作符 `[...iterable]` 一样**。因此，它也是创建数组副本的一种简单方式:

```js
let copy = Array.from(original);
```

`Array.from()` 很重要，因为**它定义了一种给类数组对象创建真正的数组副本的机制**。类数组对象不是数组对象，但也有一个数值 `length` 属性，而且每个属性的键也都是整数。在客户端 JS 中，有些浏览器方法返回的值就是类数组对象，那么像这样先把它们转换成真正的数组便于后续的操作:

```js
let truearray = Array.from(arraylike);
```

**`Array.from()` 也接受可选的第二个参数。如果给第二个参数传入了一个函数，那么在构建新数组时，源对象的每个元素都会传入这个函数，这个函数的返回值将代替原始值成为新数组的元素**（这一点跟数组的 `map()` 方法很像，但在构建数组间执行映射的效率要高于先构建一个数组再把它映射为另一个新数组）。

### 7.2 读写数组元素

可以使用 `[]` 操作符访问数组元素，方括号左侧应该是一个对数组的引用，方括号内应该是一个具有非负整数值的表达式。这个语法可以读和写数组元素的值。因此，下面都是合法的 JS 语句：

```js
let a = ['world']; // 先创建包含一个元素的数组
let value = a[0]; // 读取元素 0
a[1] = 3.14; // 写入元素 1
let i = 2;
a[i] = 3; // 写入元素 2
a[i + 1] = 'hello'; // 写入元素 3
a[a[i]] = a[0]; // 读取元素 0 和 2，写入元素 3
```

数组特殊的地方在于，只要使用小于 `2^32^-1` 的非负整数作为属性名，数组就会自动为维护 `length` 属性的值。比如在前面的例子中，先创建了一个只有一个元素的数组。而在给它的索引 1、2、3 赋值之后，数组的 `length` 属性也会相应改变，因此:

```js
a.length; // 4
```

**数组是一种特殊的对象。用于访问数组元素的方括号与用于访问对象属性的方括号是类似的**。JS 会将数值数组索引转换为字符串，即索引 `1` 会变成字符串 `"1"`。然后再将这个字符串作为属性名。这个从数值到字符串的转换没什么特别的，使用普通对象也一样:

```js
let o = {}; // 创建一个普通对象
o[1] = 'one'; // 通过整数索引一个值
o['1']; // "one"，数值和字符串属性名是同一个
```

明确区分数组索引和对象属性名是非常有帮助的。所有索引都是属性名，但只有介于 `0` 和 `2^32^-2` 之间的整数属性名才是素引。所有数组都是对象，可以在数组上以任意名字创建属性。只不过，如果这个属性是数组索引，数组会有特殊的行为，即自动按需更新其 `length` 属性。

**可以使用负数或非整数值来索引数组。此时，数值会转换为字符串，而这个字符串会作为属性名**。因为这个名字是非负整数，所以会被当成常规的对象属性，而不是数组素引。另外，如果碰巧使用了非负整数的字符串来索引数组，那这个值会成为数组素引，而不是对象属性。同样，如果使用了与整数相等的浮点值也是如此:

```js
a[-1.23] = true; // 这样会创建一个属性 "-1.23"
a['1000'] = 0; // 这是数组中第 1001 个元素
a[1.0] = 1; // 数组索引 1，相当于 a[1]=1;
```

**由于数组索引其实就是一种特殊的对象属性，所以 JS 数组没有所谓"越界错误"**。查询任何对象中不存在的属性都不会导致错误，只会返回 undefined，数组作为一种特殊对象也是如此:

```js
let a = [true, false]; // 数组的索引 0 和 1 有元素
a[2]; // undefined，这个索引没有元素
a[-1]; // undefined，这名字没有属性
```

### 7.3 稀疏数组

稀疏数组就是其元素没有从 `0` 开始的索引的数组。正常情况下，数组的 `length` 属性表明数组中元素的个数。如果数组是稀疏的，则 `length` 属性的值会大于元素个数。

可以使用 `Array()` 构造函数创建稀疏数组，或者直接给大于当前数组 `length` 的数组索引赋值：

```js
let a = new Array(5); // 没有元素，但 a.length 是 5
a = []; // 创建一个空数组，此时 length = 0
a[1000] = 0; // 赋值增加了一个元素，但 length 变成了 1001
```

使用 `delete` 操作符也可以创建稀疏数组。

> 足够稀疏的数组通常是以较稠密数组慢、但内存占用少的方式实现的，查询这种数组的元素与查询常规对象属性的时间相当。

如果省略数组字面量中的一个值（像 `[1,,3]` 这样重复逗号两次），也会得到稀疏数组，被省略的元素是不存在的:

```js
let a1 = [,]; // 这个数组没有元素，但 length 是 1
let a2 = [undefined]; // 这个数组有一个 undefined 元素
0 in a1; // false：a1 在索引 0 没有元素
0 in a2; // true：a2 在索引 0 有 undefined 值
```

> 理解稀疏数组是真正理解 JS 数组的重要一环。但在实践中，碰到的多数 JS 数组都不是稀疏的。如果真的碰到了稀疏数组，可以把稀疏数组当成包含 undefined 元素的非稀疏数组。

### 7.4 数组长度

**每个数组都有 `length` 属性，正是这个属性让数组有别于常规的 JS 对象**。对于稠密数组（即非稀疏数组），`length` 属性就是数组中元素的个数。这个值比数组的最高索引大 1:

```js
[].length; // 0: 数组没有元素
['a', 'b', 'c'].length; // 3: 最高索引为 2, length 值为 3
```

对于稀疏数组，`length` 属性会大于元素个数，也可以说稀疏数组的 `length` 值一定大于数组中任何元素的索引。从另一个角度说，数组（无论稀疏与否）中任何元素的索引都不会大于或等于数组的 `length`。

为了维护这种不变式（invariant），数组有两个特殊行为：

- 如果给一个索引为 `i` 的数组元素赋值，而 `i` 大于或等于数组当前的 `length`，则数组的 `length` 属性会被设置为 `i+1`

- 如果将 `length` 属性设置为一个小于其当前值的非负整数 `n`，则任何索引大于或等于 `n` 的数组元素都会从数组中被删除:

  ```js
  a = [1, 2, 3, 4, 5]; // 先定义一个包含 5 个元素的数组
  a.length = 3; // a 变成 [1,2,3]
  a.length = 0; // 删除所有元素。a 是 []
  a.length = 5; // 长度是 5，但没有元素,类似 new Array(5)
  ```

  也可以把数组的 `length` 属性设置为一个大于其当前值的值。这样做并不会向数组中添加新元素，只会在数组末尾创建一个稀疏的区域。

### 7.5 添加和删除数组元素

- 为数组添加元素的最简单方式，就是给它的一个新索引赋值:

  ```js
  let a = 0; // 创建一个空数组
  a[0] = 'zero'; // 添加一个元素
  a[1] = 'one';
  ```

- 也可以使用 `push()` 方法在数组末尾添加一个或多个元素:

  ```js
  let a = []; // 创建一个空数组
  a.push('zero'); // 在末尾添加一个值，a= ["zero"]
  a.push('one', 'two'); // 再在末尾添加两个值，a = ["zero", "one", "two"]
  ```

- 向数组 `a` 中推入一个值等同于把这个值赋给 `a[a.length]`。要在数组开头插入值，可以使用 [`unshift()` 方法](#78-数组方法)，这个方法将已有数组元素移动到更高索引位。

- 与 [`push()`](#78-数组方法) 执行相反操作的是 `pop()` 方法，它删除数组最后一个元素并返回该元素，同时导致数组长度减 1。类似地，`shift()` 方法删除并返回数组的第一个元素，让数组长度减 1 并将所有元素移动到低一位的索引。

- 可以使用 delete 操作符删除数组元素:

  ```js
  let a = [1, 2, 3];
  delete a[2]; // 现在索引 2 没有元素了
  2 in a; // false: 数组索引 2 没有定义
  a.length; // 3: 删除元素不影响数组长度
  ```

  删除数组元素类似于（但不完全等同于）给该元素赋 undefined 值。

  > **注意**：对数组元素使用 `delete` 操作符不会修改 `length` 属性，也不会把高索引位的元素向下移动来填充被删除属性的空隙。从数组中删除元素后,数组会变稀疏。

- 把数组 `length` 属性设置成一个新长度值，也可以从数组末尾删除元素。

- [`splice()`](#78-数组方法) 是一个可以插入、删除或替换数组元素的通用方法。这个方法修改 `length` 属性并按照需要向更高索引或更低索引移动数组元素。

### 7.6 迭代数组

- 在 ES6 以前，遍历一个数组（或任何可迭代对象）的最简单方式是使用 `for/of` 循环:

  ```js
  let letters = [...'Hello world'];
  let string = '';
  for (let letter of letters) {
    string += letter;
  }
  string; // "Hello world"; 重新组装了原始文本
  ```

  `for/of` 循环使用的内置数组迭代器按照升序返回数组的元素。对于稀疏数组，这个循没有特殊行为，凡是不存在的元素都返回 undefined。

- 如果要对数组使用 `for/of` 循环，并且想知道每个数组元素的索引，可以使用数组的 `entries()` 方法和解构赋值：

  ```js
  let everyother = '';
  for (let [index, letter] of Letters.entries()) {
    if (index % 2 === 0) everyother += letter; // 偶数索引的字母
  }
  everyother; // 'Hlowrd'
  ```

- 另一种**迭代数组的推荐方式**是使用 [`forEach()`](#781-数组迭代器方法)。它并不是一种新的 for 循环，而是数组提供的一种用于自身迭代的函数式方法。因此需要给 `forEach()` 传一个函数，然后 `forEach()` 会用数组的每个元素调用一次这个函数：

  ```js
  let uppercase = '';
  // 注意这里使用的是箭头函数
  letters.forEach(letter => {
    uppercase += letter.toUpperCase();
  });
  uppercase; // "HELLO WORLD"
  ```

  `forEach()` 按顺序迭代数组，而且会将索引作为第二个参数传给函数。与 `for/of` 循环不同，`forEach()` 能感知稀疏数组，不会对没有的元素数组调用函数。

- 使用老式的 for 循环也可以遍历数组：

  ```js
  let vowels = '';
  // 对数组中的每个索引
  for (let i = 0; i < letters.Length; i++) {
    let letter = letters[i]; // 取得该索引处的元素
    // 使用正则表达式测试
    if (/[aeiou]/.test(letter)) {
      vowels += letter; // 如果是元音就记住它
    }
  }
  vowels; // "eoo"
  ```

  在嵌套循环中，或其他性能攸关的场合，有时候会看到这种简单的数组迭代循环，但只会读取一次数组长度，而不是在每个迭代中都读取一次。下面展示的两种 for 循环形式都是比较推荐的：

  ```js
  // 把数组长度保存到局部变量中
  for (let i = 0, len = letters.length; i < len; i++) {
    // 循环体不变
  }

  // 从后向前迭代数组
  for (let i = letters.length - 1; i >= 0; i--) {
    //循环体不变
  }
  ```

  这两个例子假定数组是稠密的，即所有元素都包含有效数据。如果不是这种情况，那应该在使用每个元素前先进行测试。如果想跳过未定义或不存在的元素，可以这样写:

  ```js
  for (let i = 0; i < a.length; i++) {
    if (a[i] === undefined) continue; // 跳过未定义及不存在的元素
    // 这里的循环体
  }
  ```

### 7.7 多维数组

JS 并不支持真正的多维数组，但可以使用数组的数组来模拟。要访问数组的数组的值，使用两个 `[]` 即可。比如，假设变量 matrix 是一个数值数组的数组，则 `matrix[x]` 的每个元素都是一个数值数组。要访问这个数组中的某个数值，就要使用 `matrix[x][y]` 这种形式。下面这个例子利用二维数组生成了乘法表:

```js
// 创建一个多维数组
let table = new Array(10);
// 表格的 10 行
for (let i = 0; i < table.length; i++) {
  table[i] = new Array(10); // 每行有 10 列
}

// 初始化数组
for (let row = 0; row < table.length; row++) {
  for (let col = 0; col < table[row].length; col++) {
    table[row][col] = row * col;
  }
}
// 从这个多维数组中获得5*7的值
table[5][7]; // 35
```

### 7.8 数组方法

前面主要是 JS 操作数组的基本语法。但一般来说，还是 Array 类定义的方法用处最大。接下来会介绍几个相关的数组方法：

- **迭代器方法**：用于遍历数组元素，通常会对每个元素调用一次指定的函数。

- **栈和队列方法**：用于在开头或末尾向数组中添加元素或从数组中删除元素。

- **子数组方法**：用于提取、删除、插入、填充和复制更大数组的连续区域。

- **搜索和排序方法**：用于在数组中查找元素和对数组元素排序。

#### 7.8.1 数组迭代器方法

**作用**
数组迭代器方法，它们会按照顺序把数组的每个元素传给提供的函数，可便于对数组进行迭代、映射、过滤、测试和归并。

**共性**
首先，所有这些方法都接收一个函数作为第一个参数，并且对数组的每个元素（或某些元素）都调用一次这个函数。如果数组是稀疏的，则不会对不存在的数组元素调用传入的这个函数。多数情况下，提供的这个函数被调用时都会收到 3 个参数，分别是数组元素的值、数组元素的索引和数组本身。

多数迭代器方法都接收可选的第二个参数。如果指定这个参数，则第一个函数在被调用时就好像它是第二个参数的方法一样。换句话说，传入的第二个参数会成为作为第一个参数传入的函数内部的 this 值。传入函数的返回值通常不重要，但不同的方法会以不同的方式处理这个返回值。

所有这些方法在被调用时第一个参数都是函数，因此在方法调用表达式中直接定义这个函数参数是很常见的。[箭头函数](#813-箭头函数)特别适合在这些方法中使用。

- `forEach()`
  `forEach()` 方法迭代数组的每个元素，并对每个元素都调用一次指定的函数。传统 `forEach()` 方法的第一个参数是函数。**`forEach()` 在调用这个函数时会给它传 3 个参数: 数组元素的值、数组元素的索引和数组本身**。如果只关心数组元素的值，可以把函数写成只接收一个参数，即忽略其他参数：

  ```js
  let data = [1, 2, 3, 4, 5],
    sum = 0;
  // 计算数组元素之和
  data.forEach(value => {
    sum += value; // sum == 15
  });

  // 递增每个元素的值
  data.forEach(function (v, i, a) {
    a[i] = v + 1; // data == [2,3,4,5,6]
  });
  ```

  > **注意**：`forEach()` 并未提供一种提前终止迭代的方式。即，在这里没有与常规 for 循环中的 break 语句对等的机制。

- `map()`

  `map()` 方法把调用它的数组的每个元素分别传给指定的函数，返回这个函数的返回值构成的数组。例如：

  ```js
  let a = [1, 2, 3];
  a.map(x => x * x); // [1,4,9]: 这个函数接收 x 并返回 x*x
  ```

  传给 `map()` 的函数与传给 `forEach()` 的函数会以同样的方式被调用。但对于 `map()` 方法来说，传入的函数应该返回值。

  > **注意**：`map()` 返回一个新数组，并不修改调用它的数组。如果数组是稀疏的，则缺失元素不会调用函数，但返回的数组也会与原始数组一样稀疏: 长度相同，缺失的元素也相同。

- `filter()`
  `filter()` 方法返回一个数组，该数组包含调用它的数组的子数组。**传给这个方法的函数应该是个断言函数，即返回 true 或 false 的函数**。这个函数与传给 `map()` 的函数一样被调用。如果函数返回 true 或返回的值转换为 true，则传给这个函数的元素就是 `filter()` 最终返回的子数组的成员。看例子：

  ```js
  let a = [5, 4, 3, 2, 1];
  a.filter(x => x < 3); // [2, 1] 小于 3 的值
  a.filter((x, i) => i % 2 === 0); // [5, 3, 1]，隔一个选一个
  ```

  > **注意**：`filter()` 会跳过稀疏数组中缺失的元素，它返回的数组始终是稠密的。因此可以使用 `filter()` 方法像下面这样**清理掉稀疏数组中的空隙**:

  ```js
  let dense = sparse.filter(() => true);
  ```

  如果既想清理空隙，又想删除值为 undefined 和 null 的元素，则可以这样写:

  ```js
  a = a.filter(x => x !== undefined && x !== null);
  ```

- `find()` 与 `findIndex()`

  `find()` 和 `findIndex()` 方法与 `filter()` 类似，表现在它们都遍历数组，寻找断言函数返回真值的元素。

  但与 `filter()`不同的是，这两个方法会在断言函数找到第一元素时停止迭代。此时，`find()` 返回匹配的元素，`findIndex()` 返回匹配元素的索引。

  没有找到匹配的元素，则 `find()` 返回 undefined，而 `findIndex()` 返回 -1:

  ```js
  let a = [1, 2, 3, 4, 5];
  a.findIndex(x => x === 3); // 2，值 3 的索引是 2
  a.findIndex(x => x < 0); // -1，数组中没有负数
  a.find(x => x % 5 === 0); // 5：5 的倍数
  a.find(x => x % 7 === 0); // undefined：数组中没有 7 的倍数
  ```

- `every()` 与 `some()`

  `every()` 和 `some()` 方法是数组断言方法，即它们会对数组元素调用传入的断言函数，最后返回 true 或 false。

  `every()` 方法与数学上的 “全称” 量词类似，**它在且只在断言函数对数组的所有元素都返回 true 时才返回 true**：

  ```js
  let a = [1, 2, 3, 4, 5];
  a.every(x => x < 10); // true：所有值都小于 10
  a.every(x => x % 2 === 0); // false：并非所有值都是偶数
  ```

  `some()` 方法类似于数学上的 “存在” 量词，只要数组元素中有一个让断言函数 true 它就返回 true，但必须数组的所有元素对断言函数都返回 false 才返回 false:

  ```js
  let a = [1, 2, 3, 4, 5];
  a.some(x => x % 2 === 0); // true，a 包含偶数
  a.some(isNaN); // false，a 没有非数值
  ```

  > **注意**：
  >
  > 1. `every()` 和 `some()` 都会在它们知道要返回什么值时停止迭代数组。`some()` 在断言函数第一次返回 true 时返回 true，只有全部断言都返回 false 时才会遍历数组。`every()` 正好相反，它在断言函数第一次返回 false 时返回 false，只有全部断言都返回 true 时才会遍历数组。
  > 2. 如果在空数组上调用它们，按照数学的传统，`every()` 返回 true，`sone()` 返回 false。

- `reduce()` 与 `reduceRight()`

  `reduce()` 和 `reduceRight()` 方法使用指定的函数归并数组元素，最终产生一个值。在函数编程中，归并是一个常见操作，有时候也称为注入（Inject）或折叠（fold）。例子：

  ```js
  let a = [1, 2, 3, 4, 5];
  a.reduce((x, y) => x + y, 0); // 15; 所有值之和
  a.reduce((x, y) => x * y, 1); // 120; 所有值之积
  a.reduce((x, y) => (x > y ? x : y)); //5，最大值
  ```

  `reduce()` 接收两个参数。第一个参数是执行归并操作的函数。这个归并函数的任务就是把两个值归并或组合为一个值并返回这个值。在上面的例子中，归并函数通过把两个值相加、相乘和选择最大值来合并两个值。第二个参数是可选的，是传给归并函数的初始值。

  在 `reduce()` 中使用的函数与在 `forEach()` 和 `map()` 中使用的函数不同。值、索引和数组本身在这里作为第二、第三和第四个参数。第一个参数是目前为止归并操作的累计结果。在第一次调用这个函数时，第一个参数作为 `reduce()` 的第二个参数的初始值。在后续调用中，第一个参数则是上一次调用这个函数的返回值。

  在第一个例子中，初次调用归并函数传入的是 0 和 1，归并函数把它们相加后返回 1。然后再以参数 1 和 2 调用它并返回 3。接着计算 3+4=6、6+4=10，最后 10+5=15。最终值 15 成为 `reduce()` 的返回值。

  上面例子中第三次调用 `reduce()` 只传了一个参数，即并未指定初始值。在像这样不指定初始值调用时，`reduce()` 会使用数组的第一个元素作为初始值。这意味着首次调用归并函数将以数组的第一和第二个元素作为其第一和第二个参数。

  > **注意**：如果不传初始值参数，在空数组上调用 `reduce()` 会导致 TypeError。如果调用它时只有一个值，比如用只包含一个元素的数组调用且不传初始值，或者用空数组调用但传了初始值，则 `reduce()` 直接返回这个值，不会调用归并函数。

  `reduceRight()` 与 `reduce()` 类似，只不过是从高索引向低索引（从右到左）处理数组，而不是从低到高。如果归并操作具有从右到左的结合性，那可能要考虑 `reduceRight()`。比如:

  ```js
  // 计算 2^(3^4) 求幂具有从右到左的优先数
  let a = [2, 3, 4];
  a.reduceRight((acc, val) => Math.pow(vaL, acc)); // 2.4178516392292583e+24
  ```

  > **注意**：
  >
  > 1. 无论 `reduce()` 还是 `reduceRight()` 都不接收用于指定归并函数 this 值的可选参数。它们用可选的初始值参数取代了这个值。如果需要把归并函数作为特定对象的方法调用,可以考虑 8.7.5<!--TODO--> 节介绍的 Function.bind() 方法。
  > 2. `reduce()` 和 `reduceRight()` 并不是专门为数学计算而设计的。只要是能够把两个值（比如两个对象）组合成一个同类型值的函数，都可以用作归并函数。另一方面，使用数组归并表达的算法很容易复杂化，因而难以理解。此时可能使用常规循环逻辑处理数组反倒更容易阅读、编写和分析。

#### 7.8.2 使用 `flat()` 和 `flatMap()` 打平数组

在 ES2019 中，`flat()` 方法用于创建并返回一个新数组，这个新数组包含与它调用 `flat()` 的数组相同的元素，只不过其中任何本身也是数组的元素会被 “打平” 填充到返回的数组中。例如：

```js
[1, [2, 3]].flat(); // [1,2,3]
[1, [2, [3]]].flat(); // [1,2,[3]]
```

在不传参调用时，`flat()` 会打平一级嵌套，原始数组中本身也是数组的元素会被打平，但打平后的元素如果还是数组则不会再打平。如果想打平更多层级,需要给 `flat()` 传一个数值参数：

```js
let a = [1, [2, [3, [4]]]];
a.flat(1); // [1, 2, [3, [4]]]
a.flat(2); // [1,2,3,[4]]
a.flat(3); // [1,2,3,4]
a.flat(4); // [1,2,3,4]
```

`flatMap()` 方法与 `flat()` 方法相似，只不过返回的数组会自动打平就像传给 `flat()` 一样。换句话说，调用 `a.flatMap(f)` 等同于（但效率远高于）`a.map(f).flat()`。

```js
let phrases = ['hello world', 'the definitive guide'];
let words = phrases.flatMap(phrase => phrase.split(' '));
words; // ["hello", "world", "the", "definitive", "guide"]
```

可以把 `flatMap()` 想象为一个通用版的 `map()`，可以把输入数组中的一个元素映射为输出数组中的多个元素。特别地，`flatMap()` 允许把输入元素映射为空数组，这样打平后并不会有元素出现在输出数组中：

```js
// 将非负数映射为它们的平方根
[-2, -1, 1, 2].flatMap(x => (x < 0 ? [] : Math.sqrt(x))); // [1, 2**0.5]
```

#### 7.8.3 使用 `concat()` 添加数组

`concat()` 方法创建并返回一个新数组，新数组包含调用 `concat()` 方法的数组的元素，以及传给 `concat()` 的参数。如果这些参数中有数组，则拼接的是它们的元素而非数组本身。但要注意，`concat()` 不会递归打平数组的数组。`concat()` 并不修改调用它的数组:

```js
let a = [1, 2, 3];
a.concat(4, 5); // [1, 2, 3, 4, 5]
a.concat([4, 5], [6, 7]); // [1, 2, 3, 4, 5, 6, 7]，数组被打平了
a.concat(4, [5, [6, 7]]); // [1, 2, 3, 4, 5, [6, 7]，但不会打平嵌套的数组
a; // [1, 2, 3]，原始数组没有改变
```

> **注意**：`concat()` 会创建调用它的数组的副本。很多情况下，这样做都是正确的，只不过操作代价有点大。如果正在写类似 `a = a.concat(x)` 这样的代码，那应该考虑使用 `push()` 或 `splice()` 就地修改数组。

#### 7.8.4 通过 `push()`、`pop()`、`shift()` 和 `unshift()` 实现栈和队列操作

- `push()` 和 `pop()`
  `push()` 和 `pop()` 方法可以把数组作为栈来操作。其中，`push()` 方法用于在数组末尾添加一个或多个新元素，并返回数组的新长度。与 `concat()` 不同，`push()` 不会打平数组参数。`pop()` 方法恰好相反，它用于删除数组最后面的元素，减少数组长度，并返回删除的值。

  > **注意**：这两个方法都会就地修改数组。组合使用 `push()` 和 `pop()` 可以使用 JS 数组实现先进后出的栈。

  ```js
  let stack = []; // stack == []
  stack.push(1, 2); // stack == [1, 2]
  stack.pop(); // stack == [1]，返回 2
  stack.push(3); // stack == [1, 3]
  stack.pop(); // stack == [1]，返回 3
  stack.push([4, 5]); // stack == [1, [4, 5]]
  stack.pop(); // stack == [1]，返回 [4, 5]
  stack.pop(); // stack == []，返回 1
  ```

  `push()` 方法不会打平传入的数组，如果想把一个数组中的所有元素都推送到另一个数组中，可以使用扩展操作符(参见 8.3.4 节<!--TODO-->)显式打平它:

  ```js
  a.push(...values);
  ```

- `unshift()` 和 `shift()`
  `unshift()` 和 `shift()` 方法与 `push()` 和 `pop()` 很类似，只不过它们是从数组开头而非末尾插入和删除元素。`unshift()` 用于在数组开头添加一个或多个元素，已有元素的索引会相应向更高索引移动，并返回数组的新长度。

  `shift()` 删除并返回数组的第一个元素，所有后续元素都会向下移动一个位置，以占据数组开头空出的位置。

  使用 `unshift()` 和 `shift()` 可以实现栈，但效率不如使用 `push()` 和 `pop()`，因为每次在数组开头添加或删除元素都要向上或向下移动元素。不过，可以使用 `push()` 在数组末尾添加元素，使用 `shift()` 在数组开头删除元素来实现队列:

  ```js
  let q = []; // q == []
  q.push(1, 2); // q == [1,2]
  g.shift(); // q == [2]，返回 1
  q.push(3); // q == [2, 3]
  q.shift(); // q == [3]，返回 2
  q.shift(); // q == []，返回 3
  ```

  `unshift()` 还有一个特殊特性。在给 `unshift()` 传多个参数时，这些参数会一次性插入数组。这意味着一次插入与多次插入之后的数组顺序不一样。

  ```js
  let a = []; // a == []
  a.unshift(1); // a == [1]
  a.unshift(2); // a == [2, 1]
  a = [];
  a.shift(1, 2); // a = [1, 2]
  ```

#### 7.8.5 使用 `slice()`、`splice()`、`fill()` 和 `copyWithin()`

数组定义了几个处理连续区域（或子数组，或数组“切片”）的方法。

- `slice()`
  `slice()` 方法返回一个数组的切片（slice）或者子数组。这个**方法接收两个参数，分别用于指定要返回切片的起止位置**。返回的数组包含第一个参数指定的元素，以及所有后续元素，直到（但不包含）第二个参数指定的元素。如果只指定一个参数，返回的数组将包含从该起点开始直到数组末尾的所有元素。如果任何一个参数是负值，则这个值相对于数组长度指定数组元素。比如，参数 -1 指定数组的最后一个元素，参数 -2 指定倒数第二个元素。

  > **注意**：`slice()` 不会修改调用它的数组。

  ```js
  let a = [1, 2, 3, 4, 5];
  a.slice(0, 3); // 返回 [1, 2, 3]
  a.slice(3); // 返回 [4, 5]
  a.slice(1, -1); // 返回 [2, 3]
  a.slice(3, -2); // 返回 [3]
  ```

- `splice()`
  `splice()` 是一个对数组进行插入和删除的通用方法。与 `slice()` 和 `concat()` 不同，`splice()` 会修改调用它的数组。

  `splice()` 可以从数组中删除元素，可以向数组中插入新元素，也可以同时执行这两种操作。位于插入点或删除点之后的元素的索引会按照需要增大或减少，从而与数组剩余部分保持连续。**`splice()` 的第一个参数指定插入或删除操作的起点位置。第二个参数指定要从数组中删除（切割出来）的元素个数**。如果省略第二个参数，从起点元素开始的所有数组元素都将被删除。`splice()` 返回被删除元素的数组，如果没有删除元素返回空数组。例如：

  ```js
  let a = [1, 2, 3, 4, 5, 6, 7, 8];
  a.splice(4); // [5, 6, 7, 8]，a 现在是 [1, 2, 3, 4]
  a.splice(1, 2); // [2, 3]，a 现在是 [1, 4]
  a.splice(1, 1); // [4]，a 现在是 [1]
  ```

  **`splice()` 的前两个参数指定要删除哪些元素。这两个参数后面还可以跟任意多个参数，表示要在第一个参数指定的位置插入到数组中的元素**。例如:

  ```js
  let a = [1, 2, 3, 4, 5];
  a.splice(2, 0, 'a', 'b'); // []; a 现在是 [1, 2, "a", "b", 3, 4, 5]
  a.splice(2, 2, [1, 2], 3); // ["a""b"]; a 现在是 [1, 2, [1, 2], 3, 3, 4, 5]
  ```

  > **注意**：与 `concat()` 不同，`splice()` 插入数组本身，而不是数组的元素。

- `fill()`
  `fill()` 方法将数组的元素或切片设置为指定的值。它会修改调用它的数组，也返回修改后的数组:

  ```js
  let a = new Array(5); // 创建一个长度为 5 的没有元素的数组
  a.fill(0); // [0,0,0,0,0]，用 0 填充数组
  a.fill(9, 1); // [0,9,9,9,9]，从索引 1 开始填充 9
  a.fill(8, 2, -1); // [0,9,8,8,9]，在索引 2、3 填充 8
  ```

  **`fill()` 的第一个参数是要把数组元素设置成的值。可选的第二个参数指定起始索引，如果省略则从索引 0 开始填充。可选的第三个参数，指定终止索引，到这个索引为止（但不包含）的数组元素会被填充。如果省略第三个参数，则从起始索引开始一直填充到数组末尾**。与使用 `slice()` 一样，也可以传入负值相对于数组末尾指定索引。

- `copyWithin()`
  `copyWithin()` 把数组切片复制到数组中的新位置。它会就地修改数组并返回修改后的数组，但不会改变数组的长度。**第一个参数指定要把第一个元素复制到的目的索引。第二个参数指定要复制的第一个元素的索引。如果省略第二个参数，则默认值为 0。第三个参数指定要复制的元素切片的终止索引。如果省略，则使用数组的长度。从起始索引到（但不包含）终止索引的元素会被复制**。与使用 `slice()` 一样，也可以传入负值相对于数组末尾指定索引。

  ```js
  let a = [1, 2, 3, 4, 5];
  a.copyWithin(1); // [1,1,2,3,4]：把数组元素复制到索引 1 及之后
  a.copyWithin(2, 3, 5); // [1,1,3,4,4]：把最后两个元素复制到索引 2
  a.copyWithin(0, -2); // [4,4,3,4,4]：负偏移量也可以
  ```

  `copyWithin()` 本意是作为一个高性能方法，尤其对定型数组（参见 11.2<!--TODO--> 节）特别有用。它模仿的是 C 标准库的 `memmove()` 函数。**即使来源和目标区域有重叠，复制也是正确的**。

#### 7.8.6 数组索引与排序方法

数组实现与字符串的同名方法类似的 `indexOf()`、`lastIndexOf()` 和 `includes()` 方法。此外还有 `sort()` 和 `reverse()` 方法用于对数组元素重新排序。

- `indexOf()` 和 `lastIndexOf()`
  `indexOf()` 和 `lastIndexOf()` 从数组中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回 -1。`indexOf()` 从前到后（或从头到尾）搜索数组，而 `lastIndexOf()` 从后向前搜索数组:

  ```js
  let a = [0, 1, 2, 1, 0];
  a.indexOf(1); // 1：a[1] 是 1
  a.lastIndexOf(1); // 3：a[3] 是 1
  a.indexOf(3); // -1：没有元素的值是 3
  ```

  `indexOf()` 和 `lastIndexOf()` 使用 `===` 操作符比较它们的参数和数组元素。如果数组包含对象而非原始值，这些方法检查两个引用是否引用同一个对象。如果想查找对象的内容，可以使用 `find()` 方法并传入自定义的断言函数。

  `indexOf()` 和 `lastIndexOf()` 都接收第二个可选的参数，指定从哪个位置开始搜索。如果省略这个参数，`indexOf()` 会从头开始搜索， `lastIndexOf()` 会从尾开始搜索。第二个参数可以是负值，相对于数组末尾偏移。比如，-1 指定数组的最后一个元素。

  下面这个函数从指定的数组中搜索指定的值，并返回所有匹配元素的索引。这个例子演示了 `indexOf()` 的第二个参数可以用来找到除第一个之外的匹配值：

  ```js
  // 从数组 a 中找到所有值 x，返回匹配索引的数组
  function findall(a, x) {
    let results = [], // 要返回的索引数组
      len = a.length, // 要搜索的数组长度
      pos = 0; // 搜索的起始位置

    while (pos < len) {
      pos = a.indexOf(x, pos); // 搜索
      if (pos === -1) break; // 如果没找到，结束
      results.push(pos); // 否则把索引保存在数组中
      pos = pos + 1; // 从下一个元素开始搜索
    }
    return results; // 返回索引数组
  }
  ```

  > **注意**：字符串也有 `indexOf()` 和 `lastindexOf()` 方法，跟这两个数组方法类似，区别在于第二个参数如果是负值会被当成 0。

- `includes()`
  ES2016 的 `includes()` 方法接收一个参数，如果数组包含该值则返回 true，否则返回 false。`includes()` 方法实际上是测试数组的成员是否属于某个集合。

  > **注意**：数组并非集合的有效表示方式，如果元素数量庞大，应该选择真正的 Set 对象(参见 11.1.1 <!--TODO-->)。

  `includes()` 方法与 `indexOf()` 方法有一个重要区别。`indeOf()` 使用与 `===` 操作符同样的算法测试相等性，而该相等算法将非数值的值看成与其他值都不一样，包括与其自身也不一样。`includes()` 使用稍微不同的相等测试，认为 NaN 与自身相等。这意味着 `indexOf()` 无法检测数组中的 NaN 值，但 `includes()` 可以：

  ```js
  let a = [1, true, 3, NaN];
  a.includes(true); // true
  a.includes(2); // false
  a.includes(NaN); // true
  a.indexOf(NaN); // -1，indexOf 无法找到 NaN
  ```

- `sort()`
  `sort()` 对数组元素就地排序并返回排序后的数组。在不传参调用时，`sort()` 按字母顺序对数组元素排序（如有必要，临时把它们转换为字符串再比较）：

  ```js
  let a = ['banana', 'cherry', 'apple'];
  a.sort(); // a == ["apple", "banana", "cherry"]
  ```

  如果数组包含未定义的元素，它们会被排到数组末尾。

  要对数组元素执行非字母顺序的排序，必须给 `sort()` 传一个比较函数作为参数。这个函数决定它的两个参数哪一个在排序后的数组中应该出现在前面。如果第一个参数应该出现在第二个参数前面，比较函数应该返回一个小于 0 的数值。如果第一个参数应该出现在第二个参数后面，比较函数应该返回一个大于 0 的数值。如果两个值相等（也就是它们的顺序不重要），则比较函数应该返回 0。因此，要对数组元素按照数值而非字母顺序排序，应该这样做：

  ```js
  let a = [33, 4, 1111, 22];
  a.sort(); // a == [1111, 22, 33, 4]，字母顺序
  // 传入一个比较函数
  a.sort(function (a, b) {
    return a - b; // 取决于顺序，返回<0、0 或>0
  }); // a == [4,33,222,1111]，数值顺序
  a.sort((a, b) => b - a); // a == [1111, 222, 33, 4]，相反的数值顺序
  ```

  再来看一个排序数组元素的例子。如果想对字符串数组做不区分大小写的字母序排序，传入的比较函数应该（使用 `toLowerCase()` 方法）将其两个参数都转换为小写，然后再比较：

  ```js
  let a = ['ant', 'Bug', 'cat', 'Dog'];
  a.sort(); // a == ["Bug","Dog","ant","cat"]，区分大小写的排序
  a.sort(function (s, t) {
    let a = s.toLowerCase();
    let b = t.toLowerCase();
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  }); // a == ["ant", "Bug", "cat", "Dog"] 不区分大小写的排序
  ```

- `reverse()`

  `reverse()` 方法反转数组元素的顺序，并返回反序后的数组。这个反序是就地反序，换句话说，不会用重新排序后的元素创建新数组，而是直接对已经存在的数组重新排序:

  ```js
  let a = [1, 2, 3];
  a.reverse(); // a == [3, 2, 1]
  ```

#### 7.8.7 数组到字符串的转换

Array 类定义了 3 个把数组转换为字符串的方法，通常可以用在记录目志或错误消息的时候（如果想把数组的文本内容保存起来以备后用，可以使用 [`JSON.stringify()`](#68-序列化对象)方法对数组执行序列化）。

`join()` 方法把数组的所有元素转换为字符串，然后把它们拼接起来并返回结果字符串。可以指定一个可选的字符串参数，用于分隔结果字符串中的元素。如果不指定分隔符，则默认使用逗号:

```js
let a = [1, 2, 3];
a.join(); // "1,2,3"
a.join(' '); // "1 2 3"
a.join(''); // "123"
let b = new Array(10); // 长度为 10 但没有元素的数组
b.join('-'); // "---------": 包含 9 个连字符的字符串
```

`join()` 方法执行的是 `String.split()` 方法的反向操作，后者通过把字符串分割为多个片段来创建数组与任何 JS 对象一样，数组也有 `toString()` 方法。对于数组而言，这个方法的逻辑与没有参数的 `join()` 方法一样:

```js
[1, 2, 3].toString(); // "1,2,3"
['a', 'b', 'c'].toString(); // "a,b,c"
[1, [2, 'c']].toString(); // "1,2,c"
```

> **注意**：输出中不包含方括号或者数组值的定界符。

`toLocaleString()` 是 `toString()` 的本地化版本。它调用 `toLocaleString()` 方法将每个数组元素转换为字符串，然后再使用（实现定义的）当地分隔符字符串来拼接结果字符串。

#### 7.8.8 静态数组函数

Array 类也定义了 3 个静态函数，可以通过 Array 构造函数而非数组调用。`Array.of()` 和 `Array.from()` 是创建新数组的工厂方法。

另一个静态数组函数是 `Array.isArray()`，用于确定一个未知值是不是数组：

```js
Array.isArray([]); // true
Array.isArray({}); // false
```

### 7.9 类数组对象

JS 数组具有一些其他对象不具备的特殊特性：

- 数组的 `length` 属性会在新元素加入时自动更新
- 设置 `length` 为更小的值会截断数组
- 数组从 Array.prototype 继承有用的方法
- `Array.isArray()` 对数组返回 true

这些特性让 JS 数组与常规对象有了明显区别。但是，这些特性并非定义数组的本质特性。事实上，只要对象有一个数值属性 length，而且有相应的非负整数属性，那就完全可以视同为数组。

实践当中，偶尔会碰到“类数组”对象。虽然不能直接在它们上面调用数组方法或期待 `length` 属性的特殊行为，但仍然可以通过写给真正数组的代码来遍历它们。说到底，就是因为很多数组算法既适用于真正的数组，也适用于类数组对象。特别是在将数组视为只读或者至少不会修改数组长度的情况下，就更是这样了。

下面的代码会为一个常规对象添加属性，让它成为一个类数组对象，然后再遍历得到的伪数组的“元素”：

```js
let a = {}; // 创建一个常规的空对象
// 添加属性让它变成“类数组”对象
let i = 0;
while (i < 10) {
  a[i] = i * i;
  i++;
}
a.length = i;
// 像遍历真正的数组一样遍历这个对象
let total = 0;
for (let j = 0; j < a.length; j++) {
  total += a[j];
}
```

在客户端 JS 中，很多操作 HTML 文档的方法（比如 `document.querySelectorAll()`）都返回类数组对象。下面的函数可以用来测试对象是不是类数组对象:

```js
// 确定 o 是不是类数组对象
// 字符串和函数有数值 length 属性，但是通过
// typeof 测试可以排除。在客户端 JS 中
// DOM 文本节点有数值 length 属性,可能需要加上
// o.nodeType !== 3 测试来排除
function isArrayLike(o) {
  if (
    o && // o 不是 null、 undefined 等假值
    typeof o === 'Object' && // o 是对象
    Number.isFinite(o.length) && // o.length 是有限数值
    o.length >= 0 && // o.length 是非负数组
    Number.isInteger(o.length) && // o.length 是整数
    o.length < 4294967295 // o.length < 2^32 - 1
  ) {
    return true; // 是类数组对象
  } else {
    return false; // 不是类数组对象
  }
}
```

多数 JS 数组方法有意地设计成了泛型方法，因此除了真正的数组，同样也可以用于类数组对象。但由于类数组对象不会继承 Array.prototype，所以无法直接在它们上面调用数组方法。为此，可以使用 `Function.call()` 方法(详见 8.7.4 节<!--TODO-->)来调用:

```js
let a = { 0: 'a', 1: 'b', 2: 'c', length: 3 }; //类数组对象
Array.prototype.join.call(a, '+'); // "a+b+c"
Array.prototype.map.call(a, x => x.toUpperCase()); // ["A", "B", "C"]
Array.prototype.slice.call(a, 0); // ["a", "b", "c"]: 真正的数组副本
Array.from(a); // ["a","b","c"]: 更容易的数组复制
```

倒数第二行代码在类数组对象上调用了 Array 的 `slice()` 方法，把该对象的元素复制到一个真正的数组对象中。在很多遗留代码中这都是常见的习惯做法，但现在使用 `Array.from()` 会更容易。

### 7.10 作为数组的字符串

JS 字符串的行为类似于 UTF-16 Unicode 字符的只读数组。除了使用 `charAt()` 方法访问个别字符，还可以使用方括号语法：

```js
let s = 'test';
s.charAt(0); // "t"
s[1]; // "e"
```

可以通过索引访问字符串的好处，就是可以用方括号代替 `charAt()` 调用，这样更简洁也更容易理解，可能效率也更高。不过，字符串与数组的行为类似也意味着可以对字符串使用泛型的字符串方法。比如：

```js
Array.prototype.join.call('JavaScript', ' '); // "J a v a S c r i p t"
```

> **注意**：字符串是不可修改的值，因此在把它们当成数组来使用时，它们是只读数组。像 `push()`、`sort()`、`reverse()` 和 `splice()` 这些就地修改数组的数组方法，对字符串都不起作用。但尝试用数组方法修改字符串并不会导致错误，只会静默失败。

## 八. 函数

函数是 JS 程序的一个基本组成部分，也是几乎所有编程语言共有的特性。其他语言中所说的子例程（subroutine）或过程（procedure），就是函数。

函数是一个 JS 代码块，定义之后，可以被执行或调用任意多次。**JS 函数是参数化的，即函数定义可以包含一组标识符，称为参数或形参（parameter）**。这些形参类似函数体内定义的局部变量。函数调用会为这些形参提供值或实参（argument）。

函数通常会使用实参的值计算自己的返回值，这个返回值会成为函数调用表达式的值。除了实参，每个调用还有另外一个值，即调用上下文（invocation context），也就是 this 关键字的值。

**如果把函数赋值给一个对象的属性，则可以称其为该对象的方法**。如果函数是在一个对象上被调用或通过一个对象被调用，这个对象就是函数的调用上下文或 this 值。设计用来初始化一个新对象的函数称为构造函数（constructor）。

JS 中的函数是对象，可以通过程序来操控。比如，JS 可以把函数赋值给变量，然后再传递给其他函数。因为函数是对象，所以可以在函数上设置属性，甚至调用函数的方法。

JS 函数可以嵌套定义在其他函数里，内嵌的函数可以访问定义在函数作用域的任何变量。这意味着 JS 函数是闭包（closure），基于闭包可以实现重要且强大的编程技巧。

### 8.1 定义函数

在 JS 中定义函数最直观的方式就是使用 `function` 关键字，这个关键字可以用作声明或表达式。ES6 定义了一种新的方式，可以不通过 `function` 关键字定义函数，即“箭头函数”。箭头函数的语法特别简洁，很适合把函数作为参数传给另一个函数。

在对象字面量和类定义中，有一个定义方法的[快捷语法](#6105-简写方法)。等价于使用函数定义表达式并使用基本的 `name:value` 对象字面量语法，将其赋值给对象的属性。另一种特殊情况是在对象字面量中使用关键字 `get` 和 `set` [定义特殊的获取和设置方法](#6106-属性的获取方法与设置方法访问器属性)。

> **注意**：也可以使用 `Function()` 构造函数定义新函数，而这是 8.7.7 节<!--TODO-->的主题。另外，JS 也定义了一些特殊函数。 `function*` 用于定义生成器函数(参见第 12 章)，而 `async function` 用于定义异步函数(参见第 13 章)<!--TODO-->。

#### 8.1.1 函数声明

函数声明由 `function` 关键字后跟如下组件构成：

- **命名函数的标识符**：这个作为函数名的标识符对于函数声明是必需的，它作为一个变量名使用，新定义的函数对象会赋值给这个变量。

- **一对圆括号，中间包含逗号分隔的零或多个标识符**：这些标识符是函数的参数名，它们就像是函数体内的局部变量。

- **一对花括号，其中包含零或多个 JS 语句**：这些语句构成函数体，会在函数被调用时执行。

下面是几个函数声明的例子：

```js
// 打印对象 o 的每个属性的名字和值。返回 undefined
function printprops(o) {
  for (let p in o) {
    console.log(`${p}: ${o[p]}\n`);
  }
}

// 计算笛卡儿坐标点(x1，y1)和(×2，y2)之间的距离
function distance(x1, y1, X2, y2) {
  let dx = x2 - x1;
  let dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

// 计算阶乘的递归函数(调用自身的函数)
// x! 是 x 与所有小于它的正整数的积。
function factorial(x) {
  if (x <= 1) return 1;
  return x * factorial(x - 1);
}
```

**要理解函数声明，关键是理解函数的名字变成了一个变量，这个变量的值就是函数本身**。函数声明语句会被“提升”到包含脚本、函数或代码块的顶部，因此调用以这种方式定义的函数时，调用代码可以出现在函数定义代码之前。

前面看到的 `distance()` 和 `factorial()` 函数用来执行计算并得到一个值，它们都使用 `return` 把该值返回给调用者。`return` 语句导致函数停止执行并将其表达式（如果有）的值返回给调用者。如果 `return` 语句没有关联的表达式，则函数的返回值是 undefined。

`printprops()` 函数不一样：它的任务是输出对象的属性的名字和值。此时并不需要返回值，而且函数也不包含 `return` 语句。对 `printprops()` 函数调用的值始终是 undefined。如果函数并不包含 `return` 语句，那么就简单地执行函数体内的每个语句，直到最后向调用者返回 undefined。

在 ES6 以前，函数声明只能出现在 JS 文件或其他函数的顶部。虽然有些实现弱化了这个限制，但严格来讲在循环体、条件或其他语句块中定义函数都不合法。不过在 ES6 的严格模式下，函数声明可以出现在语句块中。不过，在语句块中定义的函数只在该块中有定义，对块的外部不可见。

#### 8.1.2 函数表达式

函数表达式看起来很像函数声明，但它们出现在复杂表达式或语句的上下文中，而且函数名是可选的。以下是几个函数表达式的示例:

```js
// 这个函数表达式定义一个对参数求平方的函数
// 注意，把它赋值给了一个变量
const square = function (x) {
  return x * x;
};

// 函数表达式可以包含名字，这对递归有用
const f = function fact(x) {
  if (x <= 1) return 1;
  else return x * fact(x - 1);
}[
  // 函数表达式也可以用作其他函数的参数:
  (3, 2, 1)
].sort(function (a, b) {
  return a - b;
});

// 函数表达式也可以定义完立即调用:
let tensquared = (function (x) {
  return x * x;
})(10);
```

> **注意**：函数名对定义为表达式的函数而言是可选的，前面看到的多数函数表达式都没有名字。函数声明实际上会声明一个变量，然后把函数对象赋值给它。而函数表达式不会声明变量，至于要把新定义的函数赋值给一个常量还是变量都可以，方便多次引用。**最佳实践是使用 `const` 把函数表达式赋值给常量，以防止意外又给它赋新值而重写函数**。

如果需要引用自身，也可以带函数名，比如前面的阶乘函数。如果函数表达式包含名字，则该函数的局部作用域中也会包含一个该名字与函数对象的绑定。实际上，函数名就变成了函数体内的一个局部变量。多数定义为表达式的函数都不需要名字，这让定义更简洁。

**函数表达式与函数声明的重要区别**
在使用声明形式时，先创建好函数对象，然后再运行包含它们的代码，而且函数的定义会被提升到顶部，因此在定义函数的语句之前就可以调用它们。但对于定义为表达式的函数就不一样了，这些函数在定义它们的表达式实际被求值以前是不存在的。不仅如此，要调用函数要求必须可以引用函数，在把函数表达式赋值给变量之前是无法引用函数的，因此定义为表达式的函数不能在它们的定义之前调用。

#### 8.1.3 箭头函数

在 ES6 中，可以使用一种特别简洁的语法来定义函数，叫作“箭头函数”。它使用“箭头”分隔函数的参数和函数体。因为箭头函数是表达式而不是语句，所以不必使用 `function` 关键字，而且也不需要函数名。

箭头函数的一般形式是圆括号中逗号分隔的参数列表，后跟箭头 `=>`，再跟包含在花括号中的函数体：

```js
const sum = (x, y) => {
  return x + y;
};
```

但箭头函数还支持一种更简洁的语法。如果函数体只有一个 `return` 语句，那么可以省略 `return` 关键字、语句末尾的分号以及花括号，将函数体写成一个表达式，它的值将被返回:

```js
const sum = (x, y) => x + y;
```

更进一步，如果箭头函数只有一个参数，也可以省略包围参数列表的圆括号

```js
const polynomial = x => x * x + 2 * x + 3:
```

> **注意**：
>
> 1. 对于没有参数的箭头函数则必须把空圆括号写出来。
> 2. 在写箭头函数时，不能在函数参数和箭头之间放换行符。否则，就会出现类似 `const polynomial = x` 这样的一行代码，而这行代码本身是一条有效的赋值语句。
> 3. 如果箭头函数的函数体是一个 `return` 语句，但要返回的表达式是对象字面量，那必须把这个对象字面量放在一对圆括号中，以避免解释器分不清花括号到底是函数体的花括号，还是对象字面量的花括号。

箭头函数的简洁语法让它们非常适合作为值传给其他函数，而这在使用 `map()`、`filter()` 和 `reduce()` 等[数组方法](#781-数组迭代器方法)时是非常常见的：

```js
// 得到一个过滤掉 null 元素的数组
let filtered = [1, null, 2, 3].filter(x => x !== null); // filtered = [1, 2, 3]

// 求数值的平方
let squares = [1, 2, 3, 4].map(x => x * x); // squares == [1, 4, 9, 16]
```

**箭头函数与其他函数极其重要的区别**
箭头函数从定义自己的环境继承 this 关键字的值，而不是像以其他方式定义的函数那样定义自己的调用上下文。这是箭头函数的一个重要且非常有用的特性。箭头函数与其他函数还有一个区别，就是它们没有 `prototype` 属性。这意味着箭头函数不能作为新类的构造函数(参见 9.2 节<!--TODO-->)。

#### 8.1.4 嵌套函数

在 JS 中，函数可以嵌套在其他函数中。例如：

```js
function hypotenuse(a, b) {
  function square(x) {
    return x * x;
  }

  return Math.sqrt(square(a) + square(b));
}
```

**关于嵌套函数，最重要的是理解它们的变量作用域规则**：它们可以访问包含自己的函数（或更外层函数）的参数和变量。例如，在上面的代码中，内部函数 `square()` 可以读写外部函数 `hypotenuse()` 定义的参数 a 和 b。嵌套函数的这种作用域规则是非常重要的，会在 8.6<!--TODO--> 节再详细解释。

### 8.2 调用函数

构成函数体的 JS 代码不在定义函数的时候执行，而在调用函数的时候执行。JS 函数可以通过 5 种方式来调用:

- 作为函数
- 作为方法
- 作为构造函数
- 通过 `call()` 或 `apply()` 方法间接调用
- 通过 JS 语言特性隐式调用（与常规函数调用不同）

#### 8.2.1 函数调用

函数是通过调用[表达式](#45-逻辑表达式)被作为函数或方法调用的。调用表达式包括求值为函数对象的函数表达式，后跟一对圆括号，圆括号中是逗号分隔的零或多个参数表达式列表。如果函数表达式是属性访问表达式，即函数是对象的属性或数组的元素，那么它是一个方法调用表达式。下面这段代码包含几个常规的函数调用表达式：

```js
printprops({ x: 1 });
let total = distance(0, 0, 2, 1) + distance(2, 1, 3, 5);
let probability = factorial(5) / factorial(13);
```

在一次调用中，每个（位于括号中的）实参表达式都会被求值，求值结果会变成函数的实参。换句话说，这些值会被赋予函数定义中的命名形参。在函数体内，对形参的引用会求值为对应的实参值。

对常规函数调用来说，函数的返回值会变成调用表达式的值。如果函数由于解释器到达末尾而返回，则返回值是 undefined。如果函数由于解释器执行到 `return` 语句而返回，则返回值是 `return` 后面表达式的值；如果 `return` 语句没有值就是 undefined。

对于非严格模式下的函数调用，调用上下文（this 值）是全局对象。但在严格模式下，调用上下文是 undefined。

> **注意**：使用箭头语法定义的函数又有不同：它们总是继承自身定义所在环境的 this 值。

要作为函数（而非方法）来调用的函数通常不会在定义中使用 this 关键字。但是可以在这些函数中使用 this 关键来确定是不是处于严格模式：

```js
// 定义并调用函数，以确定当前是不是严格模式
const strict = (function () {
  return !this;
})();
```

**递归函数与调用栈**
通归函数是调用自己的函数，就像前面的 `factorial()` 函数一样。某些算法，比如涉及与树相关的数据结构的算法，利用递归可以非常简洁地实现。

但在写递归函数时，一定要考虑内存的限制。如果函数 A 调用函数 B，而函数 B 调用函数 C，JS 解释器需要记住全部 3 个函数的执行上下文。当函数 C 完成时，解释器需要知道在哪里恢复函数 B，而当函数 B 完成时，它需要知道在哪里恢复函数 A。可以把这些函数的依次执行想象成一个调用栈。当函数调用另一个函数时，就会有一个新执行上下文被推到这个调用栈上面。如果函数递归调用自身 100 次，那么这个栈上就会被推入 100 个对象，而后这 100 个对象又会被弹出。这个调用栈会占用内存空间。对于现代的硬件能力而言，写一个调用自己几百次的递归函数通常没什么问题。但如果函数调用自己达到上万次，很可能会导致“最大调用栈溢出”（Maximum call-stack size exceeded）错误。

#### 8.2.2 方法调用

**方法其实就是 JS 的函数，只不过它保存为对象的属性而已**。如果有一个函数 f 和一个对象 o，那么可以像这样定义一个方法 `o.m = f;`，对象 o 有了方法 m() 后，就可以这样调用 `o.m()`。如果 m() 期待两个参数，可以这样调用 `o.m(x, y)`。

这个例子中的代码是调用表达式，包括函数表达式 o.m 和两个参数表达式 x 和 y。这个函数表达式本身是个属性访问表达式，这意味着函数在这里是作为方法而非常规函数被调用的。**方法调用的参数和返回值与常规函数调用的处理方式完全一样**。

**方法调用与函数调用有一个重要的区别**
就是调用上下文。属性访问表达式由两部分构成：对象（o）和属性名（m）。在像这样的方法调用表达式中，对象 o 会成为调用上下文，而函数体可以通过关键字 this 引用这个对象。例子:

```js
// 对象字面量
let calculator = {
  operand1: 1,
  operand2: 1,
  // 对这个函数使用了方法简写语法
  add() {
    // 注意这里使用 this 关键字引用了包含对象
    this.result = this.operand1 + this.operand2;
  }
};
calculator.add(); // 方法调用，计算 1+1
calculator.result; // 2
```

多数方法调用使用点号进行属性访问，但使用方括号的属性访问表达式也可以实现方法调用。比如，下面这两个例子都是方法调用:

```js
o['m'](x, y); // 对 o.m(x,y) 的另一种写法
a[0](z); // 也是一种方法调用(假设 a[0] 是函数)
```

方法调用也可能涉及更复杂的属性访问表达式:

```js
customer.surname.toUpperCase(); // 调用 customer.surname 的方法
f().m(); // 在 f()的返回值上调用 m()
```

**方法和 this 关键字是面向对象编程范式的核心**。任何用作方法的函数实际上都会隐式收到一个参数，即调用它的对象。通常，方法会在对象上执行某些操作，而方法调用语法是表达函数操作对象这一事实的直观方式。比如下面这两行代码:

```js
rect.setSize(width, height);
setRectSize(rect, width, height);
```

上面两行代码中的函数是假想的，这两个调用实际上会对（假想的）rect 对象执行相同的操作。但第一行的方法调用语法更清晰地传达出了对象 rect 才是这个操作的焦点。

**方法调用链**
如果方法返回对象，那么基于这个方法调用的返回值还可以继续调用其他方法。这样就会得到表现为一个表达式的一系列方法调用（或方法调用链）。比如，在使用基于期约的异步操作(参见第 13 章<!--TODO-->)时，以下代码结构很常见:

```js
// 依次运行三个异步操作,最后处理错误
doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);
```

如果方法没有自己的返回值，可以考虑让它返回 this。如果能在自己的 API 中统一这么做，那就可以支持一种被称为方法调用链（method channing）的编程风格。这样只要给对象命名，之后就可以连续调用这个对象的方法:

```js
new Square().x(100).y(100).size(50).outline('red').fill('blue').draw();
```

> **注意**：`this` 是个关键字，不是变量也不是属性名。JS 语法不允许给 `this` 赋值。

`this` 关键字不具有变量那样的作用域机制，除了箭头函数，嵌套函数不会继承包含函数的 `this` 值。如果嵌套函数被当作方法来调用，那它的 this 值就是调用它的对象。如果嵌套函数（不是箭头函数）被当作函数来调用，则它的 this 值要么是全局对象（非严格模式），要么是 undefined（严格模式）。

这里有一个常见的错误，就是对于定义在方法中的嵌套函数，如果将其当作函数来调用，以为可以使用 this 获得这个方法的调用上下文。以下代码演示了这个问题:

```js
// 对象 o
let o = {
  // 对象的方法 m
  m: function () {
    let self = this; //把 this 值保存在变量中
    this === o; // true：this 是对象 o
    f(); // 调用嵌套函数 f()
    // 嵌套函数
    function f() {
      this === o; // false：this 是全局对象或 undefined
      self === o; // true：self 是外部的 this 值
    }
  }
};
o.m(); // 在对象 o 上调用方法
```

在嵌套函数 `f()` 内部，`this` 关键字不等于对象 o。这被广泛认为是 JS 语言的一个缺陷，所以了解这个问题很重要。上面的代码演示了一个常见的技巧。在方法 m 中，把 `this` 值赋给变量 self，然后在嵌套函数 f 中，就可以使用 self 而非 this 来引用包含对象。

在 ES6 及之后的版本中，解决这个问题的另一个技巧是把嵌套函数 f 转换为箭头函数，因为箭头函数可以继承 this 值：

```js
const f = () => {
  this === o; // true，因为箭头函数继承 this
};
```

函数表达式不像函数声明语句那样会被提升，因此为了让上面的代码有效，需要将这个函数 f 的定义放到方法 m 中调用函数 f 的代码之前。

还有一个技巧是调用嵌套函数的 `bind()` 方法 8.7.5 节<!--TODO-->，以定义一个在指定对象上被隐式调用的新函数：

```js
const f = function () {
  this === 0; // true，因为把这个函数绑定到了外部的 this
}.bind(this);
```

#### 8.2.3 构造函数调用

如果函数或方法调用前面加了一个关键字 `new`，那它就是构造函数调用。**构造函数调用与常规函数和方法调用的区别在于参数处理、调用上下文和返回值**。

如果构造函数调用在圆括号中包含参数列表，则其中的参数表达式会被求值，并以与函数和方法调用相同的方式传给函数。不过，假如没有参数列表，构造函数调用时其实也可以省略空圆括号。例如：

```js
o = new Object(); // 等价于 new Object
```

构造函数调用会创建一个新的空对象，这个对象继承构造函数的 prototype 属性指定的对象。构造函数就是为初始化对象而设计的，这个新创建的对象会被用作函数的调用上下文，因此在构造函数中可以通过 `this` 关键字引用这个新对象。

> **注意**：即使构造函数调用看起来像方法调用，这个新对象也仍然会被用作调用上下文。换句话说，在表达式 `new o.m()` 中，o 不会用作调用上下文。

构造函数正常情况下不使用 `return` 关键字，而是初始化新对象并在到达函数体末尾时隐式返回这个对象。此时，这个新对象就是构造函数调用表达式的值。但是，如果构造函数显式使用了 `return` 语句返回某个对象，那该对象就会变成调用表达式的值。如果构造函数使用 `return` 但没有返回值，或者返回的是一个原始值，则这个返回值会被忽略，仍然以新创建的对象作为调用表达式的值。

#### 8.2.4 间接调用

JS 函数是对象，与其他 JS 对象一样，JS 函数也有方法。其中有两个方法 [`call()` 和 `apply()`](#874-call-和-apply-方法)，可以用来间接调用函数。这两个方法允许指定调用时的 `this` 值，这意味着可以将任意函数作为任意对象的方法来调用，即使这个函数实际上并不是该对象的方法。

这两个方法都支持指定调用参数。其中，`call()` 方法使用自己的参数列表作为函数的参数，而 `apply()` 方法则期待数组值作为参数。

#### 8.2.5 隐式函数调用

有一些 JS 语言特性看起来不像函数调用，但实际上会导致某些函数被调用。要特别关注会被隐式调用的函数，因为这些函数涉及的 bug、副效应和性能问题都比常规函数更难排查。因为只看代码可能无法知晓什么时候会调用这些函数。

以下是可能导致隐式函数调用的一些语言特性：

- 如果对象有获取方法或设置方法，则[查询或设置其属性值](#6106-属性的获取方法与设置方法访问器属性)可能会调用这些方法。

- 当对象在字符串上下文中使用时（比如当拼接对象与字符串时），会调用对象的 `toString()` 方法。类似地，当对象用于数值上下文时，则会调用它的 `valueOf()`方法。

- 在遍历可迭代对象的元素时，也会涉及一系列方法调用。第 12 章从函数调用层面解释了迭代器的原理，演示了如何写这些方法来定义自己的可迭代类型。<!--TODO-->

- 标签模板字面量是一种伪装的函数调用。14.5 节演示了如何编写与模板字面量配合使用的函数。<!--TODO-->

- 代理对象(参见 14.7 节<!--TODO-->)的行为完全由函数控制。这些对象上的几乎任何操作都会导致一个函数被调用。

### 8.3 函数实参与形参

JS 函数定义不会指定函数形参的类型，函数调用也不对传入的实参进行任何类型检查。事实上，JS 函数调用连传入实参的个数都不检查。

#### 8.3.1 可选形参与默认值

当调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是 undefined。有时候，函数定义也需要声明一些可选参数。例子：

```js
// 把对象的可枚举属性名放到数组 a 中，返回 a
// 如果不传 a，则创建一个新数组
function getPropertyNames(o, a) {
  if (a === undefined) a = []; // 如果是 undefined，创建一个新数组
  for (let property in o) a.push(property);
  return a;
}

// 调用 getPropertyNames() 时可以传一个参数，也可以传两个参数
let o = { x: 1 },
  p = { y: 2, z: 3 }; // 两个用于测试的对象
let a = getPropertyNames(o); // a == ["x"]： o 的属性保存在新数组中
getPropertyNames(p, a); // a = ["x", "y", "z"]：把 p 的属性也放到 a 中
```

这个函数的第一行也可以不使用 if 语句，而是像下面这样约定你成地使用 `||`：

```js
a = a || [];
```

> **注意**：在设置有可选参数的函数时，一定要把可选参数放在参数列表最后，这样在调用时才可以省略。

在 ES6 及更高的版本中，可以在函数形参列表中直接为每个参数定义默认值。语法是在形参名后面加上等于号和默认值，这样在没有给该形参传值时就会使用这个默认值:

```js
// 把对象 o 的可枚举属性名放到数组 a 中，返回 a
// 如果不传 a，则创建一个新数组
function getPropertyNames(o, a = []) {
  for (let property in o) a.push(property);
  return a;
}
```

函数的形参默认值表达式会在函数调用时求值，不会在定义时求值。因此每次调用 `getPropertyNames()` 函数时如果只传一个参数，都创建并传入一个新的空数组法。如果形参默认值是常量（或类似 []、{} 这样的字面量表达式），那函数是最容易理解的。

但这不是必需的，也可以使用变量或函数调用计算形参的默认值。对此有一种有意思的情形，即如果函数有多个形参，则可以使用前面参数的值来定义后面参数的默认值：

```js
// 这个函数返回一个表示矩形尺寸的对象
// 如果只提供 width，则 height 就是它的两倍。
const rectangle = (width, height = width * 2) => ({ width, height });
rectangle(1); // { width: 1, height: 2 }
```

#### 8.3.2 剩余形参与可变长度实参列表

形参默认值可以编写用少于形参个数的实参来调用的函数。剩余形参（restparameter）的作用恰好相反：它能够编写在调用时传入比形参多任意数量的实参的函数。下面是示例函数，接收一个或多个实参，返回其中最大的一个：

```js
function max(first = -Infinity, ...rest) {
  let maxValue = first; //假设第一个参数是最大的
  // 遍历其他参数，寻找更大的数值
  for (let n of rest) {
    if (n > maxValue) maxValue = n;
  }
  // 返回最大的数值
  return maxValue;
}
nax(1, 10, 100, 2, 3, 1000, 4, 5, 6); // 1000
```

剩余形参前面有 3 个点，而且必须是函数声明中最后一个参数。在调用有剩余形参的函数时，传入的实参首先会赋值到非剩余形参，然后所有剩余的实参会保存在一个数组中赋值给剩余形参。最后一点很重要：**在函数体内，剩余形参的值始终是数组。数组有可能为空，但剩余形参永远不可能是 undefined**（相应地，也要记住，永远不要给剩余形参定义默认值，这样既没有用，也不合法）。

类似前面例子中那样可以接收任意数量实参的函数称为可变参数函数（variadicfunction）、可变参数数量函数（variable arity function）或变长函数（vararg function）。“变长函数”，这个称呼可以追溯到 C 编程语言诞生的时期。

> 一定要分清在函数定义中用于定义剩余形参的 `...` 和 8.34 节介绍的扩展操作符，后者可以在函数调用中使用。

#### 8.3.3 Arguments 对象

剩余形参是 ES6 引入 JS 的。在 ES6 之前，变长函数是基于 Arguments 对象实现的。也就是说，在任何函数体内，标识符 `arguments` 引用该次调用的 Arguments 对象。

Arguments 对象是一个[类数组对象](#79-类数组对象)，它允许通过数值而非名字取得传给函数的参数值。例子:

```js
function max(x) {
  let maxValue = -Infinity;
  // 遍历 arguments，查找并记住最大的数值
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > maxValue) maxValue = arguments[i];
  }
  // 返回最大的数值
  return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6); //=>1000
```

**不建议使用 Arguments**
Arguments 对象可以追溯到 JS 诞生之初，也有一些奇怪的历史包袱，导致它效率低且难优化，特别是在非严格模式下。阅读代码的时候，还是可以看到 Arguments 的身影，但**在新写的代码中应该避免使用它**。在重构老代码时，如果碰到了使用 `arguments` 的函数，通常可以将其替换为 `...args` 剩余形参。

由于 Arguments 对象属于历史遗留问题，在严格模式下，`arguments` 会被当成保留字。因此不能用这个名字来声明函数形参或局部变量。

#### 8.3.4 在函数调用中使用扩展操作符

在期待单个值的上下文中，扩展操作符 `...` 用于展开或“扩展”数组（或任何可选代对象，如字符串）的元素，这个操作符同样可以用在函数调用中:

```js
let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers); // -1
```

> **注意**：从求值并产生一个值的角度说，`...` 并不是真正的操作符。应该说，它是一种可以针对数组字面量或函数调用使用的特殊 JS 语法。

如果在函数定义（而非函数调用）时使用同样的 `...` 语法，那么会产生与扩展操作符相反的作用。在函数定义中使用 `...` 可以将多个函数实参收集到一个数组中。剩余形参和扩展操作符经常同时出现，如以下函数所示，它接收一个函数实参并返回该函数的可测量版本，以用于测试：

```js
// 这个函数接收一个函数并返回一个包装后的版本
function timed(f) {
  return function (...args) {
    // 把实参收集到一个剩余形参数组 args 中
    console.log(`Entering function ${f.name}`);
    let startTime = Date.now();
    try {
      // 把收集到的实参传给包装后的函数a
      return f(...args); // 把 args 扩展回原来的形式
    } finally {
      // 在返回被包装的返回值之前，打印经过的时间
      console.log(`Exiting ${f.name} after ${Date.now() - startTime}ms`);
    }
  };
}

// 以简单粗暴的方式计算 1 到 n 的数值之和
function benchmark(n) {
  let sum = 0;
  for (let i = 1; i < n; i++) sum += i;
  return sum;
}

// 调用测试函数的计时版
timed(benchmark)(100000); // 50005000，这是数值之和
```

#### 8.3.5 把函数实参解构为形参

调用函数时如果传入一个实参列表，则所有参数值都会被赋给函数定义时声明的形参。函数调用的这个初始化阶段非常类似变量赋值。因此对于函数使用解构赋值技术并不奇怪。

如果定义了一个函数，它的形参名包含在方括号中，那说明这个函数期待对每对方括号都传入一个数组值。作为调用过程的一部分，传入的数组实参会被解构赋值为单独的命名形参。

例如，假设要用数组来表示两个数值的 2D 向量，数组的第一个元素是 X 坐标，第二个元素是 Y 坐标。基于这个简单的数据结构，可以像下面这样写一个把它们相加的函数：

```js
function vectorAdd(vl, v2) {
  return [v1[0] + v2[0], v1[1] + v2[1]];
}
vectorEd([1, 2], [3, 4]); // [4, 6]
```

如果换成把两个向量实参解构为命名更清晰的形参，以上代码就更好理解了：

```js
// 把2个实参解构赋值为4个形参
function vectorAdde([x1, y1], [x2, y2]) {
  return [x1 + x2, y1 + y2];
}
vectorAdde([1, 2], [3, 4]); // [4,6]
```

类似地，如果定义的函数需要一个对象实参，也可以把传入的对象解构赋值给形参。以前面的向量计算为例，但这次假设传入一个有 x 和 y 参数的对象：

```js
// 用标量乘以向量 {x, y}
function vectorMultiply({ x, y }, scalar) {
  return { x: x * scalar, y: y * scalar };
}
vectorMultiply({ x: 1, y: 2 }, 2); // {x: 2, y: 4}
```

这个例子把一个对象实参解构为两个形参，由于形参名与对象的属性名一致，所以相当清晰。但是，如果需要把解构的属性赋值给不同的名字，那代码会更长也更不好理解。

下面是一个向量加法的例子，用基于对象的向量实现：

```js
function vectorAdd(
  { x: x1, y: y1 }, // 把第一个对象展开为 x1 和 y1
  { x: x2, y: y2 } // 把第二个对象展开为 x2 和 y2
) {
  return { x: x1 + x2, y: y1 + y2 };
}
vectorAdd({ x: 1, y: 2 }, { x: 3, y: 4 }); // {x: 4, y: 6}
```

对于像 `{x:x1, y:y1}` 这样的解构语法，关键是记住哪些是属性名，哪些是实参名。无论是解构赋值还是解构函数调用，要记住的是声明的变量或参数都位于对象字面量中待值的位置。因此，属性名始终在冒号左侧，而形参名则在冒号右侧。

在解构赋值中也可以为形参定义默认值。下面是针对 2D 或 3D 向量乘法的例子:

```js
// 用标量乘以向量 {x,y} 或 {x,y,z}
function vectorMuLtiply({ x, y, z = 0 }, scalar) {
  return { x: x * scalar, y: y * scaLar, z: z * scalar };
}
vectorMultiply({ x: 1, y: 2 }); // {x: 2, y: 4, z:0}
```

有些语言（如 Python）允许函数的调用者在调用函数时使用 `name=value` 的形式指定实参，在可选参数很多或参数列表太长无法记住顺序时这种方式是有用的。JS 不直接支持这种调用方式，但可以通过把对象参数解构为函数参数来模拟。比如，一个函数从指定数组中把指定个数的元素复制到另一个数组中，参数中可选地指定每个数组的起始索引值。此时至少涉及 5 个参数，其中有的有默认值，而调用者又很难记住这些参数的顺序。为此可以像下面这样定义 `arraycopy()` 函数：

```js
function arraycopy({ from, to = from, n = from.length, fromIndex = 0, toIndex = 0 }) {
  let valuesToCopy = from.slice(fromIndex, fromIndex + n);
  to.splice(toIndex, 0, ...valuesToCopy);
  return to;
}

let a = [1, 2, 3, 4, 5],
  b = [9, 8, 7, 6, 5];
arraycopy({ form: a, n: 3, to: b, toIndex: 4 }); // [9,8,7,6,1,2,3,5]
```

解构数组时，可以为被展开数组中的额外元素定义一个剩余形参。位于方括号中的剩余形参与函数真正的剩余形参完全不同：

```js
// 这个函数期待一个数组参数。数组的前两个元素
// 会展开赋值给 X 和 y，而剩下的所有元素则保存在
// coords 数组中。第一个数组之后的参数则会保存
// 到 rest 数组中
function f([x, y, ...coords], ...rest) {
  return [x + y, ...rest, ...coords]; // 注意: 这里是扩展操作符
}

f([1, 2, 3, 4], 5, 6); // [3, 5, 6, 3, 4]
```

在 ES2018 中，解构对象时也可以使用剩余形参。此时剩余形参的值是一个对象，包含所有未被解构的属性。对象剩余形参经常与对象扩展操作一起使用，后者也是 ES2018 中新增的特性：

```js
// 用标量乘以向量 {x,y} 或 {x,y,z}，其他属性保持不变
function vectorMultiply({ x, y, z = 0, ...props }, scalar) {
  return { x: x * scalar, y: y * scalar, z: z * scalar, ...props };
}
vectorMultiply({ x: 1, y: 2, w: -1 }, 2); // { x: 2, y:4, z:0, w:-1 }
```

**除了解构作为参数的对象和数组，也可以解构对象的数组、有数组属性的对象，以及有对象属性的对象，无论层级多深**。比如，有关图形的代码中，圆形可以表示为包含 x、y、 radius 和 color 属性的对象，其中 color 属性本身是一个包含红、绿、蓝组件的数组。那么定义的函数可以只接收一个圆形对象，但可以将该对象解构为 6 个具体的参数:

```js
function drawCircle({x, y, radius, color: [r, g,b]) {
  // 未实现
}
```

如果函数参数解构的复杂程度超过了这个示例，代码会变得更难理解，而不是更容易理解。有时，通过对象属性和数组索引来获取值反倒更清晰。

#### 8.3.6 参数类型

JS 方法的参数没有预定义的类型，在调用传参时也没有类型检查。可以用描述性强的名字作为函数参数，同时通过在注释中解释函数的参数来解决这个问题（此外，可以选择 17.8 节介绍的一种语言扩展，在 JS 之上引入类型检查能力）。

JS 会按需执行任意的类型转换。因此如果函数接收字符串参数，而调用时传的是其他类型的值，则这个值在函数想把它当成字符串使用时，会尝试将它转换为字符串。所有原始类型的值都可以转换为字符串，所有对象都有
`toString()` 方法（尽管有些不一定真正有用），因此这种情况下永远不会出错。

不过也并非没有例外。仍以前面的 `arraycopy()` 方法为例。该方法期待一个或多个数组参数，如果参数类型不对就会失败。除非写的是个私有函数，只会在自己的代码内部调用，否则就必须增加像下面这样用于检查参数类型的代码。**对函数来说,在发现传入的值不对时立即失败，一定好过先执行逻辑再以出错告终，而且前者比后者更清晰**。下面看一个执行类型检查的函数示例:

```js
// 返回可迭代对象 a 中所有元素之和。
// a 的元素必须全部是数值。
function sum(a) {
  let total = 0;
  // 如果 a 不是可迭代对象则抛出 TypeError
  for (let element of a) {
    if (typeof element !== 'number') {
      throw new TypeError('sum(): elements must be numbers');
    }
    total += element;
  }
  return total;
}
sum([1, 2, 3]); // 6
sm(1, 2, 3); // !TypeError：1不是可迭代对象
sun([1, 2, '3']); // !TypeError：元素 2 不是数值
```

### 8.4 函数作为值

**函数最重要的特性在于可以定义和调用它们**。函数定义和调用是 JS 和大多数语言的语法特性。但**在 JS 中，函数不仅是语法，也是值**。这意味着可以把函数赋值给变量、保存为对象的属性或者数组的元素、作为参数传给其他函数，等等。

要理解函数既是 JS 数据又是 JS 语法到底意味着什么，可以看看下面的例子：

```js
function square(x) {
  return x * x;
}
```

这个定义创建了一个新函数对象并把它赋值给变量 square。函数的名字其实不重要，因为它就是引用函数对象的一个变量名。把函数赋值给另一个变量同样可以调用：

```js
let s = square; // s 也引用了与 square 相同的函数对象
square(4); // 16
```

除了变量，也可以把函数赋值给对象的属性：

```js
let o = {
  square: function (x) {
    return x * x;
  }
}; // 对象字面量
let y = o.square(16); // y == 256
```

函数甚至可以没有名字，比如可以把匿名函数作为一个数组元素：

```js
let a = [x => x * x, 20]; // 数组字面量
a[0](a[1]); // 400
```

为了更好地理解把函数作为值有多大用处，可以想一想 `Array.sort()` 方法。这个方法可以对数组元素进行排序。因为可能的排序方式有很多种（按数值排序、按字母排序、按日期排序,还有升序、降序，等等），所以 `sort()` 方法可选地接收一个函数作为参数，并根据这个函数的返回值决定如何排序。

这个函数的任务非常简单：对于传给它的两个值，它要返回一个表示哪个值在排序后的数组中排在前面的值。这个函数参数让 `Array.sort()` 变得非常通用，而且无比灵活。可以通过它把任何类型的数据按照任何可以想象出来的方式进行排序。

```js
// 这里定义了几个简单的函数
function add(x, y) {
  return x + y;
}
function subtract(x, y) {
  return x - y;
}
function multiply(x, y) {
  return x * y;
}
function divide(x, y) {
  return x / y;
}

// 这个函数接收前面定义的任意一个函数
// 作为参数，然后再用两个操作数调用它
function operate(operator, operand1, operand2) {
  return operator(operand1, operand2);
}

// 可以像这样调用这个函数，计算 (2+3) + (4*5) 的值
let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));

// 为演示方便,我们又一次实现了这些简单的函数
// 这次把它们放到了对象字面量中
const operators = {
  add: (x, y) => x + y,
  subtract: (x, y) => x - y,
  multiply: (x, y) => x * y,
  divide: (x, y) => x / y,
  pow: Math.pow // 预定义的函数也没问题
};

// 这个函数只接收操作的名字，然后在对象中查询
// 这个名字，然后再使用传入的操作数调用它
// 注意这里调用操作函数的语法
function operate(operation, operand1, operand2) {
  if (typeof operators[operation] === 'function') {
    return operators[operation](operand1, operand2);
  } else throw 'unknown operator';
}

operate('add', 'hello', operate2('add', ' ', 'world')); // "hello world"
operate2('pow', 10, 2); //100
```

#### 8.4.1 定义自己的函数属性

函数在 JS 中并不是原始值，而是一种特殊的对象。这意味着函数也可以有属性。如果一个函数需要一个“静态”变量，且这个变量的值需要在函数每次调用时都能访问到，则通常把这个变量定义为函数自身的一个属性。

比如，假设要写一个每次调用都返回唯一整数的函数，那么每次调用都不能返回相同的值。为保证这一点，函数需要记录自己已经返回过的值，这个信息必须在每次调用时都能访问到。可以把这个信息保存一个全局变量中，但其实没有这个必要，因为这个信息只有函数自己会用到。**更好的方式是把这个信息保存在函数对象的一个属性中**。下面就是一个每次调用都返回唯一整数值的函数实现：

```js
// 初始化函数对象的计数器（counter）属性
// 函数声明会被提升，因此可以在函数声明之前在这里就给它赋值
uniqueInteger.counter = 0;

// 这个函数每次被调用时都返回一个不同的整数
// 它使用自身的属性记住下一个要返回什么值
function uniqueInteger() {
  return uniqueInteger.counter++;
}
uniqueInteger(); // 0
uniqueInteger(); // 1
```

再看一个例子，下面的 `factorial()` 函数使用了自身的属性来缓存之前计算的结果（函数将自身作为一个数组）：

```js
// 计算阶乘并把结果缓存到函数本身的属性中
function factorial(n) {
  // 仅限于正整数
  if (Number.isInteger(n) && n > 0) {
    // 如果没有缓存的结果
    if (!(n in factorial)) {
      factorial[n] = n * factorial(n - 1); // 计算并缓存这个结果
    }
    return factorial[n]; // 返回缓存的结果
  } else {
    return NaN;
  }
}

factorial[1] = 1; // 初始化缓存，保存最基础的值
factorial(6); // 720
factorial[4]; // 24 上面的调用缓存了这个值
```

### 8.5 函数作为命名空间

在函数体内声明的变量在函数外部不可见。为此，有时候可以把函数用作临时的命名空间，这样可以保证在其中定义的变量不会污染全局命名空间。

假设有一段 JS 代码，想在几个不同的 JS 程序中使用它（或在客户端 JS 中，在不同网页中使用它）。再假设这段代码跟多数代码一样定义了存储中间计算结果的变量。问题来了：这段代码可能被很多程序用到，不知道那些程序创建的变量会不会跟这段代码中的变量冲突。解决方案就是把这段代码放到一个函数中，然后调用这个函数。这样，原本可能会定义在全局的变量就变成函数的局部变量了:

```js
function chunkNamespace() {
  // 要复用的代码放在这里
  // 在这里定义的任何变量都是函数的局部变量，
  // 不会污染全局命名空间
}
chunkNamespace(); // 别忘了调用这个函数
```

以上代码只定义了一个全局变量，即函数 chunkNamespace。如果就连定义一个属性也嫌多，那可以在一个表达式中定义并调用匿名函数

```js
(function () {
  // 将 chunkNamespacer() 函数重写为一个无名表达式
  // 要复用的代码放在这里
})(); // 函数定义结束后立即调用它
```

在一个表达式中定义并调用匿名函数的技术非常常用，因此甚至有了别称，叫“**立即调用函数表达式**”（immediately invoked function expression）。

> **注意**：前面代码中括号的使用。位于 `function` 关键字前面的左开括号是必需的，因为如果没有它，JS 解释器会把 `function` 关键字作为函数声明语句来解析。有了这对括号，解释器会把它正确地
> 识别为函数定义表达式。而且开头的括号也便于程序员知道这是个定义后立即调用的函数，而不是为后面使用定义的函数。

函数作为命名空间真正的用武之地，还是**在命名空间中定义一个或多个函数，而这些函数又使用该命名空间中的变量，最后这些函数又作为命名空间函数的返回值从内部传递出来。类似这样的函数被称为闭包（closure）**。

### 8.6 闭包

与多数现代编程语言一样，JS 使用词法作用域（lexical scoping）。这意味着函数执行时使用的是定义函数时生效的变量作用域，而不是调用函数时生效的变量作用域。

为了实现词法作用域，JS 函数对象的内部状态不仅要包括函数代码，还要包括对函数定义所在作用域的引用。这种函数对象与作用域（即一组变量绑定）组合起来解析函数变量的机制，在计算机科学文献中被称作闭包（closure）。

严格来讲，所有 JS 函数都是闭包。但由于多数函数调用与函数定义都在同作用域内，所以闭包的存在无关紧要。**闭包真正值得关注的时候，是定义函数与调用函数的作用域不同的时候**。最常见的情形就是一个函数返回了在它内部定义的嵌套函数。很多强大的编程技术都是建立在这种嵌套函数闭包之上的，因此嵌套函数闭包在 JS 程序中也变得比较常见。

要理解闭包，第一步需要先回顾嵌套函数的词法作用域规则。来看下面的代码:

```js
let scope = 'global scope'; // 全局变量

function checkscope() {
  let scope = 'local scope'; // 局部变量
  function f() {
    return scope; // 返回当前作用域中的值
  }
  return f();
}
checkscope(); // "local scope"
```

`checkscope()` 函数声明了一个局部变量，然后定义了一个返回该变量的值的函数并调用了该函数。很显然，调用 `checkscope()` 应该返回 "local scope"。现在，稍微改一改代码：

```js
let scope = 'global scope'; // 全局变量
function checkscope() {
  let scope = 'local scope'; // 局部变量
  function f() {
    return scope;
  } // 返回当前作用域中的值
  return f;
}
let s = checkscope()(); // 'local scope'
```

在上面的代码中，把 `checkscope()` 中的一对圆括号转移到了外部。转移前调用的是嵌套函数并返回结果，而现在 `checkscope()` 返回的是嵌套函数。

JS 词法作用域的基本规则是：JS 函数是使用定义它们的作用域来执行的。在定义嵌套函数 `f()` 的作用域中，变量 scope 绑定的值是 "local scope"，该绑定在 f 执行时仍然有效，无论它在哪里执行。因此前面代码示例最后一行返回 "local scope"，而非"global scope"。

这正是**闭包惊人且强大的本质：它们会捕获自身定义所在外部函数的局部变量（及参数）绑定**。

在前面定义了一个 [`uniqueInteger()`](#841-定义自己的函数属性) 函数，该函数使用一个函数自身的属性来跟踪要返回的下一个值。该方式有一个缺点，就是容易被错误或恶意代码重置计数器，或者把计数器设置为非整数，导致 `uniqueInteger()` 函数违反自己契约的“唯一”（unique）或“整数”（Integer）规则。

闭包可以捕获一次函数调用的局部变量，可以将这些变量作为私有状态。为此，可以像下面这样改写 `uniqueInteger()` 函数，使用立即调用函数表达式定义一个命名空间，再通过一个闭包利用该命名空间来保证自己的状态私有:

```js
// 定义并调用
let uniqueInteger = (function () {
  let counter = 0; //下面函数的私有状态
  return function () {
    return counter++;
  };
})();
uniqueInteger(); // 0
uniqueInteger(); // 1
```

乍一看，第一行代码像一条赋值语句，把一个函数赋值给变量 uniqueInteger。实际上，这行代码定义并调用了一个函数，因此真正赋给 uniqueInteger 的是这个函数的返回值。再仔细看一下函数体，会发现它的返回值是另一个函数。换句话说，这个嵌套的函数最终被赋值给了 uniqueInteger。这个嵌套函数有权访问其作用域中的变量，而且可以使用定义在外部函数中的变量 counter。

外部函数一旦返回，就没有别的代码能够看到变量 counter 了，此时内部函数拥有对它的专有访问权。类似 counter 这样的私有变量并非只能由一个闭包独享。同一个外部函数中完全可以定义两个或更多嵌套函数，而它们共享相同的作用域。来看下面的代码:

```js
function counter() {
  let n = 0;
  return {
    count: function () {
      return n++;
    },
    reset: function () {
      n = 0;
    }
  };
}

let c = counter(),
  d = counter(); // 创建两个计数器

c.count(); // 0
d.count(); // 0 它们分别计数
c.reset(); // reset()和 count() 方法共享状态
c.count(); // 0: 因为重置了c
d.count(); // 1
```

这个 `counter()` 函数返回一个“计数器”对象。该对象有两个方法: `count()` 和 `reset()`。前者返回下一个整数,后者重置内部状态。首先要理解的是，这两个方法都有权访问私有变量 n。其次是要知道，每次调用 `counter()` 都会创建一个新作用域（与之前调用创建的作用域相互独立），还有作用中域中的一个新私有变量。

因此如果调用两次 `counter()`，就会得到拥有两个不同私有变量的计数器对象。在一个计数器上调用 `count()` 或 `reset()` 不会影响另一个计数器。可以将这种闭包技术与属性获取方法和设置方法组合使用。

```js
// 函数参数 n 是私有变量
function counter(n) {
  return {
    // 属性获取方法，返回递增后的私有计数器值
    get count() {
      return n++;
    },
    // 属性设置方法，不允许 n 的值减少
    set count(m) {
      if (m > n) n = m;
      else throw Error('count can only be set to a larger value');
    }
  };
}

let c = counter(1000);
c.count; // 1000
c.count; // 1001
c.count = 2000;
c.count; // 2000
c.count = 2000; // 错误: 计数只能设置为更大的数
```

> **注意**：`counter()` 函数没有声明局部变量，只使用自己的参数 n 保存供属性访问器方法共享的私有状态。这样可以让 `counter()` 的调用者指定私有变量的初始值。

下面的示例，基于闭包技术实现了一个通用的共享私有状态的函数。例子中的函数 `addPrivateProperty()` 定义了一个私有变量和两个分别用于获取和设置该变量值的嵌套函数，而且将这两个嵌套函数作为方法添加到了调用时指定的对象：

```js
// 使用闭包的私有属性访问器方法
// 这个函数按照指定的名字为对象 o 添加属性访问器方法
// 方法命名为 get<name> 和 set<name>
// 如果提供断言（predicate）函数，则设置方法用它测试自己的参数，在存储前先验证
// 如果断言返回 false，则设置方法抛出异常

// 操作的值并没有保存在对象 o 上，而是保存在了这个函数的一个局部变量中。
// 获取方法和设置方法也是在函数局部定义的，因而可以访问这个局部变量。这意味着该变量对两个访问器方法而言是私有的
// 除了设置方法,没有别的途径可以设置或修改这个变量的值
function addPrivateProperty(o, name, predicate) {
  let value; // 这是属性值

  // 获取方法简单地返回属性值
  o[`get${name}`] = function () {
    return value;
  };

  // 设置方法保存值或在断言失败时抛出异常
  o[`set${name}`] = function (v) {
    if (predicate && !predicate(v)) {
      throw new TypeError(`set${name}: invalid value ${v}`);
    } else {
      value = v;
    }
  };
}

// 下面的代码演示了如何使用 addPrivateProperty()方法
let o = {}; // 先创建一个空对象

// 添加属性访问器方法 getName()和 setName()
// 确保只能设置字符串值
addPrivateProperty(o, 'Name', X => typeof x === 'string');
o.setName('Frank'); // 设置属性的值
o.getName(); // "Frank"
o.setName(0); // !TypeError：尝试设置一个错误类型的值
```

前面的几个例子都是在相同作用域中定义两个闭包，共享访问相同的私有变量或变量。这个技术很重要，但同样重要的是应该知道什么情况下闭包会意外地共享访问不该被共享的变量。比如下面的代码:

```js
// 这个函数返回一个始终返回 v 的函数
function constfunc(v) {
  return () => v;
}

// 创建一个常量函数的数组
let funcs = [];
for (var i = 0; i < 10; i++) funcs[i] = constfunc(i);
// 索引 5 对应的函数返回数值 5
funcs[5](); // 5
```

在编写这种使用循环创建多个闭包的代码时，一个常见的错误是把循环转移到定义闭包的函数中。比如下面的代码：

```js
// 返回一个函数数组，其中的函数返回数值 0-9
function constfuncs() {
  let funcs = [];
  for (var i = 0; i < 10; i++) {
    funs[i] = () => i;
    return funcs;
  }
}

let funcs = constfuncs();
funcs[5](); // 10; 为什么这时候不返回 5?
```

以上代码创建了 10 个闭包并将它们保存在一个数组中。而闭包全部是在同一个函数调用中定义的，因此它们可以共享访问变量 i。当 `constfuncs()` 返回后，变量 i 的值是 10，全部 10 个闭包共享这个值。因此，返回的函数数组中的所有函数都返回相同的值。

这绝对不是想要的结果。关键是要记住，与闭包关联的作用域是“活的”。**嵌套函数不会创建作用域的私有副本或截取变量绑定的静态快照**。从根本上说，这里的问题在于通过 var 声明的变量在整个函数作用域内都有定义。

代码中的 for 循环使用 var 声明循环变量，因此变量 i 的作用域是整个函数体，而不是更小的循环体。这段代码演示了 ES5 及之前版本代码中常见的一类错误，而 ES6 增加的块级作用域变量解决了这个问题。只要把这里的 var 替换成 let 或 const，问题马上就会消失。因为 let 和 const 是块级作用域的标志，这意味着每次循环都会定义一个与其他循环不同的独立作用域，而每个作用域中都有自己独立的 i 绑定。

> **注意**：在写闭包的时候，`this` 是 JS 关键字，不是变量。箭头函数继承包含它们的函数中的 this 值，但使用 function 定义的函数并非如此。因此如果要写的闭包需要使用其包含函数的 this 值，那应该在返回闭包之前使用箭头函数或调用 `bind()`，也可把外部的 this 值赋给闭包将继承的变量:
>
> ```js
> const self = this; // 让嵌套函数可以访问外部的 this 值
> ```

### 8.7 函数属性、方法与构造函数

函数在 JS 中也是一种值。对函数使用 `typeof` 操作符会返回字符串 "function"，但函数实际上是一种特殊的 JS 对象。由于函数是对象，因此它们也有属性和方法。甚至还有一个 `Function()` 构造函数可以用来创建新函数对象。

#### 8.7.1 length 属性

**函数有一个只读的 `length` 属性，表示函数的元数（arity），即函数在参数列表中声明的形参个数**。这个值通常表示调用函数时应该传入的参数个数。如果函数有剩余形参，则这个剩余形参不包含在 length 属性内。

#### 8.7.2 name 属性

函数有一个只读的 `name` 属性，表示定义函数时使用的名字（如果是用名字定义的），如果是未命名的函数，表示在第一次创建这个函数时赋给该函数的变量名或属性名。这个属性**主要用于记录调试或排错消息**。

#### 8.7.3 prototype 属性

除了箭头函数，所有函数都有一个 `prototype` 属性，这个属性引用一个被称为[原型对象](#623-原型)的对象。每个函数都有自己的原型对象。当函数被作为构造函数使用时，新创建的对象从这个原型对象继承属性。

#### 8.7.4 call() 和 apply() 方法

`call()` 和 `apply()` 允许[间接调用](#824-间接调用)一个函数，就像这个函数是某个其他对象的方法一样。`call()` 和 `apply()` 的第一个参数都是要在其上调用这个函数的对象，也就是函数的调用上下文，在函数体内它会变成 this 关键字的值。要把函数 f() 作为对象的方法进行调用（不传参数），可以使用 `call()` 或 `apply()`:

```js
f.call(o);
f.apply(o);
```

这两行代码都类似于下面的代码（假设 o 并没有属性 m）：

```js
o.m = f; // 把 f 作为 o 的一个临时方法
o.m(); // 调用它，不传参数
delete o.m; // 删除这个临时方法
```

箭头函数从定义它的上下文中继承 this 值。这个 this 值不能通过 `call()` 和 `apply()` 方法重写。**如果对箭头函数调用这两个方法，那第一个参数实际上会被忽略**。

除了作为调用上下文传给 `call()` 的第一参数，后续的所有参数都会传给被调用的函数（调用箭头函数时不会忽略这些参数）。比如，要将函数 f() 作为对象 o 的方法进行调用，并同时给函数 f() 传两个参数，可以这样写：

```js
f call(o, 1, 2);
```

`apply()` 方法与 `call()` 方法类似，只不过要传给函数的参数需要以数组的形式提供:

```js
f.apply(o, [1, 2]);
```

如果函数定义时可以接收任意多个参数，则使用 `apply()` 方法可以在调用这个函数时把任意长度的数组内容传给它。在 ES6 及之后的版本中可以使用扩展操作符，但也有可能看到使用 `apply()` 的 ES5 代码。

例如，在不使用扩展操作符的情况下，想找到一个数值数组中的最大值，可以使用 `apply()` 方法把数组的元素传给 `Math.max()` 函数:

```js
let biggest = Math.max.apply(Math, arrayOfNumbers);
```

用与包装方法（新方法）相同的参数和 this 值调用被包装的方法（原始方法）:

```js
// 将对象 o 的方法 m 替换成另一个版本,
// 新版本在调用原始方法前、后会打印日志
function trace(o, m) {
  let original = o[m]; // 在闭包中记住原始方法
  // 定义新方法
  o[m] = function (...args) {
    console.log(new Date(), 'Entering: ', m); // 打印消息
    let result = original.apply(this, args); // 调用原始方法
    console.log(new Date(), 'Exiting: ', m); // 打印消息
    return result; // 返回结果
  };
}
```

#### 8.7.5 bind() 方法

**`bind()` 方法的主要目的是把函数绑定到对象**。如果在函数 f 上调用 `bind()` 方法并传入对象 o，则这个方法会返回一个新函数。如果作为函数来调用这个新函数，就会像 f 是 o 的方法一样调用原始函数。传给这个新函数的所有参数都会传给原始函数。例如:

```js
function f(y) {
  return this.x + y; // 这个函数需要绑定
}

let o = { x: 1 }; // 要绑定的对象
let g = f.bind(o); // 调用 g(x) 会在 o 上调用 f()
g(2); // 3
let p = { x: 10, g }; //作为这个对象的方法调用 g()
p.g(2); // 3: g 仍然绑定到 o，而非 p
```

箭头函数从定义它们的环境中继承 this 值，且这个值不能被 `bind()` 覆盖，因此如果前面代码中的函数 f() 是以箭头函数定义的，则绑定不会起作用。不过，由于**调用 `bind()` 最常见的目的是让非箭头函数变得像箭头函数**，因此这个关于绑定箭头函数的限制在实践中通常不是问题。

事实上，除了把函数绑定到对象，`bind()` 方法还会做其他事。比如，`bind()` 也可以执行“部分应用”，即在第一个参数之后传给 `bind()` 的参数也会随着 this 值一起被绑定。

部分应用是函数式编程中的一个常用技术，有时候也被称为柯里化（currying）。下面是几个使用 `bind()` 方法实现部分应用的例子:

```js
let sum = (x, y) => x + y; // 返回 2 个参数之和
let succ = sum.bind(null, 1); // 把第一个参数绑定为 1
succ(2); // 3: x 绑定到 1，2 会传给参数 y

function f(y, z) {
  return this.x + y + z;
}
let g = f.bind({ x: 1 }, 2); // 绑定 this 和 y
g(3); // 6: this.x 绑定到 1，y 绑定到 2，z 是 3
g.name; // "bound f"
```

> `bind()` 返回函数的 `name` 属性由单词 "bound" 和调用 `bind()` 的函数的 `name` 属性构成。

#### 8.7.6 tostring()方法

与所有 JS 对象一样，函数也有 `toString()` 方法。ECMAScript 规范要求这个方法返回一个符合函数声明语句的字符串。实践中，这个方法的多数实现都返回函数完整的源代码。内置函数返回的字符串中通常包含 "[native code]"，表示函数体。

#### 8.7.7 Function() 构造函数

因为函数是对象，所以就有一个 `Function()` 构造函数可以用来创建新函数:

```js
const f = new Function('x', 'y', 'return x*y');
```

上面的代码创建了一个新函数，差不多相当于使用如下语法定义的函数：

```js
const f = function (x, y) {
  return x * y;
};
```

`Function()` 构造函数可以接收任意多个字符串参数，其中最后一个参数是函数体的文本。这个函数体文本中可以包含任意 JS 语句，相互以分号分隔。传给这个构造函数的其他字符串都用于指定新函数的参数名。如果新函数没有参数，可以只给构造函数传一个字符串（也就是函数体）。

> **注意**：`Function()` 构造函数不接收任何指定新函数名字的参数。与函数字面量一样，`Function()` 构造函数创建的也是匿名函数。

要理解 `Function()` 构造函数，需要理解以下几点：

- `Function()` 函数允许在运行时动态创建和编译 JS 函数。

- `Function()` 构造函数每次被调用时都会解析函数体并创建一个新函数对象。如果在循环中或者被频繁调用的函数中出现了对它的调用，可能会影响程序性能。相对而言，出现在循环中的嵌套函数和函数表达式不会每次都被重新编译。

- 最后，也是关于 `Function()` 非常重要的一点，就是它创建的函数不使用词法作用域，而是始终编译为如同顶级函数一样，如下所示:

  ```js
  let scope = 'global';
  function constructFunction() {
    let scope = 'local';
    return new Function('return scope'); // 不会捕获局部作用域
  }
  // 这行代码返回 "global"，因为 Function()
  // 构造函数返回的函数不使用局部作用域。
  constructFunction()(); // "global"
  ```

> 最好将 `Function()` 构造函数作为在自己私有作用域中定义新变量和函数的 `eval()` 的全局作用域版。自己写的代码中可能永远也用不到这个构造函数。

### 8.8 函数式编程

JS 并不是 Lisp 或 Haskell 那样的函数式编程语言，但 JS 可以把函数作为对象来操作意味着可以在 JS 中使用函数式编程技巧。像 `map()` 和 `reduce()` 这样的数组方法就特别适合函数式编程风格。

#### 8.8.1 使用函数处理数组

假设有一个数值数组，希望计算这些数值的平均值和标准差。如果使用非函数式风格的代码，可能会这样写

```js
let data = [1, 1, 3, 5, 5]; // 这是数值数组

// 平均值等于所有元素之和除以元素个数
let total = 0;
for (let i = 0; i < data.length; i++) total += data[i];
let mean = total / data.length; // mean == 3，平均值为 3

// 要计算标准差，首先要计算每个元素
// 相对于平均值偏差的平方
total = 0;
for (let i = 0; i < data.length; i++) {
  let deviation = data[i] - mean;
  total += deviation * deviation;
}
let stddev = Math.sqrt(total / (data.length - 1)); // stddev == 2
```

而使用数组方法 `map()` 和 `reduce()`，可以像下面这样以简洁的函数式风格实现同样的计算:

```js
// 首先，定义两个简单的函数
const sum = (x, y) => x + y;
const square = x => x * x;

// 然后，使用数组方法计算平均值和标准差
let data = [1, 1, 3, 5, 5];
let mean = data.reduce(sum) / data.length; // mean == 3
let deviations = data.map(x => x - mean);
let stddev = Math.sqrt(deviations.map(square).reduce(sum) / (data.length - 1));
stddev; // 2
```

新版本的代码看起来与第一个版本差别很大，但仍然调用对象上的方法，因此还可以看出一些面向对象的痕迹。下面再来定义 `map()` 和 `reduce()` 方法的函数版:

```js
const map = function (a, ...args) {
  return a.map(...args);
};
const reduce = function (a, ...args) {
  return a.reduce(...args);
};
```

定义了 `map()` 和 `reduce()` 函数后，计算平均值和标准差的的代码就变成这样了:

```js
const sum = (x, y) => x + y;
const square = x => x * x;

let data = [1, 1, 3, 5, 5];
let mean = reduce(data, sum) / data.length;
let deviations = map(data, x => x - mean);
let stddev = Math.sqrt(reduce(map(deviations, square), sum) / (data.length - 1));
stddev; // 2
```

#### 8.8.2 高阶函数

高阶函数就是操作函数的函数，它接收一个或多个函数作为参数并返回一个新函数。例如:

```js
// 这个高阶函数返回一个新函数
// 新函数把参数传给 f 并返回 f 返回值的逻辑非
function not(f) {
  // 返回一个新函数
  return function (...args) {
    let result = f.apply(this, args); // 新函数调用 f
    return result; // 对结果求逻辑非
  };
}
const even = x => x % 2 === 0; // 确定数值是不是偶数的函数
const odd = not(even); // 确定数值是不是奇数的新函数
[1, 1, 3, 5, 5].every(odd); // true: 数组的所有元素都是奇数
```

下面的 `mapper()` 函数接收一个函数参数并返回一个新函数，新函数使用传入的函数把一个数组映射为另一个数组。这个函数使用了前面定义的 `map()` 函数，理解这两个函数之间的区别非常重要:

```js
// 返回一个函数，这个函数接收一个数组并对每个元素应用 f，返回每个返回值的数组
function mapper(f) {
  return a => map(a, f);
}
const increment = x => x + 1;
const incrementAll = mapper(increment);
incrementAll([1, 2, 3]); // [2,3,4]
```

下面是一个更通用的例子，这个高阶函数接收两个函数 f 和 g，返回一个计算 `f(g())` 的新函数：

```js
// 返回一个计算 f(g(...))的新函数
// 返回的函数 h 会把它接收的所有参数传给 g
// 再把 g 的返回值传给 f，然后返回 f 的返回值
// f 和 g 被调用时都使用与 h 被调用时相同的 this 值
function compose(f, g) {
  return function (...args) {
    // 这里对 f 使用 call 是因为只给它传一个值,
    // 而对 g 使用 apply 是因为正在传一个值的数组
    return f.call(this, g.apply(this, args));
  };
}

const sum = (x, y) => x + y;
const square = x => x * x;
compose(square, sum)(2, 3); // 25，平方和
```

#### 8.8.3 函数的部分应用

函数 f 的 `bind()` 方法返回一个新函数，这个新函数在指定的上下文中以指定的参数调用 f。可以说它把这个函数绑定到了一个对象并部分应用了参数。`bind()` 方法在左侧部分应用参数，即传给 `bind()` 的参数会放在传给原始函数的参数列表的开头。但是也有可能在右侧部分应用参数:

```js
// 传给这个函数的参数会传到左侧
function partialLeft(f, ...outerArgs) {
  // 返回这个函数
  return function (...innerArgs) {
    let args = [...outerArgs, ...innerArgs]; // 构建参数列表
    return f.apply(this, args); // 然后通过它调用 f
  };
}

// 传给这个函数的参数会传到右侧
function partialRight(f, ...outerArgs) {
  // 返回这个函数
  return function (...innerArgs) {
    let args = [...innerArgs, ...outerArgs]; //构建参数列表
    return f.apply(this, args); // 然后通过它调用 f
  };
}

// 这个函数的参数列表作为一个模板。这个参数列表中的 undefined 值会被来自内部参数列表的值填充
function partial(f, ...outerArgs) {
  return function (...innerArgs) {
    let args = [...outerArgs]; // 外部参数模板的局部副本
    let innerIndex = 0; // 下一个是哪个内部参数
    // 循环遍历 args，用内部参数填充 undefined 值
    for (let i = 0; i < args.length; i++) {
      if (args[i] === undefined) args[i] = innerArgs[innerIndex++];
      // 现在把剩余的内部参数都加进来
    }
    args.push(...innerArgs.slice(innerIndex));
    return f.apply(this, args);
  };
}

// 下面是有 3 个参数的函数
const f = function (x, y, z) {
  return x * (y - z);
};
// 注意这3个部分应用的区别
partialLeft(f, 2)(3, 4); // -2：绑定第一个参数: 2 * (3 - 4)
partialRight(f, 2)(3, 4); // 6：绑定最后一个参数: 3 * (4 - 2)
partial(f, undefined, 2)(3, 4); // -6：绑定中间的参数: 3 * (2 - 4)
```

这些部分应用函数允许在已经定义的函数基础上轻松定义有意思的函数。下面是几个例子

```js
const increment = partialLeft(sum, 1);
const cuberoot = partialRight(Math.pow, 1 / 3);
cuberoot(increment(26)); // 3
```

部分应用的函数如果与其他高阶函数组合会更有意思。例如，下面的代码通过组合与部分应用定义 `not()` 函数：

```js
const not = partialLeft(compose, x => !x);
const even = x => x % 2 === 0;
const odd = not(even);
const isNumber = not(isNaN);
odd(3) && isNumber(2); // true
```

还可以使用组合和部分应用以函数方式重新计算平均值和标准差：

```js
// sun() 和 square() 函数在前面定义过。下面是更多函数
const product = (x, y) => x * y;
const neg = partial(product, -1);
const sqrt = partia(Math.pow, undefined, 0.5);
const reciprocal = partial(Math.pow, undefined, neg(1));

// 现在计算平均值和标准差
let data = [1, 1, 3, 5, 5];
let mean = product(reduce(data, sum), reciprocal(data.length));
let stddev = sqrt(
  product(
    reduce(map(data, compose(square, partial(sum, neg(mean)))), sum),
    reciprocal(sum(data.length, neg(1)))
  )
);

[mean, stddev]; // [3, 2]
```

> **注意**：这里计算平均值和标准差的代码完全是函数调用，没有操作符，圆括号的数量已经多到让 JS 看起来像 Lisp 了。这并不是推荐的 JS 编程风格。但通过这个例子可以知道 JS 中的函数如何实现多层嵌套。

#### 8.8.4 函数记忆

在前面[函数属性](#841-定义自己的函数属性)定义了一个缓存自己之前计算结果的阶乘函数。在函数式编程中，这种缓存被称为函数记忆（memoization）。下面的代码展示了高阶函数 `memoize()` 可以接收一个函数参数，然后返回这个函数的记忆版:

```js
// 返回 f 的记忆版
// 只适用于 f 的参数都有完全不同的字符串表示的情况
function memoize(f) {
  const cache = new Map(); // cache 保存在这个闭包中

  return function (...args) {
    // 创建参数的字符串版，以用作缓存键
    let key = args.length + args.join('+');
    if (cache.has(key)) {
      return cache.get(key);
    } else {
      let result = f.apply(this, args);
      cache.set(key, result);
      return result;
    }
  };
}
```

这个 `memoize()` 函数创建了一个新对象作为缓存使用，并将这个对象赋值给一个局部变量，从而让它（在闭包中）成为被返回的函数的私有变量。返回的函数将其参数数组转换为字符串，并使用该字符串作为缓存对象的属性。如果缓存存在某个值，就直接返回该值;否则，就调用指定的函数计算这些参数的值，然后缓存这个值，最后返回这个值。

下面是使用 `memoRize()` 的例子：

```js
// 使用欧几里德算法返回两个整数的最大公约数
// http://en.wikipedia.org/wiki/euclideanalgorithm
// 省略了对 a 和 b 的类型检查
function gcd(a, b) {
  // 开始时保证 a ≥ b
  if (a < b) {
    [a, b] = [b, a]; // 用解构赋值交换变量
  }
  // 这是求最大公约数的欧几里德算法
  while (b !== 0) {
    [a, b] = [b, a % b];
  }
  return a;
}

const gcdmemo = memoize(gcd);
gcdmemo(85, 187); // 17

// 注意，在编写需要记忆的递归函数时，通常希望递归记忆版，而非原始版
const factorial = memoize(function (n) {
  return n <= 1 ? 1 : n * factorial(n - 1);
});

factorial(5); // 120:也为 4、3、2 和 1 缓存了值
```

## 九. 类

JS 对象是一种独特的属性集合，每个对象都不一样。然而，多个对象经常需要共享一些属性，此时可以为这些对象定义一个类。这个类的成员或实例，各自拥有属性来保存或定义自己的状态，但也有方法定义它们的行为。

这些方法是由类定义且由所有实例共享的。想象有一个 Complex 类，表示和执行复数的计算。Complex 的实例会有属性保存复数的实数和虚数部分（状态）。同时 Complex 类也会定义对这些数执行加法和乘法操作（行为）的方法。

**在 JS 中，类使用基于原型的继承。如果两个对象从同一个原型继承属性（通常是以函数作为值的属性，或者方法），那说这些对象是同一个类的实例。简言之，这就是 JS 类原理**。

如果两个对象继承同一个原型，通常（但不必定）意味着它们是通过同一个构造函数或工厂函数创建和初始化的。JS 一直允许定义类。ES6 新增了相关语法（包括 `class` 关键字）让创建类更容易。通过新语法创建的 JS 类与老式的类原理相同。

JS 类与 Java 或 C++ 等强类型面向对象语言的类非常不一样。虽然语法上有些类似，JS 也可以模拟一些“经典的”类特性，但最重要的是要明白：**JS 的类和基于原型的继承机制与 Java 等语言中类和基于类的继承机制有着本质区别**。

### 9.1 类和原形

**在 JS 中，类意味着一组对象从同一个原型对象继承属性。因此，原型对象是类的核心特征**。`Object.create()` 函数用于创建一个新对象，这个新对象继承指定的原型对象。如果定义了一个原型对象，然后使用 `Object.create()` 创建一个继承它的对象，那就定义了一个 JS 类。

通常，一个类的实例需要进一步初始化，因此常见的做法是定义一个函数来创建和初始化新对象。示例 9-1 演示了这个过程，它为一个表示数值范围的类定义了一个原型对象，同时也定义了一个工厂函数用于创建和初始化该类的新实例：

```js
// 示例 9-1: 一个简单的 JS 类
// 这个工厂函数返回一个新范围对象
function range(from, to) {
  // 使用 Object.create() 创建一个对象，继承下面定义的原型对象。
  // 这个原型对象保存为这个函数的一个属性，为所有范围对象定义共享方法(行为)
  let r = Object.create(range.methods);

  // 保存新范围对象的起点和终点(状态)，这些属性不是继承的，是当前对象独有的
  r.from = from;
  r.to = to;
  // 最后返回新对象
  return r;
}

// 这个原型对象定义由所有范围对象继承的方法
range.methods = {
  // 如果 x 在范围内则返回 true，否则返回 false
  // 这个方法适用于文本、日期和数值范围
  includes(x) {
    return this.from <= x && x <= this.to;
  },

  // 这个生成器函数让这个类的实例可迭代
  // 注意：只适用于数值范围
  *[Symbol.iterator]() {
    for (let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  },
  // 返回范围的字符串表示
  toString() {
    return '(' + this.from + '...' + this.to + ')';
  }
};

// 下面是使用范围对象的示例
let r = range(1, 3); // 创建一个范围对象
r.includes(2); // true：2 在范围内
r.toString(); // "(1...3)"
[...r]; // [1, 2, 3]; 通过迭代器转换为数组
```

以上示例中有几个方面需要注意:

- 这段代码定义了一个工厂函数 `range()`，用于创建新的 Range 对象。

- 它使用 `range()` 函数的 methods 属性保存定义这个类的原型对象。把原型对象放在这里没有什么特别的，也不是习惯写法。

- 这个 `range()` 函数为每个 Range 对象定义 `from` 和 `to` 属性。这两个属性是非共享、非继承属性，定义每个范围对象独有的状态。

- `range.methods` 对象使用了 ES6 定义方法的[简写语法](#6105-简写方法)，所以没有出现 function 关键字。

- 原型的方法中有一个是[计算的名字](#6102-计算的属性名) `Symbol.iterator`，这意味着它为 Range 对象定义了一个迭代器。这个方法的名字前面有一个星号 `*`，表示它是一个生成器函数，而非普通函数。迭代器和生成器在第 12 章介绍。现在只要知道这个 Range 类的实例可以与 for/of 循环和扩展操作符一起使用就可以了

- 定义在 `range.methods` 中的共享方法都会用到在 `range()` 工厂函数中初始化的 `from` 和 `to` 属性，它们通过 this 关键字引用调用它们的对象。**使用 this 是所有类方法的基本特征**。

### 9.2 类和构造函数

例 9-1 展示了一种定义 JS 类的简单方式。不过，这种方式并非习惯写法，因为它没有定义构造函数。构造函数是一种专门用于初始化新对象的函数。

**构造函数要使用 `new` 关键字调用**。使用 `new` 调用构造函数会自动创建新对象，因此构造函数本身只需要初始化新对象的状态。构造函数调用的关键在于构造函数的 prototype 属性将被用作新对象的原型。

几乎所有对象都有原型，但只有函数对象才有 `prototype` 属性。这意味着使用同一个构造函数创建的所有对象都继承同一个对象，因而是同一个类的成
员。

示例 9-2 展示了如何修改示例 9-1 中的 Range 类来使用构造函数而非工厂函数。示例 9-2 演示了在不支持 ES6 `class` 关键字的 JS 版本中创建类的习惯做法。虽然 `class` 目前已经得到全面支持，但仍有很多老 JS 代码是以这种方式来定义类的。同时也理解在使用 `class` 关键字时“底层”都发生了什么：

```js
// 示例 9-2：使用构造函数的 Range 类
// 这是用来初始化新 Range 对象的构造函数
// 注意它不创建或返回对象，只初始化 this
function Range(from, to) {
  // 保存新范围对象的起点和终点(状态)
  // 这些属性不是继承的,是当前对象独有的
  this.from = from;
  this.to = to;
}

// 所有 Range对象都继承这个对象
// 注意这个属性必须命名为 prototype 才行
Range.prototype = {
  // 如果 x 在范围内则返回 true，否则返回 false
  // 这个方法适用于文本、日期和数值范围
  includes: function (x) {
    return this.from <= x && x <= this.to;
  },

  // 这个生成器函数让这个类的实例可迭代
  // 注意:只适用于数值范围
  [Symbol.iterator]: function* () {
    for (let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  },

  // 返回范围的字符串表示
  toString: function () {
    return '(' + this.from + '...' + this.to + ')';
  }
};

// 下面是使用这个新 Range类的示例
let r = new Range(1, 3); // 创建一个 Range对象
r.includes(2); // true：2在范围内
r.toString(); // "(1...3)"
[...r]; // [1,2,3]; 通过迭代器转换为数组
```

比较示例 9-1 和示例 9-2，观察这两种定义类的方式之间的区别：

- 首先，`range()` 工厂函数在转换为构造函数时被重命名为了 `Range()`。这是一个非常常见的编码约定。因为构造函数在某种意义上是定义类的，而**类名（按照惯例）应以大写字母开头。普通函数和方法的名字则以小写字母开头**。

- 其次，`Range()` 构造函数是以 `new` 关键字调用的，而 `range()` 工厂函数被调用时没有这个关键字。示例 9-1 使用普通函数调用创建新对象，而示例 9-2 使用构造函数调用创建新对象。

  因为 `Range()` 构造函数是通过 `new` 调用的，所以它没有调用 `Object.create()`，也没有执行任何创建对象的操作。新对象是在调用构造函数之前自动创建的，可以通过 `this` 来访问。`Range()` 构造函数仅仅需要初始化 this。构造函数甚至不需要返回新创建的对象，它的调用会自动创建新对象，并将构造函数作为该对象的方法来调用，然后返回新对象。

  构造函数调用与普通函数调用的这个重要区别也是用首字母大写的名字命名构造函数的一个原因。构造函数在编写时就会考虑它会作为构造函数以 `new` 关键字来调用，因此把它们当成普通函数来调用通常会有问题。这个命名约定让构造函数有别于普通函数，方便知道什么时候使用 `new`。

- 另一个**关键区别是命名原型对象的方式**。在第一个示例中，原型是 `range.methods`。这是一个方便且好懂的名字，但太随意。在第二个示例中，原型是 `Range.prototype`，这个名字是强制性的。对构造函数 `Range()` 的调用会自动把 `Range.prototype` 作为新 Range 对象的原型。

- 最后，要注意示例 9-1 和示例 9-2 相比没有变化的部分，两个类的范围相关方法是以相同方式定义和调用的。因为示例 9-2 演示了 JS 在 ES6 之前创建类的习惯做法，所以原型对象中没有使用 ES6 简写语法定义方法，而是明确使用了 `function` 关键字。但那些方法的实现在两个示例中都是一样的。

- 还有一点很重要，就是这两个范围类的示例都没使用箭头函数定义构造函数或方法，**用箭头函数方式定义的函数没有 prototype 属性，因此不能作为构造函数使用**。而且，箭头函数中的 this 是从定义它们的上下文继承的，不会根据调用它们的对象来动态设置。这样定义的方法就不能用了，因为方法的典型特点就是使用 this 引用调用它们的实例。

> **注意**：ES6 新增的类语法不允许使用箭头函数定义方法。

**构造函数和 `new.target`**
在函数体内，可以通过一个特殊表达式 `new.target` 判断函数是否作为构造函数被调用了。如果该表达式的值有定义，就说明函数是作为构造函数，通过 `new` 关键字调用的。在 9.5<!--TODO--> 节讨论子类时，会看到 `new.target` 并非一直引用它所在的构造函数，也可能引用子类的构造函数。

如果 `new.target` 是 undefined，那么包含函数就是作为普通函数被调用的，没有使用 `new` 关键字。JS 的各种错误构造函数可以不使用 new 调用，如果想在构造函数中模拟这个特性，可以像下面这样编码:

```js
function C() {
  if (!new.target) return new C();
  // 这里是初始化代码
}
```

> 这个技术只适用于以这种老方式定义的构造函数。使用 `class` 关键字创建的类不允许不使用 new 调用它们的构造函数。

#### 9.2.1 构造函数、类标识和 instanceof

如前所见，原型对象是类标识的基本：当且仅当两个对象继承同一个原型对象时，它们才是同一个类的实例。初始化新对象状态的构造函数不是基本标识，因为两个构造函数的 prototype 属性可能指向同一个原型对象，此时两个构造函数都可以用于创建同一个类的实例。

虽然构造函数不像原型那么基本，但构造函数充当类的外在表现。最明显的，构造函数的名字通常都用作类名。例如，`Range()` 构造函数可以创建 Range 对象。但更根本的问题在于，在使用 `instanceof` 操作符测试类的成员关系时，构造函数是其右操作数。如果想测试对象 r 是不是 Range 对象：

```js
r instanceof Range; // true：继承了 Range.prototype
```

`instanceof` 操作符，其左操作数应该是要检测的对象，右操作数应该是代表某个类的构造函数。对于表达式 `o instanceof c`，如果 o 继承 c.prototype，则表达式求值为 true。这里的继承不一定是直接继承，如果 o 继承的对象继承了 c.prototype，这个表达式仍然求值为 true。

严格来讲，对于前面的表达式，`instanceof` 操作符并非检查 r 是否通过 Range 构造函数初始化，而是检查 r 是否继承 `Range.prototype`。如果定义了一个函数 `Strange()`，并将其 prototype 属性设置为等于 Range.prototype，那么 instanceof 操作符也会将 `new Strange()` 创建的对象判定为 Range 对象（尽管它们不能像真正的 Range 对象一样工作，因为它们的 from 和 to 属性都没有初始化）:

```js
function Strange() {}
Strange.prototype = Range.prototype;
new Strange() instanceof Range; // true
```

虽然 `instanceof` 不能验证使用的是哪个构造函数，但它仍然以构造函数作为其右操作数，因为构造函数是类的公共标识。

如果不想以构造函数作为媒介，直接测试某个对象原型链中是否包含指定原型，可以使用 `isPrototypeof()` 方法。例如在示例 9-1 中，定义类时没有使用构造函数，因而无法对这个类使用 `instanceof` 操作符。此时，可以通过如下代码检测对象 r 是不是这个无构造函数类的成员

```js
range.methods.isPrototypeof(r); // range.methods 是 r 的原型对象
```

#### 9.2.2 constructor 属性

在示例 9-2 中，把 `Range.prototype` 设置为一个新对象，其中包含类的方法。尽管把方法定义为对象字面量的属性很便捷，但实际上没有必要创建一个新对象。

任何普通 JS 函数（不包括箭头函数、生成器函数和异步函数）都可以用作构造函数，而构造函数调用需要一个 prototype 属性。为此，每个普通 JS 函数自动拥有一个 prototype 属性。这个属性的值是一个对象，有一个不可枚举的 constructor 属性。而这个 constructor 属性的值就是该函数对象:

```js
let F = function () {}; // 这是一个函数对象
let p = F.prototype; // 这是一个与 F 关联的原型对象
let c = p.constructor; // 这是与原型关联的函数
c === F; // true：对任何 F，F.prototype.constructor === F
```

这个预定义对象及其 constructor 属性的存在，意味着对象也会继承一个引用其构造函数的 constructor 属性。因为构造函数充当类的公共标识，所以这个 constructor 属性返回对象的类:

```js
let o = new F(); // 创建类 F 的对象 o
o.constructor === F; // true：constructor 属性指定类
```

图 9-1 直观地展示了构造函数、其原型对象、原型对构造函数的反向引用，以及通过该构造函数创建的实例之间的关系：

![9-1](./image/9-1.jpg)

> **注意**：图 9-1 使用了 `Range()` 构造函数作为示例。但实际上，例 9.2 定义的 Range 类用自己的对象重写了预定义的 `Range.prototype` 对象。而它定义的这个新的原型对象并没有 constructor 属性。所以按照定义， Range 类的实例都没有 constructor 属性。这个问题可以通过显式地为原型添加一个 constructor 属性来解决。
>
> ```js
> Range.prototype = {
>   constructor: Range // 显式设置反向引用 constructor
>   /*以下是方法定义*/
> };
> ```

另一个在老代码中常见的技术是使用预定义的原型对象及其 constructor 属性，然后像下面这样每次给它添加一个方法：

```js
// 扩展预定义的 Range.prototype 对象，不重写自动创建的 Range.prototype.constructor 属性
Range.prototype.includes = function (x) {
  return this.from <= x && x <= this.to;
};

Range.prototype.toString = function () {
  return '(' + this.from + '...' + this.to + ')';
};
```

### 9.3 使用 class 关键字的类

JS 在它最初的版本就支持类，只不过自 ES6 引入 `class` 关键字才有了自己的语法。示例 9-3 展示了以这种新语法重写的 Range 类。

```js
// 示例 9-3：使用 class 重写的 Range 类
class Range {
  constructor(from, to) {
    // 保存新范围对象的起点和终点（状态）
    // 这些属性不是继承的，是当前对象独有的
    this.from = from;
    this.to = to;
  }

  // 如果 x 在范围内则返回 true，否则返回 false
  // 这个方法适用于文本、日期和数值范围
  includes(x) {
    return this.from <= x && x <= this.to;
  }

  // 这个生成器函数让这个类的实例可迭代
  // 注意：只适用于数值范围
  *[Symbol.iterator]() {
    for (let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  }

  // 返回范围的字符串表示
  toString() {
    return `(${this.from}...${this.to})`;
  }
}

// 下面是使用这个新 Range 类的示例
let r = new Range(1, 3); // 创建一个 Range 对象
r.includes(2); // true：2 在范围内
r.toString(); // "(1...3)"
[...r]; // [1, 2, 3]; 通过迭代器转换为数组
```

示例 9-2 和示例 9-3 中定义的类工作方式完全一样，理解这一点非常重要。新增 `class` 关键字并未改变 JS 类基于原型的本质。虽然示例 9-3 使用了 `class` 关键字，但得到的 Range 对象是一个构造函数，与示例 9-2 定义的版本一样。新的 `class` 语法虽然明确、方便，但最好把它看成示例 9-2 中更基础的类定义机制的“语法糖”

对于示例 9-3 展示的类语法，需要注意以下几点:

- 类是以 `class` 关键字声明的，后面跟着类名和花括号中的类体。

- 类体包含使用对象字面量方法简写形式（示例 9-1 中使用过）定义的方法，因此省略了 function 关键字。但与对象字面量不同的是方法之间没有逗号（尽管类体与对象字面量表面上相似，但它们不是一回事。特别地，类体中不支持名/值对形式的属性定义）。

- 关键字 `constructor` 用于定义类的构造函数。但实际定义的函数并不叫 “constructor”。class 声明语句会定义一个新变量 Range，并将这个特殊构造函数的值赋给该变量。

- 如果类不需要任何初始化，可以省略 `constructor` 关键字及其方法体，解释器隐式创建一个空构造函数。

如果想定义一个继承另一个类（或作为另一个类子类）的类，可以使用 `extends` 关键字和 `class` 关键字:

```js
// Span 与 Range 相似，但初始化使用的不是起点和终点，而是起点和长度。
class Span extends Range {
  constructor(start, length) {
    if (length > 0) {
      super(start, start + length);
    } else {
      super(start + length, start);
    }
  }
}
```

与函数定义类似，类声明也有语句和表达式两种形式。可以像这样声明类:

```js
let Square = class {
  constructor(x) {
    this.area = x * x;
  }
};
new Square(3).area; // 9
```

**与函数定义表达式一样，类定义表达式也可以包含可选的类名。如果提供了名字，则该名字只能在类体内部访问到**。虽然函数表达式很常见（特别是箭头函数简写形式），但在 JS 编程中，除非需要写一个以类作为参数且返回其子类的函数，否则类定义表达式并不常用。

#### 9.3.1 静态方法

在 class 体中，把 `static` 关键字放在方法声明前面可以定义静态方法。静态方法是作为构造函数而非原型对象的属性定义的。

例如，假设在示例 9-3 中添加如下代码:

```js
static parse(s) {
  let matches = s.match(/^\((\d+)\.\.\.(\d+)\)$/);

  if(!matches) {
    throw new TypeError(`Cannot parse Range from "${s}".`);
  }
  return new Range(parseInt(matches[1]), parseInt(matches[2]));
}
```

这段代码定义的方法是 `Range.parse()`，而非 `Range.prototype.parse()`，必须通过构造函数而非实例调用它：

```js
let r = Range.parse('(1...10)'); // 返回一个新 Range 对象
r.parse('(1...10)'); // TypeError：r.parse 不是一个函数
```

有人也把静态方法称为类方法，因为它们要通过类（构造函数）名调用。这么叫是为了区分类方法和在类实例上调用的普通实例方法。**由于静态方法是在构造函数而非实例上调用的，所以在静态方法中使用 this 关键字没什么意义**。

#### 9.3.2 获取方法、设置方法及其他形式的方法

在 class 体内，可以像在对象字面量中一样定义[获取方法和设置方法](#6106-属性的获取方法与设置方法访问器属性)。唯一的区别是类体内的获取方法和设置方法后面不加逗号。示例 9-4 展示了如何在类中定义获取方法。

一般来说，对象字面量支持的所有简写的方法定义语法都可以在类体中使用。这包括生成器方法（带`*`）和名字为方括号中表达式值的方法。

#### 9.3.3 公有、私有和静态字段

**ES6 标准只允许创建方法（包括获取方法、设置方法和生成器）和静态方法，还没有定义字段的语法**。如果想在类实例上定义字段（这只是面向对象的“属性”的同义词），必须在构造函数或某个方法中定义。如果想定义类的静态字段，必须在类体之外，在定义类之后定义。示例 9-4 中也包含这两种字段的示例。

不过，扩展类语法以支持定义实例和静态字段的标准化过程还在继续。本节后面展示的代码在 2020 年初还不是标准 JS 写法，但 Chrome 已经支持，Firefox 已经部分支持了（仅公有实例字段）。

假设写了一个类似下面的类，使用构造函数初始了 3 个字段：

```js
class Buffer {
  constructor() {
    this.size = 0;
    this.capacity = 4096;
    this.buffer = new Uint8Array(this.capacity);
  }
}
```

**可能会被标准化的新实例字段语法**
如果使用将来可能会被标准化的新实例字段语法，那可以这样写:

```js
class Buffer {
  size = 0;
  capacity = 4096;
  buffer = new Uint8Array(this.capacity);
}
```

也就是说，字段初始化的代码从构造函数中挪了出来，直接写在了类体内（当然，这些代码仍然作为构造函数的一部分运行。如果没有定义构造函数，这些字段则作为隐式创建的构造函数的一部分被初始化）。

> **注意**：虽然赋值语句左操作数中的 `this.` 前缀已经不见了，但要引用这些字段仍然要加上 `this.`，即便是在初始化赋值的右操作数中。**使用这种语法初始化实例字段的好处是可以把初始化代码放到类定义的顶部（但不是必需的)**，让读者对实例都有哪些字段一目了然。声明字段时也可以不初始化，只写字段名和分号。这样一来，字段的初始值就是 undefined。不过更好的做法是始终给所有类字段赋一个初始值。

在不使用这种字段语法的情况下，类体看起来非常像使用简写方法语法的对象字面量（除了没有逗号）。这种字段语法（等号和分号，而不是冒号加逗号）使得类体更明确地区别于对象字面量。

**可能会被标准化的私有实例字段**
试图标准化这些实例字段的同一提案也定义了私有实例字段。如果像前面示例中那样使用实例字段初始化语法，但字段名前面加上 `#`（通常不是合法的 JS 标识符字符），则该字段就只能在类体中（带着 `#` 前缀）使用，对类体外部的任何代码都不可见、不可访问（因而无法修改）。对于前面假想的 Buffer 类，如果想确保类用户不会意外修改实例的 size 字段，可以使用私有的 #size 字段，然后定义一个获取函数，只允许读取该字段的值:

```js
class Buffer {
  #size = 0;
  get size() {
    return this.#size;
  }
}
```

> **注意**：私有字段必须先使用这种语法声明才能使用。换句话说，如果没有直接在类体中“声明” `#size` 字段，就不能在类的构造函数中写 `this.#size = 0;`。

**在字段前使用 `static` 关键字标准化的提案**
最后，还有一个相关提案希望将在字段前使用 `static` 关键字标准化。根据这份提案，如果在公有或私有字段声明前加上 `static`，这些字段就会被创建为构造函数的属性，而非实例属性。以前面创建的静态 `Range.parse()` 方法为例，其中定义了一个相当复杂的正则表达式。如果把这个正则表达式提炼为一个静态字段会更有利于维护。使用新的静态字段语法，可以这样写：

```JS
static integerRangePattern = /^\((\d+)\.\.\.(\d+)\)$/;
static parse(s) {
  let matches = s.match(Range.integerRangePattern);

  if(!matches) {
    throw new TypeError(`Cannot parse Range from "${s}".`);
  }
  return new Range(parseInt(matches[1]), parseInt(matches[2]));
}
```

如果想让这个字段只能在类内部访问，可以使用类似 `#pattern` 的名字把它变成私有静态字段。

#### 9.3.4 示例:复数类

示例 9-4 定义了一个表示复数的类。这个类相对比较简单，但包含了实例方法（包括获取方法）、静态方法、实例字段和静态字段。代码中的注释解释了应该怎么在类体中使用尚未成为标准的定义实例字段和静态字段的语法。

```js
/**
 * 这个 Complex 类的实例代表复数
 * 复数是一个实数和一个虚数之和,
 * 而虚数 i 是 -1 的平方根
 */
class Complex {
  // 在这种类字段声明标准化之后，可以像下面这样，声明私有字段来保存复数的实数和虚数部分
  // #r = 0;
  // #i = 0;

  // 这个构造函数定义了它需要在每个实例上
  // 创建的实例属性 r 和 i。这两个字段保存复数的实数和虚数部分，即对象的状态
  constructor(real, imaginary) {
    this.r = real; // 这个字段保存这个数的实数部分
    this.i = imaginary; // 这个字段保存这个数的虚数部分
  }

  // 这里是两个实例方法，用于做复数的加法和乘法。如果 c 和 d 是这个类两个实例，则
  // 可以写 c.plus(d) 或 d.times(c)
  plus(that) {
    return new Complex(this.r + that.r, this.i + that.i);
  }
  times(that) {
    return new Complex(this.r * that.r - this.i * that.i, this.r * that.i + this.i * this.r);
  }

  // 而这里是两个复数计算方法的静态版本。这样可以写
  // Complex.sum(c, d) 和 Complex.product(c, d)
  static sum(c, d) {
    return c.plus(d);
  }
  static product(c, d) {
    return c.times(d);
  }

  // 这些也是实例方法,但是使用获取函数定义的，因此可以像使用字段一样使用它们。
  // 如果我们使用的是私有字段 this.#r 和 this.#i，那这里的获取方法就有用了
  get real() {
    return this.r;
  }
  get imaginary() {
    return this.i;
  }
  get magnitude() {
    return Math.hypot(this.r, this.i);
  }

  // 每个类都应该有一个 toString() 方法
  toString() {
    return `(${this.r},${this.i})`;
  }

  // 这个方法可以用来测试类的两个实例是否表示相同的值
  equals(that) {
    return that instanceof Complex && this.r === that.r && this.i === that.i;
  }

  // 如果类体支持静态字段，那我们就可以像下面这样定义一个常量 Complex.ZERO
  // static ZERO = new Complex(0,0)
}

// 下面定义了几个保存预定义复数的类字段
Complex.ZERO = new Complex(0, 0);
Complex.ONE = new Complex(1, 0);
Complex.I = new Complex(0, 1);
```

有了示例 9-4 中的 Complex 类，就可以像下面这样使用构造函数、实例字段、实例方法、类字段和类方法：

```js
let c = new Complex(2, 3); // 通过构造函数创建一个新对象
let d = new Complex(c.i, c.r); // 使用 c 的实例字段
c.plus(d).toString(); // "(5,5}"; 使用实例方法
c.magnitude; // Math.hypot(2,3); 使用获取函数
Complex.product(c, d); // new Complex(0,13); 使用静态方法
Complex.ZERO.toString(); // "{0,0}"; 使用静态属性
```

### 9.4 为已有类添加方法

JS 基于原型的继承机制是动态的。换句话说，对象从它的原型继承属性，如果在创建对象之后修改了原型的属性,则对象继承修改后的属性。这意味着只要给原型对象添加方法，就可以增强 JS 类。

例如，下面的代码为示例 9-4 定义的 Complex 类添加了一个计算共轭复数的方法:

```js
// 返回当前复数的共轭复数
Complex.prototype.conj = function () {
  return new Complex(this.r, this.i);
};
```

**内置 JS 类的原型对象也跟这里一样是开放的**，因此可以为数值、字符串、数组、函数等添加方法。如果想在旧版本 JS 中添加新语言特性,就可以这么做:

```js
// 如果字符串上没有定义 startsWith() 方法……
if (!String.prototype.startswith) {
  // 则使用已有的 indexOf() 方法实现一个
  String.prototype.startsWith = function (s) {
    return this.indexOf(s) === 0;
  };
}
```

下面是另一个示例：

```js
// 多次调用函数 f，传给它送代数值
// 如，要打印 3 次 "hello"
// let n = 3
// n.times(i => { console.log(`hello ${i}`); });
Number.prototype.times = function (f, context) {
  let n = this.valueOf();
  for (let i = 0; i < n; i++) f.call(context, i);
};
```

> **注意**：**像这样给内置类型的原型添加方法通常被认为是不好的做法**。因为如果 JS 未来某个新版本也定义了同名方法，就会导致困惑和兼容性问题。当然，给 `Object.prototype` 添加方法也是可以的，这样所有对象都会继承新方法。但最好不要这样做，因为添加到 `Object.prototype` 上的属性在 for/in 循环中是可见的（尽管使用 14.1 节介绍的 `Object.defineProperty()` 方法把新属性设置为不可枚举能够避免这个问题）。

### 9.5 子类

在面向对象编程中，类 B 可以扩展或子类化类 A。此时说 A 是父类，B 是子类。B 的实例继承 A 的方法。类 B 也可以定义自己的方法，其中有些方法可能覆盖类 A 的同名方法。如果 B 的方法覆盖了 A 的方法，B 中的覆盖方法经常需要调用 A 中被覆盖的方法。类似地，子类构造函数 B() 通常必须调用父类构造函数 A() 才能将实例完全初始化。

本节首先展示如何以 ES6 之前的旧方式定义子类，然后迅速转换为使用 `class` 和 `extends` 关键字定义子类，以及通过 `super` 关键字调用父类构造函数。接下来讨论如何避免使用子类，利用对象组合而非继承。本节最后将展示一个综合性的示例，其中定义了几个层次的 Set 类，演示了如何利用抽象类分隔接口与实现。

#### 9.5.1 子类与原型

假设想定义示例 9-2 中 Range 类的一个子类 Span。这个子类与 Range 相似，但不是初始化起点和终点，而是初始化起点和距离或跨度（span）。

Span 类的实例也是父类 Range 的实例。跨度的实例从 `Span.prototype` 继承了自定义的 `toString()` 方法，但为了成为 Range 的子类，它也必须从 `Range.prototype` 继承方法（如 `includes()`）。

```js
// 示例 9-5: Range 的简单的子类（Span.js）
// 这是子类构造函数
function Span(start, span) {
  if (span >= 0) {
    this.from = start;
    this.to = start + span;
  } else {
    this.to = start;
    this.from = start + span;
  }

  // 确保 Span 的原型继承 Range 的原型
  Span.prototype = Object.create(Range.prototype);

  // 不想继承 Range.prototype.constructor
  // 因此需要定义自己的 constructor 属性
  Span.prototype.constructor = Span;

  // 通过定义自己的 toString() 方法，Span 覆盖了 toString(，否则就要从 Range 继承
  Span.prototype.toString = function () {
    return `(${this.from}...${this.to - this.from})`;
  };
}
```

为了让 Span 成为 Range 的子类，需要让 `Span.prototype` 继承 `Range.prototype`。前面示例中最关键的一行代码就是这一行，如果能明白，那就理解了 JS 中子类的工作机制:

```js
Span.prototype = Object.create(Range.prototype);
```

通过 Span() 构造函数创建的对象会继承 `Span.prototype` 对象。但在创建该对象时让它继承了 `Range.prototype`，因此 Span 对象既会继承 `Span.prototype`，也会继承 `Range.prototype`。

> **注意**：
>
> Span() 构造函数像 Range() 构造函数一样，也设置了 from 和 to 属性，因此不需要调用 Range() 构造函数来初始化新对象。
> 类似地，Span 的 toString() 方法完全重新实现了字符串转换逻辑，不需要调用 Range 的 toString()。这让 Span 成为一个特例，只有在知道父类实现细节的前提下才可能这样定义子类。健壮的子类化机制应该允许类调用父类的方法和构造函数，但在 ES6 之前，JS 中没有简单的办法做这些。
> 好在 ES6 通过 `super` 关键字作为 `class` 语法的一部分解决了这个问题。

#### 9.5.2 通过 extends 和 super 创建子类

在 ES6 及以后，要继承父类，可以简单地在类声明中加上一个 `extends` 子句，甚至对内置的类也可以这样:

```js
// Array 的一个简单子类，为第一个和最后一个元素添加了获取函数
class EZArray extends Array {
  get first() {
    return this[0];
  }
  get last() {
    return this[this.length - 1];
  }
}
let a = new EZArray();
a instanceof EZArray; // true：a 是子类的实例
a instanceof Array; // true：a 也是父类的实例
a.push(1, 2, 3, 4); // a.length == 4; 可以使用继承的方法
a.pop(); // 4: 使用另一个继承的方法
a.first; // 1:子类定义的 first 获取方法
a.last; // 3:子类定义的 last 获取方法
a[1]; // 2:普通数组访问语法仍然有效
Array.isArray(a); // true:子类实例确实是数组
EZArray.isArray(a); // true:子类也继承了静态方法
```

这个 EZArray 子类定义了两个简单的获取方法。EZArray 的实例就像普通数组一样，拥有继承的方法和属性，如 `push()`、`pop()` 和 `length`。但是它也有子类定义的 first 和 last 获取方法。另外，子类实例不仅继承了 `pop()` 等实例方法，子类本身也继承了 `Array.isArray` 这种静态方法。这是 ES6 类语法带来的新特性: `EZArray()` 是个函数，但它继承 Array()。

```js
// EZArray 的实例之所以能继承实例方法，是因为 EZArray.prototype 继承 Array.prototype
Array.prototype.isPrototypeOf(EZArray.prototype); // true

// EZArray 之所以能继承静态方法和属性，是因为 EZArray 继承 Array。这是 extends 关键字独有的特性，在 ES6 之前是不可能做到的
Array.isPrototypeOf(EZArray); // true
```

EZArray 子类太简单，很难充分说明问题。示例 9-6 是一个相对更完善的示例，该示例为内置 Map 类定义了一个 TypedMap 子类，添加了类型检查以确保映射的键和值都是指定的类型（根据 typeof）。重点是，该示例展示了使用 `super` 关键字调用父类构造函数和方法。

```js
// 示例 9-6: Map 检查键和值类型的子类（TypedMap.js）
class TypedMap extends Map {
  constructor(keyType, valueType, entries) {
    // 如果指定了条目，检查它们的类型
    if (entries) {
      for (let [k, v] of entries) {
        if (typeof k !== keyType || typeof v !== valueType) {
          throw new TypeError(`wrong type for entry [${k}, ${v}]`);
        }
      }
    }
    // 使用（通过类型检查的）初始条目初始化父类
    super(entries);
    // 然后初始化子类，保存键和值的类型
    this.keyType = keyType;
    this.valueType = valueType;
  }

  // 现在，重定义 set() 方法，为所有新增映射条目添加类型检查逻辑
  set(key, value) {
    // 如果键或值的类型不对就抛出错
    if (this.keyType && typeof key !== this.keyType) {
      throw new TypeError(`${key} is not of type ${this.keyType}`);
    }
    if (this.valueType && typeof value !== this.valueType) {
      throw new TypeError(`${value} is not of type ${this.valueType}`);
    }
    // 如果类型正确，则调用超类的 set()，方法为映射添加条目。同时,返回父类方法返回的值
    return super.set(key, value);
  }
}
```

`TypedMap()` 构造函数的前两个参数是期望的键和值类型，应该是字符串，例如 "number"、"boolean" 等 `typeof` 操作符返回的值。还可以指定第三个参数：一个 `[key, value]` 数组的数组（或可迭代对象），用于指定映射的初始条目。如果指定了初始条目，则构造函数的第一件事就是检查它们的类型是否正确。然后，再通过 `super` 调用父类构造函数，就像它是一个函数名一样。

`Map()` 构造函数接收一个可选的参数：一个 `[key, value]` 数组的可迭代对象。因此，`TypedMap()` 构造函数可选的第三个参数就是 `Map()` 构造函数可选的第一个参数，通过 `super(entries)` 把它传给父类构造函数。

在调用父类构造函数初始化父类状态后，`TypedMap()` 构造函数接着通过把 `this.keyType` 和 `this.valueType` 设置为指定类型初始化了自己这个子类的状态。之所以要保存这两个值，是因为后面的 `set()` 方法要使用。

关于在构造函数中使用 `super()`，有几个重要的规则需要知道：

- 如果使用 `extends` 关键字定义了一个类，那么这个类的构造函数必须使用 `super()` 调用父类构造函数。

- 如果没有在子类中定义构造函数，解释器会自动创建一个。这个隐式定义的构造函数会取得传给它的值，然后把这些值再传给 `super()`。

- 在通过 `super()` 调用父类构造函数之前，不能在构造函数中使用 `this` 关键字。这条强制规则是为了确保父类先于子类得到初始化。

- 在没有使用 `new` 关键字调用的函数中，特殊表达式 `new.target` 的值是 `undefined`。而在构造函数中，`new.target` 引用的是被调用的构造函数。当子类构造函数被调用并使用 `super()` 调用父类构造函数时，该父类构造函数通过 `new.target` 可以获取子类构造函数。设计良好的父类无须知道自己是否有子类，但它们可以使用 `new.target.name` 来记录日志消息。

在示例 9-6 中，构造函数后面是一个名为 `set()` 的方法。父类 `Map()` 定义了一个名为 `set()` 的方法用于向映射中添加新条目。TypedMap 中的这个 `set()` 方法覆盖了其父类的 `set()` 方法。

这个简单的 TypedMap 子类并不知道怎么向映射中添加新条目，但它知道怎么检查类型，这也是它先做的：验证添加到映射的键和值都是正确的类型，如果不是则抛出错误。这个 `set()` 方法本身不能向映射中添加键和值，但这正是父类 `set()` 方法的作用。因此再次使用 `super` 关键字，调用父类的这个方法。此时，`super` 的角色很像 `this` 关键字，它引用当前对象，但允许访问父类定义的被覆盖的方法。

在构造函数中，必须先调用父类构造函数才能访问 `this` 并初始化子类的新对象。但在覆盖方法时则没有这个限制。覆盖父类方法的方法不一定调用父类的方法。如果它确实要通过 `super` 调用父类被覆盖的方法（或其他方法），那在覆盖方法的开头、中间或末尾调用都没问题。

#### 9.5.3 委托而不是继承

使用 `extends` 关键字可以轻松地创建子类。但这并不意味就应该创建很多子类。如果写了一个类，这个类与另一类有相同的行为，可以通过创建子类来继承该行为。但是，在类中创建另一个类的实例，并在需要时委托该实例去做希望的事反而更方便，也更灵活。

这时候，不需要创建一个类的子类，只要**包装或组合其他类即可。这种委托策略常常被称为“组合”**（composition），也是面向对象编程领域奉行的一个准则，即**开发者应该“能组合就不继承”**（favor composition over inherit）。

例如，假设想写一个 Histogram（直方图）类，这个类有些像 JS 的 Set 类，但除了记录一个值是否被添加到集合，它还要维护值被添加的次数。因为这个 Histogram 类的 API 类似于 Set，可以考虑扩展 Set 并添加一个 `count()` 方法。但从另一个角度有看，在思考如何实现这个 `count()` 方法时，又会发现这个 Histogram 类更像是 Map 而不是 Set。因为它需要维护值与添加次数的映射。所以与其创建 Set 的子类，不如创建一个类，为它定义类似 Set 的 API，但通过把相应操作委托给一个内部 Map 对象来实现那些方法。示例 9-7 展示了这个类：

```js
// 示例 9-1：通过委托实现的类似 Set 的类（Histogram.js）

/**
 * 一个类似 Set 的类，但会记录值被添加的次数，可以像使用 Set 一样调用 add() 和 remove()
 * 调用 count() 获取某个值已经被添加了多少次
 * 默认迭代器回送至少被添加过1次的值。如果想迭代 [value, count] 对，使用 entries()
 */

class Histogram {
  // 初始化只涉及创建一个要委托的 Map 对象
  constructor() {
    this.map = new Map();
  }

  // 对给定的键，次数就是映射中的值。如果映射中不存在这个键，则为 0
  count(key) {
    return this.map.get(key) || 0;
  }

  // 这个类似 Set 的方法 has() 在次数大于 0 时返回true
  has(key) {
    return this.count(key) > 0;
  }

  // 直方图的大小就是映射中条目的数量
  get size() {
    return this.map.size;
  }

  // 要添加一个键，只需递增其在映射中的次数
  add(key) {
    this.map.set(key, this.count(key) + 1);
  }

  // 删除键稍微麻烦点，因为必须在次数回到 0 时从映射中删除相应的键
  delete(key) {
    let count = this.count(key);
    if (count === 1) {
      this.map.delete(key);
    } else if (count > 1) {
      this.map.set(key, count - 1);
    }
  }

  // 迭代直方图就是返回映射中存储的键
  [Symbol.iterator]() {
    return this.map.keys();
  }

  // 其他迭代器方法直接委托给映射对象
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
}
```

例 9-7 中 `Histogram()` 构造函数只做了一件事，就是创建了一个 Map 对象。而这个类的多数方法只有一行，因为都委托给了相应的映射方法，所以实现特别简单。由于使用委托而非继承，Histogram 对象既不是 Set 的实例，也不是 Map 的实例。但 Histogram 实现了一些常用的 Set 方法，在像 JS 这样的弱类型语言中，这通常就足够了。正式的继承关系有时候确实好，但并不是必需的。

#### 9.5.4 类层次与抽象类

示例 9-6 演示了如何创建 Map 的子类。示例 9-7 演示了如何委托 Map 对象而不创建子类。使用 JS 类封装数据和组织代码通常是个不错的技术，因此可能会经常使用 `class` 关键字。但是，可能会发现组合比继承更常用，因而几乎不会用到 `extends`（除非使用某个库或框架，要求必须扩展其基类）。

然而，也存在需要多级子类的情况。示例 9-8 其中涉及表示不同集合的类层次（其中定义的集合类与 JS 内置的 Set 类相似，但不完全兼容）。

示例 9-8 定义了很多子类，同时也演示了如何定义抽象类，也就是不包含完整实现的类。抽象类在这里作为一组相关子类的公共父类。抽象父类可以定义部分实现，供所有子类继承和共享。子类只需实现父类定义（但未实现）的抽象方法。不过，JS 没有正式定义抽象方法或抽象类的语法。这里只是借用它们来指代未实现的方法和未完全实现的类。

示例 9-8 包含完善的注释，自成一体。建议读者将它作为本章展示 JS 类使用的顶级范例。示例 9-8 定义的最后一个类通过 `&`、`|` 和 `~` 操作符实现了很多位操作。

```js
// 示例 9-8: 抽象与具体的集合类层次（Sets.js）

/**
 * AbstractSet 类只定义了一个抽象方法 has()
 */
class AbstractSet {
  // 抛出错误，强制子类必须定义这个方法的可用版本
  has(x) {
    throw new Error('Abstract method');
  }
}

/**
 * Notset 是 AbstractSet 的一个具体子类，这个集合的成员是不属于其他集合的任何值
 * 因为使用另一个集合定义，所以它不可写，而且因为它有无限个成员，所以不可枚举
 * 这个类只支持检测成员关系和使用数学符号把集合转换为字符串
 */
class NotSet extends AbstractSet {
  constructor(set) {
    super();
    this.set = set;
  }
  // 实现继承的抽象方法
  has(x) {
    return !this.set.has(x);
  }
  // 同时覆盖 Object 的方法
  toString() {
    return `{ x| x ∉ ${this.set.toString()} }`;
  }
}

/**
 * Range 集合是 AbstractSet 的一个具体子类
 * 这个集合的成员是介于 from 和 to（含二者）之间的所有值
 * 由于其成员可能是浮点数值，因此不可枚举，也不具备有意义的大小
 */
class RangeSet extends AbstractSet {
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
  }

  has(x) {
    return x >= this.from && x <= this.to;
  }
  toString() {
    return `{ x| ${this.from} ≦ x ≦ ${this.to} }`;
  }
}

/**
 * AbstractEnumerableSet 是 AbstractSet 的一个抽象子类
 * 这个抽象类定义了一个抽象的获取方法，返回集合的大小
 * 还定义了一个抽象迭代器。然后在此基础上实现了具体的 isEmpty()、toString() 和 equals() 方法。
 * 实现这个迭代器、大小获取方法以及（继承的） has() 方法的子类无偿获得这些具体方法
 */
class AbstractEnumerableSet extends AbstractSet {
  get size() {
    throw new Error('Abstract method');
  }
  [Symbol.iterator]() {
    throw new Error('Abstract method');
  }

  isEmpty() {
    return this.size === 0;
  }
  toString() {
    return `{${Array.from(this).join(', ')}}`;
  }

  equals(set) {
    // 如果另一个集合不是 AbstractEnumerableSet，那肯定不等于当前集合
    if (!(set instanceof AbstractEnumerableSet)) return false;

    // 如果两个集合大小不一样，它们也不相等
    if (this.size !== set.size) return false;

    // 循环检查集合的元素
    for (let element of this) {
      // 只要有一个元素不在另一个集合中，它们就不相等
      if (!set.has(element)) return false;
    }

    // 元素匹配，因此两个集合相等
    return true;
  }
}

/**
 * SingletonSet 是 AbstractEnumerableSet 的一个具体子类
 * 单体集合是只有一个成员的只读集合
 */
class SingletonSet extends AbstractEnumerableSet {
  constructor(member) {
    super();
    this.member = member;
  }

  // 实现 3 个抽象方法，同时继承基于这 3 个方法实现的 isEmpty()、equals() 和 toString()
  has(x) {
    return x === this.member;
  }
  get size() {
    return 1;
  }
  *[Symbol.iterator]() {
    yield this.member;
  }
}

/**
 * AbstractWritableSet 是 AbstractEnumerableSet 的一个抽象子类
 * 这个抽象类定义了抽象方法 insert() 和 remove()，分别用于插入和删除个别集合元素
 * 然后在此基础上实现了具体的 add()、subtract()和 intersect() 方法。
 *
 * 注意，API 从这里开始偏离了标准的 JS Set 类
 */
class AbstractWritableSet extends AbstractEnumerableSet {
  insert(x) {
    throw new Error('Abstract method');
  }
  remove(x) {
    throw new Error('Abstract method');
  }

  add(set) {
    for (let element of set) {
      this.insert(element);
    }
  }

  subtract(set) {
    for (let element of set) {
      this.remove(element);
    }
  }

  intersect(set) {
    for (let element of this) {
      if (!set.has(element)) {
        this.remove(element);
      }
    }
  }
}

/**
 * Bitset 是 AbstractwritableSet 的一个具体子类
 * 这个类是非常高效的固定大小集合的实现，用于元素为小于某个最大值的非负整数集合
 */
class BitSet extends AbstractwritableSet {
  constructor(max) {
    super();
    this.max = max; // 可存储的最大整数
    this.n = 0; // 集合中整数的个数
    this.numBytes = Math.floor(max / 8) + 1; // 需要多少字节
    this.data = new Unit8Array(this.numBytes); // 实际的字节
  }

  // 内部方法，检测一个值是否为当前集合的合法成员
  _valid(x) {
    return Number.isInteger(x) && x >= 0 && x <= this.max;
  }

  // 测试数据数组中指定字节的指定位是否有值，返回 true 或 false
  _has(byte, bit) {
    return (this.data[byte] & BitSet.bits[bit]) !== 0;
  }

  // x 在这个 BitSet 中吗?
  has(x) {
    if (this._valid(x)) {
      let byte = Math.floor(x / 8);
      let bit = x % 8;
      return this._has(byte, bit);
    } else {
      return false;
    }
  }

  // 把 x 插入当前 BitSet
  insert(x) {
    // 如果这个值有效
    if (this._valid(x)) {
      let byte = Math.floor(x / 8); // 转换为字节和位
      let bit = x % 8;
      // 如果对应的位没有值
      if (!this._has(byte, bit)) {
        this.data[byte] |= BitSet.bits[bit]; // 则设置该位的值
        this.n++; // 并递增集合大小
      }
    } else {
      throw new TypeError('Invalid set element: ' + x);
    }
  }

  remove(x) {
    // 如果这个值有效
    if (this._valid(x)) {
      let byte = Math.floor(x / 8); // 则计算字节和位
      let bit = x % 8;
      if (this._has(byte, bit)) {
        // 如果该位已经设置了值
        this.data[byte] &= Bitset.masks[bit]; // 则取消设置的值
        this.n--; // 并递减集合大小
      }
    } else {
      throw new TypeError('Invalid set element：' + x);
    }
  }

  // 获取方法，返回集合大小
  get size() {
    return this.n;
  }

  // 迭代集合，只依次检查每一位(应该可以更聪明一点，大幅优化这里的逻辑)
  *[Symbol.iterator]() {
    for (let i = 0; i <= this.max; i++) {
      if (this.has(i)) {
        yield i;
      }
    }
  }
}

// has()、insert() 和 remove() 方法会用的几个预定义值
BitSet.bits = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
BitSet.masks = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~1281]);
```

## 十. 模块

模块化编程的目标是能够用不同作者和来源的代码模块组装成大型程序，即使不同模块的作者无法预知如何使用，代码仍然可以正确运行。**实践中，模块化的作用主要体现在封装和隐藏私有实现细节，以及保证全局命名空间清洁上，因而模块之间不会意外修改各自定义的变量、函数和类**。

### 10.1 基于类、对象和闭包的模块

**类的一个重要特性，就是它们充当了自己方法的模块**。示例 9-8 中定义了几个不同的类，这些类都有个名叫 `has()` 的方法。可以在一个程序中同时使用该示例定义的多个集合类，而不必担心 BitSet 的 `has()` 方法会被 SingletonSet 的 `has()` 方法重写。

**不相关的类的方法之所以能够相互独立，是因为每个类的方法都被定义为独立原型对象的属性**。而类之所以成为模块是因为对象是模块：给一个 JS 对象定义属性非常像声明变量，但给对象添加属性不影响程序的全局命名空间，也不影响其他对象的属性。

JS 定义了不少数学函数和常量，但并没有把它们定义在全局命名空间中，而是将它们分组作为属性定义在全局 Math 对象上。示例 9-8 也借鉴了同样的思路。例如，不是把 SingletonSet 和 Bitset 定义为全局类，而是只定义一个全局 Sets 对象，通过这个对象的属性引用不同的类。然后，这个 Sets 库的用户可以通过类似 `Sets.Singleton` 和 `Sets.Bit` 这样的方式引用这些类。

使用类和对象实现模块化是 JS 编程中常见且有用的技术，但这还不够。特别地，类和对象没有提供任何方式来隐藏模块的内部实现细节。再看看示例 9-8，如果把该示例写成一个模块，那么会希望把各种抽象类作为模块的内部代码，只对模块用户暴露具体的子类。类似地，在 BitSet 类中，`_valid()` 和 `_has()` 是内部辅助方法，也不应该暴露给类的用户。而 `Bitset.bits` 和 `Bitset.masks` 也是实现细节，最好也隐藏。

在函数中声明的局部变量和嵌套函数都是函数私有的。这意味着可以使用立即调用的函数表达式来实现某种模块化，把实现细节和辅助函数隐藏在包装函数中，只将模块的公共 API 作为函数的值返回。以 BitSet 类为例，可以像下面这样实现这个模块：

```js
// 将 Bitset 设置为这个函数的返回值
const BitSet = (function () {
  // 这里是私有实现细节
  function isValid(set, n) {}
  function has(set, byte, bit) {}
  const BITS = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
  const MASKS = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~1281]);

  // 这个模块的公共 API 就是 BitSet 类，在这里定义并返回
  // 这个类可以使用上面定义的私有函数和常量，但这些私有函数和常量对这个类的用户是不可见的
  return class BitSet extends AbstractWritableSet {
    // 省略实现
  };
})();
```

如果模块需要暴露多个值，这种实现模块化的方式就比较有意思了。例如，以下代码定义了一个小型统计模块，暴露了 `mean()` 和 `stddev()` 函数，同时隐藏了实现细节:

```js
// 可以像这样定义 stats 模块
const stats = (function () {
  // 模块私有的辅助函数
  const sum = (x, y) => x + y;
  const square = x => x * x;

  //要导出的公有函数
  function mean(data) {
    return data.reduce(sum) / data.length;
  }

  // 另一个要导出的公有函数
  function stddev(data) {
    let m = mean(data);
    return Math.sqrt(
      data
        .map(x => x - m)
        .map(square)
        .reduce(sum) /
        (data.length - 1)
    );
  }

  // 将公有函数作为一个对象的属性导出出来
  return { mean, stddev };
})();

// 下面是使用这个模块的示例
stats.mean([1, 3, 5, 7, 9]); // 5
stats.stddev([1, 3, 5, 7, 9]); // Math.sqrt(10)
```

#### 10.1.1 基于闭包的自动模块化

在一个 JS 代码文件开头和末尾插入一些文本，把它转换为类似的模块是一个相当机械的过程。这里所需要的就是对 JS 代码文件设定一些规则，按照规则可以指定哪些值要导出，哪些值不导出。

可以想象有一个工具，它能解析代码文件，把每个文件的内容包装在一个立即调用的函数表达式中，还可以跟踪每个函数的返回值，并将所有内容拼接为一个大文件。结果可能类似如下所示:

```js
const modules = {};
function require(moduleName) {
  return modules[moduleName];
}

modules["sets.js"] = (function() {
  const exports = {}

  // sets.js 文件的内容在这里:
  exports.BitSet = class BitSet {};
  return export;
}());

modules["stats.js"] = (function() {
  const exports = {}

  // stats.js 文件的内容在这里
  const sum = (x, y) => x + y;
  const square = x => x * x;
  exports.mean= function(data) {}
  exports.stddev = function(data) {}
  return exports;
}());
```

把所有模块都打包到类似上面的单个文件中之后，可以像下面这样写代码来使用它们:

```js
// 取得对所需模块(或模块内容)的引用
const stats = require('stats.js');
const BitSet = require('sets.js').Bitset;

// 接下来写使用这些模块的代码
let s = new BitSet(100);
s.insert(10);
s.insert(20);
s.insert(30);
let average = stats.mean([...s]); // 平均数是 20
```

以上代码展示了针对浏览器的代码打包工具（如 webpack 和 Parcel）的基本工作原理。也是对 Node 程序中使用的 `require()` 函数的一个简单介绍。

### 10.2 Node 中的模块

编写 Node 程序时，可以随意将程序拆分到任意多个文件中。这些 JS 代码文件被假定始终存在于一个快速文件系统中。与通过相对较慢的网络连接读取 JS 文件的浏览器不同，把所有 Node 代码都写到一个 JS 文件中既无必要也无益处。

在 Node 中，每个文件都是一个拥有私有命名空间的独立模块。在一个文件中定义的常量、变量、函数和类对该文件而言都是私有的，除非该文件会导出它们。而被模块导出的值只有被另一个模块显式导入后才会在该模块中可见。

Node 模块使用 `require()` 函数导入其他模块，通过设置 `Exports` 对象的属性或完全替换 `module.exports` 对象来导出公共 API。

#### 10.2.1 Node 的导出

Node 定义了一个全局 exports 对象，这个对象始终有定义。如果要写一个导出多个值的 Node 模块，可以直接把这些值设置为 exports 对象的属性:

```js
const sum = (x, y) => x + y;
const square = x => x * x;

exports.mean = data => data.reduce(sum) / data.length;
exports.stddev = function (d) {
  let m = exports.mean(d);
  return Math.sqrt(
    d
      .map(x => x - m)
      .map(square)
      .educe(sum) /
      (d.length - 1)
  );
};
```

不过，更多的时候只想让模块导出一个函数或类，而非一个包含很多函数或类的对象。为此，只要把想导出的值直接赋给 `module.exports` 即可：

```js
module.exports = class BitSet extends AbstractWritableSet {
  // 省略实现
};
```

`module.exports` 的默认值与 exports 引用的是同一个对象。在前面的统计模块中，实际上也可以直接把 mean 函数赋值给 `module.exports.mean`。另一种重写这个统计模块的方式是在模块末尾导出一个对象，而不是写一个函数导出一个：

```js
// 定义所有公有函数和私有函数
const sum = (x, y) => x + y;
const square = x => x * x;
const mean = data => data.reduce(sum) / data.length;
const stddev = d => {
  let m = mean(d);
  return Math.sqrt(
    d
      .map(x => x - m)
      .map(square)
      .reduce(sum) /
      (d.length - 1)
  );
};

// 最后只导出公有函数
module.exports = { mean, stddev };
```

#### 10.2.2 Node 的导入

**Node 模块通过调用 `require()` 函数导入其他模块。这个函数的参数是要导入模块的名字，返回值是该模块导出的值（通常是一个函数、类或对象）**。

如果想导入 Node 内置的系统模块或通过包管理器安装在系统上的模块，可以使用模块的非限定名，即不带会被解析为文本系统路径的 “/” 字符的模块名：

```js
// 这些都是 Node 内置的模块
const fs = require('fs'); // 内置的文件系统模块
const https = require('http'); // 内置的 HTP 模块

// Express Http 服务器框架是第三方模块不属于 Node，但已经安装在本地
const express = require('express');
```

如果想导入自己代码中的模块，则模块名应该是指向包含模块代码的模块文件的路径（相对于当前模块文件）。虽然可以使用以 “/” 开头的绝对路径，但在导入自己程序的模块时，通常都使用以 “./” 或 “../” 开头的模块名，以表示它们相对于当前的目录或父目录。例如：

```js
const stats = require('/stats.js');
const Bitset = require('./utils/bitset.js');
```

虽然省略导入文件的 `.js` 后缓，Node 仍然可以找到这些文件，但包含这些文件扩展名还是很常见的。

如果模块只导出一个函数或类，则只要调用 `require()` 取得返回值即可。如果模块导出一个带多个属性的对象，则有两个选择：

- 导入整个对象

- 通过解构赋值只导入打算使用的特定属性

比较一下这两种方式:

```js
// 导入整个 stats 对象，包含所有函数
const stats = require('./stats.js');

// 虽然导入了用不到的函数，但这些函数都隐藏在 "stats" 命名空间之后
let average = stats.mean(data);

// 当然，也可以使用常见的解构赋值直接向本地命名空间中导入想用的函数
const { stddev } = require('/stats.js');

// 这样当然简洁明了，只是 stddev() 函数没有 'stats' 前缀作为命名空间，因此少了上下文信息
let sd = stddev(data);
```

### 10.3 ES6 中的模块

ES6 为 JS 添加了 `import` 和 `export` 关键字，终于将模块作为核心语言特性来支持了。**ES6 模块化与 Node 的模块化在概念上是相同的：每个文件本身都是模块，在文件中定义的常量、变量、函数和类对这个文件而言都是私有的，除非它们被显式导出**。

另外，一个模块导出的值只有在显式导入它们的模块中才可以使用。**ES6 模块与 Node 模块的区别在于导入和导出所用的语法，以及浏览器中定义模块的方式**。

**ES6 模块与常规 JS “脚本”的区别**：

- 最明显的区别是模块化本身：在常规脚本中，顶级声明的变量、函数和类会进入被所有脚本共享的全局上下文。而在模块中，每个文件都有自己的私有上下文，可以使用 `import` 和 `export` 语句。

- ES6 模块中的代码自动应用严格模式。这意味着在使用 ES6 模块时，永远不用再写 `use strict` 了。同时也意味着模块中的代码无法使用 `with` 语句和 `arguments` 对象或未声明的变量。ES6 模块甚至比严格模式还要更严格：在严格模式下，在作为函数调用的函数中 this 是 undefined。而在模块中，即便在顶级代码中 this 也是 undefined（相对而言，浏览器和 Node 中的脚本都将 this 设置为全局对象）。

#### 10.3.1 ES6 的导出

要从 ES6 模块导出常量、变量、函数或类，只要在声明前加上 `export` 关键字即可:

```js
export const PI = Math.PI;

export function degreesToRadians(d) {
  return (d * PI) / 180;
}

export class Circle {
  constructor(r) {
    this.r = r;
  }
  area() {
    return PI * this.r * this.r;
  }
}
```

要取代使用多个 `export` 关键字的做法，可以先正常定义常量、变量、函数和类，不加 `export` 关键字。然后（通常在模块末尾）只用一个 `export` 语句声明真正要导出的值。也就是说，前面使用三个 `export` 的代码等价于下面这一行代码：

```js
export { Circle, degreesToRadians, PI };
```

这个语法看起来是 `export` 关键字后跟一个对象字面量（使用了简化写法），但这里的花括号实际上不会定义对象字面量。这个导出语法仅仅是要求在一对花括号中给出一个逗号分隔的标识符列表。

一个模块只导出一个值（通常是一个函数或类）的情况是很常见的，此时通常可以使用 `export default` 而不是 `export`：

```js
export default class BitSet {
  // 省略实现
}
```

> **注意**：
>
> 1. 使用 `export` 的常规导出只对有名字的声明有效。而使用 `export default` 的默认导出则可以导出任意表达式，包括匿名函数表达式和匿名类表达式。这意味着如果使用 `export default`，则可以导出对象字面量。因此，与 `export` 语法不同，位于 `export default` 后面的花括号是实实在在会被导出的对象字面量。
> 2. 模块中同时有一些常规导出和一个默认导出是合法的，只是不太常见。如果模块中有默认导出，那就只能有一个。
> 3. `export` 关键字只能出现在 JS 代码的顶层。不能在类、函数、循环或条件内部导出值（这是 ES6 模块系统的重要特性，用以支持静态分析：模块导出的值在毎次运行时都相同，而导出的符号可以在模块实际运行前确定）。

#### 10.3.2 ES6 的导入

导入其他模块导出的值要使用 `import` 关键字。最简单的形式是导入定义了默认导出的模块：

```js
import BitSet from './bitset.js';
```

首先是 `import` 关键字，跟着一个标识符，再跟着一个 `from` 关键字，最后的字符串字面值是要导入其默认导出的模块的名字。指定模块默认导出的值会变成当前模块中指定标识符的值。

获得导入值的标识符是一个常量，就像是使用 `const` 关键字声明的一样。与导出类似，导入也只能出现在模块顶层，不允许在类、函数、循环或条件中出现。按照惯例，一个模块所需的导入都应该放在这个模块的开头。不过，这个规则并不是强制性的。导入与函数声明类似，会被“提升”到顶部，因此所有导入的值在模块代码运行时都是可用的。

**从中导入值的模块**
从中导入值的模块以常量字符串字面量的形式在单引号或双引号中给出（不能使用变量或其他值作为字符串的表达式，也不能把字符串放在反引号中，因为模板字面量有可能插入变量，并非只包含常量值）。

在浏览器中，这个字符串会被解释为一个相对于导入模块位置的 URL（在 Node 中，或当使用打包工具时，这个字符串会被解释为相对于当前模块的文件名，不过这在实践中没有太大差别）。模块标识符字符串必须是一个以 "/" 开头的绝对路径，或者是一个以 "./" 或 "../" 开头的相对路径，又或者是一个带有协议及主机名的完整 URL。

ES6 规范不允许类似 "util.js" 的非限定模块标识符字符串，因为它存在歧义：它是当前模块同级目录下的一个模块呢，还是安装在特殊位置的某个系统模块呢?（webpack 等代码打包工具不会限制这种“裸模块标识符”，因为通过配置很容易在指定的库目录中找到裸模块）。JS 语言未来的某个版本可能会允许“裸模块标识符”，但现在还不允许。如果想从当前模块的同级目录导入模块，只需要在模块名前面加上 "./"，也就是使用 "./util.js" 而非 "util.js"。

导出多个值的模块导入值的语法:

```js
import { mean, stddev } from './stats.js';
```

默认导出在定义它们的模块中不需要名字，在导入这些值的时候可以再给它们提供一个局部名。但非默认导出在导出它们的模块中则是有名字的，在导入这些值时，需要通过名字引用它们。导出模块可以导出任意多个命名的值。引用该模块的 `import` 语句可以导入这些值的任意子集，只要在花括号中列出它们的名字即可。花括号让 `import` 语句看起来像是解构赋值，而解构赋值也确实是这种导入风格一个不错的类比。花括号中的标识符都会被提升到导入模块顶部，行为类似常量。

风格指南有时会推荐显式导入模块将用到的所有符号。不过在从定义了很多导出的模块导入值时，可以像下面这样以一条 `import` 语句导入所有值：

```js
import * as stats from './stats.js';
```

像这样一条 `import` 语句可以创建一个对象，并将其赋值给一个名为 `stats` 的常量。被导入模块的每个非默认导出都会变成这个 `stats` 对象的一个属性。非默认导出始终有名字，这些名字将作为这个对象的属性名。这些属性是常量，不能被重写或删除。在使用前面这个带通配符的导入语句时，导入模块需要通过 `stats` 对象使用导入的 `mean()` 和 `stddev()` 函数，即要通过 `stats.mean()` 和 `stats.stddev()` 调用它们。

模块通常要么定义一个默认导出，要么定义多个命名导出。但一个模块同时使用 `export` 和 `export default` 也合法。可以只通过以下语句同时导入默认值和命名值：

```js
import Histogram, { mean, stddev } from './histogram-stats.js';
```

`import` 语句还有另一种形式，用于导入没有任何导出的模块。要在程序中包含没有导出的模块，只要在 `import` 关键字后面直接写出模块标识符即可：

```js
import './analytics.js';
```

这样的模块会在被首次导入时运行一次（之后再导入时则什么也不做）。如果模块中只定义了一些函数，那么它至少要导出其中一个函数才能有用。而如果模块中运行一些代码，那么即便没有符号导入也会很有用。

Web 应用可以使用分析模块（如 analytics.js）运行注册各种事件处理程序的代码，然后通过这些事件处理程序在合适的时机向服务器发送遥测数据。虽然模块是自包含的，不需要导出任何值，但仍然需要通过 `import` 导入才能让它作为程序的一部分运行。

> **注意**：对那些有导出的模块也可以使用这种什么也不导入的 `import` 语法。如果模块定义了与它的导出值无关的有用行为，而程序不需要它的任何导出值，那么可以只为它的默认行为导入这个模块。

#### 10.3.3 导入和导出时重命名

如果两个模块使用相同的名字导出了两个不同的值，而希望同时导入这两个值，那必须在导入时对其中一个或这两个进行重命名。类似地，如果在导入某个值时发现它的名字已经被占用了，则需要重命名这个导入值。可以在命名导入时使用 `as` 关键字对导入值进行重命名：

```js
import { render as renderImage } from './imageUtils.js';
import { render as renderUI } from './ui.js';
```

这两行代码向当前模块导入了两个函数。这两个函数在定义它们的模块中都被命 `render()`，但在导入时被重命名为更好理解且没有歧义的 `renderImage()` 和 `renderUI()`。

默认导出没有名字。导入模块在导入默认导出时始终需要选择一个名字。因此这种情况下不需要特殊语法。

尽管如此，导入时重命名的机制也为同时定义了默认导出和命名导出的模块提供了另一种导入方式:

```js
import { default as histogram, mean, stddev } from './histogram-stats.js';
```

在这种情况下，JS 关键字 `default` 充当一个占位符，允许指明想导入模块的默认导出并为其提供一个名字。

导出值时也可以重命名，但仅限于使用 `export` 语句的花括号形式。通常并不需要这样做，但如果在模块内部使用了简洁短小的名字，那在导出值时可能希望使用更有描述
