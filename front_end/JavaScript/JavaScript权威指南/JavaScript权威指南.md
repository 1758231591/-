---
title: JavaScript权威指南
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [JavaScript 权威指南](#javascript-权威指南)
  - [一. 基础](#一-基础)
    - [1.1 方法与函数的区别](#11-方法与函数的区别)
    - [1.2 JS 支持面向对象的编程风格](#12-js-支持面向对象的编程风格)
    - [1.3. 使用 JS 分析文件中的字符频率](#13-使用-js-分析文件中的字符频率)
  - [二. 词法结构](#二-词法结构)
    - [2.1 字面量含义](#21-字面量含义)
    - [2.2 JS 标识符命名规则](#22-js-标识符命名规则)
    - [2.3 Unicode 转义序列](#23-unicode-转义序列)
    - [2.4 箭头函数的 `=>` 必须跟参数列表在同一行](#24-箭头函数的-必须跟参数列表在同一行)
  - [三. 类型、值和变量](#三-类型-值和变量)
    - [3.1 数值](#31-数值)
      - [3.1.1 整数字面量支持的进制表示](#311-整数字面量支持的进制表示)
      - [3.1.2 数值字面量中的分隔符](#312-数值字面量中的分隔符)
      - [3.1.3 JS 通过 Math 对象提供了一组函数和常量，以支持更复杂的数学计算](#313-js-通过-math-对象提供了一组函数和常量以支持更复杂的数学计算)
      - [3.1.4 Number ES6 新增属性](#314-number-es6-新增属性)
      - [3.1.5 通过 BigInt 表示任意精度整数](#315-通过-bigint-表示任意精度整数)
    - [3.2 文本](#32-文本)
      - [3.2.1 使用字符串](#321-使用字符串)
      - [3.2.2 模板字符串](#322-模板字符串)
    - [3.3 null 与 undefined](#33-null-与-undefined)
    - [3.4 Symbol](#34-symbol)
    - [3.5 类型转换](#35-类型转换)
      - [3.4.1 显式转换](#341-显式转换)
      - [3.4.2 对象到原始值转换](#342-对象到原始值转换)
    - [3.6 变量声明与赋值](#36-变量声明与赋值)
    - [3.7 解构赋值](#37-解构赋值)
  - [四. 表达式与操作符](#四-表达式与操作符)
    - [4.1 表达式](#41-表达式)
    - [4.2 操作符](#42-操作符)
      - [4.2.1 操作符优先级](#421-操作符优先级)
      - [4.2.2 求值顺序](#422-求值顺序)
    - [4.3 算术表达式](#43-算术表达式)
      - [4.3.1 + 操作符](#431-操作符)
      - [4.3.2 一元算术操作符](#432-一元算术操作符)
    - [4.4 关系表达式](#44-关系表达式)
      - [4.4.1 严格相等](#441-严格相等)
      - [4.4.2 比较操作符](#442-比较操作符)
      - [4.4.3 in 操作符](#443-in-操作符)
      - [4.4.4 instanceof 操作符](#444-instanceof-操作符)
    - [4.5 逻辑表达式](#45-逻辑表达式)
      - [4.5.1 逻辑与（&&）](#451-逻辑与)
      - [4.5.2 逻辑或（||）](#452-逻辑或)
      - [4.5.3 逻辑非（!）](#453-逻辑非)
    - [4.6 赋值表达式](#46-赋值表达式)
    - [4.7 其他操作符](#47-其他操作符)
      - [4.7.1 空值合并运算符（??）](#471-空值合并运算符)
      - [4.7.2 typeof 操作符](#472-typeof-操作符)
      - [4.7.3 delete 操作符](#473-delete-操作符)
      - [4.7.4 await 操作符](#474-await-操作符)
  - [五. 语句](#五-语句)
  - [六. 对象](#六-对象)
    - [6.1 对象简介](#61-对象简介)
    - [6.2 创建对象](#62-创建对象)
      - [6.2.1 对象字面量](#621-对象字面量)
      - [6.2.2 使用 new 创建对象](#622-使用-new-创建对象)
      - [6.2.3 原型](#623-原型)
      - [6.2.4 `Object.create()`](#624-objectcreate)
    - [6.3 查询和设置属性](#63-查询和设置属性)
      - [6.3.1 作为关联数组的对象](#631-作为关联数组的对象)
      - [6.3.2 继承](#632-继承)
      - [6.3.3 属性访问错误](#633-属性访问错误)
    - [6.4 删除属性](#64-删除属性)
    - [6.5 测试属性](#65-测试属性)
    - [6.6 枚举属性](#66-枚举属性)
      - [6.6.1 属性枚举顺序](#661-属性枚举顺序)
    - [6.7 扩展对象](#67-扩展对象)
    - [6.8 序列化对象](#68-序列化对象)
    - [6.9 对象方法](#69-对象方法)
      - [6.9.1 toString() 方法](#691-tostring-方法)
      - [6.9.2 toLocaleString() 方法](#692-tolocalestring-方法)
      - [6.9.3 valueOf() 方法](#693-valueof-方法)
      - [6.9.4 toJSON() 方法](#694-tojson-方法)
    - [6.10 对象字面量扩展语法](#610-对象字面量扩展语法)
      - [6.10.1 简写属性](#6101-简写属性)
      - [6.10.2 计算的属性名](#6102-计算的属性名)
      - [6.10.3 符号作为属性名](#6103-符号作为属性名)
      - [6.10.4 扩展操作符](#6104-扩展操作符)
      - [6.10.5 简写方法](#6105-简写方法)
      - [6.10.6 属性的获取方法与设置方法（访问器属性）](#6106-属性的获取方法与设置方法访问器属性)
  - [七. 数组](#七-数组)
    - [7.1 创建数组](#71-创建数组)
      - [7.1.1 数组字面量](#711-数组字面量)
      - [7.1.2 扩展操作符](#712-扩展操作符)
      - [7.1.3 Array() 构造函数](#713-array-构造函数)
      - [7.1.4 Array.of()](#714-arrayof)
      - [7.1.5 Array.from()](#715-arrayfrom)
    - [7.2 读写数组元素](#72-读写数组元素)
    - [7.3 稀疏数组](#73-稀疏数组)
    - [7.4 数组长度](#74-数组长度)
    - [7.5 添加和删除数组元素](#75-添加和删除数组元素)
    - [7.6 迭代数组](#76-迭代数组)
    - [7.7 多维数组](#77-多维数组)
    - [7.8 数组方法](#78-数组方法)
      - [7.8.1 数组迭代器方法](#781-数组迭代器方法)
      - [7.8.2 使用 `flat()` 和 `flatMap()` 打平数组](#782-使用-flat-和-flatmap-打平数组)
      - [7.8.3 使用 `concat()` 添加数组](#783-使用-concat-添加数组)
      - [7.8.4 通过 `push()`、`pop()`、`shift()` 和 `unshift()` 实现栈和队列操作](#784-通过-push-pop-shift-和-unshift-实现栈和队列操作)
      - [7.8.5 使用 `slice()`、`splice()`、`fill()` 和 `copyWithin()`](#785-使用-slice-splice-fill-和-copywithin)
      - [7.8.6 数组索引与排序方法](#786-数组索引与排序方法)
      - [7.8.7 数组到字符串的转换](#787-数组到字符串的转换)
      - [7.8.8 静态数组函数](#788-静态数组函数)
    - [7.9 类数组对象](#79-类数组对象)
    - [7.10 作为数组的字符串](#710-作为数组的字符串)
  - [八. 函数](#八-函数)
    - [8.1 定义函数](#81-定义函数)
      - [8.1.1 函数声明](#811-函数声明)
      - [8.1.2 函数表达式](#812-函数表达式)
      - [8.1.3 箭头函数](#813-箭头函数)
      - [8.1.4 嵌套函数](#814-嵌套函数)
    - [8.2 调用函数](#82-调用函数)
      - [8.2.1 函数调用](#821-函数调用)
      - [8.2.2 方法调用](#822-方法调用)
      - [8.2.3 构造函数调用](#823-构造函数调用)
      - [8.2.4 间接调用](#824-间接调用)
      - [8.2.5 隐式函数调用](#825-隐式函数调用)
    - [8.3 函数实参与形参](#83-函数实参与形参)
      - [8.3.1 可选形参与默认值](#831-可选形参与默认值)
      - [8.3.2 剩余形参与可变长度实参列表](#832-剩余形参与可变长度实参列表)
      - [8.3.3 Arguments 对象](#833-arguments-对象)
      - [8.3.4 在函数调用中使用扩展操作符](#834-在函数调用中使用扩展操作符)
      - [8.3.5 把函数实参解构为形参](#835-把函数实参解构为形参)
      - [8.3.6 参数类型](#836-参数类型)
    - [8.4 函数作为值](#84-函数作为值)
      - [8.4.1 定义自己的函数属性](#841-定义自己的函数属性)
    - [8.5 函数作为命名空间](#85-函数作为命名空间)
    - [8.6 闭包](#86-闭包)
    - [8.7 函数属性、方法与构造函数](#87-函数属性-方法与构造函数)
      - [8.7.1 length 属性](#871-length-属性)
      - [8.7.2 name 属性](#872-name-属性)
      - [8.7.3 prototype 属性](#873-prototype-属性)
      - [8.7.4 call() 和 apply() 方法](#874-call-和-apply-方法)
      - [8.7.5 bind() 方法](#875-bind-方法)
      - [8.7.6 toString() 方法](#876-tostring-方法)
      - [8.7.7 Function() 构造函数](#877-function-构造函数)
    - [8.8 函数式编程](#88-函数式编程)
      - [8.8.1 使用函数处理数组](#881-使用函数处理数组)
      - [8.8.2 高阶函数](#882-高阶函数)
      - [8.8.3 函数的部分应用](#883-函数的部分应用)
      - [8.8.4 函数记忆](#884-函数记忆)
  - [九. 类](#九-类)
    - [9.1 类和原形](#91-类和原形)
    - [9.2 类和构造函数](#92-类和构造函数)
      - [9.2.1 构造函数、类标识和 instanceof](#921-构造函数-类标识和-instanceof)
      - [9.2.2 constructor 属性](#922-constructor-属性)
    - [9.3 使用 class 关键字的类](#93-使用-class-关键字的类)
      - [9.3.1 静态方法](#931-静态方法)
      - [9.3.2 获取方法、设置方法及其他形式的方法](#932-获取方法-设置方法及其他形式的方法)
      - [9.3.3 公有、私有和静态字段](#933-公有-私有和静态字段)
      - [9.3.4 示例:复数类](#934-示例复数类)
    - [9.4 为已有类添加方法](#94-为已有类添加方法)
    - [9.5 子类](#95-子类)
      - [9.5.1 子类与原型](#951-子类与原型)
      - [9.5.2 通过 extends 和 super 创建子类](#952-通过-extends-和-super-创建子类)
      - [9.5.3 委托而不是继承](#953-委托而不是继承)
      - [9.5.4 类层次与抽象类](#954-类层次与抽象类)
  - [十. 模块](#十-模块)
    - [10.1 基于类、对象和闭包的模块](#101-基于类-对象和闭包的模块)
      - [10.1.1 基于闭包的自动模块化](#1011-基于闭包的自动模块化)
    - [10.2 Node 中的模块](#102-node-中的模块)
      - [10.2.1 Node 的导出](#1021-node-的导出)
      - [10.2.2 Node 的导入](#1022-node-的导入)
    - [10.3 ES6 中的模块](#103-es6-中的模块)
      - [10.3.1 ES6 的导出](#1031-es6-的导出)
      - [10.3.2 ES6 的导入](#1032-es6-的导入)
      - [10.3.3 导入和导出时重命名](#1033-导入和导出时重命名)
      - [10.3.4 再导出](#1034-再导出)
      - [10.3.5 在网页中使用 JS 模块](#1035-在网页中使用-js-模块)
      - [10.3.6 通过 import() 动态导入](#1036-通过-import-动态导入)
      - [10.3.7 import.meta.url](#1037-importmetaurl)
  - [十一. JS 标准库](#十一-js-标准库)
    - [11.1 集合与映射](#111-集合与映射)
      - [11.1.1 Set 类](#1111-set-类)
      - [11.1.2 Map 类](#1112-map-类)
      - [11.1.3 WeakMap 和 WeakSet](#1113-weakmap-和-weakset)
    - [11.2 定型数组与二进制数据](#112-定型数组与二进制数据)
      - [11.2.1 定型数组的类型](#1121-定型数组的类型)
      - [11.2.2 创建定型数组](#1122-创建定型数组)
      - [11.2.3 使用定型数组](#1123-使用定型数组)
      - [11.2.4 定型数组的方法与属性](#1124-定型数组的方法与属性)
      - [11.2.5 Date View 与字节序](#1125-date-view-与字节序)
    - [11.3 正则表达式与模式匹配](#113-正则表达式与模式匹配)
      - [11.3.1 定义正则表达式](#1131-定义正则表达式)
      - [11.3.2 模式匹配的字符串方法](#1132-模式匹配的字符串方法)
      - [11.3.3 RegExp 类](#1133-regexp-类)
    - [11.4 日期与时间](#114-日期与时间)
      - [11.4.1 时间戳](#1141-时间戳)
      - [11.4.2 日期计算](#1142-日期计算)
      - [11.4.3 格式化与解析日期字符串](#1143-格式化与解析日期字符串)
    - [11.5 Error 类](#115-error-类)
    - [11.6 JSON 序列化与解析](#116-json-序列化与解析)
      - [11.6.1 JSON 自定义](#1161-json-自定义)
    - [11.7 国际化 API](#117-国际化-api)
      - [11.7.1 格式化数值](#1171-格式化数值)
      - [11.7.2 格式化日期和时间](#1172-格式化日期和时间)
      - [11.7.3 比较字符串](#1173-比较字符串)
    - [11.8 控制台 API](#118-控制台-api)
      - [11.8.1 通过控制台格式化输出](#1181-通过控制台格式化输出)
    - [11.9 URL API](#119-url-api)
      - [11.9.1 遗留 URL 函数](#1191-遗留-url-函数)
    - [11.10 计时器](#1110-计时器)
  - [十二. 迭代器与生成器](#十二-迭代器与生成器)
    - [12.1 迭代器原理](#121-迭代器原理)
    - [12.2 实现可迭代对象](#122-实现可迭代对象)
      - [12.2.1 “关闭” 迭代器：return() 方法](#1221-关闭-迭代器return-方法)
    - [12.3 生成器](#123-生成器)
      - [12.3.1 生成器的示例](#1231-生成器的示例)
      - [12.3.2 `yield*` 与递归生成器](#1232-yield-与递归生成器)
    - [12.4 高级生成器特性](#124-高级生成器特性)
      - [12.4.1 生成器函数的返回值](#1241-生成器函数的返回值)
      - [12.4.2 yield 表达式的值](#1242-yield-表达式的值)
      - [12.4.3 生成器的 return() 和 throw() 方法](#1243-生成器的-return-和-throw-方法)
  - [十三. 异步 JS](#十三-异步-js)
    - [13.1 使用回调的异步编程](#131-使用回调的异步编程)
      - [13.1.1 事件](#1311-事件)
      - [13.1.2 网络事件](#1312-网络事件)
      - [13.1.3 Node 中的回调与事件](#1313-node-中的回调与事件)
    - [13.2 期约](#132-期约)
      - [13.2.1 使用期约](#1321-使用期约)
      - [13.2.2 期约链](#1322-期约链)
      - [13.2.3 解决期约](#1323-解决期约)
      - [13.2.4 再谈期约和错误](#1324-再谈期约和错误)
      - [13.2.5 并行期约](#1325-并行期约)
      - [13.2.6 创建期约](#1326-创建期约)
      - [13.2.7 串行期约](#1327-串行期约)
    - [13.3 async 和 await](#133-async-和-await)
      - [13.3.1 await 表达式](#1331-await-表达式)
      - [13.3.2 async 函数](#1332-async-函数)
      - [13.3.3 等候多个期约](#1333-等候多个期约)
      - [13.3.4 实现细节](#1334-实现细节)
    - [13.4 异步迭代](#134-异步迭代)
      - [13.4.1 for/await 循环](#1341-forawait-循环)
      - [13.4.2 异步迭代器](#1342-异步迭代器)
      - [13.4.3 异步生成器](#1343-异步生成器)
      - [13.4.4 实现异步迭代器](#1344-实现异步迭代器)
  - [十四. 元编程](#十四-元编程)
    - [14.1 属性的特性](#141-属性的特性)
    - [14.2 对象的可扩展能力](#142-对象的可扩展能力)
    - [14.3 prototype 特性](#143-prototype-特性)
    - [14.4 公认符号](#144-公认符号)
      - [14.4.1 Symbol.iterator 和 Symbol.asyncIterator](#1441-symboliterator-和-symbolasynciterator)
      - [14.4.2 Symbol.hasInstance](#1442-symbolhasinstance)
      - [14.4.3 Symbol.toStringTag](#1443-symboltostringtag)
      - [14.4.4 Symbol.species](#1444-symbolspecies)
      - [14.4.5 Symbol.isConcatSpreadable](#1445-symbolisconcatspreadable)
      - [14.4.6 模式匹配符号](#1446-模式匹配符号)
      - [14.4.7 Symbol.toPrimitive](#1447-symboltoprimitive)
      - [14.4.8 Symbol.unscopables](#1448-symbolunscopables)
    - [14.5 模板标签](#145-模板标签)
    - [14.6 反射 API](#146-反射-api)
    - [14.7 代理对象](#147-代理对象)
      - [14.7.1 代理不变式](#1471-代理不变式)
  - [十五. 浏览器中的 JS](#十五-浏览器中的-js)
    - [15.1 web 编程基础](#151-web-编程基础)
      - [15.1.1 HTML `<script>` 标签中的 JS](#1511-html-script-标签中的-js)
      - [15.1.2 文档对象模型](#1512-文档对象模型)
      - [15.1.3 浏览器中的全局对象](#1513-浏览器中的全局对象)
      - [15.1.4 脚本共享一个命名空间](#1514-脚本共享一个命名空间)
      - [15.1.5 JS 程序的执行](#1515-js-程序的执行)
      - [15.1.6 程序输入与输出](#1516-程序输入与输出)
      - [15.1.7 程序错误](#1517-程序错误)
      - [15.1.8 Web 安全模型](#1518-web-安全模型)
    - [15.2 事件](#152-事件)
      - [15.2.1 事件类别](#1521-事件类别)
      - [15.2.2 注册事件处理程序](#1522-注册事件处理程序)
      - [15.2.3 调用事件处理程序](#1523-调用事件处理程序)
      - [15.2.4 事件传播](#1524-事件传播)
      - [15.2.5 事件取消](#1525-事件取消)
      - [15.2.6 派发自定义事件](#1526-派发自定义事件)
    - [15.3 操作 DOM](#153-操作-dom)
      - [15.3.1 选择 Document 元素](#1531-选择-document-元素)
      - [15.3.2 文档结构与遍历](#1532-文档结构与遍历)
      - [15.3.3 属性](#1533-属性)
      - [15.3.4 元素内容](#1534-元素内容)
      - [15.3.5 创建、插入和删除节点](#1535-创建-插入和删除节点)
      - [15.3.6 示例：生成目录](#1536-示例生成目录)
    - [15.4 操作 CSS](#154-操作-css)
      - [15.4.1 CSS 类](#1541-css-类)
      - [15.4.2 行内样式](#1542-行内样式)
      - [15.4.3 计算样式](#1543-计算样式)
      - [15.4.4 操作样式表](#1544-操作样式表)
      - [15.4.5 CSS 动画与事件](#1545-css-动画与事件)
    - [15.5 文档几何与滚动](#155-文档几何与滚动)
      - [15.5.1 文档坐标与视口坐标](#1551-文档坐标与视口坐标)
      - [15.5.2 查询元素的几何大小](#1552-查询元素的几何大小)
      - [15.5.3 确定位于某一点的元素](#1553-确定位于某一点的元素)
      - [15.5.4 滚动](#1554-滚动)
      - [15.5.5 视口大小、内容大小和滚动位置](#1555-视口大小-内容大小和滚动位置)
    - [15.6 Web 组件](#156-web-组件)
      - [15.6.1 使用 Web 组件](#1561-使用-web-组件)
      - [15.6.2 HTML 模板](#1562-html-模板)
      - [15.6.3 自定义元素](#1563-自定义元素)
      - [15.6.4 影子 DOM](#1564-影子-dom)
      - [15.6.5 示例：<search-box> Web 组件](#1565-示例search-box-web-组件)
    - [15.7 可伸缩矢量图形](#157-可伸缩矢量图形)
      - [15.7.1 在 HTML 中使用 SVG](#1571-在-html-中使用-svg)
      - [15.7.2 编程操作 SVG](#1572-编程操作-svg)
      - [15.7.3 通过 JS 创建 SVG 图片](#1573-通过-js-创建-svg-图片)
    - [15.8 `<canvas>` 与图形](#158-canvas-与图形)
      - [15.8.1 路径与多边形](#1581-路径与多边形)
      - [15.8.2 画布大小与坐标](#1582-画布大小与坐标)
      - [15.8.3 图形属性](#1583-图形属性)
      - [15.8.4 画布绘制操作](#1584-画布绘制操作)
      - [15.8.5 坐标系变换](#1585-坐标系变换)
      - [15.8.6 剪切](#1586-剪切)
      - [15.8.7 像素操作](#1587-像素操作)
    - [15.9 Audio APl](#159-audio-apl)
      - [15.9.1 Audio() 构造函数](#1591-audio-构造函数)
      - [15.9.2 WebAudio APl](#1592-webaudio-apl)
    - [15.10 位置、导航与历史](#1510-位置-导航与历史)
      - [15.10.1 加载新文档](#15101-加载新文档)
      - [15.10.2 浏览历史](#15102-浏览历史)
      - [15.10.3 使用 hashchange 事件管理历史](#15103-使用-hashchange-事件管理历史)
      - [15.10.4 使用 pushState() 管理历史](#15104-使用-pushstate-管理历史)
    - [15.11 网络](#1511-网络)
      - [15.11.1 fetch()](#15111-fetch)
      - [15.11.2 服务器发送事件](#15112-服务器发送事件)
      - [15.11.3 Web Socket](#15113-web-socket)
    - [15.12 存储](#1512-存储)
      - [15.12.1 localStorage 和 sessionStorage](#15121-localstorage-和-sessionstorage)
      - [15.12.2 cookie](#15122-cookie)
      - [15.12.3 IndexedDB](#15123-indexeddb)
    - [15.13 工作线程与消息传递](#1513-工作线程与消息传递)
      - [15.13.1 Worker 对象](#15131-worker-对象)
      - [15.13.2 工作线程中的全局对象](#15132-工作线程中的全局对象)

<!-- /code_chunk_output -->

# JavaScript 权威指南

## 一. 基础

### 1.1 方法与函数的区别

**通过对象使用函数时，称其为方法**，所有的 JS 对象都有方法。

### 1.2 JS 支持面向对象的编程风格

JS 支持面向对象的编程风格，但与 “经典的” 面向对象编程语言非常不一样。

```js
// 定义 Point 类以表示几何平面上的一个点，作为这个类的实例的对象有一个方法，叫做 distance()，用于计算该点与原点的距离
// 按惯例，类名需要首字母大写
class Point {
  // 构造函数用于初始化新实例
  constructor(x, y) {
    this.x = x; // this 关键字代表要初始化的新对象
    this.y = y; // 将函数参数保存为对象属性
  } // 构造函数中不需要 return 语句

  distance() {
    // 计算从原点到当前点的距离的方法
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
}

// 使用 Point() 构造函数和 new 创建 Point 对象
let p = new Point(1, 1); // 几何平面上的点

// 调用 Point 对象 p 的方法
p.distance(); // Math.SQRT2
```

### 1.3. 使用 JS 分析文件中的字符频率

这个 [Node 程序](./examples/charFreq.js) 使用标准输入读取文本，计算该文本的 _字符频率柱形图_ 和 _总字符数_，然后打印出来。

```js
node charFreq.js < ../JavaScript权威指南.md
```

## 二. 词法结构

**编程语言的词法结构是一套基本规则，规定了如何使用这门编程语言编写程序**。词法结构是一门语言最低级的语法，规定了变量如何命名、注释的界定符，以及如何分隔程序的语句。

### 2.1 字面量含义

字面量（literal）是一种直接出现在程序中的数据值。

### 2.2 JS 标识符命名规则

JS 标识符必须以字母、下划线 `_` 或美元符号 `$` 开头。后续字符可以是字母、数字、`_` 或 `$`（**数字不能作为第一个字符，以便 JS 区分标识符和数值**）。

### 2.3 Unicode 转义序列

为了方便程序员编码和支持老技术的系统，JS 定义了转义序列，从而可以仅使用 ASCII 字符来表示 Unicode 字符。有两种方式来表示：

- 已 `\u` 开头，后跟 4 位十六进制数字（包括大小写的 A~F）

- 包含在一对花括号中内的 1~6 位十六进制数字。ES6 新增，为了更好的支持大于 16 位的 Unicode 码点，比如表情符号

  ```js
  console.log('\u{1F600}'); // 打印一个笑脸符号
  ```

### 2.4 箭头函数的 `=>` 必须跟参数列表在同一行

## 三. 类型、值和变量

### 3.1 数值

#### 3.1.1 整数字面量支持的进制表示

- 以 `0x` 或 `0X` 开头，后跟一个十六进制数字字符串。

- ES6 及以后的版本中，也可以通过二进制或八进制表示整数，分别使用前缀 `0b` 和 `0o`。

#### 3.1.2 数值字面量中的分隔符

可以使用下划线将数值字面量分隔为容易看清的数字段。

```js
let billion = 1_000_000_000; // 以下划线作为千分位分隔符
let bytes = 0x89_ab_cd_ef; // 作为字节分隔符
let bits = 0b0001_1101_0111; // 作为半字节分隔符
let fraction = 0.123_456_789; // 也可以使用小数部分
```

> 这个特性暂时没有成为 JS 标准，但已经进入标准化流程的后期，而且已经被所有主流浏览器以及 Node 实现了。

#### 3.1.3 JS 通过 Math 对象提供了一组函数和常量，以支持更复杂的数学计算

```js
// 9007199254740992: 2的53次方
Math.pow(2, 53);
// 1.0: 舍入到最接近的整数
Math.round(0.6);
// 1.0: 向上舍入到一个整数
Math.ceil(0.6);
// 0.0: 向下舍入到一个整数
Math.floor(0.6);
// 5: 绝对值
Math.abs(-5);
// 返回最大的参数
Math.max(x, y, z);
// 返回最小的参数
Math.min(x, y, z);
// 伪随机数 x,范围 0 <= x < 1.0
Math.random();
// π 圆周率
Math.PI;
// 自然对数的底数
Math.E;
// 3**0.5: 3的平方根
Math.sqrt(3);
// 3**(1/3): 3的立方根
Math.pow(3, 1 / 3);
// 三角函数，还有 Math.cos、Math.atan 等
Math.sin(0);
// 10 的自然对数
Math.log(10);
// 以 10 为底 100 的对数
Math.log(100) / Math.LN10;
// 以 2 为底 512 的对数
Math.log(512) / Math.LN2;
// Math.E 的立方
Math.exp(3);
```

ES6 在 Math 对象上又定义了一批函数

```js
// 3: 立方根
Math.cbrt(27);
// 5: 所有参数平方和的平方根
Math.hypot(3, 4);
// 2: 以 10 为底的对数
Math.log10(100);
// 10：以 2 为底的对数
Math.log2(1024);
// (1+x) 的自然对数；精确到非常小的x
Math.log1p(x);
// Math.exp(x)-1; Math.log1p() 的逆运算
Math.expm1(1);
// 对 <、== 或 >0 的参数返回 -1、0 或 1
Math.sign(x);
// 6：优化的32位整数乘法
Math.imul(2, 3);
// 28: 32位整数中前导 0 的位数
Math.clz32(0xf);
// 3: 减掉小数部分得到整数
Math.trunc(3.9);
// 舍入到最接近的 32 位浮点数
Math.fround(x);
// 双曲线正弦，还有 Math.cosh() 和 Math.tanh()
Math.sinh(x);
// 双曲线反正弦，还有 Math.acosh() 和 Math.atanh()
Math.asinh(x);
```

#### 3.1.4 Number ES6 新增属性

```js
// 同全局 parseInt() 函数
Number.parseInt();
// 同全局 parseFloat() 函数
Number.parseFloat();
Number.isNaN(x);
Number.isFinite(x);
// 判断 x 是不是整数
Number.isInteger(x);
// -(2**53 - 1)
Number.MIN_SAFE_INTEGER;
// 2**53 -1
Number.MAX_SAFE_INTEGER;
// 数值与数值之间最小的差
Number.EPSILON;
```

#### 3.1.5 通过 BigInt 表示任意精度整数

ES2020 为 JS 定义了一种新的数值类型 BigInt。之所以增加了这个类型，**主要是为了表示 64 位整数，这对于兼容很多其他语言和 API 是必需的**。

BigInt 字面量写作一串数字后跟小写字母 `n`。默认情况下，进制是 10，但也可以通过前缀 `0b`、`0o`、`0x` 来表示二进制、八进制和十六进制 BigInt。

```js
1234n;
0b11241n; // 二进制 BigInt
0o777n; // 八进制 BigInt
```

可以使用 `BigInt()` 函数把常规 JS 数值或字符串转换为 BigInt 值。

```js
BigInt(123); // 123n
let string = '1' + '0'.repeat(100);
BigInt(string); // 10n**100n: 一个天文数字
```

> **注意**：
>
> 1. 算术操作符不能混用 BigInt 操作数和常规数值操作数。
> 2. 比较操作符允许混用操作数类型。
> 3. 位操作符通常可以用于 BigInt 操作数。
> 4. Math 对象的任何函数都不接受 BigInt 操作数。

### 3.2 文本

JS 中表示文本的类型是 String，即字符串。字符串是 16 位值的不可修改的有序序列，其中每个值都表示一个 Unicode 字符。

#### 3.2.1 使用字符串

```js
let s = 'Hello，world';

// 取得字符串的一部分
s.substring(1, 4); // "ell": 第 2~4 个字符
s.slice(1, 4); // "ell": 同上
s.slice(-3); // rld: 最后 3 个字符
s.split(', '); // ["hello", "world"]: 从界定符处拆开

// 搜索字符串
s.indexOf('l'); // 2: 第一个字母 l 的位置
s.indexOf('l', 3); // 3: 位置3后面第一个 "l" 的位置
s.indexOf('zz'); // -1: s 并不包含子串 "zz"
s.lastIndexOf('l'); // 10: 最后一个字母 "l" 的位置

// ES6 及之后版本中的布尔值搜索函数
s.startsWith('Hell'); // true：字符串是以这些字符开头的
s.endWith('!'); // false：s 不是以它结尾的
s.includes('or'); // true: s 包含子串 "or"

// 创建字符串的修改版本
s.replace('llo', 'ya'); // "Heya, world"
s.toLowerCase(); // "hello，world"
s.toUpperCase(); // "HELLO，WORLD"
s.normalize(); // Unicode NFC 归一化：ES6 新增
s.normalize('NFD'); // NFD 归一化。还有 "NFKC" "NFKD"

// 访问字符串中的个别（16位值）字符
s.charAt(0); // "H": 第一个儿字符
s.charAt(s.length - 1); // "d"：最后一个字符
s.charCodeAt(0); // 72：指定位置的16位数值
s.codePointAt(0); // 72: ES6，适用于码点大于 16 位的情况

// ES2017 新增的字符串填充函数
'x'.padStart(3); // "  x"：在左侧添加空格，让字符串长度变成 3
'x'.padEnd(3); // "x  ": 在右侧添加空格，让字符串长度变成 3
'x'.padStart(3, '*'); // "**x"：在左侧添加星号，让字符串长度变成 3
'x'.padEnd(3, '-'); // "x--"：在右侧添加破折号，让字符串长度变成 3

// 删除空格函数，trim() 是 ES5 就有的，其他是 ES2019 增加的
' test'.trim(); // "test"：删除开头和结尾的空格
' test'.trimStart(); // "test "：删除左侧空格。也叫 trimLeft
' test '.trimEnd(); // " test"：删除右侧空额。也叫 trimRight

// 未分类字符串方法
s.concat('!'); // "Hello，world!"：可以用 + 操作符代替
'<>'.repeat(3); // "<><><>"：拼接 n 次，ES6 新增
```

> **注意**：JS 中的字符串是不可修改的，像 `replace()` 这样的方法都是返回的新字符串，它们并不会修改调用它们的字符串。

#### 3.2.2 模板字符串

**标签化模板字面量**
模板字面量有一个强大但不太常用的特性，如果在开头的反引号前面有一个函数名（标签），那么模板字面量中的文本和表达式的值将作为参数传给这个函数。这个特性可以用于先对某些值进行 HTML 或 SQL 转义，然后在把它们插入文本中。

ES6 提供了一个内置的标签函数：`String.row()`。这个函数返回反引号中未经处理的文本，即不会处理任何反斜杠转义。

```js
`\n`.length; // 1: 字符串中只包含一个换行符
String.raw`\n`.length; // 2: 一个反写杠字符和一个字母 n
```

> **注意**：即使标签化模板字面量的标签部分是函数，在调用这个函数时也没有圆括号。在这种特殊的情况下，反引号字符充当开头和结尾的圆括号。

### 3.3 null 与 undefined

- `undefined`：可以表示一种系统级别、意料之外或类似错误的没有值。

- `null`：可以表示程序级别，正常或意料之外的没有值。

### 3.4 Symbol

**符号（Symbol）是 ES6 新增的一种原始类型。用作非字符串的属性名**。要理解 Symbol，需要了解 JS 的基础类型 Object 是一个属性的无序集合，其中每一个属性都有一个名字和一个值。属性名通常是字符串。但在 ES6 及之后的版本中，Symbol 也可以作为属性名：

```js
let strname = 'string name'; // 可以用作属性名的字符串
let symname = Symbol('propname'); // 可以用作属性名的符号
typeof strname; // string：strname 是字符串
typeof symname; // Symbol：symname 是符号
let o = {}; // 创建一个新对象
// 使用字符串名顶一个属性
o[strname] = 1;
// 使用符号名定义一个属性
o[symname] = 2;
o[strname]; // 1
o[symname]; // 2
```

Symbol 类型没有字面量语法。要获取一个 Symbol 值，需要调用 `Symbol()` 函数。这个函数永远不会返回相同的值，即使每次传入的参数都一样。这意味着可以将调用 `Symbol()` 取得的符号值安全地用于为对象添加属性，而无需担心可能重写已有的同名属性。

如果定义了 Symbol 属性但没有共享相关 Symbol，也可以确信程序中的其他代码不会意外重写这个属性。

实践中，Symbol 通常作为一种语言扩展机制。ES6 新增了 [for/of 循环](../JavaScript.md#4354-forof-循环)和[可迭代对象](#十二-迭代器与生成器)，为此就需要定义一种标准的机制让类可以实现，从而把自身变得可迭代。但选择任何特定的字符串作为这个迭代器方法的名字都有可能破坏已有的代码。为此，Symbol 应运而生，`Symbol.iterator` 是一个符号值，可以作一个方法名，让对象变得可迭代。

`Symbol()` 函数可选地接收一个字符串参数，返回唯一的符号值。如果提供了字符串参数，那么调用返回符号值的 `toString()` 方法得到的结果中会包含该字符串。

为了定义一些可以与其他代码共享的 Symbol 值，JS 定义了一个全局符号注册表。`Symbol.for()` 函数接收一个字符串参数，返回一个与该字符串关联的符号值。如果没有 Symbol 与该字符串关联，则会创建并返回一个新 Symbol；否则，会返回已有的 Symbol。

`Symbol.for()` 与 `Symbol()` 完全不同：`Symbol()` 永远不会返回相同的值。而在以相同字符串调用 `Symbol.for()` 时始终返回相同的值。传给 `Symbol.for()` 的字符串会出现在 `toString()` 的输出中。而且，这个字符串也可以通过将返回的符号传给 `Symbol.keyFor()` 来得到：

```js
let s = Symbol.for('shared');
let t = Symbol.for('shared');
s === t; // true
s.toString(); // "Symbol(shared)"
Symbol.keyFor(t); // "shared"
```

### 3.5 类型转换

| 值                 | 转换为字符串                              | 转换为数值                                | 转换为布尔值 |
| ------------------ | ----------------------------------------- | ----------------------------------------- | ------------ |
| undefined          | "undefined"                               | NaN                                       | false        |
| null               | "null"                                    | 0                                         | false        |
| true               | "true"                                    | 1                                         | -            |
| false              | "false"                                   | 0                                         | -            |
| ""(空字符串)       | -                                         | 0                                         | false        |
| "1.2"(非空,数值)   | -                                         | 1.2                                       | true         |
| "one"(非空,非数值) | -                                         | NaN                                       | true         |
| 0                  | "0"                                       | -                                         | false        |
| -0                 | "0"                                       | -                                         | false        |
| 1(有限,非零)       | "1"                                       | -                                         | true         |
| Infinit            | "Infinity"                                | -                                         | true         |
| -Infinity          | "-Infinity""                              | -                                         | true         |
| NaN                | "NaN"                                     | -                                         | false        |
| {}(任何对象)       | [对象到原始值转换](#342-对象到原始值转换) | [对象到原始值转换](#342-对象到原始值转换) | true         |
| [](空数组)         | ""                                        | 0                                         | true         |
| [9]                | "9"                                       | 9                                         | true         |
| ["a"]              | 使用 `join()` 方法                        | NaN                                       | true         |
| Function(){}       | [对象到原始值转换](#342-对象到原始值转换) | NaN                                       | true         |

#### 3.4.1 显式转换

除了 `null` 和 `undefined` 之外的所有值都有 `toString()` 方法。

在使用金融或科学数据时，可能需要控制转换后得到的字符串的小数位的个数或者有效数字的个数，或者需要控制是否采用指数记数法。Number 类为这些数值到字符串的转换定义了 3 种方法：

- `toFixed()`：把数值转换为字符串时可以指定小数点后面的位数。这个方法不使用指数记数法。
- `toExponential()`：使用指数记数法将数值转换为字符串，结果是小数点前 1 位，小数点后为指定位数（意味着有效数字个数比指定的值多 1 位）。
- `toPrecision()`：按照指定的有效数字个数将数值转换为字符串。如果有效数字个数不足以显示数值的整数部分，它会使用指数记数法。

> **注意**：这三种方法必要时都会舍去末尾的数字或者补零。

```js
let n = 123456.789;
n.toFixed(o); // "123457"
n.toFixed(2); // "123456.79"
n.toFixed(5); // "123456.78900"

n.toExponential(1); // "1.2e+5"
n.toExponential(3); // "1.235e+5"

n.toPrecision(4); // "1.235e+5"
n.toPrecision(7); // "123456.8"
n.toPrecision(10); // "123456.789"
```

除了这里介绍的数值格式化方法，[`Intl.NumberFormat` 类](#1171-格式化数值)定义了一个更通用、更国际化的数值格式化方法。

#### 3.4.2 对象到原始值转换

JS 对象到原始值转换的复杂性，主要原因在于某些对象类型有不止一种原始值的表示。比如，Date 对象可以用字符串表示，也可以用时间戳表示。JS 规范定义了对象到原始值转换的 3 种基本算法。

**偏字符**
: 该算法返回原始值，而且只要可能就返回字符串

**偏数值**
: 该算法返回原始值，而且只要可能就返回数值

**无偏好**
: 该算法不倾向于任何原始值类型，而是由类定义自己的转换规则。**JS 内置类型除了 Date 类都实现了偏数值算法。Date 类实现了偏字符串算法**。

- **对象转换为布尔值**
  对象到布尔值的转换很简单: 所有对象都转换为 true。

  > **注意**：这个转换不需要使用对象到原始值的转换算法，而是直接适用于所有对象。包括空数组，甚至包括 `new Boolean(false)` 这样的包装对象。

- **对象转换为字符串**
  在将对象转换为字符串时，JS 首先使用偏字符串算法将它转换为一个原始值，然后将得到的原始值再转换为字符串。
  这种转换会发生在把对象传给一个接收字符串参数的内置函数时，比如将 `String()` 作为转换函数，或者将对象插入模板字面量中时就会发生这种转换。

- **对象转换为数值**
  当需要把对象转换为数值时，JS 首先使用偏数值算法将它转换为一个原始值，然后将得到的原始值再转换为数值。
  接收数值参数的内置 JS 函数和方法都以这种方式将对象转换为数值，而除数值操作符之外的多数（参见下面的例外情况）JS 操作符也按照这种方式把对象转换为数值。

**操作符转换特例**：

- JS 中的 `+` 操作符执行数值加法和字符串拼接。

  - 如果一个操作数是对象，那 JS 会使用无偏好算法将对象转换为原始值。
  - 如果两个操作数都是原始值，则会先检查它们的类型。如果有一个参数是字符串，则把另一个原始值也转换为字符串并拼接两个字符串。否则，把两个参数都转换为数值并把它们相加。

- `==` 和 `!=` 操作符以允许类型转换的宽松方式执行相等和不相等测试。
  如果一个操作数是对象，另一个操作数是原始值，则这两个操作符会使用无偏好算法将对象转换为原始值，然后再比较两个原始值。

- 关系操作符 `<`、`<=`、`>` 和 `>=` 比较操作数的顺序，既可以比较数值，也可以比较字符串。如果操作数中有一个是对象，则会使用偏数值算法将对象转换为原始值。

  > **注意**：与对象到数值转换不同，这个偏数值算法返回的原始值不会再被转换为数值。

> **注意**：Date 对象的数值表示是可以使用 `<` 和 `>` 进行有意义的比较的，但它的字符串表示则不行。对于 Date 对象，无偏好算法会将其转换为字符串，而 JS 中这两个操作符会使用偏数值算法的事实意味着可以比较两个 Date 对象的顺序。

**`toString()` 和 `valueOf()` 方法**

所有对象都会继承两个在对象到原始值转换时使用的方法，在接下来解释偏字符串、偏数值和无偏好转换算法前，必须先解释这两个方法：

- `tostring()`
  返回对象的字符串表示。默认情况下，`tostring()` 方法不会返回特别的值:

  ```js
  ({ x: 1, y: 23 }.toString()); // [object Object]
  ```

  很多类都定义了自己特有的 `toString()` 版本。比如：

  - Array 类的 `toString()` 方法会将数组的每个元素转换为字符串，然后再使用逗号作为分隔符将它们拼接起来。
  - Function 类的 `tostring()` 方法会将用户定义的函数转换为 JS 源代码的字符串。
  - Date 类定义的 `toString()` 方法返回一个人类友好（且 JS 可解析）的日期和时间字符串。
  - RegExp 类定义的 `toString()` 方法会将 RegExp 对象转换为一个看起来像 RegExp 字面量的字符串。

  ```js
  [1, 2, 3].toString(); // "1,2,3"

  (function (x) {
    f(x);
  }.toString()); // "function(x) { f(x); }"

  /\d+/g.toString(); // "/\\d+/g"

  let d = new Date(2020, 0, 1);
  d.toString(); // "Wed Jan 01 2020 00:00:00 GMT+0800 (GMT+08:00)"
  ```

- `valueOf()`
  这个方法的任务并没有太明确的定义，大体上可为认为它是把对象转换为代表对象的原始值（如果存在这样一个原始值）。
  对象是复合值且多数对象不能真正通过一个原始值来表示，因此 `valueOf()` 方法默认情况下只返回对象本身，而非返回原始值。

  - String、Number 和 Boolean 这样的包装类定义的 `valueOf()`方法也只是简单地返回被包装的原始值。
  - Array、Function 和 RegExp 简单地继承默认方法。在这些类型的实例上调用 `valueOf()` 会返回对象本身。
  - Date 对象定义的 `valueOf()` 方法返回日期的内部表示形式: 自 1970 年 1 月 1 日至今的毫秒数:

    ```js
    Let d = new Date(2010, 0, 1);// January 1, 2010,(Pacific time)
    d.valueOf(); // 1262332800000
    ```

**对象到原始值转换算法**
解释完 `toString()` 和 `valueOf()` 方法后，现在可以大致地解释前面三个[对象到原始值转换算法的实现](#1447-symboltoprimitive)了。

- **偏字符串算法**

  - 首先尝试 `toString()` 方法。如果这个方法有定义且返回原始值，则 JS 使用该原始值（即使这个值不是字符串）。
  - 如果 `toString()` 不存在，或者存在但返回对象，则 JS 尝试 `valueOf()` 方法。
  - 如果这个方法存在且返回原始值，则 JS 使用该值。否则，转换失败，报 TypeError。

- **偏数值算法**
  与偏字符串算法类似，只不过是先尝试 `valueOf()` 方法，再尝试 `toString()` 方法。

- **无偏好算法**
  取决于被转换对象的类，如果是一个 Date 对象，则使用偏字符串算法。如果是其他类型的对象，则使用偏数值算法。

以上规则适用于所有内置 JS 类型，也是所有自定义类的默认规则。[Symbol.toPrimitive](#1447-symboltoprimitive)解释了如何在自定义类中定义自己的对象到原始值转换算法。

### 3.6 变量声明与赋值

1. `const` 必须在声明时初始化常量。

2. 如果声明位于顶级，且在任何代码块外部，则称其为**全局变量或常量**，具有全局作用域。

   - 在 Node 和[客户端 JS 模块](#十-模块)中，全局变量的作用域是定义它们的文件。

   - 在传统客户端 JS 中，全局变量的作用域是定义它们的 HTML 文档。
     如果有 `<script>` 标签声明了一个全局变量或常量，则该变量或常量在同一个文档的任何 `<script>` 元素中（或者至少在 `let` 和 `const` 语句执行之后执行的所有脚本中都有定义）。

3. `var` 与 `let` 的区别

   - 使用 `var` 声明的变量不具有块作用域。这种变量的作用城仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。

   - 如果在函数体外部使用 `var`，会声明一个全局变量。但通过 `var` 声明的全局变量与通过 `let` 声明的全局变量有一个重要区别。
     通过 `var` 声明的全局变量被实现为全局对象的属性。全局对象可以通过 `globalThis` 引用。
     通过全局 `var` 创建的这个属性不能使用 [delete 操作符](#473-delete-操作符)删除。

     > 通过 `let` 和 `const` 声明的全局变量和常量不是全局对象的属性。

   - 与通过 `let` 声明的变量不同，使用 `var` 多次声明同名变量是合法的。而且由于 `var` 变量具有函数作用域而不是块作用域，这种重新声明实际上是很常见的。
     变量 i 经常用于保存整数值，特别是经常用作 for 循环的索引变量。在有多个 for 循环的函数中,每个循环通常都以 `for(var i=0;...` 开头。因为 `var` 并不会把这些变量的作用域限定在循环体内，每次循环都会（无害地）重新声明和重新初始化同一个变量。

   - `var` 声明的一个**最不同寻常的特性是作用域提升**（hoisting）。
     在使用 `var` 声明变量时，该声明会被提高到包含函数的顶部。但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。因此对使用 `var` 声明的变量，可以在包含函数内部的任何地方使用而不会报错。

     如果初始化代码尚未运行，则变量的值可能是 undefined，但在初始化之前是可以使用变量而不报错的，这会成为一个 bug 来源，也是 **`let` 要纠正的一个最重要的错误特性**。如果使用 `let` 声明了一个变量，但试图在 `let` 语句运行前使用该变量则会导致错误，而不是得到 undefined 值。

### 3.7 解构赋值

ES6 实现了一种复合声明与赋值语法，叫作**解构赋值**（destructuring assignment）。

在解构赋值中，等号右手端的值是数组或对象（“结构化”的值）左手端通过模拟数组或对象字面量语法指定一个或多个变量。在解构赋值发生时，会从右侧的值中提取（解构）出一个或多个值，并保存到左侧列出的变量中。

解构赋值可能最常用于在 `const`、`let` 或 `var` 声明语句中初始化变量，但也可以在**常规赋值表达式**中使用（给已声明的变量赋值）。解构也可以在**定义函数参数**时使用。

```js
let [x, y] = [1, 2]; // 相当于 let x=1, y=2
[x, y] = [x + 1, y + 1]; // 相当于 x = x + 1, y = y + 1
[x, y] = [y, x]; // 交换两个变量的值
[x, y]; // [3,2]: 递增和交换后的值
```

解构赋值让**使用返回数组的函数变得异常便捷**:

```js
// 将 [x,y] 坐标转换为 [r, theta] 极坐标
function toPoLar(x, y) {
  return [Math.sqrt(x * x + y * y), Math.atan2(y, x)];
}

// 将极坐标转换为笛卡儿坐标
function toCartesian(r, theta) {
  return [r * Math.cos(theta), r * Math.sin(theta)];
}

let [r, theta] = toPolar(1.0, 1.0); // r == Math. sqrt(2); theta == Math PI/4
let [x, y] = toCartesian(r, theta); // [x, y] == [1.0, 1.0]
```

可以在 JS 的各种 for 循环中声明变量和常量。同样也可以**在这个上下文中使用变量解构赋值**。下面这段代码循环遍历了一个对象所有属性的名/值，并使用解构赋值将两个元素的数组转换为单个变量:

```js
let o = { x: 1, y: 2 }; // 要遍历的对象

for (const [name, value] of Object.entries(o)) {
  console.log(name, value); // 打印"x 1"和"y 2"
}
```

> 解构赋值左侧变量的个数不一定与右侧数组中元素的个数相同。左侧多余的变量会被设置为 undefined，而右侧多余的值会被忽略。

**左侧的变量列表可以包含额外的逗号，以跳过右侧的某些值**:

```js
let [x, y] = [1]; // x == 1; y == undefined
[x, y] = [1, 2, 3]; // x == 1; y == 2
[, x, , y] = [1, 2, 3, 4]; // x == 2; y == 3
```

在解构赋值时，如果想把所有未使用或剩余的值收集到一个变量中，可以在左侧最后一个变量名前面加上 3 个点（...）：

```js
let [x, ...y] = [1, 2, 3, 4]; // y == [2,3,4]
```

**解构赋值可用于嵌套数组**。此时，赋值的左侧看起来也应该像一个嵌套的数组字面量:

```js
let [a, [b, c]] = [1, [2, 2.5], 3]; // a == 1; b == 2; c == 2.5
```

**数组解构的一个强大特性是它并不要求必须是数组**！实际上，赋值的右侧可以是任何[可迭代对象](#十二-迭代器与生成器)，任何可以在 [fo/of 循环](../JavaScript.md#4354-forof-循环)中使用的对象也可以被解构：

```js
let [first, ...rest] = 'Hello'; // first == "H"; rest == ["e", "l", "l", "o"]
```

解构赋值在右侧是对象值的情况下也可以执行。此时，赋值的左侧看起来就像一个对象字面量，即一个包含在花括号内的逗号分隔的变量名列表：

```js
let transparent = { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }; // 一个 RGBA 颜色对象
let { r, g, b } = transparent; // r == 0.0; g == 0.0; b == 0.0
```

下面这个例子展示了如何把 Math 对象的全局函数复制到变量中，这样可以简化需要大量三角计算的代码:

```js
// 相当于 const sin = Math.sin, cos=Math.cos, tan=Math.tan
const { sin, cos, tan } = Math;
```

> **注意**：代码中 Math 对象的属性远远不止解构赋值给个别变量的这 3 个。那些没有提到名字的属性都被忽略了。如果赋值的左侧包含一个不是 Math 属性的变量名，该变量将被赋值 undefined。

在上面每个对象解构的例子中，都选择了与要解构对象的属性一致的变量名。这可以保持语法简单且容易理解，但这并不是必需的。对象解构赋值左侧的每个标识符都可以是一个冒号分隔的标识符对，其中第一个标识符是要解构其值的属性名，第二个标识符是要把值赋给它的变量名：

```js
// 相当于 const cosine = Math.cos, tangent = Math.tan
const { cos: cosine, tan: tangent } = Math;
```

> **如果变量名和属性名不一样，对象解构语法会变得过于复杂，反而导致用处不大。建议不使用这种形式**。如果选择使用，要记住属性名一定是在冒号左侧，无论是在对象字面量中，还是在对象解构赋值的左侧。

在使用嵌套对象、对象的数组，或数组的对象时，解构赋值甚至会变得更复杂，但都是合法的:

```js
// 两个坐标点对象的数组
let points = [
  { x: 1, y: 2 },
  { x: 3, y: 4 }
];

let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = points; // 解构到 4 个变量中
x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4; // true
```

如果不是解构对象的数组，也可以解构数组的对象：

```js
let points = { p1: [1, 2], p2: [3, 4] }; // 有两个数组属性的对象

// 解构到 4 个变量中
let {
  p1: [x1, y1],
  p2: [x2, y2]
} = points;

x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4; // true
```

> 类似这样的复杂解构语法既难写又难理解，不建议使用。

## 四. 表达式与操作符

### 4.1 表达式

[JavaScript#-表达式语句](../JavaScript.md#44-表达式语句)

### 4.2 操作符

下表总结了所有操作符,可以作为一个参考。

> **注意**：多数操作符都以 `+` 和 `=` 这样的标点符号表示。不过，有一些也以 `delete` 和 `instanceof` 这样的关键字表示。关键字操作符也是常规操作符，与标点符号表示的操作符一样，只不过它们的语法没那么简短而已。

下表按操作符优先级组织：

- 表格前面的操作符比后面的操作符优先级更高。
- “结合性” 中的 “左” 表示 “从左到右执行”，“右” 表示 “从右到左执行”。
- “操作数” 表示操作数的个数。
- “类型” 表示操作数的类型，以及操作符的结果类型（`→` 后面）。

| 操作符                                                      | 操作                                           | 结合性 | 操作数 | 类型                 |
| ----------------------------------------------------------- | ---------------------------------------------- | ------ | ------ | -------------------- |
| ++                                                          | 先或后递增                                     | 右     | 1      | lval → num           |
| --                                                          | 先或后递减                                     | 右     | 1      | lval → num           |
| -                                                           | 负值                                           | 右     | 1      | num → num            |
| +                                                           | 转换为数值                                     | 右     | 1      | any → num            |
| ~                                                           | 反转二进制位                                   | 右     | 1      | int → int            |
| !                                                           | 反转布尔值                                     | 右     | 1      | bool → bool          |
| delete                                                      | 删除属性                                       | 右     | 1      | lval → bool          |
| typeof                                                      | 确定操作数类型                                 | 右     | 1      | any → str            |
| void                                                        | 返回 undefined                                 | 右     | 1      | any → undef          |
| \*\*                                                        | 幂                                             | 右     | 2      | num,num → num        |
| \*、/、%                                                    | 乘、除、取余                                   | 左     | 2      | num,num → num        |
| +、-                                                        | 加、减                                         | 左     | 2      | num,num → num        |
| +                                                           | 拼接字符串                                     | 左     | 2      | str, str → str       |
| <<                                                          | 左移位                                         | 左     | 2      | int,int → int        |
| >>                                                          | 右移位以符号填充                               | 左     | 2      | int,int → int        |
| >>>                                                         | 右移位以零填充                                 | 左     | 2      | int,int → int        |
| <、<=、>、>=                                                | 按数值顺序比较                                 | 左     | 2      | num,num → bool       |
| <、<=、>、>=                                                | 按字母表顺序比较                               | 左     | 2      | str,str → bool       |
| instanceof                                                  | 测试对象类                                     | 左     | 2      | obi,func → bool      |
| in                                                          | 测试属性是否存在                               | 左     | 2      | any,obj → bool       |
| ==                                                          | 非严格相等测试                                 | 左     | 2      | any,any → bool       |
| !=                                                          | 非严格不相等测试                               | 左     | 2      | any,any → bool       |
| ===                                                         | 严格相等测试                                   | 左     | 2      | any,any → bool       |
| !==                                                         | 严格不相等测试                                 | 左     | 2      | any,any → bool       |
| &                                                           | 计算按位与                                     | 左     | 2      | int,int → int        |
| ^                                                           | 计算按位异或                                   | 左     | 2      | int,int → int        |
| 竖杠                                                        | 计算按位或                                     | 左     | 2      | int,int → int        |
| &&                                                          | 计算逻辑与                                     | 左     | 2      | any,any → any        |
| 双竖杠                                                      | 计算逻辑或                                     | 左     | 2      | any,any → any        |
| ??                                                          | 选择第一个有定义的操作数，非 null 或 undefined | 左     | 2      | any, any → any       |
| ? :                                                         | 选择第二或第三个操作数                         | 右     | 3      | bool, any, any → any |
| =                                                           | 为变量或属性赋值                               | 右     | 2      | lval,any → any       |
| \*_=、_=、/=、%=、+=、-=、&=、^=、 竖杠等于、<<=、>>=、>>>= | 操作并赋值                                     | 右     | 2      | lval,any → any       |
| ,                                                           | 丢弃第一个操作数，返回第二个                   | 左     | 2      | any, any → any       |

> **注意**：表中列出的赋值操作符和少数其他操作符期待操作数类型为 `lval`。`lval` 即 lvalue（左值），是一个历史悠久的术语，意思是 “一个可以合法地出现在赋值表法式左侧的表达式”。在 JS 中，变量、对象属性和数组元素都是“左值”。

#### 4.2.1 操作符优先级

**JS 新增的操作符并不总是符合上表这个优先级模式**。比如在表中 [`??` 操作符](#471-空值合并运算符) `||` 和 `&&` 优先级低，而实际上它相对于这两个操作符的优先级并没有定义。

**ES2020 要求在混用 `??`和 `||` 或 `&&` 时使用必须使用圆括号**。类似地，新的幂操作符 `**` 相对于一元负值操作符的优先级也没有明确定义，因此在同时求负值和求幂时也必须使用圆括号。

#### 4.2.2 求值顺序

操作符的优先级和结合性规定了复杂表达式中操作的执行顺序，但它们没有规定子表达式的求值顺序。**JS 始终严格按照从左到右的顺序对表达式求值**。

例如，在表达式 `w = x + y * z` 中，子表达式 w 首先被求值，再对 x、y 和 z 求值。然后将 y 和 z 相乘，加到 x 上，再把结果赋值给表达式 w 表示的变量或属性。在表达式中使用圆括号改变乘法、加法和赋值的相对顺序，但不会改变从左到右的求值顺序。

**求值顺序只在一种情况下会造成差异，即被求值的表达式具有副效应**，这会影响其他表达式的求值。比如，表达式 x 递增一个变量，而表达式 z 会使用这个变量，此时保证 x 先于 z 被求值就很重要了。

### 4.3 算术表达式

基本的算术操作符是 `**`(幂)、`*`(乘)、`/`(除)、`%`(模：除后的取余)、`+`(加) 和 `-`(减)。

#### 4.3.1 + 操作符

严格来讲，`+` 操作符的行为如下所示：

1. 如果有一个操作数是对象，则 `+` 操作符使用[对象到原始值](#342-对象到原始值转换)的算法把该操作数转换为原始值。Date 对象用 `toString()` 方法来转换，其他所有对象通过 `valueOf()` 转换（如果这个方法返回原始值）。不过，多数对象并没有 `valueOf()` 方法，因此它们也会通过 `toString()` 方法转换。

2. 完成对象到原始值的转换后，如果有操作数是字符串，另一个操作数也会被转换为字符串进行拼接。 否则，两个操作数都被转换为数值（或 NaN），计算加法。

#### 4.3.2 一元算术操作符

一元操作符有：`+`、`-`、`++`、`--`。在 JS 中，**一元操作符全部具有高优先级和右结合性**。

> **注意**：`+` 和 `-`，既是一元操作符，也是二元操作符。

### 4.4 关系表达式

#### 4.4.1 严格相等

严格相等操作符 `===` 求值其操作数，然后按下列步骤比较两个值，不做类型转换：

- 如果两个值类型不同，则不相等。

- 如果两个值都是 null 或都是 undefined，则相等。

- 如果两个值都是布尔值 true 或都是布尔值 false，则相等。

- 如果一个或两个值是 NaN，则不相等（NaN 确实不等于任何值，也包括 NaN 自身！要检查某个值 ⅹ 是不是 NaN，使用 `x !== x` 或全局 `isNaN()` 函数）。

- 如果两个值都是数值且值相同，则相等。如果一个值是 0 而另一个是 -0，也相等。

- 如果两个值都是字符串且相同位置包含完全相同的 16 位值，则相等。
  如果两个字符串长度或内容不同，则不相等。两个字符串有可能看起来相同，也表示同样的意思，但底层编码却使用不同的 16 位值序列。JS 不会执行 Unicode 归一化操作，像这样的两个字符串用 `===` 或 `==` 操作符都不会判定相等。

- 如果两个值引用同一个对象、数组或函数，则相等。如果它们引用不同的对象，即使两个对象有完全相同的属性，也不相等。

#### 4.4.2 比较操作符

比较和转换规则如下：

- 如果有操作数求值为对象，该对象会按照[对象到原始值转换](#342-对象到原始值转换)的算法被转换为原始值。即如果它的 `valueOf()` 方法返回原始值，就使用这个值，否则就使用它的 `toString()` 方法返回的值。

- 如果在完成对象到原始值的转换后两个操作数都是字符串，则使用字母表顺序比较这两个字符串，其中 “字母表顺序” 就是组成字符串的 16 位 Unicode 值的数值顺序。

- 如果在完成对象到原始值的转换后至少有一个操作数不是字符串，则两个操作数都会被转换为数值并按照数值顺序来比较。
  0 和 -0 被认为相等。Infinity 比它本身之外的任何数都大，-Infinity 比它本身之外的任何数都小。如果有一个操作数是（或转换后是）NaN，则这些比较操作符都返回 false。

  > 虽然算术操作符不允许 BigInt 值与常规数值混用，但比较操作符允许数值与 BigInt 进行比较。

JS 字符串是 16 位整数值的序列，而字符串比较就是比较两个字符串的数值序列。Unicode 定义的这个数值编码顺序不一定与特定语言或地区使用的传统校正顺序（collation order）匹配。

> **注意**：字符串比较是区分大小写的，而**所有大写 ASCII 字母比所有小写 ASCII 字母都小**。

如果需要**更可靠的字符串比较算法，可以用 `String.localeCompare()` 方法**，这个方法也会考虑特定地区的字母表顺序。

要执行不区分大小写的比较，可以使用 `String.toLowerCase()` 或 `String.toUpperCase()` 先把字符串转换为全小写或全大写。

如果需要更通用和更好的本地化字符串比较工具，可以使用[`Intl.Collator` 类](#1173-比较字符串)。

**`+` 操作符和比较操作符同样都会对数值和字符串操作数区别对待**：

- `+` 偏向字符串，即只要有一个操作数是字符串，它就会执行拼接操作。

- 比较操作符偏向数值，只有两个操作数均为字符串时才按字符串处理。

> **注意**：
>
> 1. `<=`（小于或等于）和 `>=`（大于或等于）操作符不依赖相等或严格相等操作符确定两个值是否 “相等”。其中，小于或等于操作符只是简单地定义为 “不大于”，而大于或等于操作符则定义为 “不小于”。
> 2. 还有例外情形，即只要有操作数是（或可以转换为）NaN，则全部 4 个比较操作符都返回 false。

#### 4.4.3 in 操作符

如果指定的属性在指定的对象或其原型链中，则 `in` 运算符返回 true。

`in` 操作符期待左侧操作数是字符串、符号或可以转换为字符串的值，期待右侧操作数是对象。

```js
let point = { x: 1, y: 1 };
'x' in point; // true：对象有名为 "x" 的属性
'z' in point; // false：对象没有名为 "z" 的属性
'toString' in point; // true：对象的继承了 toString 方法

let data = [8, 0, 1];
'0' in data; // true
1 in data; // true
5 in data; // false：没有元素 5
```

#### 4.4.4 instanceof 操作符

**`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上**。

`instanceof` 操作符期待左侧操作数是对象，右侧操作数是对象类的标识。这个操作符在左侧对象是右侧类的实例时求值为 true，否则求值为 false。

在 JS 中，[对象类](#九-类)是通过初始化它们的构造函数定义的。因而，`instanceof` 的右侧操作数应该是一个函数。

```js
let d = new Date(); // 通过 Date() 构造函数创建一个新对象
d instanceof Date; // true: d 是通过 Date() 创建的
d instanceof Object; // true: 所有对象都是 Object 的实例
d instanceof Number; // false: d 不是 Number 对象

let a = [1, 2, 3]; // 通过数组字面量语法创建一个数组
a instanceof Array; // true: a 是个数组
a instanceof Object; // true: 所有数组都是对象
a instanceof RegExp; // false: 数组不是正则表达式
```

> **注意**：
>
> 1. 所有对象都是 Object 的实例。`instanceof` 在确定对象是不是某个类的实例时会考虑 “超类”。
> 2. 如果 `instanceof` 的左侧操作数不是对象，它会返回 false。如果右侧操作数不是对象的类，它会抛出 TypeError。

要理解 `instanceof` 的工作原理，必须理解“原型链”。[原型链](#632-继承)是 JS 的继承机制。

为了对表达式 `o instanceof f` 求值，JS 会求值 `f.prototype`，然后在 `o` 的原型链上查找这个值。如果找到了，则 o 是 f（或 f 的子类）的实例，`instanceof` 返回 true。如果 `f.prototype` 不是 o 原型链上的一个值，则 o 不是 f 的实例，`instanceof` 返回 false。

### 4.5 逻辑表达式

#### 4.5.1 逻辑与（&&）

`&&` 操作符首先对它左边的表达式求值，如果左边的值是假值，则整个表达式的值是假值，因此 `&&` 返回它左侧的值，不再求值它右侧的表达式。

如果 `&&` 左侧的值是真值，则整个表达式的值取决于右侧的值。如果右侧的值是真值，则整个表达式的值一定是真值；如果右侧的值是假值，则整个表达式的值一定是假值。因此，在左侧的值为真值时，`&&`操作符求值并返回它右侧的值:

```js
let o = { x: 1 };
let p = null;
o && o.x; // 1: o 是真值，因此返回 o.x 的值
p && p.x; // null: p是假值，因此返回它，不对p，x求值
```

#### 4.5.2 逻辑或（||）

`||` 的习惯用法是在一系列备选项中选择第一个真值：

```js
let max = maxWidth || preferences.maxWidth || 500;
```

> **注意**：如果 `0` 是 maxWidth 的有效值，则以上代码可能有问题，因为 0 是一个假值。此时可以使用 [`??` 操作符](#471-空值合并运算符)。

#### 4.5.3 逻辑非（!）

作为一元操作符，`!` 操作符优先级较高。如果想反转表达式 `p && q` 的值，需要使用圆括号：`!(p && q)`。

可以通过如下 JS 语法来表达布尔代数的两个法则：

```js
// 德摩根定律
!(p && q) === (!p || !q); // true：p 和 q 可以是任何值
!(p || q) === (!p && !q); // true
```

### 4.6 赋值表达式

`=` 操作符期待其左侧操作数是一个左值，即变量或对象属性或数组元素。它期待右侧操作数是任意类型的任意值。赋值表达式的值是右侧操作数的值。

可以像下面这样在同一个表达式中赋值并测试这个值：

```js
(a = b) === 0;
```

> **注意**：**`=` 的优先级很低**，在较大的表达式中使用赋值的值通常需要使用圆括号。

赋值操作符**具有右结合性**，这意味着如果一个表达式中出现多个赋值操作符，它们会从右向左求值。因此，可以通过如下代码将一个值赋给多个变量:

```js
i = j = k = 0; // 把 3 个变量都初始化为 0
```

### 4.7 其他操作符

#### 4.7.1 空值合并运算符（??）

`??` 求值其先定义的操作数，如果其左操作数不是 null 或 undefined，就返回该值。否则，它会返回右操作数的值。

与 `&&` 或 `||` 操作符类似，`??` 是短路的：它只在第一个操作数求值为 null 或 undefined 时才会求值二个操作数。表达式 `a ?? b` 等价于:

```js
a !== null && a !== undefined ? a : b;
```

`??` 是对 `||` 的一个有用的替代，适合选择先定义的操作数，而不是第一个为真值的操作数。

`??` 操作符与 `&&` 和 `||` 操作符类似，但优先级并不比它们更高或更低。如果表达中混用了 `??` 和它们中的任何一个，必须使用圆括号说明先执行哪个操作。

#### 4.7.2 typeof 操作符

`typeof` 是个一元操作符，放在自己的操作数前面，这个操作数可以是任意类型。typeof 操作符的值是一个字符串，表明操作数的类型。

下表列出了所有 JS 值在应用 typeof 操作符后得到的值：

| x              | typeof x    |
| -------------- | ----------- |
| undefined      | "undefined" |
| null           | "object"    |
| true 或 false  | "boolean"   |
| 任意数值或 NaN | "number"    |
| 任意 BigInt    | "bigint"    |
| 任意字符串     | "string"    |
| 任意符号       | "symbol"    |
| 任意函数       | "function"  |
| 任意非函数对象 | "object"    |

可以像下面这样在表达式中使用 typeof 操作符:

```js
// 如果 value 是字符串，把它包含在引号中，否则把它转换为字符串
typeof value === 'string' ? "'" + value + "'" : value.toString();
```

> **注意**：
>
> 1. 如果操作数的值是 null，typeof 返回 “object”。如果想区分 null 和对象，必项显式测试这个特殊值。
> 2. 尽管 JS 函数是一种对象，typeof 操作符也认为函数不一样，因为它们有自己的返回值。
> 3. 因为对除函数之外的所有对象和数组值，typeof 都求值为 “object"，所以**可以只用它来区分对象和其他原始类型。而要区分不同对象的类，必须使用其他方法**，例如 [instanceof 操作符](#444-instanceof-操作符)、class 特性（参见 [Symbol.toStringTag](#1443-symboltostringtag)），或者 [constructor 属性](#922-constructor-属性)。

#### 4.7.3 delete 操作符

`delete` 是一元操作符，尝试删除其操作数指定的对象属性或数组元素。

```js
let o = { x: 1, y: 2 }; //先定义一个对象
delete o.x; // 删除它的属性
'x' in o; // false: 这个属性不存在了

let a = [1, 2, 3]; // 定义一个数组
delete a[2]; // 删除数组的最后一个元素
2 in a; // false: 数组元素 2 不存在了
a.length; // 5: 但要注意,数组长度没有变化
```

> **注意**：被删除的属性或数组元素不仅会被设置为 undefined 值。当删除一个属性时，这个属性就不复存在了。尝试读取不存在的属性会返回 undefined，但可以通过 [`in` 操作符](#443-in-操作符)测试某个属性是否存在。删除某个数组元素会在数组中留下一个“坑”，并不改变数组的长度。结果数组是一个[稀疏数组](#73-稀疏数组)。

delete 期待它的操作数是个左值。如果操作数不是左值，delete 什么也不做，且返回 true。否则，delete 尝试删除指定的左值。如果删除成功则返回 true。但是并非所有属性都是可以删除的：[不可配置属性](#141-属性的特性)就无法删除。

在严格模式下，delete 的操作数如果是未限定标识符，比如变量、函数或函数参数，就会导致 Syntax Error。此时，delete 操作符只能作用于属性访问表达式。

严格模式也会在 delete 尝试删除不可配置（即不可删除）属性时抛出 TypeError。但在严格模式之外，这两种情况都不会发生异常，delete 只是简单地返回 false，表示不能删除操作数。

下面是几个使用 delete 操作符的例子：

```js
let o = { x: 1, y: 2 };
delete o.x; // 删除对象的一个属性: 返回 true
typeof o.x; // 属性不存在: 返回 "undefined"
delete o.x; // 删除不存在的属性: 返回 true
delete 1; // 这样做毫无意义,但会返回 true

// 不能删除变量，返回 false,或在严格模式下报 SyntaxError
delete o;
// 不可删除的属性: 返回 false，或在严格模式下报 TypeError
delete Object.prototype;
```

#### 4.7.4 await 操作符

[`await`](#十三-异步-js) 是 ES2017 增加的，**用于让 JS 中的异步编程更自然**。

简单来说，`await` 期待一个 Promise 对象（表示异步计算）作为其唯一操作数，可以让代码看起来像是在等待异步计算完成（但实际上它不会阻塞主线程，不会妨碍其他异步操作进行）。

`await` 操作符的值是 Promise 对象的兑现值。关键在于，**`await` 只能出现在已经通过 `async` 关键字声明为异步的函数中**。

## 五. 语句

[JavaScript#-表达式语句](../JavaScript.md#424-语句)

## 六. 对象

### 6.1 对象简介

对象是一种复合值，它汇聚多个值（原始值或其他对象）并允许按名字存储和获取这些值。对象是一个属性的无序集合，每个属性都有名字和值。属性名通常是字符串（也可以是[符号](#6103-符号作为属性名)），因此可以说对象把字符串映射为值。

这种字符串到值的映射曾经有很多种叫法，包括 “散列” “散列表” “字典” 或 “关联数组” 等熟悉的基本数据结构。不过，对象不仅仅是简单的字符串到值的映射。除了维持自己的属性之外，JS 对象也可以从其他对象继承属性，这个其他对象称为其 “原型”。

**对象的方法通常是继承来的属性，而这种“原型式继承”也是 JS 的主要特性**。

JS 对象是动态的，即可以动态添加和删除属性。不过，可以用对象来模拟静态类型语言中的静态对象和 “结构体”。对象也可以用于表示一组字符串（忽略字符串到值的映射中的值）。

> 在 JS 中，任何不是字符串、数值、符号或 true、false、null、undefined 的值都是对象。即使字符串、数值和布尔值不是对象，它们的行为也类似不可修改的对象。

对象是可修改的，是按引用操作而不是按值操作的。如果变量 x 指向一个对象，则代码 `let y = x;` 执行后，变量 y 保存的是同一个对象的引用，而不是该对象的副本。通过变量 y 对这个对象所做的任何修改，在变量 x 上都是可见的。

有时候，区分直接定义在对象上的属性和那些从原型对象上继承的属性很重要。JS 使用术语 “自有属性” 指代非继承属性。

除了名字和值之外，每个属性还有 3 个属性特性（property attribute）：

- **writable**（可写）：指定是否可以设置属性的值。
- **enumerable**（可枚举）：指定是否可以在 for/in 循环中返回属性的名字。
- **configurable**（可配置）：指定是否可以删除属性，以及是否可修改其特性。

很多 JS 内置对象拥有只读、不可枚举或不可配置的属性。不过，默认情况下，所创建对象的所有属性都是可写、可枚举和可配置的。

### 6.2 创建对象

对象可以通过 3 种方式创建：

- 对象字面量
- `new` 关键字
- `Object.create()` 函数来创建

#### 6.2.1 对象字面量

创建对象最简单的方式是在 JS 代码中直接包含对象字面量。对象字面量的最简单形式是包含在一对花括号中的一组逗号分隔的 “name:value” 对。属性名是 JS 标识符或字符串字面量（**允许空字符串**）。属性值是任何 JS 表达式，这个表达式的值（可以是原始值或对象值）会变成属性的值。

```js
let empty = {}; // 没有属性的对象
let point = { x: 0, y: 0 }; // 包含两个数值属性
let p2 = { x: point.x, y: point.y + 1 }; // 值比较复杂
let book = {
  'main title': 'JavaScript', // 属性名包含空格
  'sub-title': 'The Definitive Guide', // 和连字符,因此使用字符串字面量对象
  for: 'all audiences', // for 是保留字，但没有引号
  // 这个属性的值本身是一个对象
  author: {
    firstname: 'David',
    surname: 'Flanagan'
  }
};
```

对象字面量是一个表达式，每次求值都会创建并初始化一个新的、不一样的对象。字面量每次被求值的时候，它的每个属性的值也会被求值。这意味着同一个对象字面量如果出现在循环体中，或出现在被重复调用的函数体丙，可以创建很多新对象，且这些对象属性的值可能不同。

#### 6.2.2 使用 new 创建对象

`new` 操作符用于创建和初始化一个新对象。**new 关键字后面必须跟一个函数调用。以这种方式使用的函数被称为构造函数**（constructor），目的是初始化新创建的对象。JS 为内置的类型提供了构造函数。例如:

```js
let o = new Object(); // 创建一个空对象，与 {} 相同
let a = new Array(); // 创建一个空数组，与 [] 相同
let d = new Date(); // 创建一个表示当前时间的日期对象
let r = new Map(); // 创建一个映射对象，用于存储键/值映射
```

除了内置的构造函数，实践中经常需要[定义自己的构造函数](#九-类)来初始化新创建的对象。

#### 6.2.3 原型

在学习 `Object.create()` 函数前，必须先了解原型。**几乎每个 JS 对象都有另一个与之关联的对象。这另一个对象被称为原型（prototype）**，第一个对象从这个原型继承属性。

通过对象字面量创建的所有对象都有相同的原型对象，在 JS 代码中可以通过 `Object.prototype` 引用这个原型对象。

`new` 关键字和构造函数调用创建的对象使用构造函数 `prototype` 属性的值作为它们的原型。换句话说，使用 `new Object()` 创建的对象继承自 `Object.prototype`，与通过 `{}` 创建的对象一样。

> 几乎所有对象都有原型,但只有少数对象有 `prototype` 属性。正是这些有 `prototype` 属性的对象为所有其他对象定义了原型。

`Object.prototype` 是为数不多的没有原型的对象，因为它不继承任何属性。其他原型对象都是常规对象，都有自己的原型。多数内置构造函数（和多数用户定义的构造函数）的原型都继承自 `Object.prototype`。

`Date.prototype` 从 `Object.prototype` [继承](#632-继承)属性，因此通过 `new Date()` 创建的日期对象从 `Date.prototype` 和 `Object.prototype`继承属性。**这种原型对象链接起来的序列被称为原型链**。

[类](#九-类)会更详细地解释原型与构造函数之间的联系，将展示如何定义新的对象类，包括编写构造函数以及将其 `prototype` 属性设置为一个原型对象，让通过该构造函数创建的 “实例” 继承这个原型对象的属性。另外，[公认符号](#144-公认符号)还将介绍如何查询（甚至修改）一个对象的原型。

#### 6.2.4 `Object.create()`

- `Object.create()` 用于创建一个新对象，使用其第一个参数作为新对象的原型:

  ```js
  let o1 = Object.create({ x: 1, y: 2 }); // o1 继承属性 x 和 y
  o1.x + o1.y; // 3
  ```

- 传入 `null` 可以创建一个没有原型的新对象。不过，这样创建的新对象不会继承任何东西，连 `toString()` 这种基本方法都没有（意味着不能对该对象应用 `+` 操作符）:

  ```js
  let o2 = Object.create(null); // 不继承任何属性或方法
  ```

- 如果想创建一个普通的空对象（类似或 `new Object()` 返回的对象），传入 `Object.prototype`:

  ```js
  let o3 = Object.create(object.prototype); // o3 与 {} 或 new Object() 类似
  ```

- `Object.create()` 还可接收可选的第二个参数，用于[描述新对象的属性](#141-属性的特性)。

**防止意外修改**
`Object.create()` 的一个用途是防止对象被某个第三方库函数意外修改。这种情况下，不要直接把对象传给库函数，而要传入一个继承自它的对象。如果函数读取这个对象的属性，可以读到继承的值。而如果它设置这对象的属性，则修改不会影响原始对象。

```js
let o = { x: 'todo list' };
library.function(Object.create(o)); // 防止意外修改
```

要理解其中的原理需要知道 JS 中属性查询和设置的过程。

### 6.3 查询和设置属性

要获得一个属性的值，可以使用 点（`.`）或方括号（`[]`）操作符。左边应该是一个表达式，其值为一个对象。

- 如果使用点操作符，右边必须是一个命名属性的简单标识符。

- 如果使用方括号，方括号中的值必须是一个表达式，其结果为包含目的属性名的字符串或一个可以转换为字符串或符号的值。

```js
let author = book.author;
let surname = book['surname'];
```

要创建或设置属性，与查询属性一样，可以使用点或方括号，只是要把它们放到赋值表达式的左边：

```js
book.edition = 7;
book['author'] = 'tom';
```

#### 6.3.1 作为关联数组的对象

下面两个 JS 表达式的值相同：

```js
object.property;
object['property'];
```

第一种语法使用点和标识符，与在 C 或 Java 中访问结构体或对象的静态字段的语法类似。

第二种语法使用方括号和字符串，看起来像访问数组，只不过是以字符串而非数值作为索引的数组。这种数组也被称为关联数组（或散列、映射、字典）。**JS 对象是关联数组**。

在使用点（`.`）操作符访问对象的属性时，属性名是通过标识符来表示的。标识符必须直接书写在 JS 程序中，它们不是一种数据类型，因此不能被程序操作。

在通过方括号（`[]`）这种数组表示法访问对象属性时，属性名是通过字符串来表示的。字符串是一种 JS 数据类型，因此可以在程序运行期间修改和创建，例如：

```js
let addr = '';
for (let i = 0; i < 4; i++) {
  addr += customer[`address${i}`] + '\n';
}
```

#### 6.3.2 继承

JS 对象有一组 “自有属性”，同时也从它们的原型对象继承一组属性。要理解这一点，必须更详细地分析属性存取。

可以使用 `Object.create()` 函数以指定原型来创建对象。也可以通过 new 创建一个[类的实例](#九-类)，这两个都会创建从某个原型对象继承属性的对象。

假设要从对象 `o` 中查询属性 `x`。如果 `o` 没有 `x` 这个自有属性，则会从 `o` 的原型对象查询属性 `x`。如果原型对象也没有叫这个名字的自有属性，但它有自己的原型，则会继续查询这个原型的原型。这个过程一直持续，直至找到属性 `x` 或者查询到一个原型为 null 的对象。可见，对象通过其 `prototype` 属性创建了一个用于继承属性的链条或链表。

> 几乎所有对象都有原型，但大多数对象没有 [`prototype`](#143-prototype-特性) 属性。即便不能通过代码直接访对象的原型，JS 继承机制仍然照常运作。

```js
let o = {}; // o 从 Object.prototype 继承对象方法
o.x = 1; // 现在有自有属性 x

let p = Object.create(o); // p 从 o 和 Object.prototype 继承属性
p.y = 2; // 而且有一个自有属性 y

let q = Objet.create(p); // q 从 p、o 和 Object.prototype 继承属性
q.z = 3; // 且有一个自有属性 z

let f = q.toString(); // toString 继承自 Object.prototype
q.x + q.y; // 3: x 和 y 分别继承自 o 和 p
```

现在为对象 `o` 的 `y` 属性赋值。如果 `o` 有一个名为 `x` 的自有属性，这次赋值就会修改已有 `x` 属性的值。否则，这次赋值会在对象 `o` 上创建一个名为 `x` 的新属性。

如果 `o` 之前继承了属性 `x`，那么现在这个**继承的属性会被新创建的同名属性隐藏**。

**属性赋值査询原型链只为确定是否允许赋值**。如果 `o` 继承了一个名为 `x` 的只读属性，则不允许赋值。不过，如果允许赋值则只会在原始对象上创建或设置属性，而**不会修改原型链中的对象**。

**查询属性时会用到原型链，而设置属性时不影响原型链是一个重要的 JS 特性**，利用这一点，可以选择性地覆盖继承的属性:

```js
let unitcircle = { r: 1 }; // c 继承的对象
let c = Object.create(unitcircle); // c 继承了属性
c.x = 1;
c.y = 1; // c 定义了两个自有属性

c.r = 2; // c 覆盖了它继承的属性

unitcircle.r; // 1: 原型不受影响
```

属性赋值要么失败要么在原始对象上创建或设置属性的规则有一个**例外**：

如果 `o` 继承了属性 `x`，而该属性是一个通过设置方法定义的[访问器属性](#6106-属性的获取方法与设置方法访问器属性)，那么就会调用该设置方法而不会在 `o` 上创建新属性 `x`。

> **注意**：此时会在对象 `o` 上而不是在定义该属性的原型对象上调用设置方法。因此如果这个设置方法定义了别的属性，那也会在定义同样的属性，但仍然不会修改原型链。

#### 6.3.3 属性访问错误

属性访问表达式并不总是会返回或设置值。査询不存在的属性不是错误。如果在 `o` 的自有属性和继承属性中都没找到属性 `x`，则属性访问表达式 `o.x` 的求值结果为 `undefined`。

例如，book 对象有一个 "sub-title" 属性，没有 "subtitle" 属性：

```js
book.subtitle; // undefined: 属性不存在
```

然而，查询不存在对象的属性则是错误。因为 null 和 undefined 值没有属性，查询这两个值的属性是错误。继续前面的示例：

```js
let len = book.subtitle.length; // TypeError: undefined 没有 length 属性
```

如果 `.` 的左边是 `null` 或 `undefined`，则属性访问表达式会失败。因此在写类似 `book.author.surname` 这样的表达式时，要确保 book 和 book.author 是有定义的。以下是两种防止这类问题的写法:

```js
// 简单但麻烦的技术
let surname = undefined;
if (book) {
  if (book.author) {
    surname = book.author.surname;
  }
}

// 取得 surname、null 或 undefined 的简洁的惯用技术
surname = book && book.author && book.author.surname;
```

ES2020 还可以通过 `?.` 支持条件式属性访问，用它可以把前面的赋值表达式改写成:

```js
let surname = book?.author?.surname;
```

尝试在 null 或 undefined 上设置属性也会导致 TypeError。而且，尝试在其他值上设置属性也不总是会成功，因为有些属性是只读的，不能设置，而有些对象不允许添加新属性。在严格模式下，只要尝试设置属性失败就会抛出 TypeError。在非严格模式下，这些失败通常是静默失败。

尝试在对象 `o` 上设置属性 p 在以下情况下会失败：

- `o` 有一个只读自有属性 p: **不可能设置只读属性**。
- `o` 有一个只读继承属性 p: **不可能用同名自有属性隐藏只读继承属性**。
- `o` 没有自有属性 `p`，`o` 没有继承通过设置方法定义的属性 `p`,`o` 的 [`extensible` 特性](#142-对象的可扩展能力)是 false。因为 `p` 在 `o` 上并不存在，如果没有要调用的设置方法，那么 `p` 必须要添加到 `o` 上。但如果 `o` 不可扩展(`extensible` 为 false)，则不能在它上面定义新属性。

### 6.4 删除属性

delete 操作符用于从对象中移除属性。它唯一的操作数应该是属性访问表达式。**delete 并不操作属性的值，而是操作属性本身**:

```js
delete book.author; // book 对象现在没有 author 属性了
delete book['main title']; // book 对象也没有 "main title" 属性了
```

**delete 操作符只删除自有属性，不删除继承属性**（要删除继承属性，必须从定义属性的原型对象上删除。这样做会影响继承该原型的所有对象）。

如果 delete 操作成功或没有影响（如删除不存在的属性），则 delete 表达式求值为 true。对非属性访问表达式（无意义地）使用 delete，同样也会求值为 true：

```js
let o = { x: 1 }; // o 有自有属性 x 和继承属性 toString
delete o.x; // true: 删除属性 x
delete o.x; // true: 什么也不做(x 不存在)但仍然返回 true
delete o.toString; // true: 什么也不做（toString 不是自有属性）
delete 1; // true：无意义，但仍然返回 true
```

delete 不会删除 `configurable` 特性为 false 的属性。与通过变量声明或函数声明创建的全局对象的属性一样，某些内置对象的属性也是不可配置的。在严格模式下，尝试删除不可配置的属性会导致 TypeError。在非严格模式下, delete 直接求值为 false:

```js
// 在严格模式下，以下所有删除操作都会抛出 TypeError，而不是返回 false
delete Object.prototype; // false: 属性不可配置
var x = 1; // 声明一个全局变量
delete globalThis.x; // false: 不能删除这个属性
function f() {} // 声明一个全局函数
delete globalThis.f; // false: 不能删除这个属性
```

**删除全局对象可配置的属性**:

- 在非严格模式下，可以省略对全局对象的引用，只在 delete 操作符后面加上属性名:

  ```js
  globalThis.x = 1; // 创建可配置的全局属性(没有 let 或 var)
  delete x; // true: 这个属性可以删除
  ```

- 在严格模式下，如果操作数是一个像 x 这样的非限定标识符，delete 会抛出 Syntax Error，即必须写出完整的属性访问表达式:

  ```js
  delete x; //在严格模式下报 SyntaxError
  delete globalThis.x; //这样可以
  ```

### 6.5 测试属性

JS 对象可以被想象成一组属性，实际开发中经常需要测试这组属性的成员关系，即检查对象是否有一个给定名字的属性。为此，可以使用:

- `in` 操作符
- `hasOwnProperty()`
- `propertyIsEnumerable()`
- 直接查询相应属性

下面的示例都使用字符串作为属性名，这些示例也适用于[符号属性](#6103-符号作为属性名)。

- `in` 操作符要求左边是一个属性名，右边是一个对象。如果**对象有包含相应名字的自有属性或继承属性，将返回 true**:

  ```js
  let o = { x: 1 };
  'x' in o; // true: o 有自有属性 "x"
  'y' in o; // false: o 没有属性"y"
  'toString' in o; //=>true: o 继承了 toString 属性
  ```

- 对象的 `hasOwnProperty()` 方法**用于测试对象是否有给定名字的属性。对继承的属性，它返回 false**:

  ```js
  let o = { x: 1 };
  o.hasOwnProperty('x'); // true: o 有自有属性 X
  o hasOwnProperty('y'); // false: o 没有属性 y
  o.hasOwnProperty('toString'); // false: toString 是继承属性
  ```

- `propertyIsEnumerable()` 方法细化了 `hasOwnProperty()` 测试。如果**传入的命名属性是自有属性且这个属性的 `enumerable` 特性为 true，这个方法会返回 true**。某些内置属性是不可枚举的。

  > 使用常规 JS 代码创建的属性都是可枚举的，除非使用[属性的特性](#141-属性的特性)将它们限制为不可枚举。

  ```js
  let o = { x: 1 };
  o.propertyIsEnumerable('x'); // true: o 有一个可枚举属性 x
  o.propertyIsEnumerable('toString'); // false: toString不是自有属性
  Object.prototype.propertyIsEnumerable('toString'); // false: toString 不可枚举
  ```

- 除了使用 `in` 操作符，通常简单的属性查询配合 `!==` 确保其不是未定义的就可以了：

  ```js
  let o = { x: 1 };
  o.x !== undefined; // true: o 有属性 x
  o.y !== undefined; // false: o 没有属性 y
  o.toString !== undefined; // true: o 继承了 tostring 属性
  ```

但有一件事 `in` 操作符可以做，而简单的属性访问技术做不到。**`in` 可以区分不存在的属性和存在但被设置为 undefined 的属性**。来看下面的代码:

```js
let o = { x: undefined }; // 把属性显式设置为 undefined
o.x !== undefined; // false: 属性 x 存在但值是 undefined
o.y !== undefined; // false: 属性 y 不存在
'x' in o; // true: 属性 x 存在
'y' in o; // false: 属性 y 不存在
delete o.x; // 删除属性 ⅹ
'x' in o; // false: 属性 x 不存在
```

### 6.6 枚举属性

除了测试属性是否存在，有时候也需要遍历或获取对象的所有属性。为此有几种不同的实现方式。

**`for/in` 循环对指定对象的每个可枚举（自有或继承）属性都会运行一次循环体，将属性的名字赋给循环变量**。对象继承的内置方法是不可枚举的，但 JS 代码添加给对象的属性默认是可枚举的。例如:

```js
let o = { x: 1, y: 2, z: 3 }; // 3 个可枚举自有属性
o.propertyIsEnumerable('toString'); // false: toString 不可枚举也不是自有属性
for (let p in o) {
  console.log(p); // 打印 x、y、z，但没有 toString
}
```

为防止通过 `for/in` 枚举继承的属性，可以在循环体内添加一个显式测试:

```js
for (let p in o) {
  if (!o.hasOwnProperty(p)) continue; // 跳过继承属性
}

for (let p in o) {
  if (typeof o[p] === 'function') continue; // 跳过所有方法
}
```

除了使用 `for/in` 循环，有时候可以先获取对象所有属性名的数组，然后再通过 `for/of` 循环遍历该数组。有 4 个函数可以用来取得属性名数组:

- `Object.keys()` 返回对象可枚举自有属性名的数组。不包含不可枚举属性、继承属性或[符号属性](#6103-符号作为属性名)。
- `Object.getOwnProperNames()` 与 `Object.keys()` 类似，但也会返回不可枚举自有属性名的数组，只要它们的名字是字符串。
- `Object.getOwnPropertySymbols()` 返回名字是符号的自有属性，无论是否可枚举。
- [`Reflect.ownKeys()`](#146-反射-api) 返回所有属性名，包括可枚举和不可枚举属性，以及字符串属性和符号属性。

#### 6.6.1 属性枚举顺序

ES6 正式定义了枚举对象自有属性的顺序。`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnProperSymbols()`、`Reflect.ownKeys()`及 `JSON.stringify()` 等相关方法都按照下面的顺序列出属性，另外也受限于它们要列出不可枚举属性还是列出字符串属性或符号属性：

1. 先列出名字为非负整数的字符串属性，按照数值顺序从最小到最大。这条规则意味着数组和类数组对象的属性会按照顺序被枚举。

2. 在列出类数组索引的所有属性之后，再列出所有剩下的字符串名字（包括看起来像负数或浮点数的名字）的属性。这些属性按照它们添加到对象的先后顺序列出。对于在对象字面量中定义的属性，按照它们在字面量中出现的顺序列出。

3. 最后，名字为符号对象的属性按照它们添加到对象的先后顺序列出。

`for/in` 循环的枚举顺序并不像上述枚举函数那么严格，但实现通常会按照上面描述的顺序枚举自有属性，然后再沿原型链上溯，以同样的顺序枚举每个原型对象的属性。

> **注意**：如果已经有同名属性被枚举过了，甚至如果有一个同名属性是不可枚举的，那这个属性就不会枚举了。

### 6.7 扩展对象

在 JS 程序中，把一个对象的属性复制到另一个对象上是很常见的。使用下面的代码很容易做到:

```js
let target = { x: 1 },
  source = { y: 2, z: 3 };
for (let key of Object.keys(source)) {
  target[key] = source[key];
}
```

**`Object.assign()`**
ES6 进入了核心 JS 语言。**`Object.assign()` 接收两个或多个对象作为其参数。它会修改并返回第一个参数，第一个参数是目标对象，但不会修改第二个及后续参数，那些都是来源对象**。

对于每个来源对象，它会把该对象的可枚举自有属性（包括名字为符号的属性）复制到目标对象。它按照参数列表顺序逐个处理来源对象，第一个来源对象的属性会覆盖目标对象的同名属性，而第二个来源对象（如果有）的属性会覆盖第一个来源对象的同名属性。

`Object.assign()` 以普通的属性获取和设置方式复制属性，因此如果一个来源对象有获取方法或目标对象有设置方法，则它们会在复制期间被调用，但这些方法本身不会被复制。

将属性从一个对象分配到另一个对象的一个原因是，如果有一个默认对象为很多属性定义了默认值，并且如果该对象中不存在同名属性，可以将这些默认属性复制到另一个对象中。但是，像下面这样简单地使用 `Object.assign()` 不会达到目的：

```js
Object.assign(o, defaults); // 用 defaults 覆盖 o 的所有属性
```

此时，需要创建一个新对象，先把默认值复制到新对象中，然后再使用 `o` 的属性覆盖那些默认值

```js
o = Object.assign({}, defaults, o);
```

使用扩展操作符 `...` 也可以表达这种对象复制和覆盖操作:

```js
o = { ...defaults, ...o };
```

为了避免额外的对象创建和复制，也可以重写一版 `Object.assign()`，只复制那些不存在的属性:

```js
// 与 Object.assign() 类似，但不覆盖已经存在的属性
// （同时也不处理符号属性）
function merge(target, ...sources) {
  for (let source of sources) {
    for (let key of Object.keys(source)) {
      // 这里跟 Object.assign() 不同
      if (!(key in target)) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
Object.assign({ x: 1 }, { x: 2, y: 3 }, { y: 3, z: 4 }); // {x:2, y:3, z:4}
merge({ x: 1 }, { x: 2, y: 2 }, { y: 3, z: 4 }); // {x:1, y:2, z:4}
```

### 6.8 序列化对象

**对象序列化（serialization）是把对象的状态转换为字符串的过程，之后可以从中恢复对象的状态**。

函数 [`JSON.stringify()` 和 `JSON.parse()`](#116-json-序列化与解析) 用于序列化和恢复 JS 对象。这两个函数使用 JSON 数据交换格式。JSON 表示 JavaScript Object Notation（JavaScript 对象表示法），其语法与 JS 对象和数组字面量非常类似：

```js
let o = { x: 1, y: { z: [false, null, ''] } }; // 定义一个测试对象
let s = JSON.stringify(o); // s == '{"x":1,"y":{"z":[false,null,""]}}}'
let p = JSON.parse(s); // p == { x: 1, y: { z: [false, null, ''] } }
```

JSON 语法是 JS 语法的子集，不能表示所有 JS 的值。**可以序列化和恢复的值包括对象、数组、字符串、有限数值、true、 false 和 null**。

**JSON 无法序列化和恢复的值**：

- `NaN`、`Infinity` 和 `-Infinity` 会被序列化为 `null`。
- 日期对象会被序列化为 ISO 格式的日期字符串，但 `JSON.parse()` 会保持其字符串形式，不会恢复原始的日期对象。
- 函数、RegExp 和 Error 对象以及 undefined 值不能被序列化或恢复。
- **`JSON.stringify()` 只序列化对象的可枚举自有属性**。如果属性值无法序列化，则该属性会从输出的字符串中删除。

`JSON.stringify()` 和 `JSON.parse()` 都接收可选的第二个参数，用于自定义序列化及恢复操作。例如，可以通过这个参数指定要序列化哪些属性，或者在序列化或字符串化过程中如何转换某些值。

### 6.9 对象方法

**所有 JS 对象（除了那些显式创建为没有原型的）都从 `Object.prototype` 继承属性。这些继承的属性主要是方法**，因为它们几乎无处不在，所以对 JS 程序而言特别重要。例如，`hasOwnProperty()` 和 `propertyIsEnumerable()` 方法。

下面是几个 `Object.prototype` 上的通用方法，但这些方法很有可能被更特定的实现取代。

#### 6.9.1 toString() 方法

**`toString()` 方法不接收参数，返回表示调用它的对象的值的字符串**。每当需要把一个对象转换为字符串时，JS 就会调用该对象的这个方法。例如，在使用 `+` 操作符拼接一个字符串和一个对象时，或者把一个对象传入期望字符串参数的方法时。

默认的 `toString()` 方法并不能提供太多信息（但可以用于确定对象的类）。例如，下面这行代码只会得到字符串 "[object Object]":

```js
let s = { x: 1, y: 1 }.toString(); // s == "[object Object]
```

由于这个默认方法不会显示太有用的信息，很多类都会重新定义自己的 `toString()` 方法。例如，在把数组转换为字符串时，可以得到数组元素的一个列表，每个元素也都转换为字符串。而把函数转换为字符串时，可以得到函数的源代码。可以像下面这样定义自己的 `toString()` 方法:

```js
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  }
};
String(point); // "(1, 2)": toString() 用于转换为字符串
```

#### 6.9.2 toLocaleString() 方法

除了基本的 `toString()` 方法之外，对象也都有一个 **`toLocaleString()` 方法。这个方法的用途是返回对象的本地化字符串表示**。

- Object 定义的默认 `toLocaleString()` 方法本身没有实现任何本地化，而是简单地调用 `toString()` 并返回该值。
- Date 和 Number 定义了自己的 `toLocaleString()` 方法，尝试根据本地惯例格式化数值、日期和时闻。
- 数组也定义了一个与 `toString()` 类似的 `toLocaleString()` 方法，只不过它会调用每个数组元素的 `toLocaleString()` 方法，而不是调用它们的 `toString()` 方法。

对于前面的 point 对象，也可以如法炮制:

```js
let point = {
  X: 1000,
  y: 2000,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  },
  toLocaleString: function () {
    return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`;
  }
};

point.toString(); // "(1000, 2000)"
point.toLocaleString(); // "(1,000, 2,000)": 千分位分隔符
```

#### 6.9.3 valueOf() 方法

`valueOf()` 方法与 `toString()` 方法很相似，但**会在 JS 需要把对象转换为某些非字符串原始值（通常是数值）时被调用**。如果在需要原始值的上下文中使用了对象，JS 会自动调用这个对象的 `valueOf()` 方法。

默认的 `valueOf()` 方法并没有做什么，因此一些内置类定义了自己的 `valueOf()` 方法。Date 类定义的 `valueOf()` 方法可以将日期转换为数值，这样就让日期对象可以通过 `<` 和 `>` 操作符来进行比较。类似地，对于 point 对象，也可以定义一个返回原点与当前点之间距离的 `valueOf()`:

```js
let point = {
  x: 3,
  y: 4,
  valueOf: function () {
    return Math.hypot(this.x, this.y);
  }
};

Number(point); // 5: valueOf() 用于转换为数值
point > 4;
point > 5; // false
point < 6; // true
```

#### 6.9.4 toJSON() 方法

`Object.prototype` 实际上并未定义 `toJSON()` 方法，但 `JSON.stringify()` 方法会从要序列化的对象上寻找 `toJSON()` 方法。如果要序列化的对象上存在这个方法，就会调用它，然后序列化该方法的返回值，而不是原始对象。

[Date 类](#114-日期与时间)定义了自己的 `toJSON()` 方法，返回一个表示日期的序列化字符串。同样，也可以给 point 对象定义这个方法:

```js
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return `(${this.x}, ${this.y});`;
  },
  toJSON: function () {
    return this.toString();
  }
};

JSON.stringify([point]); // '["(1, 2)"]'
```

### 6.10 对象字面量扩展语法

最近的 JS 版本从几个方面扩展了对象字面量语法。

#### 6.10.1 简写属性

假设变量 x 和 y 中保存着值，想创建一个具有属性 x 和 y 且值分别为相应变量值的对象。如果使用基本的对象字面量语法，需要把每个标识符重复两次：

```js
let x = 1,
  y = 2;
let o = {
  x: x,
  y: y
};
```

在 ES6 及之后，可以删掉其中的分号和一份标识符，得到非常简洁的代码：

```js
let x = 1,
  y = 2;
let o = { x, y };
o.x + o.y; // 3
```

#### 6.10.2 计算的属性名

有时候，需要创建一个具有特定属性的对象，但该属性的名字不是编译时可以直接写在源代码中的常量。相反，需要的这个属性名保存在一个变量里，或者是调用的某个函数的返回值。不能对这种属性使用基本对象字面量。为此，必须先创建一个对象然后再为它添加想要的属性：

```js
const PROPERTY_NAME = 'p1';
function computePropertyName() {
  return 'p' + 2;
}

let o = {};
o[PROPERTY_NAME] = 1;
o[computePropertyName()] = 2;
```

而使用 ES6 称为计算属性的特性可以更简单地创建类似对象，这个特性可以直接把前面代码中的方括号放在对象字面量中:

```js
const PROPERTY_NAME = 'p1';
function computePropertyName() {
  return 'p' + 2;
}

let p = {
  [PROPERTY_NAME]: 1,
  [computePropertyName()]: 2
};

p.p1 + p.p2; // 3
```

有了这个语法，就可以在方括号中加入任意 JS 表达式。对这个表达式求值得到的结果（必要时转换为字符串）会用作属性的名字。

#### 6.10.3 符号作为属性名

计算属性语法也让另一个非常重要的对象字面量特性成为可能。**在 ES6 及之后，属性名可以是字符串或符号。如果把符号赋值给一个变量或常量，那么可以使用计算属性语法将该符号作为属性名**：

```js
const extension = Symbol('my extension symbol');
let o = {
  [extension]: {
    /*这个对象中存储扩展数据*/
  }
};
o[extension].x = 0; // 这个属性不会与 o 的其他属性冲突
```

符号是不透明值。除了用作属性名之外，不能用它们做任何事情。不过，每个符号都与其他符号不同，这意味着符号非常适合用于创建唯一属性名。创建新符号需要调用 `Symbol()` 工厂函数（符号是原始值，不是对象，因此 `Symbol()` 不是构造函数，不能使用 new 调用）。

`Symbol()` 返回的值不等于任何其他符号或其他值。可以给 `Symbol()` 传一个字符串，在把符号转换为字符串时会用到这个字符串。但这个字符串的作用仅限于辅助调试，使用相同字符串参数创建的两个符号依旧是不同的符号。

> 使用符号不是为了安全，而是为 JS 对象定义安全的扩展机制。如果从不受控的第三方代码得到一个对象，然后需要为该对象添加一些自己的属性，但又不希望添加的属性与该对象原有的任何属性冲突，那就可以放心地使用符号作为属性名。而且，这样一来，也不必担心第三方代码会意外修改以符号命名的属性（当然，第三方代码可以使用 `Object.getOwnPropertySymbols()` 找到使用的符号，然后修改或删除属性。这也是符号不是一种安全机制的原因）。

#### 6.10.4 扩展操作符

在 ES2018 及之后，可以在对象字面量中使用 “扩展操作符” `...` 把已有对象的属性复制到新对象中：

```js
let position = { x: 0, y: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ...position, ...dimensions };
rect.x + rect.y + rect.width + rect.height; // 175
```

如果扩展对象和被扩展对象有一个同名属性，那么这个属性的值由后面的对象决定:

```js
let o = { x: 1 };
let p = { x: 0, ...o };
p.x; // 1：对象 o 的值覆盖了初始值
let q = { ...o, x: 2 };
q.x; // 2: 值 2 覆盖了前面对象 o 的值
```

> **注意**：
>
> 1. `...` 语法经常被称为扩展操作符，但却不是真正意义上的 JS 操作符。实际上，**它是仅在对象字面量中有效的一种特殊语法**（在其他 JS 上下文中，`...` 有其他用途。只有在对象字面量中 `...` 才会产生这种把一个对象的属性复制到另一个对象中的插值行为）。
> 2. 扩展操作符只扩展对象的自有属性，不扩展任何继承属性。
> 3. 虽然扩展操作符在代码中只是三个小圆点，但它可能给 JS 解释器带来巨大的工作量。如果对象有 n 个属性，把这个属性扩展到另一个对象可能是一种 O(n) 操作。这意味着，如果在循环或递归函数中通过.向一个大对象不断追加属性，则很可能是在写一个低效的 O(n2) 算法。随着 n 越来越大，这个算法可能会成为性能瓶颈。

#### 6.10.5 简写方法

**在把函数定义为对象属性时，称该函数为方法**。在 ES6 以前，需要像定义对象的其他属性一样，通过函数定义表达式在对象字面量中定义一个方法:

```js
let square = {
  area: function () {
    return this.side * this.side;
  },
  side: 10
};
square.area(); // 100
```

但在 ES6 中，对象字面量语法经过扩展，允许一种省略 `function` 关键字和冒号的简写方法，结果代码如下

```js
let square = {
  area() {
    return this.side * this.side;
  },
  side: 10
};
square.area(); // 100
```

这两段代码是等价的，都会给对象字面量添加一个名为 area 的属性，都会把该属性的值设置为指定函数。这种简写语法让人一看便知 `area()` 是方法，而不是像 side 一样的数据属性。

在使用这种简写语法来写方法时，属性名可以是对象字面量允许的任何形式。除了像上面的 area 一样的常规 JS 标识符之外，也可以使用字符串字面量和计算的属性名，包括符号属性名：

```js
const METHOD_NAME = 'm';
const symbol = Symbol();
let weirdMethods = {
  'method with Spaces'(x) {
    return x + 1;
  },
  [METHOD_NAME](x) {
    return x + 2;
  },
  [symbol](x) {
    return x + 3;
  }
};
weirdMethods['method With Spaces'](1); //2
weirdMethods[METHOD_NAME](1); // 3
weirdMethods[symbol](1); // 4
```

#### 6.10.6 属性的获取方法与设置方法（访问器属性）

除了数据属性（有一个名字和一个普通的值）之外，**JS 还支持为对象定义访问器属性（accessor property），这种属性不是一个值，而是一个或两个访问器方法:一个获取方法（getter）和一个设置方法（setter）**。

- 当程序查询一个访问器属性的值时，JS 会调用获取方法（不传参数）。这个方法的返回值就是属性访问表达式的值。

- 当程序设置一个访问器属性的值时，JS 会调用设置方法，传入赋值语句右边的值。从某种意义上说，这个方法负责 “设置” 属性的值。设置方法的返回值会被忽略。

如果一个属性既有获取方法也有设置方法，则该属性是一个可读写属性。如果只有一个获取方法，那它就是只读属性。如果只有一个设置方法，那它就是只写属性（这种属性通过数据属性是无法实现的），读取这种属性始终会得到 undefined。

访问器属性可以通过对象字面量的一个扩展语法来定义（获取方法和设置方法是在 ES5 中引入的）：

```js
let o = {
  // 一个普通的数据属性
  dataProp: value,
  // 通过一对函数定义的一个访问器属性
  get accessorProp() {
    return this.dataProp;
  },
  set accessorProp(value) {
    this.dataProp = value;
  }
};
```

**访问器属性是通过一个或两个方法来定义的，方法名就是属性名**。除了前缀是 `get` 和 `set` 之外，这两个方法看起来就像用 ES6 简写语法定义的普通方法一样（在 ES6 中，也可以使用计算的属性名来定义获取方法和设置方法。只要把替换为用方括号包含的表达式即可）。

上面定义的访问器方法只是简单地获取和设置了一个数据属性的值，这种情况使用数据属性或访问器属性都是可以的。例如，下面这个表示 2D 笛卡儿坐标点的对象。这个对象用普通数据属性保存点的 x 和 y 坐标，用访问器属性给出与这个点等价的极坐标：

```js
let p = {
  // x 和 y 是常规的可读写数据属性
  x: 1.0,
  y: 1.0,
  // r 是由获取方法和设置方法定义的可读写访问器属性
  // 不要忘了访问器方法后面的逗号
  get r() {
    return Math.hypot(this.x, this.y);
  },
  set r(newValue) {
    let oldValue = Math.hypot(this.x, this.y);
    let ratio = newValue / oldValue;
    this.x *= ratio;
    this.y *= ratio;
  },
  // theta 是一个只定义了获取方法的只读访问器属性
  get theat() {
    return Math.atan2(this.y, this.x);
  }
};

p.r; // Math.SQRT2
p.theat; // Math.PI/4
```

> **注意**：这个示例的获取和设置方法中使用了关键字 `this`。JS 会将这些函数作为定义它们的对象的方法来调用。这意味着在这些函数体内，this 引用的是表示坐标点的对象 p。因此访问器属性 r 的获取方法可以通过 `this.x` 和 `this.y` 来引用坐标点的 x 和 y 属性。

**与数据属性一样，访问器属性也是可以继承的**。因此，可以把上面义的对象 p 作为其它点的原形。可以给新对象定义自己的 x 和 y 属性，而它们将继承 r 和 theat 属性。

```js
let q = Object.create(p); // 一个继承获取和设置方法的新对象
q.x = 3;
q.y = 4; // 创建 q 的自有数据属性
q.r; // 5: 可以使用继承的访问器属性
q.theta; // Math.atan2(4, 3)
```

以上代码使用访问器属性定义了一个 API，提供了一个数据集的两种表示（笛卡儿坐标和极坐标）。使用访问器属性的其他场景还有写入属性时进行合理性检查，以及每次读取属性时返回不同的值：

```js
// 这个对象保证序号严格递增
const serialnum = {
  // 这个数据属性保存下一个序号
  // 属性名中的 _ 提示它仅在内部使用
  _n: 0,
  // 返回当前值并递增
  get next() {
    return this._n++;
  },
  // 把新值设置为 n，但 n 必须大于当前值
  set next(n) {
    if (n > this._n) this._n = n;
    else throw new Error('serial number can only be set to a Larger value');
  }
};

serialnum.next = 10; // 设置起始序号
serialnum.next; // 10
sertalnum.next; // 11: 每次读取 next 都得到不同的值
```

最后，再看一个通过获取方法实现 “魔法” 属性的示例：

```js
// 这个对象的访问器属性返回随机数值
// 例如，表达式 "random.octet" 在被求值时
// 会给出一个 0 和 255 之间的随机值
const random = {
  get octet() {
    return Math.floor(Math.random() * 256);
  },
  get uint16() {
    return Math.floor(Math.random() * 65536);
  },
  get int16() {
    return Math.floor(Math.random() * 65536) - 32768;
  }
};
```

## 七. 数组

**数组是值的有序集合，其中的值叫作元素，每个元素有一个数值表示的位置，叫作索引**。

**JS 数组有以下特点**：

- JS 数组是无类型限制的，即数组中的元素可以是任意类型，同一数组的不同元素也可以是不同的类型。

- JS 数组是基于零且使用 32 位数值索引的，第一个元素的索引为 0，最大可能的索引值是 4294967294(2^32^-2)，即数组最大包含 4294967295 个元素。

- JS 数组是动态的，它们会按需增大或缩小，因此创建数组时无须声明一个固定大小，也无须在大小变化时重新为它们分配空间。

- JS 数组可以是稀疏的，即元素不一定具有连续的索引，中间可能有间隙。每个 JS 数组都有 length 属性。对于非稀疏数组，这个属性保存数组中元素的个数。对于稀疏数组，length 大于所有元素的最高索引。

- JS 数组是一种特殊的 JS 对象，因此数组索引更像是属性名，只不过碰巧是整数而已。数组的这种特殊性，通常可以实现对数组的特别优化，从而让访问数值索引的数组元素明显快于访问常规的对象属性。

- 数组从 `Array.prototype` 继承属性，这个原型上定义了很多[数组操作方法](#78-数组方法)。其中很多方法都是泛型的，这意味着它们不仅可以用于真正的数组，也可以用于任何[“类数组对象”](#79-类数组对象)。最后，JS 字符串的行为类似[字母数组](#710-作为数组的字符串)。

**ES6 增加了一批新的数组类，统称为 [“定型数组”](#112-定型数组与二进制数据)（typed array）。与常规 JS 数组不同，定型数组具有固定长度和固定的数值元素类型。定型数组具有极高的性能，支持对二进制数据的字节级访问**。

### 7.1 创建数组

创建数组有以下几种方式：

- 数组字面量
- 对可迭代对象使用 `...` 扩展操作符
- `Array()` 构造函数
- 工厂方法 `Array.of()` 和 `Array.from()`

#### 7.1.1 数组字面量

数组字面量其实就是一对方括号中逗号分隔的数组元素的列表。例如:

```js
let empty = []; // 没有元素的数组
let primes = [2, 3, 5, 7, 11]; // 有 5 个数值元素的数组
let misc = [1.1, true, 'a']; // 3 种不同类型的元素，最后还有一个逗号
```

数组字面量中的值不需要是常量，可以是任意表达式：

```js
let base = 1024;
let table = [base, base + 1, base + 2, base + 3];
```

数组字面量可以包含对象字面量或其他数组字面量：

```js
let b = [
  [1, { x: 1, y: 2 }],
  [2, { x: 3, y: 4 }]
];
```

**如果数组字面量中连续包含多个逗号，且逗号之间没有值，则这个[数组就是稀疏的](#73-稀疏数组)**。这些省略了值的数组元素并不存在，但按照索引查询它们时又会返回 `undefined`。

```js
let count = [1, , 3]; // 索引 0 和 2 有元素，索引 1 没有元素
let undefs = [, ,]; // 这个数组没有元素但长度为 2
```

**数组字面量语法允许末尾出现逗号**，因此 `[,,]` 的长度是 2 不是 3。

#### 7.1.2 扩展操作符

在 ES6 及之后的版本中,可以使用扩展操作符 `...` 在一个数组字面量中包含另一个数组的元素：

```js
let a = [1, 2, 3];
let b = [0, ...a, 4]; // b == [0,1,2,3,4]
```

**扩展操作符是创建数组（浅）副本的一种便捷方式**：

```js
let original = [1, 2, 3];
let copy = [...original];
copy[0] = 0; // 修改 copy 不会影响 original
original[0]; // 1
```

扩展操作符适用于任何可迭代对象（可迭代对象可以使用 `for/of` 循环遍历）。**字符串是可迭代对象，因此可以使用扩展操作符把任意字符串转换为单个字符的数组**：

```js
let digits = [...'0123456789ABCDEF'];
digits; // ["0","1","2","3", "4", "5", "6", "7", "8", "9", "A","B","C","D","E","F"]
```

[集合对象](#1111-set-类)是可迭代的，因此要去除数组中的重复元素，一种便捷方式就是先把数组转换为集合，然后再使用扩展操作符把这个集合转换回数组:

```js
let letters = [...'hello world'];
[...new Set(letters)]; //=>[h","e","l", "o", " ", "w", "r", "d"]
```

#### 7.1.3 Array() 构造函数

另一种创建数组的方式是使用 `Array()` 构造函数。有三种方式可以调用这个构造函数:

- 不传参数调用

  ```js
  let a = new Array(); // 等价于数组字面量 `[]`
  ```

- 传入一个数组参数，指定长度:

  ```js
  let a = new Array(10);
  ```

  这样会创建一个指定长度的数组。如果提前知道需要多少个数组元素，可以像这样调用 `Array()` 构造函数来预先为数组分配空间。

  > **注意**：这时的数组中不会存储任何值，数组索引属性 “0”、“1” 等都没有定义。

- 传入两个或更多个数组元素，或传入一个非数值元素:

  ```js
  let a = new Array(5, 4, 3, 2, 1, 'testing');
  ```

  构造函数参数会成为新数组的元素。

#### 7.1.4 Array.of()

在使用数值参数调用 `Array()` 构造函数时，这个参数指定的是数组长度。但在使用一个以上的数值参数时，这些参数则会成为新数组的元素。这意味着**使用 `Array()` 构造函无法创建只包含一个数值元素的数组**。

在 ES6 中，`Array.of()` 函数可以解决这个问题。这是个工厂方法，可以使用其参数值（无论多少个）作为数组元素来创建并返回新数组：

```js
Array.of(); // 返回没有参数的空数组
Array.of(10); // 可以创建只有一个数值元素的数组
Array.of(1, 2, 3); // [1,2,3]
```

#### 7.1.5 Array.from()

`Array.from()` 是 ES6 新增的另一个工厂方法。**这个方法期待一个可迭代对象或类数组对象作为其第一个参数，并返回包含该对象元素的新数组。如果传入可迭代对象，`Array.from(iterable)` 与使用扩展操作符 `[...iterable]` 一样**。因此，它也是创建数组副本的一种简单方式:

```js
let copy = Array.from(original);
```

`Array.from()` 很重要，因为**它定义了一种给类数组对象创建真正的数组副本的机制**。类数组对象不是数组对象，但也有一个数值 `length` 属性，而且每个属性的键也都是整数。在客户端 JS 中，有些浏览器方法返回的值就是类数组对象，那么像这样先把它们转换成真正的数组便于后续的操作:

```js
let truearray = Array.from(arraylike);
```

**`Array.from()` 也接受可选的第二个参数。如果给第二个参数传入了一个函数，那么在构建新数组时，源对象的每个元素都会传入这个函数，这个函数的返回值将代替原始值成为新数组的元素**（这一点跟数组的 `map()` 方法很像，但在构建数组间执行映射的效率要高于先构建一个数组再把它映射为另一个新数组）。

### 7.2 读写数组元素

可以使用 `[]` 操作符访问数组元素，方括号左侧应该是一个对数组的引用，方括号内应该是一个具有非负整数值的表达式。这个语法可以读和写数组元素的值。因此，下面都是合法的 JS 语句：

```js
let a = ['world']; // 先创建包含一个元素的数组
let value = a[0]; // 读取元素 0
a[1] = 3.14; // 写入元素 1
let i = 2;
a[i] = 3; // 写入元素 2
a[i + 1] = 'hello'; // 写入元素 3
a[a[i]] = a[0]; // 读取元素 0 和 2，写入元素 3
```

数组特殊的地方在于，只要使用小于 `2^32^-1` 的非负整数作为属性名，数组就会自动为维护 `length` 属性的值。比如在前面的例子中，先创建了一个只有一个元素的数组。而在给它的索引 1、2、3 赋值之后，数组的 `length` 属性也会相应改变，因此:

```js
a.length; // 4
```

**数组是一种特殊的对象。用于访问数组元素的方括号与用于访问对象属性的方括号是类似的**。JS 会将数值数组索引转换为字符串，即索引 `1` 会变成字符串 `"1"`。然后再将这个字符串作为属性名。这个从数值到字符串的转换没什么特别的，使用普通对象也一样：

```js
let o = {}; // 创建一个普通对象
o[1] = 'one'; // 通过整数索引一个值
o['1']; // "one"，数值和字符串属性名是同一个
```

明确区分数组索引和对象属性名是非常有帮助的。所有索引都是属性名，但只有介于 `0` 和 `2^32^-2` 之间的整数属性名才是素引。所有数组都是对象，可以在数组上以任意名字创建属性。只不过，如果这个属性是数组索引，数组会有特殊的行为，即自动按需更新其 `length` 属性。

**可以使用负数或非整数值来索引数组。此时，数值会转换为字符串，而这个字符串会作为属性名**。因为这个名字是非负整数，所以会被当成常规的对象属性，而不是数组素引。另外，如果碰巧使用了非负整数的字符串来索引数组，那这个值会成为数组素引，而不是对象属性。同样，如果使用了与整数相等的浮点值也是如此：

```js
a[-1.23] = true; // 这样会创建一个属性 "-1.23"
a['1000'] = 0; // 这是数组中第 1001 个元素
a[1.0] = 1; // 数组索引 1，相当于 a[1]=1;
```

**由于数组索引其实就是一种特殊的对象属性，所以 JS 数组没有所谓"越界错误"**。查询任何对象中不存在的属性都不会导致错误，只会返回 undefined，数组作为一种特殊对象也是如此：

```js
let a = [true, false]; // 数组的索引 0 和 1 有元素
a[2]; // undefined，这个索引没有元素
a[-1]; // undefined，这名字没有属性
```

### 7.3 稀疏数组

稀疏数组就是其元素没有从 `0` 开始的索引的数组。正常情况下，数组的 `length` 属性表明数组中元素的个数。如果数组是稀疏的，则 `length` 属性的值会大于元素个数。

可以使用 `Array()` 构造函数创建稀疏数组，或者直接给大于当前数组 `length` 的数组索引赋值：

```js
let a = new Array(5); // 没有元素，但 a.length 是 5
a = []; // 创建一个空数组，此时 length = 0
a[1000] = 0; // 赋值增加了一个元素，但 length 变成了 1001
```

使用 `delete` 操作符也可以创建稀疏数组。

> 足够稀疏的数组通常是以较稠密数组慢、但内存占用少的方式实现的，查询这种数组的元素与查询常规对象属性的时间相当。

如果省略数组字面量中的一个值（像 `[1,,3]` 这样重复逗号两次），也会得到稀疏数组，被省略的元素是不存在的:

```js
let a1 = [,]; // 这个数组没有元素，但 length 是 1
let a2 = [undefined]; // 这个数组有一个 undefined 元素
0 in a1; // false：a1 在索引 0 没有元素
0 in a2; // true：a2 在索引 0 有 undefined 值
```

> 理解稀疏数组是真正理解 JS 数组的重要一环。但在实践中，碰到的多数 JS 数组都不是稀疏的。如果真的碰到了稀疏数组，可以把稀疏数组当成包含 undefined 元素的非稀疏数组。

### 7.4 数组长度

**每个数组都有 `length` 属性，正是这个属性让数组有别于常规的 JS 对象**。对于稠密数组（即非稀疏数组），`length` 属性就是数组中元素的个数。这个值比数组的最高索引大 1:

```js
[].length; // 0: 数组没有元素
['a', 'b', 'c'].length; // 3: 最高索引为 2, length 值为 3
```

对于稀疏数组，`length` 属性会大于元素个数，也可以说稀疏数组的 `length` 值一定大于数组中任何元素的索引。从另一个角度说，数组（无论稀疏与否）中任何元素的索引都不会大于或等于数组的 `length`。

为了维护这种不变式（invariant），数组有两个特殊行为：

- 如果给一个索引为 `i` 的数组元素赋值，而 `i` 大于或等于数组当前的 `length`，则数组的 `length` 属性会被设置为 `i+1`

- 如果将 `length` 属性设置为一个小于其当前值的非负整数 `n`，则任何索引大于或等于 `n` 的数组元素都会从数组中被删除:

  ```js
  a = [1, 2, 3, 4, 5]; // 先定义一个包含 5 个元素的数组
  a.length = 3; // a 变成 [1,2,3]
  a.length = 0; // 删除所有元素。a 是 []
  a.length = 5; // 长度是 5，但没有元素,类似 new Array(5)
  ```

  也可以把数组的 `length` 属性设置为一个大于其当前值的值。这样做并不会向数组中添加新元素，只会在数组末尾创建一个稀疏的区域。

### 7.5 添加和删除数组元素

- 为数组添加元素的最简单方式，就是给它的一个新索引赋值：

  ```js
  let a = 0; // 创建一个空数组
  a[0] = 'zero'; // 添加一个元素
  a[1] = 'one';
  ```

- 也可以使用 `push()` 方法在数组末尾添加一个或多个元素：

  ```js
  let a = []; // 创建一个空数组
  a.push('zero'); // 在末尾添加一个值，a= ["zero"]
  a.push('one', 'two'); // 再在末尾添加两个值，a = ["zero", "one", "two"]
  ```

- 向数组 `a` 中推入一个值等同于把这个值赋给 `a[a.length]`。要在数组开头插入值，可以使用 [`unshift()` 方法](#78-数组方法)，这个方法将已有数组元素移动到更高索引位。

- 与 [`push()`](#78-数组方法) 执行相反操作的是 `pop()` 方法，它删除数组最后一个元素并返回该元素，同时导致数组长度减 1。类似地，`shift()` 方法删除并返回数组的第一个元素，让数组长度减 1 并将所有元素移动到低一位的索引。

- 可以使用 delete 操作符删除数组元素：

  ```js
  let a = [1, 2, 3];
  delete a[2]; // 现在索引 2 没有元素了
  2 in a; // false: 数组索引 2 没有定义
  a.length; // 3: 删除元素不影响数组长度
  ```

  删除数组元素类似于（但不完全等同于）给该元素赋 undefined 值。

  > **注意**：对数组元素使用 `delete` 操作符不会修改 `length` 属性，也不会把高索引位的元素向下移动来填充被删除属性的空隙。从数组中删除元素后，数组会变稀疏。

- 把数组 `length` 属性设置成一个新长度值，也可以从数组末尾删除元素。

- [`splice()`](#78-数组方法) 是一个可以插入、删除或替换数组元素的通用方法。这个方法修改 `length` 属性并按照需要向更高索引或更低索引移动数组元素。

### 7.6 迭代数组

- 在 ES6 以前，遍历一个数组（或任何可迭代对象）的最简单方式是使用 `for/of` 循环：

  ```js
  let letters = [...'Hello world'];
  let string = '';
  for (let letter of letters) {
    string += letter;
  }
  string; // "Hello world"; 重新组装了原始文本
  ```

  `for/of` 循环使用的内置数组迭代器按照升序返回数组的元素。对于稀疏数组，这个循没有特殊行为，凡是不存在的元素都返回 undefined。

- 如果要对数组使用 `for/of` 循环，并且想知道每个数组元素的索引，可以使用数组的 `entries()` 方法和解构赋值：

  ```js
  let everyother = '';
  for (let [index, letter] of Letters.entries()) {
    if (index % 2 === 0) everyother += letter; // 偶数索引的字母
  }
  everyother; // 'Hlowrd'
  ```

- 另一种**迭代数组的推荐方式**是使用 [`forEach()`](#781-数组迭代器方法)。它并不是一种新的 for 循环，而是数组提供的一种用于自身迭代的函数式方法。因此需要给 `forEach()` 传一个函数，然后 `forEach()` 会用数组的每个元素调用一次这个函数：

  ```js
  let uppercase = '';
  // 注意这里使用的是箭头函数
  letters.forEach(letter => {
    uppercase += letter.toUpperCase();
  });
  uppercase; // "HELLO WORLD"
  ```

  `forEach()` 按顺序迭代数组，而且会将索引作为第二个参数传给函数。与 `for/of` 循环不同，`forEach()` 能感知稀疏数组，不会对没有的元素数组调用函数。

- 使用老式的 for 循环也可以遍历数组：

  ```js
  let vowels = '';
  // 对数组中的每个索引
  for (let i = 0; i < letters.Length; i++) {
    let letter = letters[i]; // 取得该索引处的元素
    // 使用正则表达式测试
    if (/[aeiou]/.test(letter)) {
      vowels += letter; // 如果是元音就记住它
    }
  }
  vowels; // "eoo"
  ```

  在嵌套循环中，或其他性能攸关的场合，有时候会看到这种简单的数组迭代循环，但只会读取一次数组长度，而不是在每个迭代中都读取一次。下面展示的两种 for 循环形式都是比较推荐的：

  ```js
  // 把数组长度保存到局部变量中
  for (let i = 0, len = letters.length; i < len; i++) {
    // 循环体不变
  }

  // 从后向前迭代数组
  for (let i = letters.length - 1; i >= 0; i--) {
    //循环体不变
  }
  ```

  这两个例子假定数组是稠密的，即所有元素都包含有效数据。如果不是这种情况，那应该在使用每个元素前先进行测试。如果想跳过未定义或不存在的元素，可以这样写:

  ```js
  for (let i = 0; i < a.length; i++) {
    if (a[i] === undefined) continue; // 跳过未定义及不存在的元素
    // 这里的循环体
  }
  ```

### 7.7 多维数组

JS 并不支持真正的多维数组，但可以使用数组的数组来模拟。要访问数组的数组的值，使用两个 `[]` 即可。比如，假设变量 matrix 是一个数值数组的数组，则 `matrix[x]` 的每个元素都是一个数值数组。要访问这个数组中的某个数值，就要使用 `matrix[x][y]` 这种形式。下面这个例子利用二维数组生成了乘法表：

```js
// 创建一个多维数组
let table = new Array(10);
// 表格的 10 行
for (let i = 0; i < table.length; i++) {
  table[i] = new Array(10); // 每行有 10 列
}

// 初始化数组
for (let row = 0; row < table.length; row++) {
  for (let col = 0; col < table[row].length; col++) {
    table[row][col] = row * col;
  }
}
// 从这个多维数组中获得5*7的值
table[5][7]; // 35
```

### 7.8 数组方法

前面主要是 JS 操作数组的基本语法。但一般来说，还是 Array 类定义的方法用处最大。接下来会介绍几个相关的数组方法：

- **迭代器方法**：用于遍历数组元素，通常会对每个元素调用一次指定的函数。

- **栈和队列方法**：用于在开头或末尾向数组中添加元素或从数组中删除元素。

- **子数组方法**：用于提取、删除、插入、填充和复制更大数组的连续区域。

- **搜索和排序方法**：用于在数组中查找元素和对数组元素排序。

#### 7.8.1 数组迭代器方法

**作用**
: 数组迭代器方法，它们会按照顺序把数组的每个元素传给提供的函数，可便于对数组进行迭代、映射、过滤、测试和归并。

**共性**
首先，所有这些方法都接收一个函数作为第一个参数，并且对数组的每个元素（或某些元素）都调用一次这个函数。如果数组是稀疏的，则不会对不存在的数组元素调用传入的这个函数。多数情况下，提供的这个函数被调用时都会收到 3 个参数，分别是数组元素的值、数组元素的索引和数组本身。

多数迭代器方法都接收可选的第二个参数。如果指定这个参数，则第一个函数在被调用时就好像它是第二个参数的方法一样。换句话说，传入的第二个参数会成为作为第一个参数传入的函数内部的 this 值。传入函数的返回值通常不重要，但不同的方法会以不同的方式处理这个返回值。

所有这些方法在被调用时第一个参数都是函数，因此在方法调用表达式中直接定义这个函数参数是很常见的。[箭头函数](#813-箭头函数)特别适合在这些方法中使用。

- `forEach()`
  `forEach()` 方法迭代数组的每个元素，并对每个元素都调用一次指定的函数。传统 `forEach()` 方法的第一个参数是函数。**`forEach()` 在调用这个函数时会给它传 3 个参数: 数组元素的值、数组元素的索引和数组本身**。如果只关心数组元素的值，可以把函数写成只接收一个参数，即忽略其他参数：

  ```js
  let data = [1, 2, 3, 4, 5],
    sum = 0;
  // 计算数组元素之和
  data.forEach(value => {
    sum += value; // sum == 15
  });

  // 递增每个元素的值
  data.forEach(function (v, i, a) {
    a[i] = v + 1; // data == [2,3,4,5,6]
  });
  ```

  > **注意**：`forEach()` 并未提供一种提前终止迭代的方式。即，在这里没有与常规 for 循环中的 break 语句对等的机制。

- `map()`

  `map()` 方法把调用它的数组的每个元素分别传给指定的函数，返回这个函数的返回值构成的数组。例如：

  ```js
  let a = [1, 2, 3];
  a.map(x => x * x); // [1,4,9]: 这个函数接收 x 并返回 x*x
  ```

  传给 `map()` 的函数与传给 `forEach()` 的函数会以同样的方式被调用。但对于 `map()` 方法来说，传入的函数应该返回值。

  > **注意**：`map()` 返回一个新数组，并不修改调用它的数组。如果数组是稀疏的，则缺失元素不会调用函数，但返回的数组也会与原始数组一样稀疏: 长度相同，缺失的元素也相同。

- `filter()`
  `filter()` 方法返回一个数组，该数组包含调用它的数组的子数组。**传给这个方法的函数应该是个断言函数，即返回 true 或 false 的函数**。这个函数与传给 `map()` 的函数一样被调用。如果函数返回 true 或返回的值转换为 true，则传给这个函数的元素就是 `filter()` 最终返回的子数组的成员。看例子：

  ```js
  let a = [5, 4, 3, 2, 1];
  a.filter(x => x < 3); // [2, 1] 小于 3 的值
  a.filter((x, i) => i % 2 === 0); // [5, 3, 1]，隔一个选一个
  ```

  > **注意**：`filter()` 会跳过稀疏数组中缺失的元素，它返回的数组始终是稠密的。因此可以使用 `filter()` 方法像下面这样**清理掉稀疏数组中的空隙**：

  ```js
  let dense = sparse.filter(() => true);
  ```

  如果既想清理空隙，又想删除值为 undefined 和 null 的元素，则可以这样写:

  ```js
  a = a.filter(x => x !== undefined && x !== null);
  ```

- `find()` 与 `findIndex()`

  `find()` 和 `findIndex()` 方法与 `filter()` 类似，表现在它们都遍历数组，寻找断言函数返回真值的元素。

  但与 `filter()` 不同的是，这两个方法会在断言函数找到第一元素时停止迭代。此时，`find()` 返回匹配的元素，`findIndex()` 返回匹配元素的索引。

  没有找到匹配的元素，则 `find()` 返回 undefined，而 `findIndex()` 返回 -1：

  ```js
  let a = [1, 2, 3, 4, 5];
  a.findIndex(x => x === 3); // 2，值 3 的索引是 2
  a.findIndex(x => x < 0); // -1，数组中没有负数
  a.find(x => x % 5 === 0); // 5：5 的倍数
  a.find(x => x % 7 === 0); // undefined：数组中没有 7 的倍数
  ```

- `every()` 与 `some()`

  `every()` 和 `some()` 方法是数组断言方法，即它们会对数组元素调用传入的断言函数，最后返回 true 或 false。

  `every()` 方法与数学上的 “全称” 量词类似，**它在且只在断言函数对数组的所有元素都返回 true 时才返回 true**：

  ```js
  let a = [1, 2, 3, 4, 5];
  a.every(x => x < 10); // true：所有值都小于 10
  a.every(x => x % 2 === 0); // false：并非所有值都是偶数
  ```

  `some()` 方法类似于数学上的 “存在” 量词，只要数组元素中有一个让断言函数 true 它就返回 true，但必须数组的所有元素对断言函数都返回 false 才返回 false：

  ```js
  let a = [1, 2, 3, 4, 5];
  a.some(x => x % 2 === 0); // true，a 包含偶数
  a.some(isNaN); // false，a 没有非数值
  ```

  > **注意**：如果在空数组上调用它们，按照数学的传统，`every()` 返回 true，`some()` 返回 false。

- `reduce()` 与 `reduceRight()`

  `reduce()` 和 `reduceRight()` 方法使用指定的函数归并数组元素，最终产生一个值。在函数编程中，归并是一个常见操作，有时候也称为注入（Inject）或折叠（fold）。例子：

  ```js
  let a = [1, 2, 3, 4, 5];
  a.reduce((x, y) => x + y, 0); // 15; 所有值之和
  a.reduce((x, y) => x * y, 1); // 120; 所有值之积
  a.reduce((x, y) => (x > y ? x : y)); //5，最大值
  ```

  `reduce()` 接收两个参数。第一个参数是执行归并操作的函数。这个归并函数的任务就是把两个值归并或组合为一个值并返回这个值。在上面的例子中，归并函数通过把两个值相加、相乘和选择最大值来合并两个值。第二个参数是可选的，是传给归并函数的初始值。

  在 `reduce()` 中使用的函数与在 `forEach()` 和 `map()` 中使用的函数不同。值、索引和数组本身在这里作为第二、第三和第四个参数。第一个参数是目前为止归并操作的累计结果。在第一次调用这个函数时，第一个参数作为 `reduce()` 的第二个参数的初始值。在后续调用中，第一个参数则是上一次调用这个函数的返回值。

  在第一个例子中，初次调用归并函数传入的是 0 和 1，归并函数把它们相加后返回 1。然后再以参数 1 和 2 调用它并返回 3。接着计算 3+4=6、6+4=10，最后 10+5=15。最终值 15 成为 `reduce()` 的返回值。

  上面例子中第三次调用 `reduce()` 只传了一个参数，即并未指定初始值。在像这样不指定初始值调用时，`reduce()` 会使用数组的第一个元素作为初始值。这意味着首次调用归并函数将以数组的第一和第二个元素作为其第一和第二个参数。

  > **注意**：如果不传初始值参数，在空数组上调用 `reduce()` 会导致 TypeError。如果调用它时只有一个值，比如用只包含一个元素的数组调用且不传初始值，或者用空数组调用但传了初始值，则 `reduce()` 直接返回这个值，不会调用归并函数。

  `reduceRight()` 与 `reduce()` 类似，只不过是从高索引向低索引（从右到左）处理数组，而不是从低到高。如果归并操作具有从右到左的结合性，那可能要考虑 `reduceRight()`。比如:

  ```js
  // 计算 2^(3^4) 求幂具有从右到左的优先数
  let a = [2, 3, 4];
  a.reduceRight((acc, val) => Math.pow(vaL, acc)); // 2.4178516392292583e+24
  ```

  > **注意**：
  >
  > 1. 无论 `reduce()` 还是 `reduceRight()` 都不接收用于指定归并函数 this 值的可选参数。它们用可选的初始值参数取代了这个值。如果需要把归并函数作为特定对象的方法调用，可以考虑使用 [Function.bind() 方法](#875-bind-方法)。
  > 2. `reduce()` 和 `reduceRight()` 并不是专门为数学计算而设计的。只要是能够把两个值（比如两个对象）组合成一个同类型值的函数，都可以用作归并函数。另一方面，使用数组归并表达的算法很容易复杂化，因而难以理解。此时可能使用常规循环逻辑处理数组反倒更容易阅读、编写和分析。

#### 7.8.2 使用 `flat()` 和 `flatMap()` 打平数组

在 ES2019 中，`flat()` 方法用于创建并返回一个新数组，这个新数组包含与它调用 `flat()` 的数组相同的元素，只不过其中任何本身也是数组的元素会被 “打平” 填充到返回的数组中。例如：

```js
[1, [2, 3]].flat(); // [1,2,3]
[1, [2, [3]]].flat(); // [1,2,[3]]
```

在不传参调用时，`flat()` 会打平一级嵌套，原始数组中本身也是数组的元素会被打平，但打平后的元素如果还是数组则不会再打平。如果想打平更多层级，需要给 `flat()` 传一个数值参数：

```js
let a = [1, [2, [3, [4]]]];
a.flat(1); // [1, 2, [3, [4]]]
a.flat(2); // [1,2,3,[4]]
a.flat(3); // [1,2,3,4]
a.flat(4); // [1,2,3,4]
```

`flatMap()` 方法与 `flat()` 方法相似，只不过返回的数组会自动打平就像传给 `flat()` 一样。换句话说，调用 `a.flatMap(f)` 等同于（但效率远高于）`a.map(f).flat()`。

```js
let phrases = ['hello world', 'the definitive guide'];
let words = phrases.flatMap(phrase => phrase.split(' '));
words; // ["hello", "world", "the", "definitive", "guide"]
```

可以把 `flatMap()` 想象为一个通用版的 `map()`，可以把输入数组中的一个元素映射为输出数组中的多个元素。特别地，`flatMap()` 允许把输入元素映射为空数组，这样打平后并不会有元素出现在输出数组中：

```js
// 将非负数映射为它们的平方根
[-2, -1, 1, 2].flatMap(x => (x < 0 ? [] : Math.sqrt(x))); // [1, 2**0.5]
```

#### 7.8.3 使用 `concat()` 添加数组

`concat()` 方法创建并返回一个新数组，新数组包含调用 `concat()` 方法的数组的元素，以及传给 `concat()` 的参数。如果这些参数中有数组，则拼接的是它们的元素而非数组本身。

> **注意**：`concat()` 不会递归打平数组的数组。`concat()` 并不修改调用它的数组:

```js
let a = [1, 2, 3];
a.concat(4, 5); // [1, 2, 3, 4, 5]
a.concat([4, 5], [6, 7]); // [1, 2, 3, 4, 5, 6, 7]，数组被打平了
a.concat(4, [5, [6, 7]]); // [1, 2, 3, 4, 5, [6, 7]，但不会打平嵌套的数组
a; // [1, 2, 3]，原始数组没有改变
```

> **注意**：`concat()` 会创建调用它的数组的副本。很多情况下，这样做都是正确的，只不过操作代价有点大。如果正在写类似 `a = a.concat(x)` 这样的代码，那应该考虑使用 `push()` 或 `splice()` 就地修改数组。

#### 7.8.4 通过 `push()`、`pop()`、`shift()` 和 `unshift()` 实现栈和队列操作

- `push()` 和 `pop()`
  `push()` 和 `pop()` 方法可以把数组作为栈来操作。其中，`push()` 方法用于在数组末尾添加一个或多个新元素，并返回数组的新长度。与 `concat()` 不同，`push()` 不会打平数组参数。`pop()` 方法恰好相反，它用于删除数组最后面的元素，减少数组长度，并返回删除的值。

  > **注意**：这两个方法都会就地修改数组。组合使用 `push()` 和 `pop()` 可以使用 JS 数组实现先进后出的栈。

  ```js
  let stack = []; // stack == []
  stack.push(1, 2); // stack == [1, 2]
  stack.pop(); // stack == [1]，返回 2
  stack.push(3); // stack == [1, 3]
  stack.pop(); // stack == [1]，返回 3
  stack.push([4, 5]); // stack == [1, [4, 5]]
  stack.pop(); // stack == [1]，返回 [4, 5]
  stack.pop(); // stack == []，返回 1
  ```

  `push()` 方法不会打平传入的数组，如果想把一个数组中的所有元素都推送到另一个数组中，可以使用[扩展操作符](#834-在函数调用中使用扩展操作符)显式打平它：

  ```js
  a.push(...values);
  ```

- `unshift()` 和 `shift()`
  `unshift()` 和 `shift()` 方法与 `push()` 和 `pop()` 很类似，只不过它们是从数组开头而非末尾插入和删除元素。`unshift()` 用于在数组开头添加一个或多个元素，已有元素的索引会相应向更高索引移动，并返回数组的新长度。

  `shift()` 删除并返回数组的第一个元素，所有后续元素都会向下移动一个位置，以占据数组开头空出的位置。

  使用 `unshift()` 和 `shift()` 可以实现栈，但效率不如使用 `push()` 和 `pop()`，因为每次在数组开头添加或删除元素都要向上或向下移动元素。不过，可以使用 `push()` 在数组末尾添加元素，使用 `shift()` 在数组开头删除元素来实现队列：

  ```js
  let q = []; // q == []
  q.push(1, 2); // q == [1,2]
  g.shift(); // q == [2]，返回 1
  q.push(3); // q == [2, 3]
  q.shift(); // q == [3]，返回 2
  q.shift(); // q == []，返回 3
  ```

  `unshift()` 还有一个特殊特性。在给 `unshift()` 传多个参数时，这些参数会一次性插入数组。这意味着一次插入与多次插入之后的数组顺序不一样。

  ```js
  let a = []; // a == []
  a.unshift(1); // a == [1]
  a.unshift(2); // a == [2, 1]
  a = [];
  a.shift(1, 2); // a = [1, 2]
  ```

#### 7.8.5 使用 `slice()`、`splice()`、`fill()` 和 `copyWithin()`

数组定义了几个处理连续区域（或子数组，或数组“切片”）的方法。

- `slice()`
  `slice()` 方法返回一个数组的切片（slice）或者子数组。这个**方法接收两个参数，分别用于指定要返回切片的起止位置**。返回的数组包含第一个参数指定的元素，以及所有后续元素，直到（但不包含）第二个参数指定的元素。如果只指定一个参数，返回的数组将包含从该起点开始直到数组末尾的所有元素。如果任何一个参数是负值，则这个值相对于数组长度指定数组元素。比如，参数 -1 指定数组的最后一个元素，参数 -2 指定倒数第二个元素。

  > **注意**：`slice()` 不会修改调用它的数组。

  ```js
  let a = [1, 2, 3, 4, 5];
  a.slice(0, 3); // 返回 [1, 2, 3]
  a.slice(3); // 返回 [4, 5]
  a.slice(1, -1); // 返回 [2, 3]
  a.slice(3, -2); // 返回 [3]
  ```

- `splice()`
  `splice()` 是一个对数组进行插入和删除的通用方法。与 `slice()` 和 `concat()` 不同，`splice()` 会修改调用它的数组。

  `splice()` 可以从数组中删除元素，可以向数组中插入新元素，也可以同时执行这两种操作。位于插入点或删除点之后的元素的索引会按照需要增大或减少，从而与数组剩余部分保持连续。**`splice()` 的第一个参数指定插入或删除操作的起点位置。第二个参数指定要从数组中删除（切割出来）的元素个数**。如果省略第二个参数，从起点元素开始的所有数组元素都将被删除。`splice()` 返回被删除元素的数组，如果没有删除元素返回空数组。例如：

  ```js
  let a = [1, 2, 3, 4, 5, 6, 7, 8];
  a.splice(4); // [5, 6, 7, 8]，a 现在是 [1, 2, 3, 4]
  a.splice(1, 2); // [2, 3]，a 现在是 [1, 4]
  a.splice(1, 1); // [4]，a 现在是 [1]
  ```

  **`splice()` 的前两个参数指定要删除哪些元素。这两个参数后面还可以跟任意多个参数，表示要在第一个参数指定的位置插入到数组中的元素**。例如:

  ```js
  let a = [1, 2, 3, 4, 5];
  a.splice(2, 0, 'a', 'b'); // []; a 现在是 [1, 2, "a", "b", 3, 4, 5]
  a.splice(2, 2, [1, 2], 3); // ["a""b"]; a 现在是 [1, 2, [1, 2], 3, 3, 4, 5]
  ```

  > **注意**：与 `concat()` 不同，`splice()` 插入数组本身，而不是数组的元素。

- `fill()`
  `fill()` 方法将数组的元素或切片设置为指定的值。它会修改调用它的数组，也返回修改后的数组：

  ```js
  let a = new Array(5); // 创建一个长度为 5 的没有元素的数组
  a.fill(0); // [0,0,0,0,0]，用 0 填充数组
  a.fill(9, 1); // [0,9,9,9,9]，从索引 1 开始填充 9
  a.fill(8, 2, -1); // [0,9,8,8,9]，在索引 2、3 填充 8
  ```

  **`fill()` 的第一个参数是要把数组元素设置成的值。可选的第二个参数指定起始索引，如果省略则从索引 0 开始填充。可选的第三个参数，指定终止索引，到这个索引为止（但不包含）的数组元素会被填充。如果省略第三个参数，则从起始索引开始一直填充到数组末尾**。与使用 `slice()` 一样，也可以传入负值相对于数组末尾指定索引。

- `copyWithin()`
  `copyWithin()` 把数组切片复制到数组中的新位置。它会就地修改数组并返回修改后的数组，但不会改变数组的长度。**第一个参数指定要把第一个元素复制到的目的索引。第二个参数指定要复制的第一个元素的索引。如果省略第二个参数，则默认值为 0。第三个参数指定要复制的元素切片的终止索引。如果省略，则使用数组的长度。从起始索引到（但不包含）终止索引的元素会被复制**。与使用 `slice()` 一样，也可以传入负值相对于数组末尾指定索引：

  ```js
  let a = [1, 2, 3, 4, 5];
  a.copyWithin(1); // [1,1,2,3,4]：把数组元素复制到索引 1 及之后
  a.copyWithin(2, 3, 5); // [1,1,3,4,4]：把最后两个元素复制到索引 2
  a.copyWithin(0, -2); // [4,4,3,4,4]：负偏移量也可以
  ```

  `copyWithin()` 本意是作为一个高性能方法，尤其对[定型数组](#112-定型数组与二进制数据)特别有用。它模仿的是 C 标准库的 `memmove()` 函数。**即使来源和目标区域有重叠，复制也是正确的**。

#### 7.8.6 数组索引与排序方法

数组实现与字符串的同名方法类似的 `indexOf()`、`lastIndexOf()` 和 `includes()` 方法。此外还有 `sort()` 和 `reverse()` 方法用于对数组元素重新排序。

- `indexOf()` 和 `lastIndexOf()`
  `indexOf()` 和 `lastIndexOf()` 从数组中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回 -1。`indexOf()` 从前到后（或从头到尾）搜索数组，而 `lastIndexOf()` 从后向前搜索数组:

  ```js
  let a = [0, 1, 2, 1, 0];
  a.indexOf(1); // 1：a[1] 是 1
  a.lastIndexOf(1); // 3：a[3] 是 1
  a.indexOf(3); // -1：没有元素的值是 3
  ```

  `indexOf()` 和 `lastIndexOf()` 使用 `===` 操作符比较它们的参数和数组元素。如果数组包含对象而非原始值，这些方法检查两个引用是否引用同一个对象。如果想查找对象的内容，可以使用 `find()` 方法并传入自定义的断言函数。

  `indexOf()` 和 `lastIndexOf()` 都接收第二个可选的参数，指定从哪个位置开始搜索。如果省略这个参数，`indexOf()` 会从头开始搜索， `lastIndexOf()` 会从尾开始搜索。第二个参数可以是负值，相对于数组末尾偏移。比如，-1 指定数组的最后一个元素。

  下面这个函数从指定的数组中搜索指定的值，并返回所有匹配元素的索引。这个例子演示了 `indexOf()` 的第二个参数可以用来找到除第一个之外的匹配值：

  ```js
  // 从数组 a 中找到所有值 x，返回匹配索引的数组
  function findall(a, x) {
    let results = [], // 要返回的索引数组
      len = a.length, // 要搜索的数组长度
      pos = 0; // 搜索的起始位置

    while (pos < len) {
      pos = a.indexOf(x, pos); // 搜索
      if (pos === -1) break; // 如果没找到，结束
      results.push(pos); // 否则把索引保存在数组中
      pos = pos + 1; // 从下一个元素开始搜索
    }
    return results; // 返回索引数组
  }
  ```

  > **注意**：字符串也有 `indexOf()` 和 `lastindexOf()` 方法，跟这两个数组方法类似，区别在于第二个参数如果是负值会被当成 0。

- `includes()`
  ES2016 的 `includes()` 方法接收一个参数，如果数组包含该值则返回 true，否则返回 false。`includes()` 方法实际上是测试数组的成员是否属于某个集合。

  > **注意**：数组并非集合的有效表示方式，如果元素数量庞大，应该选择真正的 [Set 对象](#1111-set-类)。

  `includes()` 方法与 `indexOf()` 方法有一个重要区别。`indeOf()` 使用与 `===` 操作符同样的算法测试相等性，而该相等算法将非数值的值看成与其他值都不一样，包括与其自身也不一样。`includes()` 使用稍微不同的相等测试，认为 NaN 与自身相等。这意味着 `indexOf()` 无法检测数组中的 NaN 值，但 `includes()` 可以：

  ```js
  let a = [1, true, 3, NaN];
  a.includes(true); // true
  a.includes(2); // false
  a.includes(NaN); // true
  a.indexOf(NaN); // -1，indexOf 无法找到 NaN
  ```

- `sort()`
  `sort()` 对数组元素就地排序并返回排序后的数组。在不传参调用时，`sort()` 按字母顺序对数组元素排序（如有必要，临时把它们转换为字符串再比较）：

  ```js
  let a = ['banana', 'cherry', 'apple'];
  a.sort(); // a == ["apple", "banana", "cherry"]
  ```

  如果数组包含未定义的元素，它们会被排到数组末尾。

  要对数组元素执行非字母顺序的排序，必须给 `sort()` 传一个比较函数作为参数。这个函数决定它的两个参数哪一个在排序后的数组中应该出现在前面。如果第一个参数应该出现在第二个参数前面，比较函数应该返回一个小于 0 的数值。如果第一个参数应该出现在第二个参数后面，比较函数应该返回一个大于 0 的数值。如果两个值相等（也就是它们的顺序不重要），则比较函数应该返回 0。因此，要对数组元素按照数值而非字母顺序排序，应该这样做：

  ```js
  let a = [33, 4, 1111, 22];
  a.sort(); // a == [1111, 22, 33, 4]，字母顺序
  // 传入一个比较函数
  a.sort(function (a, b) {
    return a - b; // 取决于顺序，返回<0、0 或>0
  }); // a == [4,33,222,1111]，数值顺序
  a.sort((a, b) => b - a); // a == [1111, 222, 33, 4]，相反的数值顺序
  ```

  再来看一个排序数组元素的例子。如果想对字符串数组做不区分大小写的字母序排序，传入的比较函数应该（使用 `toLowerCase()` 方法）将其两个参数都转换为小写，然后再比较：

  ```js
  let a = ['ant', 'Bug', 'cat', 'Dog'];
  a.sort(); // a == ["Bug","Dog","ant","cat"]，区分大小写的排序
  a.sort(function (s, t) {
    let a = s.toLowerCase();
    let b = t.toLowerCase();
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  }); // a == ["ant", "Bug", "cat", "Dog"] 不区分大小写的排序
  ```

- `reverse()`

  `reverse()` 方法反转数组元素的顺序，并返回反序后的数组。这个反序是就地反序，换句话说，不会用重新排序后的元素创建新数组，而是直接对已经存在的数组重新排序：

  ```js
  let a = [1, 2, 3];
  a.reverse(); // a == [3, 2, 1]
  ```

#### 7.8.7 数组到字符串的转换

Array 类定义了 3 个把数组转换为字符串的方法，通常可以用在记录目志或错误消息的时候（如果想把数组的文本内容保存起来以备后用，可以使用 [`JSON.stringify()`](#68-序列化对象)方法对数组执行序列化）。

`join()` 方法把数组的所有元素转换为字符串，然后把它们拼接起来并返回结果字符串。可以指定一个可选的字符串参数，用于分隔结果字符串中的元素。如果不指定分隔符，则默认使用逗号:

```js
let a = [1, 2, 3];
a.join(); // "1,2,3"
a.join(' '); // "1 2 3"
a.join(''); // "123"
let b = new Array(10); // 长度为 10 但没有元素的数组
b.join('-'); // "---------": 包含 9 个连字符的字符串
```

`join()` 方法执行的是 `String.split()` 方法的反向操作，后者通过把字符串分割为多个片段来创建数组与任何 JS 对象一样，数组也有 `toString()` 方法。对于数组而言，这个方法的逻辑与没有参数的 `join()` 方法一样：

```js
[1, 2, 3].toString(); // "1,2,3"
['a', 'b', 'c'].toString(); // "a,b,c"
[1, [2, 'c']].toString(); // "1,2,c"
```

> **注意**：输出中不包含方括号或者数组值的定界符。

`toLocaleString()` 是 `toString()` 的本地化版本。它调用 `toLocaleString()` 方法将每个数组元素转换为字符串，然后再使用（实现定义的）当地分隔符字符串来拼接结果字符串。

#### 7.8.8 静态数组函数

Array 类也定义了 3 个静态函数，可以通过 Array 构造函数而非数组调用。`Array.of()` 和 `Array.from()` 是创建新数组的工厂方法。

另一个静态数组函数是 `Array.isArray()`，用于确定一个未知值是不是数组：

```js
Array.isArray([]); // true
Array.isArray({}); // false
```

### 7.9 类数组对象

JS 数组具有一些其他对象不具备的特殊特性：

- 数组的 `length` 属性会在新元素加入时自动更新
- 设置 `length` 为更小的值会截断数组
- 数组从 `Array.prototype` 继承有用的方法
- `Array.isArray()` 对数组返回 true

这些特性让 JS 数组与常规对象有了明显区别。但是，这些特性并非定义数组的本质特性。事实上，只要对象有一个数值属性 length，而且有相应的非负整数属性，那就完全可以视同为数组。

实践当中，偶尔会碰到 “类数组” 对象。虽然不能直接在它们上面调用数组方法或期待 `length` 属性的特殊行为，但仍然可以通过写给真正数组的代码来遍历它们。说到底，就是因为很多数组算法既适用于真正的数组，也适用于类数组对象。特别是在将数组视为只读或者至少不会修改数组长度的情况下，就更是这样了。

下面的代码会为一个常规对象添加属性，让它成为一个类数组对象，然后再遍历得到的伪数组的 “元素”：

```js
let a = {}; // 创建一个常规的空对象
// 添加属性让它变成 “类数组” 对象
let i = 0;
while (i < 10) {
  a[i] = i * i;
  i++;
}
a.length = i;
// 像遍历真正的数组一样遍历这个对象
let total = 0;
for (let j = 0; j < a.length; j++) {
  total += a[j];
}
```

在客户端 JS 中，很多操作 HTML 文档的方法（比如 `document.querySelectorAll()`）都返回类数组对象。下面的函数可以用来测试对象是不是类数组对象：

```js
// 确定 o 是不是类数组对象
// 字符串和函数有数值 length 属性，但是通过
// typeof 测试可以排除。在客户端 JS 中
// DOM 文本节点有数值 length 属性,可能需要加上
// o.nodeType !== 3 测试来排除
function isArrayLike(o) {
  if (
    o && // o 不是 null、 undefined 等假值
    typeof o === 'Object' && // o 是对象
    Number.isFinite(o.length) && // o.length 是有限数值
    o.length >= 0 && // o.length 是非负数组
    Number.isInteger(o.length) && // o.length 是整数
    o.length < 4294967295 // o.length < 2^32 - 1
  ) {
    return true; // 是类数组对象
  } else {
    return false; // 不是类数组对象
  }
}
```

多数 JS 数组方法有意地设计成了泛型方法，因此除了真正的数组，同样也可以用于类数组对象。但由于类数组对象不会继承 Array.prototype，所以无法直接在它们上面调用数组方法。为此，可以使用 [`Function.call()` 方法](#874-call-和-apply-方法)来调用:

```js
let a = { 0: 'a', 1: 'b', 2: 'c', length: 3 }; //类数组对象
Array.prototype.join.call(a, '+'); // "a+b+c"
Array.prototype.map.call(a, x => x.toUpperCase()); // ["A", "B", "C"]
Array.prototype.slice.call(a, 0); // ["a", "b", "c"]: 真正的数组副本
Array.from(a); // ["a","b","c"]: 更容易的数组复制
```

倒数第二行代码在类数组对象上调用了 Array 的 `slice()` 方法，把该对象的元素复制到一个真正的数组对象中。在很多遗留代码中这都是常见的习惯做法，但现在使用 `Array.from()` 会更容易。

### 7.10 作为数组的字符串

JS 字符串的行为类似于 UTF-16 Unicode 字符的只读数组。除了使用 `charAt()` 方法访问个别字符，还可以使用方括号语法：

```js
let s = 'test';
s.charAt(0); // "t"
s[1]; // "e"
```

可以通过索引访问字符串的好处，就是可以用方括号代替 `charAt()` 调用，这样更简洁也更容易理解，可能效率也更高。不过，字符串与数组的行为类似也意味着可以对字符串使用泛型的字符串方法。比如：

```js
Array.prototype.join.call('JavaScript', ' '); // "J a v a S c r i p t"
```

> **注意**：字符串是不可修改的值，因此在把它们当成数组来使用时，它们是只读数组。像 `push()`、`sort()`、`reverse()` 和 `splice()` 这些就地修改数组的数组方法，对字符串都不起作用。但尝试用数组方法修改字符串并不会导致错误，只会静默失败。

## 八. 函数

函数是 JS 程序的一个基本组成部分，也是几乎所有编程语言共有的特性。其他语言中所说的子例程（subroutine）或过程（procedure），就是函数。

函数是一个 JS 代码块，定义之后，可以被执行或调用任意多次。**JS 函数是参数化的，即函数定义可以包含一组标识符，称为参数或形参（parameter）**。这些形参类似函数体内定义的局部变量。函数调用会为这些形参提供值或实参（argument）。

函数通常会使用实参的值计算自己的返回值，这个返回值会成为函数调用表达式的值。除了实参，每个调用还有另外一个值，即调用上下文（invocation context），也就是 this 关键字的值。

**如果把函数赋值给一个对象的属性，则可以称其为该对象的方法**。如果函数是在一个对象上被调用或通过一个对象被调用，这个对象就是函数的调用上下文或 this 值。设计用来初始化一个新对象的函数称为构造函数（constructor）。

JS 中的函数是对象，可以通过程序来操控。比如，JS 可以把函数赋值给变量，然后再传递给其他函数。因为函数是对象，所以可以在函数上设置属性，甚至调用函数的方法。

JS 函数可以嵌套定义在其他函数里，内嵌的函数可以访问定义在函数作用域的任何变量。这意味着 JS 函数是闭包（closure），基于闭包可以实现重要且强大的编程技巧。

### 8.1 定义函数

在 JS 中定义函数最直观的方式就是使用 `function` 关键字，这个关键字可以用作声明或表达式。ES6 定义了一种新的方式，可以不通过 `function` 关键字定义函数，即 “箭头函数”。箭头函数的语法特别简洁，很适合把函数作为参数传给另一个函数。

在对象字面量和类定义中，有一个定义方法的[快捷语法](#6105-简写方法)。等价于使用函数定义表达式并使用基本的 `name:value` 对象字面量语法，将其赋值给对象的属性。另一种特殊情况是在对象字面量中使用关键字 `get` 和 `set` [定义特殊的获取和设置方法](#6106-属性的获取方法与设置方法访问器属性)。

> **注意**：也可以使用 [`Function()` 构造函数](#877-function-构造函数)定义新函数。另外，JS 也定义了一些特殊函数。 `function*` 用于定义[生成器函数](#十二-迭代器与生成器)，而 `async function` 用于定义[异步函数](#十三-异步-js)。

#### 8.1.1 函数声明

函数声明由 `function` 关键字后跟如下组件构成：

- **命名函数的标识符**：这个作为函数名的标识符对于函数声明是必需的，它作为一个变量名使用，新定义的函数对象会赋值给这个变量。

- **一对圆括号，中间包含逗号分隔的零或多个标识符**：这些标识符是函数的参数名，它们就像是函数体内的局部变量。

- **一对花括号，其中包含零或多个 JS 语句**：这些语句构成函数体，会在函数被调用时执行。

下面是几个函数声明的例子：

```js
// 打印对象 o 的每个属性的名字和值。返回 undefined
function printprops(o) {
  for (let p in o) {
    console.log(`${p}: ${o[p]}\n`);
  }
}

// 计算笛卡儿坐标点(x1，y1)和(×2，y2)之间的距离
function distance(x1, y1, X2, y2) {
  let dx = x2 - x1;
  let dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

// 计算阶乘的递归函数(调用自身的函数)
// x! 是 x 与所有小于它的正整数的积。
function factorial(x) {
  if (x <= 1) return 1;
  return x * factorial(x - 1);
}
```

**要理解函数声明，关键是理解函数的名字变成了一个变量，这个变量的值就是函数本身**。函数声明语句会被 “提升” 到包含脚本、函数或代码块的顶部，因此调用以这种方式定义的函数时，调用代码可以出现在函数定义代码之前。

前面看到的 `distance()` 和 `factorial()` 函数用来执行计算并得到一个值，它们都使用 `return` 把该值返回给调用者。`return` 语句导致函数停止执行并将其表达式（如果有）的值返回给调用者。如果 `return` 语句没有关联的表达式，则函数的返回值是 undefined。

`printprops()` 函数不一样：它的任务是输出对象的属性的名字和值。此时并不需要返回值，而且函数也不包含 `return` 语句。对 `printprops()` 函数调用的值始终是 undefined。如果函数并不包含 `return` 语句，那么就简单地执行函数体内的每个语句，直到最后向调用者返回 undefined。

在 ES6 以前，函数声明只能出现在 JS 文件或其他函数的顶部。虽然有些实现弱化了这个限制，但严格来讲在循环体、条件或其他语句块中定义函数都不合法。不过在 ES6 的严格模式下，函数声明可以出现在语句块中。不过，在语句块中定义的函数只在该块中有定义，对块的外部不可见。

#### 8.1.2 函数表达式

函数表达式看起来很像函数声明，但它们出现在复杂表达式或语句的上下文中，而且函数名是可选的。以下是几个函数表达式的示例:

```js
// 这个函数表达式定义一个对参数求平方的函数
// 注意，把它赋值给了一个变量
const square = function (x) {
  return x * x;
};

// 函数表达式可以包含名字，这对递归有用
const f = function fact(x) {
  if (x <= 1) return 1;
  else return x * fact(x - 1);
};

// 函数表达式也可以用作其他函数的参数
[3, 2, 1].sort(function (a, b) {
  return a - b;
});

// 函数表达式也可以定义完立即调用:
let tensquared = (function (x) {
  return x * x;
})(10);
```

> **注意**：函数名对定义为表达式的函数而言是可选的，前面看到的多数函数表达式都没有名字。函数声明实际上会声明一个变量，然后把函数对象赋值给它。而函数表达式不会声明变量，至于要把新定义的函数赋值给一个常量还是变量都可以，方便多次引用。**最佳实践是使用 `const` 把函数表达式赋值给常量，以防止意外又给它赋新值而重写函数**。

如果需要引用自身，也可以带函数名，比如前面的阶乘函数。如果函数表达式包含名字，则该函数的局部作用域中也会包含一个该名字与函数对象的绑定。实际上，函数名就变成了函数体内的一个局部变量。多数定义为表达式的函数都不需要名字，这让定义更简洁。

**函数表达式与函数声明的重要区别**
在使用声明形式时，先创建好函数对象，然后再运行包含它们的代码，而且函数的定义会被提升到顶部，因此在定义函数的语句之前就可以调用它们。但对于定义为表达式的函数就不一样了，这些函数在定义它们的表达式实际被求值以前是不存在的。不仅如此，要调用函数要求必须可以引用函数，在把函数表达式赋值给变量之前是无法引用函数的，因此定义为表达式的函数不能在它们的定义之前调用。

#### 8.1.3 箭头函数

在 ES6 中，可以使用一种特别简洁的语法来定义函数，叫作 “箭头函数”。它使用 “箭头” 分隔函数的参数和函数体。因为箭头函数是表达式而不是语句，所以不必使用 `function` 关键字，而且也不需要函数名。

箭头函数的一般形式是圆括号中逗号分隔的参数列表，后跟箭头 `=>`，再跟包含在花括号中的函数体：

```js
const sum = (x, y) => {
  return x + y;
};
```

但箭头函数还支持一种更简洁的语法。如果函数体只有一个 `return` 语句，那么可以省略 `return` 关键字、语句末尾的分号以及花括号，将函数体写成一个表达式，它的值将被返回:

```js
const sum = (x, y) => x + y;
```

更进一步，如果箭头函数只有一个参数，也可以省略包围参数列表的圆括号

```js
const polynomial = x => x * x + 2 * x + 3:
```

> **注意**：
>
> 1. 对于没有参数的箭头函数则必须把空圆括号写出来。
> 2. 在写箭头函数时，不能在函数参数和箭头之间放换行符。否则，就会出现类似 `const polynomial = x` 这样的一行代码，而这行代码本身是一条有效的赋值语句。
> 3. 如果箭头函数的函数体是一个 `return` 语句，但要返回的表达式是对象字面量，那必须把这个对象字面量放在一对圆括号中，以避免解释器分不清花括号到底是函数体的花括号，还是对象字面量的花括号。

箭头函数的简洁语法让它们非常适合作为值传给其他函数，而这在使用 `map()`、`filter()` 和 `reduce()` 等[数组方法](#781-数组迭代器方法)时是非常常见的：

```js
// 得到一个过滤掉 null 元素的数组
let filtered = [1, null, 2, 3].filter(x => x !== null); // filtered = [1, 2, 3]

// 求数值的平方
let squares = [1, 2, 3, 4].map(x => x * x); // squares == [1, 4, 9, 16]
```

**箭头函数与其他函数极其重要的区别**
箭头函数从定义自己的环境继承 this 关键字的值，而不是像以其他方式定义的函数那样定义自己的调用上下文。这是箭头函数的一个重要且非常有用的特性。箭头函数与其他函数还有一个区别，就是它们没有 `prototype` 属性。这意味着箭头函数不能作为新类的[构造函数](#92-类和构造函数)。

#### 8.1.4 嵌套函数

在 JS 中，函数可以嵌套在其他函数中。例如：

```js
function hypotenuse(a, b) {
  function square(x) {
    return x * x;
  }

  return Math.sqrt(square(a) + square(b));
}
```

**关于嵌套函数，最重要的是理解它们的变量作用域规则**：它们可以访问包含自己的函数（或更外层函数）的参数和变量。例如，在上面的代码中，内部函数 `square()` 可以读写外部函数 `hypotenuse()` 定义的参数 a 和 b。嵌套函数的这种作用域规则是非常重要的，是[闭包](#86-闭包)的基础。

### 8.2 调用函数

构成函数体的 JS 代码不在定义函数的时候执行，而在调用函数的时候执行。JS 函数可以通过 5 种方式来调用：

- 作为函数
- 作为方法
- 作为构造函数
- 通过 `call()` 或 `apply()` 方法间接调用
- 通过 JS 语言特性隐式调用（与常规函数调用不同）

#### 8.2.1 函数调用

函数是通过调用[表达式](#45-逻辑表达式)被作为函数或方法调用的。调用表达式包括求值为函数对象的函数表达式，后跟一对圆括号，圆括号中是逗号分隔的零或多个参数表达式列表。如果函数表达式是属性访问表达式，即函数是对象的属性或数组的元素，那么它是一个方法调用表达式。下面这段代码包含几个常规的函数调用表达式：

```js
printprops({ x: 1 });
let total = distance(0, 0, 2, 1) + distance(2, 1, 3, 5);
let probability = factorial(5) / factorial(13);
```

在一次调用中，每个（位于括号中的）实参表达式都会被求值，求值结果会变成函数的实参。换句话说，这些值会被赋予函数定义中的命名形参。在函数体内，对形参的引用会求值为对应的实参值。

对常规函数调用来说，函数的返回值会变成调用表达式的值。如果函数由于解释器到达末尾而返回，则返回值是 undefined。如果函数由于解释器执行到 `return` 语句而返回，则返回值是 `return` 后面表达式的值；如果 `return` 语句没有值就是 undefined。

对于非严格模式下的函数调用，调用上下文（this 值）是全局对象。但在严格模式下，调用上下文是 undefined。

> **注意**：使用箭头语法定义的函数又有不同：它们总是继承自身定义所在环境的 this 值。

要作为函数（而非方法）来调用的函数通常不会在定义中使用 this 关键字。但是可以在这些函数中使用 this 关键来确定是不是处于严格模式：

```js
// 定义并调用函数，以确定当前是不是严格模式
const strict = (function () {
  return !this;
})();
```

**递归函数与调用栈**
通归函数是调用自己的函数，就像前面的 `factorial()` 函数一样。某些算法，比如涉及与树相关的数据结构的算法，利用递归可以非常简洁地实现。

但在写递归函数时，一定要考虑内存的限制。如果函数 A 调用函数 B，而函数 B 调用函数 C，JS 解释器需要记住全部 3 个函数的执行上下文。当函数 C 完成时，解释器需要知道在哪里恢复函数 B，而当函数 B 完成时，它需要知道在哪里恢复函数 A。可以把这些函数的依次执行想象成一个调用栈。当函数调用另一个函数时，就会有一个新执行上下文被推到这个调用栈上面。如果函数递归调用自身 100 次，那么这个栈上就会被推入 100 个对象，而后这 100 个对象又会被弹出。这个调用栈会占用内存空间。对于现代的硬件能力而言，写一个调用自己几百次的递归函数通常没什么问题。但如果函数调用自己达到上万次，很可能会导致 “最大调用栈溢出”（Maximum call-stack size exceeded）错误。

#### 8.2.2 方法调用

**方法其实就是 JS 的函数，只不过它保存为对象的属性而已**。如果有一个函数 f 和一个对象 o，那么可以像这样定义一个方法 `o.m = f;`，对象 o 有了方法 m() 后，就可以这样调用 `o.m()`。如果 m() 期待两个参数，可以这样调用 `o.m(x, y)`。

这个例子中的代码是调用表达式，包括函数表达式 o.m 和两个参数表达式 x 和 y。这个函数表达式本身是个属性访问表达式，这意味着函数在这里是作为方法而非常规函数被调用的。**方法调用的参数和返回值与常规函数调用的处理方式完全一样**。

**方法调用与函数调用有一个重要的区别**
就是调用上下文。属性访问表达式由两部分构成：对象（o）和属性名（m）。在像这样的方法调用表达式中，对象 o 会成为调用上下文，而函数体可以通过关键字 this 引用这个对象。例子：

```js
// 对象字面量
let calculator = {
  operand1: 1,
  operand2: 1,
  // 对这个函数使用了方法简写语法
  add() {
    // 注意这里使用 this 关键字引用了包含对象
    this.result = this.operand1 + this.operand2;
  }
};
calculator.add(); // 方法调用，计算 1+1
calculator.result; // 2
```

多数方法调用使用点号进行属性访问，但使用方括号的属性访问表达式也可以实现方法调用。比如，下面这两个例子都是方法调用：

```js
o['m'](x, y); // 对 o.m(x,y) 的另一种写法
a[0](z); // 也是一种方法调用(假设 a[0] 是函数)
```

方法调用也可能涉及更复杂的属性访问表达式：

```js
customer.surname.toUpperCase(); // 调用 customer.surname 的方法
f().m(); // 在 f()的返回值上调用 m()
```

**方法和 this 关键字是面向对象编程范式的核心**。任何用作方法的函数实际上都会隐式收到一个参数，即调用它的对象。通常，方法会在对象上执行某些操作，而方法调用语法是表达函数操作对象这一事实的直观方式。比如下面这两行代码：

```js
rect.setSize(width, height);
setRectSize(rect, width, height);
```

上面两行代码中的函数是假想的，这两个调用实际上会对（假想的）rect 对象执行相同的操作。但第一行的方法调用语法更清晰地传达出了对象 rect 才是这个操作的焦点。

**方法调用链**
如果方法返回对象，那么基于这个方法调用的返回值还可以继续调用其他方法。这样就会得到表现为一个表达式的一系列方法调用（或方法调用链）。比如，在使用[基于期约的异步操作](#十三-异步-js)时，以下代码结构很常见：

```js
// 依次运行三个异步操作，最后处理错误
doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);
```

如果方法没有自己的返回值，可以考虑让它返回 this。如果能在自己的 API 中统一这么做，那就可以支持一种被称为方法调用链（method chainning）的编程风格。这样只要给对象命名，之后就可以连续调用这个对象的方法：

```js
new Square().x(100).y(100).size(50).outline('red').fill('blue').draw();
```

> **注意**：`this` 是个关键字，不是变量也不是属性名。JS 语法不允许给 `this` 赋值。

`this` 关键字不具有变量那样的作用域机制，除了箭头函数，嵌套函数不会继承包含函数的 `this` 值。如果嵌套函数被当作方法来调用，那它的 this 值就是调用它的对象。如果嵌套函数（不是箭头函数）被当作函数来调用，则它的 this 值要么是全局对象（非严格模式），要么是 undefined（严格模式）。

这里有一个常见的错误，就是对于定义在方法中的嵌套函数，如果将其当作函数来调用，以为可以使用 this 获得这个方法的调用上下文。以下代码演示了这个问题：

```js
// 对象 o
let o = {
  // 对象的方法 m
  m: function () {
    let self = this; //把 this 值保存在变量中
    this === o; // true：this 是对象 o
    f(); // 调用嵌套函数 f()
    // 嵌套函数
    function f() {
      this === o; // false：this 是全局对象或 undefined
      self === o; // true：self 是外部的 this 值
    }
  }
};
o.m(); // 在对象 o 上调用方法
```

在嵌套函数 `f()` 内部，`this` 关键字不等于对象 o。这被广泛认为是 JS 语言的一个缺陷，所以了解这个问题很重要。上面的代码演示了一个常见的技巧。在方法 m 中，把 `this` 值赋给变量 self，然后在嵌套函数 f 中，就可以使用 self 而非 this 来引用包含对象。

在 ES6 及之后的版本中，解决这个问题的另一个技巧是把嵌套函数 f 转换为箭头函数，因为箭头函数可以继承 this 值：

```js
const f = () => {
  this === o; // true，因为箭头函数继承 this
};
```

函数表达式不像函数声明语句那样会被提升，因此为了让上面的代码有效，需要将这个函数 f 的定义放到方法 m 中调用函数 f 的代码之前。

还有一个技巧是调用嵌套函数的 [`bind()` 方法](#875-bind-方法)，以定义一个在指定对象上被隐式调用的新函数：

```js
const f = function () {
  this === 0; // true，因为把这个函数绑定到了外部的 this
}.bind(this);
```

#### 8.2.3 构造函数调用

如果函数或方法调用前面加了一个关键字 `new`，那它就是构造函数调用。**构造函数调用与常规函数和方法调用的区别在于参数处理、调用上下文和返回值**。

如果构造函数调用在圆括号中包含参数列表，则其中的参数表达式会被求值，并以与函数和方法调用相同的方式传给函数。不过，假如没有参数列表，构造函数调用时其实也可以省略空圆括号。例如：

```js
o = new Object(); // 等价于 new Object
```

构造函数调用会创建一个新的空对象，这个对象继承构造函数的 prototype 属性指定的对象。构造函数就是为初始化对象而设计的，这个新创建的对象会被用作函数的调用上下文，因此在构造函数中可以通过 `this` 关键字引用这个新对象。

> **注意**：即使构造函数调用看起来像方法调用，这个新对象也仍然会被用作调用上下文。换句话说，在表达式 `new o.m()` 中，o 不会用作调用上下文。

构造函数正常情况下不使用 `return` 关键字，而是初始化新对象并在到达函数体末尾时隐式返回这个对象。此时，这个新对象就是构造函数调用表达式的值。但是，如果构造函数显式使用了 `return` 语句返回某个对象，那该对象就会变成调用表达式的值。如果构造函数使用 `return` 但没有返回值，或者返回的是一个原始值，则这个返回值会被忽略，仍然以新创建的对象作为调用表达式的值。

#### 8.2.4 间接调用

JS 函数是对象，与其他 JS 对象一样，JS 函数也有方法。其中有两个方法 [`call()` 和 `apply()`](#874-call-和-apply-方法)，可以用来间接调用函数。这两个方法允许指定调用时的 `this` 值，这意味着可以将任意函数作为任意对象的方法来调用，即使这个函数实际上并不是该对象的方法。

这两个方法都支持指定调用参数。其中，`call()` 方法使用自己的参数列表作为函数的参数，而 `apply()` 方法则期待数组值作为参数。

#### 8.2.5 隐式函数调用

有一些 JS 语言特性看起来不像函数调用，但实际上会导致某些函数被调用。要特别关注会被隐式调用的函数，因为这些函数涉及的 bug、副效应和性能问题都比常规函数更难排查。因为只看代码可能无法知晓什么时候会调用这些函数。

以下是可能导致隐式函数调用的一些语言特性：

- 如果对象有获取方法或设置方法，则[查询或设置其属性值](#6106-属性的获取方法与设置方法访问器属性)可能会调用这些方法。

- 当对象在字符串上下文中使用时（比如当拼接对象与字符串时），会调用对象的 `toString()` 方法。类似地，当对象用于数值上下文时，则会调用它的 `valueOf()`方法。

- 在遍历可迭代对象的元素时，也会涉及一系列方法调用。

- [标签模板字面量](#145-模板标签)是一种伪装的函数调用。

- [代理对象](#147-代理对象)的行为完全由函数控制。这些对象上的几乎任何操作都会导致一个函数被调用。

### 8.3 函数实参与形参

JS 函数定义不会指定函数形参的类型，函数调用也不对传入的实参进行任何类型检查。事实上，JS 函数调用连传入实参的个数都不检查。

#### 8.3.1 可选形参与默认值

当调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是 undefined。有时候，函数定义也需要声明一些可选参数。例子：

```js
// 把对象的可枚举属性名放到数组 a 中，返回 a
// 如果不传 a，则创建一个新数组
function getPropertyNames(o, a) {
  if (a === undefined) a = []; // 如果是 undefined，创建一个新数组
  for (let property in o) a.push(property);
  return a;
}

// 调用 getPropertyNames() 时可以传一个参数，也可以传两个参数
let o = { x: 1 },
  p = { y: 2, z: 3 }; // 两个用于测试的对象
let a = getPropertyNames(o); // a == ["x"]： o 的属性保存在新数组中
getPropertyNames(p, a); // a = ["x", "y", "z"]：把 p 的属性也放到 a 中
```

这个函数的第一行也可以不使用 if 语句，而是像下面这样约定俗成地使用 `||`：

```js
a = a || [];
```

> **注意**：在设置有可选参数的函数时，一定要把可选参数放在参数列表最后，这样在调用时才可以省略。

在 ES6 及更高的版本中，可以在函数形参列表中直接为每个参数定义默认值。语法是在形参名后面加上等于号和默认值，这样在没有给该形参传值时就会使用这个默认值：

```js
// 把对象 o 的可枚举属性名放到数组 a 中，返回 a
// 如果不传 a，则创建一个新数组
function getPropertyNames(o, a = []) {
  for (let property in o) a.push(property);
  return a;
}
```

函数的形参默认值表达式会在函数调用时求值，不会在定义时求值。因此每次调用 `getPropertyNames()` 函数时如果只传一个参数，都创建并传入一个新的空数组法。如果形参默认值是常量（或类似 []、{} 这样的字面量表达式），那函数是最容易理解的。

但这不是必需的，也可以使用变量或函数调用计算形参的默认值。对此有一种有意思的情形，即如果函数有多个形参，则可以使用前面参数的值来定义后面参数的默认值：

```js
// 这个函数返回一个表示矩形尺寸的对象
// 如果只提供 width，则 height 就是它的两倍。
const rectangle = (width, height = width * 2) => ({ width, height });
rectangle(1); // { width: 1, height: 2 }
```

#### 8.3.2 剩余形参与可变长度实参列表

形参默认值可以编写用少于形参个数的实参来调用的函数。剩余形参（restparameter）的作用恰好相反：它能够编写在调用时传入比形参多任意数量的实参的函数。下面是示例函数，接收一个或多个实参，返回其中最大的一个：

```js
function max(first = -Infinity, ...rest) {
  let maxValue = first; //假设第一个参数是最大的
  // 遍历其他参数，寻找更大的数值
  for (let n of rest) {
    if (n > maxValue) maxValue = n;
  }
  // 返回最大的数值
  return maxValue;
}
nax(1, 10, 100, 2, 3, 1000, 4, 5, 6); // 1000
```

剩余形参前面有 3 个点，而且必须是函数声明中最后一个参数。在调用有剩余形参的函数时，传入的实参首先会赋值到非剩余形参，然后所有剩余的实参会保存在一个数组中赋值给剩余形参。最后一点很重要：**在函数体内，剩余形参的值始终是数组。数组有可能为空，但剩余形参永远不可能是 undefined**（相应地，也要记住，永远不要给剩余形参定义默认值，这样既没有用，也不合法）。

类似前面例子中那样可以接收任意数量实参的函数称为可变参数函数（variadicfunction）、可变参数数量函数（variable arity function）或变长函数（vararg function）。“变长函数” 这个称呼可以追溯到 C 编程语言诞生的时期。

> 一定要分清在函数定义中用于定义剩余形参的 `...` 和[扩展操作符](#834-在函数调用中使用扩展操作符)，后者可以在函数调用中使用。

#### 8.3.3 Arguments 对象

剩余形参是 ES6 引入 JS 的。在 ES6 之前，变长函数是基于 Arguments 对象实现的。也就是说，在任何函数体内，标识符 `arguments` 引用该次调用的 Arguments 对象。

Arguments 对象是一个[类数组对象](#79-类数组对象)，它允许通过数值而非名字取得传给函数的参数值。例子：

```js
function max(x) {
  let maxValue = -Infinity;
  // 遍历 arguments，查找并记住最大的数值
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > maxValue) maxValue = arguments[i];
  }
  // 返回最大的数值
  return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6); // 1000
```

**不建议使用 Arguments**
Arguments 对象可以追溯到 JS 诞生之初，也有一些奇怪的历史包袱，导致它效率低且难优化，特别是在非严格模式下。在重构老代码时，如果碰到了使用 `arguments` 的函数，通常可以将其替换为 `...args` 剩余形参。

由于 Arguments 对象属于历史遗留问题，在严格模式下，`arguments` 会被当成保留字。因此不能用这个名字来声明函数形参或局部变量。

#### 8.3.4 在函数调用中使用扩展操作符

在期待单个值的上下文中，扩展操作符 `...` 用于展开或 “扩展” 数组（或任何可选代对象，如字符串）的元素，这个操作符同样可以用在函数调用中：

```js
let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers); // -1
```

> **注意**：从求值并产生一个值的角度说，`...` 并不是真正的操作符。应该说，它是一种可以针对数组字面量或函数调用使用的特殊 JS 语法。

如果在函数定义（而非函数调用）时使用同样的 `...` 语法，那么会产生与扩展操作符相反的作用。在函数定义中使用 `...` 可以将多个函数实参收集到一个数组中。剩余形参和扩展操作符经常同时出现，如以下函数所示，它接收一个函数实参并返回该函数的可测量版本，以用于测试：

```js
// 这个函数接收一个函数并返回一个包装后的版本
function timed(f) {
  // 把实参收集到一个剩余形参数组 args 中
  return function (...args) {
    console.log(`Entering function ${f.name}`);
    let startTime = Date.now();
    try {
      // 把收集到的实参传给包装后的函数a
      return f(...args); // 把 args 扩展回原来的形式
    } finally {
      // 在返回被包装的返回值之前，打印经过的时间
      console.log(`Exiting ${f.name} after ${Date.now() - startTime}ms`);
    }
  };
}

// 以简单粗暴的方式计算 1 到 n 的数值之和
function benchmark(n) {
  let sum = 0;
  for (let i = 1; i < n; i++) sum += i;
  return sum;
}

// 调用测试函数的计时版
timed(benchmark)(100000); // 50005000，这是数值之和
```

#### 8.3.5 把函数实参解构为形参

调用函数时如果传入一个实参列表，则所有参数值都会被赋给函数定义时声明的形参。函数调用的这个初始化阶段非常类似变量赋值。因此函数使用解构赋值技术并不奇怪。

如果定义了一个函数，它的形参名包含在方括号中，那说明这个函数期待对每对方括号都传入一个数组值。作为调用过程的一部分，传入的数组实参会被解构赋值为单独的命名形参。

假设要用数组来表示两个数值的 2D 向量，数组的第一个元素是 X 坐标，第二个元素是 Y 坐标。基于这个简单的数据结构，可以像下面这样写一个把它们相加的函数：

```js
function vectorAdd(v1, v2) {
  return [v1[0] + v2[0], v1[1] + v2[1]];
}
vectorEd([1, 2], [3, 4]); // [4, 6]
```

如果换成把两个向量实参解构为命名更清晰的形参，以上代码就更好理解了：

```js
// 把2个实参解构赋值为4个形参
function vectorAdde([x1, y1], [x2, y2]) {
  return [x1 + x2, y1 + y2];
}
vectorAdde([1, 2], [3, 4]); // [4,6]
```

类似地，如果定义的函数需要一个对象实参，也可以把传入的对象解构赋值给形参。以前面的向量计算为例，但这次假设传入一个有 x 和 y 参数的对象：

```js
// 用标量乘以向量 {x, y}
function vectorMultiply({ x, y }, scalar) {
  return { x: x * scalar, y: y * scalar };
}
vectorMultiply({ x: 1, y: 2 }, 2); // {x: 2, y: 4}
```

这个例子把一个对象实参解构为两个形参，由于形参名与对象的属性名一致，所以相当清晰。但是，如果需要把解构的属性赋值给不同的名字，那代码会更长也更不好理解。

下面是一个向量加法的例子，用基于对象的向量实现：

```js
function vectorAdd(
  { x: x1, y: y1 }, // 把第一个对象展开为 x1 和 y1
  { x: x2, y: y2 } // 把第二个对象展开为 x2 和 y2
) {
  return { x: x1 + x2, y: y1 + y2 };
}
vectorAdd({ x: 1, y: 2 }, { x: 3, y: 4 }); // {x: 4, y: 6}
```

无论是解构赋值还是解构函数调用，要记住的是声明的变量或参数都位于对象字面量中期待值的位置。因此，**属性名始终在冒号左侧，而形参名则在冒号右侧**。

在解构赋值中也可以为形参定义默认值。下面是针对 2D 或 3D 向量乘法的例子：

```js
// 用标量乘以向量 {x,y} 或 {x,y,z}
function vectorMuLtiply({ x, y, z = 0 }, scalar) {
  return { x: x * scalar, y: y * scaLar, z: z * scalar };
}
vectorMultiply({ x: 1, y: 2 }); // {x: 2, y: 4, z: 0}
```

有些语言（如 Python）允许函数的调用者在调用函数时使用 `name=value` 的形式指定实参，在可选参数很多或参数列表太长无法记住顺序时这种方式是有用的。JS 不直接支持这种调用方式，但可以通过把对象参数解构为函数参数来模拟。比如，一个函数从指定数组中把指定个数的元素复制到另一个数组中，参数中可选地指定每个数组的起始索引值。此时至少涉及 5 个参数，其中有的有默认值，而调用者又很难记住这些参数的顺序。为此可以像下面这样定义 `arraycopy()` 函数：

```js
function arraycopy({ from, to = from, n = from.length, fromIndex = 0, toIndex = 0 }) {
  let valuesToCopy = from.slice(fromIndex, fromIndex + n);
  to.splice(toIndex, 0, ...valuesToCopy);
  return to;
}

let a = [1, 2, 3, 4, 5],
  b = [9, 8, 7, 6, 5];
arraycopy({ form: a, n: 3, to: b, toIndex: 4 }); // [9,8,7,6,1,2,3,5]
```

解构数组时，可以为被展开数组中的额外元素定义一个剩余形参。位于方括号中的剩余形参与函数真正的剩余形参完全不同：

```js
// 这个函数期待一个数组参数。数组的前两个元素会展开赋值给 X 和 y
// 而剩下的所有元素则保存在 coords 数组中。第一个数组之后的参数则会保存到 rest 数组中
function f([x, y, ...coords], ...rest) {
  return [x + y, ...rest, ...coords]; // 注意: 这里是扩展操作符
}

f([1, 2, 3, 4], 5, 6); // [3, 5, 6, 3, 4]
```

在 ES2018 中，解构对象时也可以使用剩余形参。此时剩余形参的值是一个对象，包含所有未被解构的属性。对象剩余形参经常与对象扩展操作一起使用，后者也是 ES2018 中新增的特性：

```js
// 用标量乘以向量 {x,y} 或 {x,y,z}，其他属性保持不变
function vectorMultiply({ x, y, z = 0, ...props }, scalar) {
  return { x: x * scalar, y: y * scalar, z: z * scalar, ...props };
}
vectorMultiply({ x: 1, y: 2, w: -1 }, 2); // {x: 2, y: 4, z: 0, w: -1}
```

**除了解构作为参数的对象和数组，也可以解构对象的数组、有数组属性的对象，以及有对象属性的对象，无论层级多深**。比如，有关图形的代码中，圆形可以表示为包含 x、y、radius 和 color 属性的对象，其中 color 属性本身是一个包含红、绿、蓝组件的数组。那么定义的函数可以只接收一个圆形对象，但可以将该对象解构为 6 个具体的参数：

```js
function drawCircle({ x, y, radius, color: [r, g, b] }) {
  // 未实现
}
```

> 如果函数参数解构的复杂程度超过了这个示例，代码会变得更难理解，而不是更容易理解。有时，通过对象属性和数组索引来获取值反倒更清晰。

#### 8.3.6 参数类型

JS 方法的参数没有预定义的类型，在调用传参时也没有类型检查。可以用描述性强的名字作为函数参数，同时通过在注释中解释函数的参数来解决这个问题。

JS 会按需执行任意的类型转换。因此如果函数接收字符串参数，而调用时传的是其他类型的值，则这个值在函数想把它当成字符串使用时，会尝试将它转换为字符串。所有原始类型的值都可以转换为字符串，所有对象都有 `toString()` 方法（尽管有些不一定真正有用），因此这种情况下永远不会出错。

不过也并非没有例外。仍以前面的 `arraycopy()` 方法为例。该方法期待一个或多个数组参数，如果参数类型不对就会失败。除非写的是个私有函数，只会在自己的代码内部调用，否则就必须增加像下面这样用于检查参数类型的代码。**对函数来说，在发现传入的值不对时立即失败，一定好过先执行逻辑再以出错告终，而且前者比后者更清晰**。下面看一个执行类型检查的函数示例：

```js
// 返回可迭代对象 a 中所有元素之和。
// a 的元素必须全部是数值。
function sum(a) {
  let total = 0;
  // 如果 a 不是可迭代对象则抛出 TypeError
  for (let element of a) {
    if (typeof element !== 'number') {
      throw new TypeError('sum(): elements must be numbers');
    }
    total += element;
  }
  return total;
}
sum([1, 2, 3]); // 6
sm(1, 2, 3); // !TypeError：1不是可迭代对象
sun([1, 2, '3']); // !TypeError：元素 2 不是数值
```

### 8.4 函数作为值

**函数最重要的特性在于可以定义和调用它们**。函数定义和调用是 JS 和大多数语言的语法特性。但**在 JS 中，函数不仅是语法，也是值**。这意味着可以把函数赋值给变量、保存为对象的属性或者数组的元素、作为参数传给其他函数，等等。

要理解函数既是 JS 数据又是 JS 语法到底意味着什么，可以看看下面的例子：

```js
function square(x) {
  return x * x;
}
```

这个定义创建了一个新函数对象并把它赋值给变量 square。把函数赋值给另一个变量同样可以调用：

```js
let s = square; // s 也引用了与 square 相同的函数对象
square(4); // 16
```

除了变量，也可以把函数赋值给对象的属性：

```js
let o = {
  square: function (x) {
    return x * x;
  }
}; // 对象字面量
let y = o.square(16); // y == 256
```

函数甚至可以没有名字，比如可以把匿名函数作为一个数组元素：

```js
let a = [x => x * x, 20]; // 数组字面量
a[0](a[1]); // 400
```

为了更好地理解把函数作为值有多大用处，可以想一想 `Array.sort()` 方法。这个方法可以对数组元素进行排序。因为可能的排序方式有很多种（按数值排序、按字母排序、按日期排序,还有升序、降序，等等），所以 `sort()` 方法可选地接收一个函数作为参数，并根据这个函数的返回值决定如何排序。

这个函数的任务非常简单：对于传给它的两个值，它要返回一个表示哪个值在排序后的数组中排在前面的值。这个函数参数让 `Array.sort()` 变得非常通用，而且无比灵活。可以通过它把任何类型的数据按照任何可以想象出来的方式进行排序。

```js
// 这里定义了几个简单的函数
function add(x, y) {
  return x + y;
}
function subtract(x, y) {
  return x - y;
}
function multiply(x, y) {
  return x * y;
}
function divide(x, y) {
  return x / y;
}

// 这个函数接收前面定义的任意一个函数
// 作为参数，然后再用两个操作数调用它
function operate(operator, operand1, operand2) {
  return operator(operand1, operand2);
}

// 可以像这样调用这个函数，计算 (2+3) + (4*5) 的值
let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));

// 为演示方便,我们又一次实现了这些简单的函数
// 这次把它们放到了对象字面量中
const operators = {
  add: (x, y) => x + y,
  subtract: (x, y) => x - y,
  multiply: (x, y) => x * y,
  divide: (x, y) => x / y,
  pow: Math.pow // 预定义的函数也没问题
};

// 这个函数只接收操作的名字，然后在对象中查询
// 这个名字，然后再使用传入的操作数调用它
// 注意这里调用操作函数的语法
function operate(operation, operand1, operand2) {
  if (typeof operators[operation] === 'function') {
    return operators[operation](operand1, operand2);
  } else throw 'unknown operator';
}

operate('add', 'hello', operate2('add', ' ', 'world')); // "hello world"
operate2('pow', 10, 2); //100
```

#### 8.4.1 定义自己的函数属性

函数在 JS 中并不是原始值，而是一种特殊的对象。这意味着函数也可以有属性。如果一个函数需要一个 “静态” 变量，且这个变量的值需要在函数每次调用时都能访问到，则通常把这个变量定义为函数自身的一个属性。

比如，假设要写一个每次调用都返回唯一整数的函数，那么每次调用都不能返回相同的值。为保证这一点，函数需要记录自己已经返回过的值，这个信息必须在每次调用时都能访问到。可以把这个信息保存一个全局变量中，但其实没有这个必要，因为这个信息只有函数自己会用到。**更好的方式是把这个信息保存在函数对象的一个属性中**。下面就是一个每次调用都返回唯一整数值的函数实现：

```js
// 初始化函数对象的计数器（counter）属性
// 函数声明会被提升，因此可以在函数声明之前在这里就给它赋值
uniqueInteger.counter = 0;

// 这个函数每次被调用时都返回一个不同的整数
// 它使用自身的属性记住下一个要返回什么值
function uniqueInteger() {
  return uniqueInteger.counter++;
}
uniqueInteger(); // 0
uniqueInteger(); // 1
```

再看一个例子，下面的 `factorial()` 函数使用了自身的属性来缓存之前计算的结果（函数将自身作为一个数组）：

```js
// 计算阶乘并把结果缓存到函数本身的属性中
function factorial(n) {
  // 仅限于正整数
  if (Number.isInteger(n) && n > 0) {
    // 如果没有缓存的结果
    if (!(n in factorial)) {
      factorial[n] = n * factorial(n - 1); // 计算并缓存这个结果
    }
    return factorial[n]; // 返回缓存的结果
  } else {
    return NaN;
  }
}

factorial[1] = 1; // 初始化缓存，保存最基础的值
factorial(6); // 720
factorial[4]; // 24 上面的调用缓存了这个值
```

### 8.5 函数作为命名空间

在函数体内声明的变量在函数外部不可见。为此，有时候可以把函数用作临时的命名空间，这样可以保证在其中定义的变量不会污染全局命名空间。

假设有一段 JS 代码，想在几个不同的 JS 程序中使用它。再假设这段代码跟多数代码一样定义了存储中间计算结果的变量。问题来了：这段代码可能被很多程序用到，不知道那些程序创建的变量会不会跟这段代码中的变量冲突。解决方案就是把这段代码放到一个函数中，然后调用这个函数。这样，原本可能会定义在全局的变量就变成函数的局部变量了：

```js
function chunkNamespace() {
  // 要复用的代码放在这里
  // 在这里定义的任何变量都是函数的局部变量，不会污染全局命名空间
}
chunkNamespace(); // 别忘了调用这个函数
```

以上代码只定义了一个全局变量，即函数 chunkNamespace。如果就连定义一个属性也嫌多，那可以在一个表达式中定义并调用匿名函数

```js
(function () {
  // 将 chunkNamespacer() 函数重写为一个无名表达式
  // 要复用的代码放在这里
})(); // 函数定义结束后立即调用它
```

在一个表达式中定义并调用匿名函数的技术非常常用，因此甚至有了别称，叫“**立即调用函数表达式**”（immediately invoked function expression）。

> **注意**：前面代码中括号的使用。位于 `function` 关键字前面的左开括号是必需的，因为如果没有它，JS 解释器会把 `function` 关键字作为函数声明语句来解析。有了这对括号，解释器会把它正确地识别为函数定义表达式。而且开头的括号也便于程序员知道这是个定义后立即调用的函数，而不是为后面使用定义的函数。

函数作为命名空间真正的用武之地，还是**在命名空间中定义一个或多个函数，而这些函数又使用该命名空间中的变量，最后这些函数又作为命名空间函数的返回值从内部传递出来。类似这样的函数被称为闭包（closure）**。

### 8.6 闭包

与多数现代编程语言一样，JS 使用词法作用域（lexical scoping）。这意味着**函数执行时使用的是定义函数时生效的变量作用域，而不是调用函数时生效的变量作用域**。

为了实现词法作用域，JS 函数对象的内部状态不仅要包括函数代码，还要包括对函数定义所在作用域的引用。这种**函数对象与作用域（即一组变量绑定）组合起来解析函数变量的机制，在计算机科学文献中被称作闭包（closure）**。

严格来讲，所有 JS 函数都是闭包。但由于多数函数调用与函数定义都在同作用域内，所以闭包的存在无关紧要。**闭包真正值得关注的时候，是定义函数与调用函数的作用域不同的时候**。最常见的情形就是一个函数返回了在它内部定义的嵌套函数。很多强大的编程技术都是建立在这种嵌套函数闭包之上的，因此嵌套函数闭包在 JS 程序中也变得比较常见。

要理解闭包，第一步需要先回顾嵌套函数的词法作用域规则。来看下面的代码：

```js
let scope = 'global scope'; // 全局变量

function checkscope() {
  let scope = 'local scope'; // 局部变量
  function f() {
    return scope; // 返回当前作用域中的值
  }
  return f();
}
checkscope(); // "local scope"
```

`checkscope()` 函数声明了一个局部变量，然后定义了一个返回该变量的值的函数并调用了该函数。很显然，调用 `checkscope()` 应该返回 "local scope"。现在，稍微改一改代码：

```js
let scope = 'global scope'; // 全局变量

function checkscope() {
  let scope = 'local scope'; // 局部变量
  function f() {
    return scope;
  } // 返回当前作用域中的值
  return f;
}
let s = checkscope()(); // 'local scope'
```

在上面的代码中，把 `checkscope()` 中的一对圆括号转移到了外部。转移前调用的是嵌套函数并返回结果，而现在 `checkscope()` 返回的是嵌套函数。

JS 词法作用域的基本规则是：JS 函数是使用定义它们的作用域来执行的。在定义嵌套函数 `f()` 的作用域中，变量 scope 绑定的值是 "local scope"，该绑定在 f 执行时仍然有效，无论它在哪里执行。因此前面代码示例最后一行返回 "local scope"，而非"global scope"。

这正是**闭包惊人且强大的本质：它们会捕获自身定义所在外部函数的局部变量（及参数）绑定**。

在前面定义了一个 [`uniqueInteger()`](#841-定义自己的函数属性) 函数，该函数使用一个函数自身的属性来跟踪要返回的下一个值。该方式有一个缺点，就是容易被错误或恶意代码重置计数器，或者把计数器设置为非整数，导致 `uniqueInteger()` 函数违反自己契约的 “唯一”（unique）或 “整数”（Integer）规则。

**闭包可以捕获一次函数调用的局部变量，可以将这些变量作为私有状态**。为此，可以像下面这样改写 `uniqueInteger()` 函数，使用立即调用函数表达式定义一个命名空间，再通过一个闭包利用该命名空间来保证自己的状态私有：

```js
// 定义并调用
let uniqueInteger = (function () {
  let counter = 0; //下面函数的私有状态
  return function () {
    return counter++;
  };
})();
uniqueInteger(); // 0
uniqueInteger(); // 1
```

乍一看，第一行代码像一条赋值语句，把一个函数赋值给变量 uniqueInteger。实际上，这行代码定义并调用了一个函数，因此真正赋给 uniqueInteger 的是这个函数的返回值。再仔细看一下函数体，会发现它的返回值是另一个函数。换句话说，这个嵌套的函数最终被赋值给了 uniqueInteger。这个嵌套函数有权访问其作用域中的变量，而且可以使用定义在外部函数中的变量 counter。

外部函数一旦返回，就没有别的代码能够看到变量 counter 了，此时内部函数拥有对它的专有访问权。类似 counter 这样的私有变量并非只能由一个闭包独享。同一个外部函数中完全可以定义两个或更多嵌套函数，而它们共享相同的作用域。来看下面的代码：

```js
function counter() {
  let n = 0;
  return {
    count: function () {
      return n++;
    },
    reset: function () {
      n = 0;
    }
  };
}

let c = counter(),
  d = counter(); // 创建两个计数器

c.count(); // 0
d.count(); // 0 它们分别计数
c.reset(); // reset() 和 count() 方法共享状态
c.count(); // 0: 因为重置了c
d.count(); // 1
```

这个 `counter()` 函数返回一个 “计数器” 对象。该对象有两个方法: `count()` 和 `reset()`。前者返回下一个整数，后者重置内部状态。首先要理解的是，这两个方法都有权访问私有变量 n。其次是要知道，每次调用 `counter()` 都会创建一个新作用域（与之前调用创建的作用域相互独立），还有作用中域中的一个新私有变量。

因此如果调用两次 `counter()`，就会得到拥有两个不同私有变量的计数器对象。在一个计数器上调用 `count()` 或 `reset()` 不会影响另一个计数器。可以将这种闭包技术与属性获取方法和设置方法组合使用。

```js
// 函数参数 n 是私有变量
function counter(n) {
  return {
    // 属性获取方法，返回递增后的私有计数器值
    get count() {
      return n++;
    },
    // 属性设置方法，不允许 n 的值减少
    set count(m) {
      if (m > n) n = m;
      else throw Error('count can only be set to a larger value');
    }
  };
}

let c = counter(1000);
c.count; // 1000
c.count; // 1001
c.count = 2000;
c.count; // 2000
c.count = 2000; // 错误: 计数只能设置为更大的数
```

> **注意**：`counter()` 函数没有声明局部变量，只使用自己的参数 n 保存供属性访问器方法共享的私有状态。这样可以让 `counter()` 的调用者指定私有变量的初始值。

下面的示例，基于闭包技术实现了一个通用的共享私有状态的函数。例子中的函数 `addPrivateProperty()` 定义了一个私有变量和两个分别用于获取和设置该变量值的嵌套函数，而且将这两个嵌套函数作为方法添加到了调用时指定的对象：

```js
// 使用闭包的私有属性访问器方法
// 这个函数按照指定的名字为对象 o 添加属性访问器方法
// 方法命名为 get<name> 和 set<name>
// 如果提供断言（predicate）函数，则设置方法用它测试自己的参数，在存储前先验证
// 如果断言返回 false，则设置方法抛出异常

// 操作的值并没有保存在对象 o 上，而是保存在了这个函数的一个局部变量中。
// 获取方法和设置方法也是在函数局部定义的，因而可以访问这个局部变量。这意味着该变量对两个访问器方法而言是私有的
// 除了设置方法,没有别的途径可以设置或修改这个变量的值
function addPrivateProperty(o, name, predicate) {
  let value; // 这是属性值

  // 获取方法简单地返回属性值
  o[`get${name}`] = function () {
    return value;
  };

  // 设置方法保存值或在断言失败时抛出异常
  o[`set${name}`] = function (v) {
    if (predicate && !predicate(v)) {
      throw new TypeError(`set${name}: invalid value ${v}`);
    } else {
      value = v;
    }
  };
}

// 下面的代码演示了如何使用 addPrivateProperty()方法
let o = {}; // 先创建一个空对象

// 添加属性访问器方法 getName()和 setName()
// 确保只能设置字符串值
addPrivateProperty(o, 'Name', X => typeof x === 'string');
o.setName('Frank'); // 设置属性的值
o.getName(); // "Frank"
o.setName(0); // !TypeError：尝试设置一个错误类型的值
```

前面的几个例子都是在相同作用域中定义两个闭包，共享访问相同的私有变量或变量。这个技术很重要，但同样重要的是应该知道什么情况下闭包会意外地共享访问不该被共享的变量。比如下面的代码：

```js
// 这个函数返回一个始终返回 v 的函数
function constfunc(v) {
  return () => v;
}

// 创建一个常量函数的数组
let funcs = [];
for (var i = 0; i < 10; i++) funcs[i] = constfunc(i);
// 索引 5 对应的函数返回数值 5
funcs[5](); // 5
```

在编写这种使用循环创建多个闭包的代码时，一个常见的错误是把循环转移到定义闭包的函数中。比如下面的代码：

```js
// 返回一个函数数组，其中的函数返回数值 0-9
function constfuncs() {
  let funcs = [];
  for (var i = 0; i < 10; i++) {
    funs[i] = () => i;
    return funcs;
  }
}

let funcs = constfuncs();
funcs[5](); // 10; 为什么这时候不返回 5?
```

以上代码创建了 10 个闭包并将它们保存在一个数组中。而闭包全部是在同一个函数调用中定义的，因此它们可以共享访问变量 i。当 `constfuncs()` 返回后，变量 i 的值是 10，全部 10 个闭包共享这个值。因此，返回的函数数组中的所有函数都返回相同的值。

这绝对不是想要的结果。关键是要记住，与闭包关联的作用域是 “活的”。**嵌套函数不会创建作用域的私有副本或截取变量绑定的静态快照**。从根本上说，这里的问题在于通过 var 声明的变量在整个函数作用域内都有定义。

代码中的 for 循环使用 var 声明循环变量，因此变量 i 的作用域是整个函数体，而不是更小的循环体。这段代码演示了 ES5 及之前版本代码中常见的一类错误，而 ES6 增加的块级作用域变量解决了这个问题。只要把这里的 var 替换成 let 或 const，问题马上就会消失。因为 let 和 const 是块级作用域的标志，这意味着每次循环都会定义一个与其他循环不同的独立作用域，而每个作用域中都有自己独立的 i 绑定。

> **注意**：在写闭包的时候，`this` 是 JS 关键字，不是变量。箭头函数继承包含它们的函数中的 this 值，但使用 function 定义的函数并非如此。因此如果要写的闭包需要使用其包含函数的 this 值，那应该在返回闭包之前使用箭头函数或调用 `bind()`，也可把外部的 this 值赋给闭包将继承的变量。

### 8.7 函数属性、方法与构造函数

函数在 JS 中也是一种值。对函数使用 `typeof` 操作符会返回字符串 "function"，但函数实际上是一种特殊的 JS 对象。由于函数是对象，因此它们也有属性和方法。甚至还有一个 `Function()` 构造函数可以用来创建新函数对象。

#### 8.7.1 length 属性

**函数有一个只读的 `length` 属性，表示函数的元数（arity），即函数在参数列表中声明的形参个数**。这个值通常表示调用函数时应该传入的参数个数。如果函数有剩余形参，则这个剩余形参不包含在 length 属性内。

#### 8.7.2 name 属性

函数有一个只读的 `name` 属性，表示定义函数时使用的名字（如果是用名字定义的），如果是未命名的函数，表示在第一次创建这个函数时赋给该函数的变量名或属性名。这个属性**主要用于记录调试或排错消息**。

#### 8.7.3 prototype 属性

除了箭头函数，所有函数都有一个 `prototype` 属性，这个属性引用一个被称为[原型对象](#623-原型)的对象。每个函数都有自己的原型对象。当函数被作为构造函数使用时，新创建的对象从这个原型对象继承属性。

#### 8.7.4 call() 和 apply() 方法

`call()` 和 `apply()` 允许[间接调用](#824-间接调用)一个函数，就像这个函数是某个其他对象的方法一样。`call()` 和 `apply()` 的第一个参数都是要在其上调用这个函数的对象，也就是函数的调用上下文，在函数体内它会变成 this 关键字的值。要把函数 f() 作为对象的方法进行调用（不传参数），可以使用 `call()` 或 `apply()`：

```js
f.call(o);
f.apply(o);
```

这两行代码都类似于下面的代码（假设 o 并没有属性 m）：

```js
o.m = f; // 把 f 作为 o 的一个临时方法
o.m(); // 调用它，不传参数
delete o.m; // 删除这个临时方法
```

箭头函数从定义它的上下文中继承 this 值。这个 this 值不能通过 `call()` 和 `apply()` 方法重写。**如果对箭头函数调用这两个方法，那第一个参数实际上会被忽略**。

除了作为调用上下文传给 `call()` 的第一参数，后续的所有参数都会传给被调用的函数（调用箭头函数时不会忽略这些参数）。比如，要将函数 f() 作为对象 o 的方法进行调用，并同时给函数 f() 传两个参数，可以这样写：

```js
f call(o, 1, 2);
```

`apply()` 方法与 `call()` 方法类似，只不过要传给函数的参数需要以数组的形式提供:

```js
f.apply(o, [1, 2]);
```

如果函数定义时可以接收任意多个参数，则使用 `apply()` 方法可以在调用这个函数时把任意长度的数组内容传给它。在 ES6 及之后的版本中可以使用扩展操作符。

例如，在不使用扩展操作符的情况下，想找到一个数值数组中的最大值，可以使用 `apply()` 方法把数组的元素传给 `Math.max()` 函数:

```js
let biggest = Math.max.apply(Math, arrayOfNumbers);
```

用与包装方法（新方法）相同的参数和 this 值调用被包装的方法（原始方法）：

```js
// 将对象 o 的方法 m 替换成另一个版本
// 新版本在调用原始方法前、后会打印日志
function trace(o, m) {
  let original = o[m]; // 在闭包中记住原始方法
  // 定义新方法
  o[m] = function (...args) {
    console.log(new Date(), 'Entering: ', m); // 打印消息
    let result = original.apply(this, args); // 调用原始方法
    console.log(new Date(), 'Exiting: ', m); // 打印消息
    return result; // 返回结果
  };
}
```

#### 8.7.5 bind() 方法

**`bind()` 方法的主要目的是把函数绑定到对象**。如果在函数 f 上调用 `bind()` 方法并传入对象 o，则这个方法会返回一个新函数。如果作为函数来调用这个新函数，就会像 f 是 o 的方法一样调用原始函数。传给这个新函数的所有参数都会传给原始函数。例如:

```js
function f(y) {
  return this.x + y; // 这个函数需要绑定
}

let o = { x: 1 }; // 要绑定的对象
let g = f.bind(o); // 调用 g(x) 会在 o 上调用 f()
g(2); // 3
let p = { x: 10, g }; //作为这个对象的方法调用 g()
p.g(2); // 3: g 仍然绑定到 o，而非 p
```

箭头函数从定义它们的环境中继承 this 值，且这个值不能被 `bind()` 覆盖，因此如果前面代码中的函数 f() 是以箭头函数定义的，则绑定不会起作用。不过，由于**调用 `bind()` 最常见的目的是让非箭头函数变得像箭头函数**，因此这个关于绑定箭头函数的限制在实践中通常不是问题。

事实上，除了把函数绑定到对象，`bind()` 方法还会做其他事。比如，`bind()` 也可以执行“部分应用”，即在第一个参数之后传给 `bind()` 的参数也会随着 this 值一起被绑定。

部分应用是函数式编程中的一个常用技术，有时候也被称为柯里化（currying）。下面是几个使用 `bind()` 方法实现部分应用的例子:

```js
let sum = (x, y) => x + y; // 返回 2 个参数之和
let succ = sum.bind(null, 1); // 把第一个参数绑定为 1
succ(2); // 3: x 绑定到 1，2 会传给参数 y

function f(y, z) {
  return this.x + y + z;
}
let g = f.bind({ x: 1 }, 2); // 绑定 this 和 y
g(3); // 6: this.x 绑定到 1，y 绑定到 2，z 是 3
g.name; // "bound f"
```

> `bind()` 返回函数的 `name` 属性由单词 "bound" 和调用 `bind()` 的函数的 `name` 属性构成。

#### 8.7.6 toString() 方法

与所有 JS 对象一样，函数也有 `toString()` 方法。ECMAScript 规范要求这个方法返回一个符合函数声明语句的字符串。实践中，这个方法的多数实现都返回函数完整的源代码。内置函数返回的字符串中通常包含 "[native code]"，表示函数体。

#### 8.7.7 Function() 构造函数

因为函数是对象，所以就有一个 `Function()` 构造函数可以用来创建新函数：

```js
const f = new Function('x', 'y', 'return x*y');
```

上面的代码创建了一个新函数，相当于使用如下语法定义的函数：

```js
const f = function (x, y) {
  return x * y;
};
```

`Function()` 构造函数可以接收任意多个字符串参数，其中最后一个参数是函数体的文本。这个函数体文本中可以包含任意 JS 语句，相互以分号分隔。传给这个构造函数的其他字符串都用于指定新函数的参数名。如果新函数没有参数，可以只给构造函数传一个字符串（也就是函数体）。

> **注意**：`Function()` 构造函数不接收任何指定新函数名字的参数。与函数字面量一样，`Function()` 构造函数创建的也是匿名函数。

要理解 `Function()` 构造函数，需要理解以下几点：

- `Function()` 函数允许在运行时动态创建和编译 JS 函数。

- `Function()` 构造函数每次被调用时都会解析函数体并创建一个新函数对象。如果在循环中或者被频繁调用的函数中出现了对它的调用，可能会影响程序性能。相对而言，出现在循环中的嵌套函数和函数表达式不会每次都被重新编译。

- 最后，也是关于 `Function()` 非常重要的一点，就是它创建的函数不使用词法作用域，而是始终编译为如同顶级函数一样，如下所示：

  ```js
  let scope = 'global';
  function constructFunction() {
    let scope = 'local';
    return new Function('return scope'); // 不会捕获局部作用域
  }
  // 这行代码返回 "global"，因为 Function() 构造函数返回的函数不使用局部作用域。
  constructFunction()(); // "global"
  ```

> 最好将 `Function()` 构造函数作为在自己私有作用域中定义新变量和函数的 `eval()` 的全局作用域版。自己写的代码中可能永远也用不到这个构造函数。

### 8.8 函数式编程

JS 并不是 Lisp 或 Haskell 那样的函数式编程语言，但 JS 可以把函数作为对象来操作意味着可以在 JS 中使用函数式编程技巧。像 `map()` 和 `reduce()` 这样的数组方法就特别适合函数式编程风格。

#### 8.8.1 使用函数处理数组

假设有一个数值数组，希望计算这些数值的平均值和标准差。如果使用非函数式风格的代码，可能会这样写：

```js
let data = [1, 1, 3, 5, 5]; // 这是数值数组

// 平均值等于所有元素之和除以元素个数
let total = 0;
for (let i = 0; i < data.length; i++) total += data[i];
let mean = total / data.length; // mean == 3，平均值为 3

// 要计算标准差，首先要计算每个元素
// 相对于平均值偏差的平方
total = 0;
for (let i = 0; i < data.length; i++) {
  let deviation = data[i] - mean;
  total += deviation * deviation;
}
let stddev = Math.sqrt(total / (data.length - 1)); // stddev == 2
```

而使用数组方法 `map()` 和 `reduce()`，可以像下面这样以简洁的函数式风格实现同样的计算：

```js
// 首先，定义两个简单的函数
const sum = (x, y) => x + y;
const square = x => x * x;

// 然后，使用数组方法计算平均值和标准差
let data = [1, 1, 3, 5, 5];
let mean = data.reduce(sum) / data.length; // mean == 3
let deviations = data.map(x => x - mean);
let stddev = Math.sqrt(deviations.map(square).reduce(sum) / (data.length - 1));
stddev; // 2
```

新版本的代码看起来与第一个版本差别很大，但仍然调用对象上的方法，因此还可以看出一些面向对象的痕迹。下面再来定义 `map()` 和 `reduce()` 方法的函数版：

```js
const map = function (a, ...args) {
  return a.map(...args);
};
const reduce = function (a, ...args) {
  return a.reduce(...args);
};
```

定义了 `map()` 和 `reduce()` 函数后，计算平均值和标准差的的代码就变成这样了：

```js
const sum = (x, y) => x + y;
const square = x => x * x;

let data = [1, 1, 3, 5, 5];
let mean = reduce(data, sum) / data.length;
let deviations = map(data, x => x - mean);
let stddev = Math.sqrt(reduce(map(deviations, square), sum) / (data.length - 1));
stddev; // 2
```

#### 8.8.2 高阶函数

高阶函数就是操作函数的函数，它接收一个或多个函数作为参数并返回一个新函数。例如：

```js
// 这个高阶函数返回一个新函数
// 新函数把参数传给 f 并返回 f 返回值的逻辑非
function not(f) {
  // 返回一个新函数
  return function (...args) {
    let result = f.apply(this, args); // 新函数调用 f
    return result; // 对结果求逻辑非
  };
}
const even = x => x % 2 === 0; // 确定数值是不是偶数的函数
const odd = not(even); // 确定数值是不是奇数的新函数
[1, 1, 3, 5, 5].every(odd); // true: 数组的所有元素都是奇数
```

下面的 `mapper()` 函数接收一个函数参数并返回一个新函数，新函数使用传入的函数把一个数组映射为另一个数组。这个函数使用了前面定义的 `map()` 函数，理解这两个函数之间的区别非常重要：

```js
// 返回一个函数，这个函数接收一个数组并对每个元素应用 f，返回每个返回值的数组
function mapper(f) {
  return a => map(a, f);
}
const increment = x => x + 1;
const incrementAll = mapper(increment);
incrementAll([1, 2, 3]); // [2,3,4]
```

下面是一个更通用的例子，这个高阶函数接收两个函数 f 和 g，返回一个计算 `f(g())` 的新函数：

```js
// 返回一个计算 f(g(...)) 的新函数
// 返回的函数 h 会把它接收的所有参数传给 g
// 再把 g 的返回值传给 f，然后返回 f 的返回值
// f 和 g 被调用时都使用与 h 被调用时相同的 this 值
function compose(f, g) {
  return function (...args) {
    // 这里对 f 使用 call 是因为只给它传一个值,
    // 而对 g 使用 apply 是因为正在传一个值的数组
    return f.call(this, g.apply(this, args));
  };
}

const sum = (x, y) => x + y;
const square = x => x * x;
compose(square, sum)(2, 3); // 25，平方和
```

#### 8.8.3 函数的部分应用

函数 f 的 `bind()` 方法返回一个新函数，这个新函数在指定的上下文中以指定的参数调用 f。可以说它把这个函数绑定到了一个对象并部分应用了参数。`bind()` 方法在左侧部分应用参数，即传给 `bind()` 的参数会放在传给原始函数的参数列表的开头。但是也有可能在右侧部分应用参数：

```js
// 传给这个函数的参数会传到左侧
function partialLeft(f, ...outerArgs) {
  // 返回这个函数
  return function (...innerArgs) {
    let args = [...outerArgs, ...innerArgs]; // 构建参数列表
    return f.apply(this, args); // 然后通过它调用 f
  };
}

// 传给这个函数的参数会传到右侧
function partialRight(f, ...outerArgs) {
  // 返回这个函数
  return function (...innerArgs) {
    let args = [...innerArgs, ...outerArgs]; //构建参数列表
    return f.apply(this, args); // 然后通过它调用 f
  };
}

// 这个函数的参数列表作为一个模板。这个参数列表中的 undefined 值会被来自内部参数列表的值填充
function partial(f, ...outerArgs) {
  return function (...innerArgs) {
    let args = [...outerArgs]; // 外部参数模板的局部副本
    let innerIndex = 0; // 下一个是哪个内部参数
    // 循环遍历 args，用内部参数填充 undefined 值
    for (let i = 0; i < args.length; i++) {
      if (args[i] === undefined) args[i] = innerArgs[innerIndex++];
      // 现在把剩余的内部参数都加进来
    }
    args.push(...innerArgs.slice(innerIndex));
    return f.apply(this, args);
  };
}

// 下面是有 3 个参数的函数
const f = function (x, y, z) {
  return x * (y - z);
};

// 注意，这 3 个部分应用的区别
partialLeft(f, 2)(3, 4); // -2：绑定第一个参数: 2 * (3 - 4)
partialRight(f, 2)(3, 4); // 6：绑定最后一个参数: 3 * (4 - 2)
partial(f, undefined, 2)(3, 4); // -6：绑定中间的参数: 3 * (2 - 4)
```

这些部分应用函数允许在已经定义的函数基础上继续定义函数。下面是几个例子：

```js
const increment = partialLeft(sum, 1);
const cuberoot = partialRight(Math.pow, 1 / 3);
cuberoot(increment(26)); // 3
```

部分应用的函数如果与其他高阶函数组合会更有意思。例如，下面的代码通过组合与部分应用定义 `not()` 函数：

```js
const not = partialLeft(compose, x => !x);
const even = x => x % 2 === 0;
const odd = not(even);
const isNumber = not(isNaN);
odd(3) && isNumber(2); // true
```

还可以使用组合和部分应用以函数方式重新计算平均值和标准差：

```js
// sun() 和 square() 函数在前面定义过。下面是更多函数
const product = (x, y) => x * y;
const neg = partial(product, -1);
const sqrt = partia(Math.pow, undefined, 0.5);
const reciprocal = partial(Math.pow, undefined, neg(1));

// 现在计算平均值和标准差
let data = [1, 1, 3, 5, 5];
let mean = product(reduce(data, sum), reciprocal(data.length));
let stddev = sqrt(
  product(
    reduce(map(data, compose(square, partial(sum, neg(mean)))), sum),
    reciprocal(sum(data.length, neg(1)))
  )
);

[mean, stddev]; // [3, 2]
```

> **注意**：这里计算平均值和标准差的代码完全是函数调用，没有操作符，圆括号的数量已经多到让 JS 看起来像 Lisp 了。这并不是推荐的 JS 编程风格。

#### 8.8.4 函数记忆

在前面[函数属性](#841-定义自己的函数属性)定义了一个缓存自己之前计算结果的阶乘函数。在函数式编程中，这种缓存被称为函数记忆（memoization）。下面的代码展示了高阶函数 `memoize()` 可以接收一个函数参数，然后返回这个函数的记忆版：

```js
// 返回 f 的记忆版
// 只适用于 f 的参数都有完全不同的字符串表示的情况
function memoize(f) {
  const cache = new Map(); // cache 保存在这个闭包中

  return function (...args) {
    // 创建参数的字符串版，以用作缓存键
    let key = args.length + args.join('+');
    if (cache.has(key)) {
      return cache.get(key);
    } else {
      let result = f.apply(this, args);
      cache.set(key, result);
      return result;
    }
  };
}
```

这个 `memoize()` 函数创建了一个新对象作为缓存使用，并将这个对象赋值给一个局部变量，从而让它（在闭包中）成为被返回的函数的私有变量。返回的函数将其参数数组转换为字符串，并使用该字符串作为缓存对象的属性。如果缓存存在某个值，就直接返回该值；否则，就调用指定的函数计算这些参数的值，然后缓存这个值，最后返回这个值。

下面是使用 `memoRize()` 的例子：

```js
// 使用欧几里德算法返回两个整数的最大公约数
// http://en.wikipedia.org/wiki/euclideanalgorithm
// 省略了对 a 和 b 的类型检查
function gcd(a, b) {
  // 开始时保证 a ≥ b
  if (a < b) {
    [a, b] = [b, a]; // 用解构赋值交换变量
  }
  // 这是求最大公约数的欧几里德算法
  while (b !== 0) {
    [a, b] = [b, a % b];
  }
  return a;
}

const gcdmemo = memoize(gcd);
gcdmemo(85, 187); // 17

// 注意，在编写需要记忆的递归函数时，通常希望递归记忆版，而非原始版
const factorial = memoize(function (n) {
  return n <= 1 ? 1 : n * factorial(n - 1);
});

factorial(5); // 120:也为 4、3、2 和 1 缓存了值
```

## 九. 类

JS 对象是一种独特的属性集合，每个对象都不一样。然而，多个对象经常需要共享一些属性，此时可以为这些对象定义一个类。这个类的成员或实例，各自拥有属性来保存或定义自己的状态，但也有方法定义它们的行为。

这些方法是由类定义且由所有实例共享的。想象有一个 Complex 类，表示和执行复数的计算。Complex 的实例会有属性保存复数的实数和虚数部分（状态）。同时 Complex 类也会定义对这些数执行加法和乘法操作（行为）的方法。

**在 JS 中，类使用基于原型的继承。如果两个对象从同一个原型继承属性（通常是以函数作为值的属性，或者方法），那说这些对象是同一个类的实例。这就是 JS 类原理**。

如果两个对象继承同一个原型，通常（但不必定）意味着它们是通过同一个构造函数或工厂函数创建和初始化的。JS 一直允许定义类。ES6 新增了相关语法（包括 `class` 关键字）让创建类更容易。通过新语法创建的 JS 类与老式的类原理相同。

JS 类与 Java 或 C++ 等强类型面向对象语言的类非常不一样。虽然语法上有些类似，JS 也可以模拟一些 “经典的” 类特性，但最重要的是要明白：**JS 的类和基于原型的继承机制与 Java 等语言中类和基于类的继承机制有着本质区别**。

### 9.1 类和原形

**在 JS 中，类意味着一组对象从同一个原型对象继承属性。因此，原型对象是类的核心特征**。`Object.create()` 函数用于创建一个新对象，这个新对象继承指定的原型对象。如果定义了一个原型对象，然后使用 `Object.create()` 创建一个继承它的对象，那就定义了一个 JS 类。

通常，一个类的实例需要进一步初始化，因此常见的做法是定义一个函数来创建和初始化新对象。示例 9-1 演示了这个过程，它为一个表示数值范围的类定义了一个原型对象，同时也定义了一个工厂函数用于创建和初始化该类的新实例：

```js
// 示例 9-1: 一个简单的 JS 类
// 这个工厂函数返回一个新范围对象
function range(from, to) {
  // 使用 Object.create() 创建一个对象，继承下面定义的原型对象。
  // 这个原型对象保存为这个函数的一个属性，为所有范围对象定义共享方法(行为)
  let r = Object.create(range.methods);

  // 保存新范围对象的起点和终点(状态)，这些属性不是继承的，是当前对象独有的
  r.from = from;
  r.to = to;
  // 最后返回新对象
  return r;
}

// 这个原型对象定义由所有范围对象继承的方法
range.methods = {
  // 如果 x 在范围内则返回 true，否则返回 false
  // 这个方法适用于文本、日期和数值范围
  includes(x) {
    return this.from <= x && x <= this.to;
  },

  // 这个生成器函数让这个类的实例可迭代
  // 注意：只适用于数值范围
  *[Symbol.iterator]() {
    for (let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  },
  // 返回范围的字符串表示
  toString() {
    return '(' + this.from + '...' + this.to + ')';
  }
};

// 下面是使用范围对象的示例
let r = range(1, 3); // 创建一个范围对象
r.includes(2); // true：2 在范围内
r.toString(); // "(1...3)"
[...r]; // [1, 2, 3]; 通过迭代器转换为数组
```

以上示例中有几个方面需要注意：

- 这段代码定义了一个工厂函数 `range()`，用于创建新的 Range 对象。

- 它使用 `range()` 函数的 methods 属性保存定义这个类的原型对象。把原型对象放在这里没有什么特别的，也不是习惯写法。

- 这个 `range()` 函数为每个 Range 对象定义 `from` 和 `to` 属性。这两个属性是非共享、非继承属性，定义每个范围对象独有的状态。

- `range.methods` 对象使用了 ES6 定义方法的[简写语法](#6105-简写方法)，所以没有出现 function 关键字。

- 原型的方法中有一个是[计算的名字](#6102-计算的属性名) `Symbol.iterator`，这意味着它为 Range 对象定义了一个[迭代器](#十二-迭代器与生成器)。这个方法的名字前面有一个星号 `*`，表示它是一个生成器函数，而非普通函数。

- 定义在 `range.methods` 中的共享方法都会用到在 `range()` 工厂函数中初始化的 `from` 和 `to` 属性，它们通过 this 关键字引用调用它们的对象。**使用 this 是所有类方法的基本特征**。

### 9.2 类和构造函数

例 9-1 展示了一种定义 JS 类的简单方式。不过，这种方式并非习惯写法，因为它没有定义构造函数。构造函数是一种专门用于初始化新对象的函数。

**构造函数要使用 `new` 关键字调用**。使用 `new` 调用构造函数会自动创建新对象，因此构造函数本身只需要初始化新对象的状态。构造函数调用的关键在于构造函数的 `prototype` 属性将被用作新对象的原型。

几乎所有对象都有原型，但只有函数对象才有 `prototype` 属性。这意味着使用同一个构造函数创建的所有对象都继承同一个对象，因而是同一个类的成员。

示例 9-2 展示了如何修改示例 9-1 中的 Range 类来使用构造函数而非工厂函数。示例 9-2 演示了在不支持 ES6 `class` 关键字的 JS 版本中创建类的习惯做法。虽然 `class` 目前已经得到全面支持，但仍有很多老 JS 代码是以这种方式来定义类的。同时也理解在使用 `class` 关键字时“底层”都发生了什么：

```js
// 示例 9-2：使用构造函数的 Range 类
// 这是用来初始化新 Range 对象的构造函数
// 注意它不创建或返回对象，只初始化 this
function Range(from, to) {
  // 保存新范围对象的起点和终点(状态)
  // 这些属性不是继承的,是当前对象独有的
  this.from = from;
  this.to = to;
}

// 所有 Range对象都继承这个对象
// 注意这个属性必须命名为 prototype 才行
Range.prototype = {
  // 如果 x 在范围内则返回 true，否则返回 false
  // 这个方法适用于文本、日期和数值范围
  includes: function (x) {
    return this.from <= x && x <= this.to;
  },

  // 这个生成器函数让这个类的实例可迭代
  // 注意:只适用于数值范围
  [Symbol.iterator]: function* () {
    for (let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  },

  // 返回范围的字符串表示
  toString: function () {
    return '(' + this.from + '...' + this.to + ')';
  }
};

// 下面是使用这个新 Range类的示例
let r = new Range(1, 3); // 创建一个 Range对象
r.includes(2); // true：2在范围内
r.toString(); // "(1...3)"
[...r]; // [1,2,3]; 通过迭代器转换为数组
```

比较示例 9-1 和示例 9-2，观察这两种定义类的方式之间的区别：

- 首先，`range()` 工厂函数在转换为构造函数时被重命名为了 `Range()`。这是一个非常常见的编码约定。因为构造函数在某种意义上是定义类的，而**类名（按照惯例）应以大写字母开头。普通函数和方法的名字则以小写字母开头**。

- 其次，`Range()` 构造函数是以 `new` 关键字调用的，而 `range()` 工厂函数被调用时没有这个关键字。示例 9-1 使用普通函数调用创建新对象，而示例 9-2 使用构造函数调用创建新对象。

  因为 `Range()` 构造函数是通过 `new` 调用的，所以它没有调用 `Object.create()`，也没有执行任何创建对象的操作。新对象是在调用构造函数之前自动创建的，可以通过 `this` 来访问。`Range()` 构造函数仅仅需要初始化 this。构造函数甚至不需要返回新创建的对象，它的调用会自动创建新对象，并将构造函数作为该对象的方法来调用，然后返回新对象。

  构造函数调用与普通函数调用的这个重要区别也是用首字母大写的名字命名构造函数的一个原因。构造函数在编写时就会考虑它会作为构造函数以 `new` 关键字来调用，因此把它们当成普通函数来调用通常会有问题。这个命名约定让构造函数有别于普通函数，方便知道什么时候使用 `new`。

- 另一个**关键区别是命名原型对象的方式**。在第一个示例中，原型是 `range.methods`。这是一个方便且好懂的名字，但太随意。在第二个示例中，原型是 `Range.prototype`，这个名字是强制性的。对构造函数 `Range()` 的调用会自动把 `Range.prototype` 作为新 Range 对象的原型。

- 最后，要注意示例 9-1 和示例 9-2 相比没有变化的部分，两个类的范围相关方法是以相同方式定义和调用的。因为示例 9-2 演示了 JS 在 ES6 之前创建类的习惯做法，所以原型对象中没有使用 ES6 简写语法定义方法，而是明确使用了 `function` 关键字。但那些方法的实现在两个示例中都是一样的。

- 还有一点很重要，就是这两个范围类的示例都没使用箭头函数定义构造函数或方法，**用箭头函数方式定义的函数没有 prototype 属性，因此不能作为构造函数使用**。而且，箭头函数中的 this 是从定义它们的上下文继承的，不会根据调用它们的对象来动态设置。这样定义的方法就不能用了，因为方法的典型特点就是使用 this 引用调用它们的实例。

> **注意**：ES6 新增的类语法不允许使用箭头函数定义方法。

**构造函数和 `new.target`**
在函数体内，可以通过一个特殊表达式 `new.target` 判断函数是否作为构造函数被调用了。如果该表达式的值有定义，就说明函数是作为构造函数，通过 `new` 关键字调用的。在讨论[子类](#95-子类)时，会看到 `new.target` 并非一直引用它所在的构造函数，也可能引用子类的构造函数。

如果 `new.target` 是 undefined，那么包含函数就是作为普通函数被调用的，没有使用 `new` 关键字。JS 的各种错误构造函数可以不使用 new 调用，如果想在构造函数中模拟这个特性，可以像下面这样编码:

```js
function C() {
  if (!new.target) return new C();
  // 这里是初始化代码
}
```

> 这个技术只适用于以这种老方式定义的构造函数。使用 `class` 关键字创建的类不允许不使用 new 调用它们的构造函数。

#### 9.2.1 构造函数、类标识和 instanceof

如前所见，原型对象是类标识的基本：当且仅当两个对象继承同一个原型对象时，它们才是同一个类的实例。初始化新对象状态的构造函数不是基本标识，因为两个构造函数的 prototype 属性可能指向同一个原型对象，此时两个构造函数都可以用于创建同一个类的实例。

虽然构造函数不像原型那么基本，但构造函数充当类的外在表现。最明显的，构造函数的名字通常都用作类名。例如，`Range()` 构造函数可以创建 Range 对象。但更根本的问题在于，在使用 `instanceof` 操作符测试类的成员关系时，构造函数是其右操作数。如果想测试对象 r 是不是 Range 对象：

```js
r instanceof Range; // true：继承了 Range.prototype
```

**`instanceof` 操作符，其左操作数应该是要检测的对象，右操作数应该是代表某个类的构造函数**。对于表达式 `o instanceof c`，如果 o 继承 c.prototype，则表达式求值为 true。这里的继承不一定是直接继承，如果 o 继承的对象继承了 c.prototype，这个表达式仍然求值为 true。

严格来讲，对于前面的表达式，`instanceof` 操作符并非检查 r 是否通过 Range 构造函数初始化，而是检查 r 是否继承 `Range.prototype`。如果定义了一个函数 `Strange()`，并将其 prototype 属性设置为等于 Range.prototype，那么 instanceof 操作符也会将 `new Strange()` 创建的对象判定为 Range 对象（尽管它们不能像真正的 Range 对象一样工作，因为它们的 from 和 to 属性都没有初始化）：

```js
function Strange() {}
Strange.prototype = Range.prototype;
new Strange() instanceof Range; // true
```

虽然 `instanceof` 不能验证使用的是哪个构造函数，但它仍然以构造函数作为其右操作数，因为构造函数是类的公共标识。

如果不想以构造函数作为媒介，直接测试某个对象原型链中是否包含指定原型，可以使用 `isPrototypeof()` 方法。例如在示例 9-1 中，定义类时没有使用构造函数，因而无法对这个类使用 `instanceof` 操作符。此时，可以通过如下代码检测对象 r 是不是这个无构造函数类的成员：

```js
range.methods.isPrototypeof(r); // range.methods 是 r 的原型对象
```

#### 9.2.2 constructor 属性

在示例 9-2 中，把 `Range.prototype` 设置为一个新对象，其中包含类的方法。尽管把方法定义为对象字面量的属性很便捷，但实际上没有必要创建一个新对象。

任何普通 JS 函数（不包括箭头函数、生成器函数和异步函数）都可以用作构造函数，而构造函数调用需要一个 prototype 属性。为此，每个普通 JS 函数自动拥有一个 prototype 属性。这个属性的值是一个对象，有一个不可枚举的 constructor 属性。而这个 constructor 属性的值就是该函数对象：

```js
let F = function () {}; // 这是一个函数对象
let p = F.prototype; // 这是一个与 F 关联的原型对象
let c = p.constructor; // 这是与原型关联的函数
c === F; // true：对任何 F，F.prototype.constructor === F
```

这个预定义对象及其 constructor 属性的存在，意味着对象也会继承一个引用其构造函数的 constructor 属性。因为构造函数充当类的公共标识，所以这个 constructor 属性返回对象的类：

```js
let o = new F(); // 创建类 F 的对象 o
o.constructor === F; // true：constructor 属性指定类
```

图 9-1 直观地展示了构造函数、其原型对象、原型对构造函数的反向引用，以及通过该构造函数创建的实例之间的关系：

![9-1](./image/9-1.jpg)

> **注意**：图 9-1 使用了 `Range()` 构造函数作为示例。但实际上，例 9.2 定义的 Range 类用自己的对象重写了预定义的 `Range.prototype` 对象。而它定义的这个新的原型对象并没有 constructor 属性。所以按照定义，Range 类的实例都没有 constructor 属性。这个问题可以通过显式地为原型添加一个 constructor 属性来解决。
>
> ```js
> Range.prototype = {
>   constructor: Range // 显式设置反向引用 constructor
>   /*以下是方法定义*/
> };
> ```

另一个在老代码中常见的技术是使用预定义的原型对象及其 constructor 属性，然后像下面这样每次给它添加一个方法：

```js
// 扩展预定义的 Range.prototype 对象，不重写自动创建的 Range.prototype.constructor 属性
Range.prototype.includes = function (x) {
  return this.from <= x && x <= this.to;
};

Range.prototype.toString = function () {
  return '(' + this.from + '...' + this.to + ')';
};
```

### 9.3 使用 class 关键字的类

JS 在它最初的版本就支持类，只不过自 ES6 引入 `class` 关键字才有了自己的语法。示例 9-3 展示了以这种新语法重写的 Range 类。

```js
// 示例 9-3：使用 class 重写的 Range 类
class Range {
  constructor(from, to) {
    // 保存新范围对象的起点和终点（状态）
    // 这些属性不是继承的，是当前对象独有的
    this.from = from;
    this.to = to;
  }

  // 如果 x 在范围内则返回 true，否则返回 false
  // 这个方法适用于文本、日期和数值范围
  includes(x) {
    return this.from <= x && x <= this.to;
  }

  // 这个生成器函数让这个类的实例可迭代
  // 注意：只适用于数值范围
  *[Symbol.iterator]() {
    for (let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  }

  // 返回范围的字符串表示
  toString() {
    return `(${this.from}...${this.to})`;
  }
}

// 下面是使用这个新 Range 类的示例
let r = new Range(1, 3); // 创建一个 Range 对象
r.includes(2); // true：2 在范围内
r.toString(); // "(1...3)"
[...r]; // [1, 2, 3]; 通过迭代器转换为数组
```

示例 9-2 和示例 9-3 中定义的类工作方式完全一样，理解这一点非常重要。新增 `class` 关键字并未改变 JS 类基于原型的本质。虽然示例 9-3 使用了 `class` 关键字，但得到的 Range 对象是一个构造函数，与示例 9-2 定义的版本一样。新的 `class` 语法虽然明确、方便，但最好把它看成示例 9-2 中更基础的类定义机制的 “语法糖”。

对于示例 9-3 展示的类语法，需要注意以下几点：

- 类是以 `class` 关键字声明的，后面跟着类名和花括号中的类体。

- 类体包含使用对象字面量方法简写形式（示例 9-1 中使用过）定义的方法，因此省略了 function 关键字。但与对象字面量不同的是方法之间没有逗号（尽管类体与对象字面量表面上相似，但它们不是一回事。特别地，类体中不支持名/值对形式的属性定义）。

- 关键字 `constructor` 用于定义类的构造函数。但实际定义的函数并不叫 “constructor”。class 声明语句会定义一个新变量 Range，并将这个特殊构造函数的值赋给该变量。

- 如果类不需要任何初始化，可以省略 `constructor` 关键字及其方法体，解释器隐式创建一个空构造函数。

如果想定义一个继承另一个类（或作为另一个类子类）的类，可以使用 `extends` 关键字和 `class` 关键字：

```js
// Span 与 Range 相似，但初始化使用的不是起点和终点，而是起点和长度。
class Span extends Range {
  constructor(start, length) {
    if (length > 0) {
      super(start, start + length);
    } else {
      super(start + length, start);
    }
  }
}
```

与函数定义类似，类声明也有语句和表达式两种形式。可以像这样声明类：

```js
let Square = class {
  constructor(x) {
    this.area = x * x;
  }
};
new Square(3).area; // 9
```

**与函数定义表达式一样，类定义表达式也可以包含可选的类名。如果提供了名字，则该名字只能在类体内部访问到**。虽然函数表达式很常见（特别是箭头函数简写形式），但在 JS 编程中，除非需要写一个以类作为参数且返回其子类的函数，否则类定义表达式并不常用。

#### 9.3.1 静态方法

在 class 体中，把 `static` 关键字放在方法声明前面可以定义静态方法。静态方法是作为构造函数而非原型对象的属性定义的。

例如，假设在示例 9-3 中添加如下代码：

```js
static parse(s) {
  let matches = s.match(/^\((\d+)\.\.\.(\d+)\)$/);

  if(!matches) {
    throw new TypeError(`Cannot parse Range from "${s}".`);
  }
  return new Range(parseInt(matches[1]), parseInt(matches[2]));
}
```

这段代码定义的方法是 `Range.parse()`，而非 `Range.prototype.parse()`，必须通过构造函数而非实例调用它：

```js
let r = Range.parse('(1...10)'); // 返回一个新 Range 对象
r.parse('(1...10)'); // TypeError：r.parse 不是一个函数
```

有人也把静态方法称为类方法，因为它们要通过类（构造函数）名调用。这么叫是为了区分类方法和在类实例上调用的普通实例方法。**由于静态方法是在构造函数而非实例上调用的，所以在静态方法中使用 `this` 关键字没什么意义**。

#### 9.3.2 获取方法、设置方法及其他形式的方法

在 class 体内，可以像在对象字面量中一样定义[获取方法和设置方法](#6106-属性的获取方法与设置方法访问器属性)。唯一的区别是类体内的获取方法和设置方法后面不加逗号。[示例 9-4](#94-为已有类添加方法) 展示了如何在类中定义获取方法。

一般来说，对象字面量支持的所有简写的方法定义语法都可以在类体中使用。这包括生成器方法（带`*`）和名字为方括号中表达式值的方法。

#### 9.3.3 公有、私有和静态字段

**ES6 标准只允许创建方法（包括获取方法、设置方法和生成器）和静态方法，还没有定义字段的语法**。如果想在类实例上定义字段（这只是面向对象的 “属性” 的同义词），必须在构造函数或某个方法中定义。如果想定义类的静态字段，必须在类体之外，在定义类之后定义。[示例 9-4](#94-为已有类添加方法) 中也包含这两种字段的示例。

不过，扩展类语法以支持定义实例和静态字段的标准化过程还在继续。本节后面展示的代码在 2020 年初还不是标准 JS 写法，但 Chrome 已经支持，Firefox 已经部分支持了（仅公有实例字段）。

假设写了一个类似下面的类，使用构造函数初始了 3 个字段：

```js
class Buffer {
  constructor() {
    this.size = 0;
    this.capacity = 4096;
    this.buffer = new Uint8Array(this.capacity);
  }
}
```

**可能会被标准化的新实例字段语法**
如果使用将来可能会被标准化的新实例字段语法，那可以这样写：

```js
class Buffer {
  size = 0;
  capacity = 4096;
  buffer = new Uint8Array(this.capacity);
}
```

也就是说，字段初始化的代码从构造函数中挪了出来，直接写在了类体内（当然，这些代码仍然作为构造函数的一部分运行。如果没有定义构造函数，这些字段则作为隐式创建的构造函数的一部分被初始化）。

> **注意**：虽然赋值语句左操作数中的 `this.` 前缀已经不见了，但要引用这些字段仍然要加上 `this.`，即便是在初始化赋值的右操作数中。**使用这种语法初始化实例字段的好处是可以把初始化代码放到类定义的顶部（但不是必需的）**，让读者对实例都有哪些字段一目了然。声明字段时也可以不初始化，只写字段名和分号。这样一来，字段的初始值就是 undefined。不过更好的做法是始终给所有类字段赋一个初始值。

在不使用这种字段语法的情况下，类体看起来非常像使用简写方法语法的对象字面量（除了没有逗号）。这种字段语法（等号和分号，而不是冒号加逗号）使得类体更明确地区别于对象字面量。

**可能会被标准化的私有实例字段**
试图标准化这些实例字段的同一提案也定义了私有实例字段。如果像前面示例中那样使用实例字段初始化语法，但字段名前面加上 `#`（通常不是合法的 JS 标识符字符），则该字段就只能在类体中（带着 `#` 前缀）使用，对类体外部的任何代码都不可见、不可访问（因而无法修改）。对于前面假想的 Buffer 类，如果想确保类用户不会意外修改实例的 size 字段，可以使用私有的 #size 字段，然后定义一个获取函数，只允许读取该字段的值：

```js
class Buffer {
  #size = 0;
  get size() {
    return this.#size;
  }
}
```

> **注意**：私有字段必须先使用这种语法声明才能使用。换句话说，如果没有直接在类体中 “声明” `#size` 字段，就不能在类的构造函数中写 `this.#size = 0;`。

**在字段前使用 `static` 关键字标准化的提案**
最后，还有一个相关提案希望将在字段前使用 `static` 关键字标准化。根据这份提案，如果在公有或私有字段声明前加上 `static`，这些字段就会被创建为构造函数的属性，而非实例属性。以前面创建的静态 `Range.parse()` 方法为例，其中定义了一个相当复杂的正则表达式。如果把这个正则表达式提炼为一个静态字段会更有利于维护。使用新的静态字段语法，可以这样写：

```js
static integerRangePattern = /^\((\d+)\.\.\.(\d+)\)$/;
static parse(s) {
  let matches = s.match(Range.integerRangePattern);

  if(!matches) {
    throw new TypeError(`Cannot parse Range from "${s}".`);
  }
  return new Range(parseInt(matches[1]), parseInt(matches[2]));
}
```

如果想让这个字段只能在类内部访问，可以使用类似 `#pattern` 的名字把它变成私有静态字段。

#### 9.3.4 示例:复数类

示例 9-4 定义了一个表示复数的类。这个类相对比较简单，但包含了实例方法（包括获取方法）、静态方法、实例字段和静态字段。代码中的注释解释了应该怎么在类体中使用尚未成为标准的定义实例字段和静态字段的语法。

```js
/**
 * 这个 Complex 类的实例代表复数
 * 复数是一个实数和一个虚数之和,
 * 而虚数 i 是 -1 的平方根
 */
class Complex {
  // 在这种类字段声明标准化之后，可以像下面这样，声明私有字段来保存复数的实数和虚数部分
  // #r = 0;
  // #i = 0;

  // 这个构造函数定义了它需要在每个实例上
  // 创建的实例属性 r 和 i。这两个字段保存复数的实数和虚数部分，即对象的状态
  constructor(real, imaginary) {
    this.r = real; // 这个字段保存这个数的实数部分
    this.i = imaginary; // 这个字段保存这个数的虚数部分
  }

  // 这里是两个实例方法，用于做复数的加法和乘法。如果 c 和 d 是这个类两个实例，则
  // 可以写 c.plus(d) 或 d.times(c)
  plus(that) {
    return new Complex(this.r + that.r, this.i + that.i);
  }
  times(that) {
    return new Complex(this.r * that.r - this.i * that.i, this.r * that.i + this.i * this.r);
  }

  // 而这里是两个复数计算方法的静态版本。这样可以写
  // Complex.sum(c, d) 和 Complex.product(c, d)
  static sum(c, d) {
    return c.plus(d);
  }
  static product(c, d) {
    return c.times(d);
  }

  // 这些也是实例方法,但是使用获取函数定义的，因此可以像使用字段一样使用它们。
  // 如果我们使用的是私有字段 this.#r 和 this.#i，那这里的获取方法就有用了
  get real() {
    return this.r;
  }
  get imaginary() {
    return this.i;
  }
  get magnitude() {
    return Math.hypot(this.r, this.i);
  }

  // 每个类都应该有一个 toString() 方法
  toString() {
    return `(${this.r},${this.i})`;
  }

  // 这个方法可以用来测试类的两个实例是否表示相同的值
  equals(that) {
    return that instanceof Complex && this.r === that.r && this.i === that.i;
  }

  // 如果类体支持静态字段，那我们就可以像下面这样定义一个常量 Complex.ZERO
  // static ZERO = new Complex(0,0)
}

// 下面定义了几个保存预定义复数的类字段
Complex.ZERO = new Complex(0, 0);
Complex.ONE = new Complex(1, 0);
Complex.I = new Complex(0, 1);
```

有了示例 9-4 中的 Complex 类，就可以像下面这样使用构造函数、实例字段、实例方法、类字段和类方法：

```js
let c = new Complex(2, 3); // 通过构造函数创建一个新对象
let d = new Complex(c.i, c.r); // 使用 c 的实例字段
c.plus(d).toString(); // "(5,5}"; 使用实例方法
c.magnitude; // Math.hypot(2,3); 使用获取函数
Complex.product(c, d); // new Complex(0,13); 使用静态方法
Complex.ZERO.toString(); // "{0,0}"; 使用静态属性
```

### 9.4 为已有类添加方法

JS 基于原型的继承机制是动态的。换句话说，对象从它的原型继承属性，如果在创建对象之后修改了原型的属性，则对象继承修改后的属性。这意味着只要给原型对象添加方法，就可以增强 JS 类。

例如，下面的代码为示例 9-4 定义的 Complex 类添加了一个计算共轭复数的方法：

```js
// 返回当前复数的共轭复数
Complex.prototype.conj = function () {
  return new Complex(this.r, this.i);
};
```

**内置 JS 类的原型对象也跟这里一样是开放的**，因此可以为数值、字符串、数组、函数等添加方法。如果想在旧版本 JS 中添加新语言特性，就可以这么做：

```js
// 如果字符串上没有定义 startsWith() 方法
if (!String.prototype.startsWith) {
  // 则使用已有的 indexOf() 方法实现一个
  String.prototype.startsWith = function (s) {
    return this.indexOf(s) === 0;
  };
}
```

下面是另一个示例：

```js
// 多次调用函数 f，传给它送代数值
// 如，要打印 3 次 "hello"
// let n = 3
// n.times(i => { console.log(`hello ${i}`); });
Number.prototype.times = function (f, context) {
  let n = this.valueOf();
  for (let i = 0; i < n; i++) f.call(context, i);
};
```

> **注意**：**像这样给内置类型的原型添加方法通常被认为是不好的做法**。因为如果 JS 未来某个新版本也定义了同名方法，就会导致困惑和兼容性问题。当然，给 `Object.prototype` 添加方法也是可以的，这样所有对象都会继承新方法。但最好不要这样做，因为添加到 `Object.prototype` 上的属性在 for/in 循环中是可见的（尽管使用 [`Object.defineProperty()`](#141-属性的特性) 方法把新属性设置为不可枚举能够避免这个问题）。

### 9.5 子类

在面向对象编程中，类 B 可以扩展或子类化类 A。此时说 A 是父类，B 是子类。B 的实例继承 A 的方法。类 B 也可以定义自己的方法，其中有些方法可能覆盖类 A 的同名方法。如果 B 的方法覆盖了 A 的方法，B 中的覆盖方法经常需要调用 A 中被覆盖的方法。类似地，子类构造函数 B() 通常必须调用父类构造函数 A() 才能将实例完全初始化。

本节首先展示如何以 ES6 之前的旧方式定义子类，然后使用 `class` 和 `extends` 关键字定义子类，以及通过 `super` 关键字调用父类构造函数。接下来讨论如何避免使用子类，利用对象组合而非继承。最后展示一个综合性的示例，其中定义了几个层次的 Set 类，演示了如何利用抽象类分隔接口与实现。

#### 9.5.1 子类与原型

假设想定义示例 9-2 中 Range 类的一个子类 Span。这个子类与 Range 相似，但不是初始化起点和终点，而是初始化起点和距离或跨度（span）。

Span 类的实例也是父类 Range 的实例。跨度的实例从 `Span.prototype` 继承了自定义的 `toString()` 方法，但为了成为 Range 的子类，它也必须从 `Range.prototype` 继承方法（如 `includes()`）。

```js
// 示例 9-5: Range 的简单的子类（Span.js）
// 这是子类构造函数
function Span(start, span) {
  if (span >= 0) {
    this.from = start;
    this.to = start + span;
  } else {
    this.to = start;
    this.from = start + span;
  }

  // 确保 Span 的原型继承 Range 的原型
  Span.prototype = Object.create(Range.prototype);

  // 不想继承 Range.prototype.constructor
  // 因此需要定义自己的 constructor 属性
  Span.prototype.constructor = Span;

  // 通过定义自己的 toString() 方法，Span 覆盖了 toString(，否则就要从 Range 继承
  Span.prototype.toString = function () {
    return `(${this.from}...${this.to - this.from})`;
  };
}
```

为了让 Span 成为 Range 的子类，需要让 `Span.prototype` 继承 `Range.prototype`。前面示例中最关键的一行代码就是这一行，如果能明白，那就理解了 JS 中子类的工作机制：

```js
Span.prototype = Object.create(Range.prototype);
```

通过 Span() 构造函数创建的对象会继承 `Span.prototype` 对象。但在创建该对象时让它继承了 `Range.prototype`，因此 Span 对象既会继承 `Span.prototype`，也会继承 `Range.prototype`。

> **注意**：
>
> 1. Span() 构造函数像 Range() 构造函数一样，也设置了 from 和 to 属性，因此不需要调用 Range() 构造函数来初始化新对象。
> 2. Span 的 toString() 方法完全重新实现了字符串转换逻辑，不需要调用 Range 的 toString()。这让 Span 成为一个特例，只有在知道父类实现细节的前提下才可能这样定义子类。健壮的子类化机制应该允许类调用父类的方法和构造函数，但在 ES6 之前，JS 中没有简单的办法做这些。好在 ES6 通过 `super` 关键字作为 `class` 语法的一部分解决了这个问题。

#### 9.5.2 通过 extends 和 super 创建子类

在 ES6 及以后，要继承父类，可以简单地在类声明中加上一个 `extends` 子句，甚至对内置的类也可以这样：

```js
// Array 的一个简单子类，为第一个和最后一个元素添加了获取函数
class EZArray extends Array {
  get first() {
    return this[0];
  }
  get last() {
    return this[this.length - 1];
  }
}
let a = new EZArray();
a instanceof EZArray; // true：a 是子类的实例
a instanceof Array; // true：a 也是父类的实例
a.push(1, 2, 3, 4); // a.length == 4; 可以使用继承的方法
a.pop(); // 4：使用另一个继承的方法
a.first; // 1：子类定义的 first 获取方法
a.last; // 3：子类定义的 last 获取方法
a[1]; // 2：普通数组访问语法仍然有效
Array.isArray(a); // true：子类实例确实是数组
EZArray.isArray(a); // true：子类也继承了静态方法
```

这个 EZArray 子类定义了两个简单的获取方法。EZArray 的实例就像普通数组一样，拥有继承的方法和属性，如 `push()`、`pop()` 和 `length`。但是它也有子类定义的 first 和 last 获取方法。另外，子类实例不仅继承了 `pop()` 等实例方法，子类本身也继承了 `Array.isArray` 这种静态方法。这是 ES6 类语法带来的新特性：`EZArray()` 是个函数，但它继承 Array()。

```js
// EZArray 的实例之所以能继承实例方法，是因为 EZArray.prototype 继承 Array.prototype
Array.prototype.isPrototypeOf(EZArray.prototype); // true

// EZArray 之所以能继承静态方法和属性，是因为 EZArray 继承 Array。这是 extends 关键字独有的特性，在 ES6 之前是不可能做到的
Array.isPrototypeOf(EZArray); // true
```

EZArray 子类太简单，很难充分说明问题。示例 9-6 是一个相对更完善的示例，该示例为内置 Map 类定义了一个 TypedMap 子类，添加了类型检查以确保映射的键和值都是指定的类型（根据 typeof）。重点是，该示例展示了使用 `super` 关键字调用父类构造函数和方法。

```js
// 示例 9-6: Map 检查键和值类型的子类（TypedMap.js）
class TypedMap extends Map {
  constructor(keyType, valueType, entries) {
    // 如果指定了条目，检查它们的类型
    if (entries) {
      for (let [k, v] of entries) {
        if (typeof k !== keyType || typeof v !== valueType) {
          throw new TypeError(`wrong type for entry [${k}, ${v}]`);
        }
      }
    }
    // 使用（通过类型检查的）初始条目初始化父类
    super(entries);
    // 然后初始化子类，保存键和值的类型
    this.keyType = keyType;
    this.valueType = valueType;
  }

  // 现在，重定义 set() 方法，为所有新增映射条目添加类型检查逻辑
  set(key, value) {
    // 如果键或值的类型不对就抛出错
    if (this.keyType && typeof key !== this.keyType) {
      throw new TypeError(`${key} is not of type ${this.keyType}`);
    }
    if (this.valueType && typeof value !== this.valueType) {
      throw new TypeError(`${value} is not of type ${this.valueType}`);
    }
    // 如果类型正确，则调用超类的 set()，方法为映射添加条目。同时,返回父类方法返回的值
    return super.set(key, value);
  }
}
```

`TypedMap()` 构造函数的前两个参数是期望的键和值类型，应该是字符串，例如 "number"、"boolean" 等 `typeof` 操作符返回的值。还可以指定第三个参数：一个 `[key, value]` 数组的数组（或可迭代对象），用于指定映射的初始条目。如果指定了初始条目，则构造函数的第一件事就是检查它们的类型是否正确。然后，再通过 `super` 调用父类构造函数，就像它是一个函数名一样。

`Map()` 构造函数接收一个可选的参数：一个 `[key, value]` 数组的可迭代对象。因此，`TypedMap()` 构造函数可选的第三个参数就是 `Map()` 构造函数可选的第一个参数，通过 `super(entries)` 把它传给父类构造函数。

在调用父类构造函数初始化父类状态后，`TypedMap()` 构造函数接着通过把 `this.keyType` 和 `this.valueType` 设置为指定类型初始化了自己这个子类的状态。之所以要保存这两个值，是因为后面的 `set()` 方法要使用。

关于在构造函数中使用 `super()`，有几个重要的规则需要知道：

- 如果使用 `extends` 关键字定义了一个类，那么这个类的构造函数必须使用 `super()` 调用父类构造函数。

- 如果没有在子类中定义构造函数，解释器会自动创建一个。这个隐式定义的构造函数会取得传给它的值，然后把这些值再传给 `super()`。

- 在通过 `super()` 调用父类构造函数之前，不能在构造函数中使用 `this` 关键字。这条强制规则是为了确保父类先于子类得到初始化。

- 在没有使用 `new` 关键字调用的函数中，特殊表达式 `new.target` 的值是 `undefined`。而在构造函数中，`new.target` 引用的是被调用的构造函数。当子类构造函数被调用并使用 `super()` 调用父类构造函数时，该父类构造函数通过 `new.target` 可以获取子类构造函数。设计良好的父类无须知道自己是否有子类，但它们可以使用 `new.target.name` 来记录日志消息。

在示例 9-6 中，构造函数后面是一个名为 `set()` 的方法。父类 `Map()` 定义了一个名为 `set()` 的方法用于向映射中添加新条目。TypedMap 中的这个 `set()` 方法覆盖了其父类的 `set()` 方法。

这个简单的 TypedMap 子类并不知道怎么向映射中添加新条目，但它知道怎么检查类型，这也是它先做的：验证添加到映射的键和值都是正确的类型，如果不是则抛出错误。这个 `set()` 方法本身不能向映射中添加键和值，但这正是父类 `set()` 方法的作用。因此再次使用 `super` 关键字，调用父类的这个方法。此时，`super` 的角色很像 `this` 关键字，它引用当前对象，但允许访问父类定义的被覆盖的方法。

在构造函数中，必须先调用父类构造函数才能访问 `this` 并初始化子类的新对象。但在覆盖方法时则没有这个限制。覆盖父类方法的方法不一定调用父类的方法。如果它确实要通过 `super` 调用父类被覆盖的方法（或其他方法），那在覆盖方法的开头、中间或末尾调用都没问题。

#### 9.5.3 委托而不是继承

使用 `extends` 关键字可以轻松地创建子类。但这并不意味就应该创建很多子类。如果写了一个类，这个类与另一类有相同的行为，可以通过创建子类来继承该行为。但是，在类中创建另一个类的实例，并在需要时委托该实例去做希望的事反而更方便，也更灵活。

这时候，不需要创建一个类的子类，只要**包装或组合其他类即可。这种委托策略常常被称为“组合”**（composition），也是面向对象编程领域奉行的一个准则，即**开发者应该“能组合就不继承”**（favor composition over inherit）。

例如，假设想写一个 Histogram（直方图）类，这个类有些像 JS 的 Set 类，但除了记录一个值是否被添加到集合，它还要维护值被添加的次数。因为这个 Histogram 类的 API 类似于 Set，可以考虑扩展 Set 并添加一个 `count()` 方法。但从另一个角度有看，在思考如何实现这个 `count()` 方法时，又会发现这个 Histogram 类更像是 Map 而不是 Set。因为它需要维护值与添加次数的映射。所以与其创建 Set 的子类，不如创建一个类，为它定义类似 Set 的 API，但通过把相应操作委托给一个内部 Map 对象来实现那些方法。示例 9-7 展示了这个类：

```js
// 示例 9-7：通过委托实现的类似 Set 的类（Histogram.js）

/**
 * 一个类似 Set 的类，但会记录值被添加的次数，可以像使用 Set 一样调用 add() 和 remove()
 * 调用 count() 获取某个值已经被添加了多少次
 * 默认迭代器回送至少被添加过1次的值。如果想迭代 [value, count] 对，使用 entries()
 */

class Histogram {
  // 初始化只涉及创建一个要委托的 Map 对象
  constructor() {
    this.map = new Map();
  }

  // 对给定的键，次数就是映射中的值。如果映射中不存在这个键，则为 0
  count(key) {
    return this.map.get(key) || 0;
  }

  // 这个类似 Set 的方法 has() 在次数大于 0 时返回true
  has(key) {
    return this.count(key) > 0;
  }

  // 直方图的大小就是映射中条目的数量
  get size() {
    return this.map.size;
  }

  // 要添加一个键，只需递增其在映射中的次数
  add(key) {
    this.map.set(key, this.count(key) + 1);
  }

  // 删除键稍微麻烦点，因为必须在次数回到 0 时从映射中删除相应的键
  delete(key) {
    let count = this.count(key);
    if (count === 1) {
      this.map.delete(key);
    } else if (count > 1) {
      this.map.set(key, count - 1);
    }
  }

  // 迭代直方图就是返回映射中存储的键
  [Symbol.iterator]() {
    return this.map.keys();
  }

  // 其他迭代器方法直接委托给映射对象
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
}
```

例 9-7 中 `Histogram()` 构造函数只做了一件事，就是创建了一个 Map 对象。而这个类的多数方法只有一行，因为都委托给了相应的映射方法，所以实现特别简单。由于使用委托而非继承，Histogram 对象既不是 Set 的实例，也不是 Map 的实例。但 Histogram 实现了一些常用的 Set 方法，在像 JS 这样的弱类型语言中，这通常就足够了。正式的继承关系有时候确实好，但并不是必需的。

#### 9.5.4 类层次与抽象类

示例 9-6 演示了如何创建 Map 的子类。示例 9-7 演示了如何委托 Map 对象而不创建子类。使用 JS 类封装数据和组织代码通常是个不错的技术，因此可能会经常使用 `class` 关键字。但是，可能会发现组合比继承更常用，因而几乎不会用到 `extends`（除非使用某个库或框架，要求必须扩展其基类）。

然而，也存在需要多级子类的情况。示例 9-8 其中涉及表示不同集合的类层次（其中定义的集合类与 JS 内置的 Set 类相似，但不完全兼容）。

示例 9-8 定义了很多子类，同时也演示了如何定义抽象类，也就是不包含完整实现的类。抽象类在这里作为一组相关子类的公共父类。抽象父类可以定义部分实现，供所有子类继承和共享。子类只需实现父类定义（但未实现）的抽象方法。不过，JS 没有正式定义抽象方法或抽象类的语法。这里只是借用它们来指代未实现的方法和未完全实现的类。

示例 9-8 包含完善的注释，自成一体。它将作为展示 JS 类使用的顶级范例。示例 9-8 定义的最后一个类通过 `&`、`|` 和 `~` 操作符实现了很多位操作。

```js
// 示例 9-8: 抽象与具体的集合类层次（Sets.js）

/**
 * AbstractSet 类只定义了一个抽象方法 has()
 */
class AbstractSet {
  // 抛出错误，强制子类必须定义这个方法的可用版本
  has(x) {
    throw new Error('Abstract method');
  }
}

/**
 * Notset 是 AbstractSet 的一个具体子类，这个集合的成员是不属于其他集合的任何值
 * 因为使用另一个集合定义，所以它不可写，而且因为它有无限个成员，所以不可枚举
 * 这个类只支持检测成员关系和使用数学符号把集合转换为字符串
 */
class NotSet extends AbstractSet {
  constructor(set) {
    super();
    this.set = set;
  }
  // 实现继承的抽象方法
  has(x) {
    return !this.set.has(x);
  }
  // 同时覆盖 Object 的方法
  toString() {
    return `{ x| x ∉ ${this.set.toString()} }`;
  }
}

/**
 * Range 集合是 AbstractSet 的一个具体子类
 * 这个集合的成员是介于 from 和 to（含二者）之间的所有值
 * 由于其成员可能是浮点数值，因此不可枚举，也不具备有意义的大小
 */
class RangeSet extends AbstractSet {
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
  }

  has(x) {
    return x >= this.from && x <= this.to;
  }
  toString() {
    return `{ x| ${this.from} ≤ x ≤ ${this.to} }`;
  }
}

/**
 * AbstractEnumerableSet 是 AbstractSet 的一个抽象子类
 * 这个抽象类定义了一个抽象的获取方法，返回集合的大小
 * 还定义了一个抽象迭代器。然后在此基础上实现了具体的 isEmpty()、toString() 和 equals() 方法。
 * 实现这个迭代器、大小获取方法以及（继承的） has() 方法的子类无偿获得这些具体方法
 */
class AbstractEnumerableSet extends AbstractSet {
  get size() {
    throw new Error('Abstract method');
  }
  [Symbol.iterator]() {
    throw new Error('Abstract method');
  }

  isEmpty() {
    return this.size === 0;
  }
  toString() {
    return `{${Array.from(this).join(', ')}}`;
  }

  equals(set) {
    // 如果另一个集合不是 AbstractEnumerableSet，那肯定不等于当前集合
    if (!(set instanceof AbstractEnumerableSet)) return false;

    // 如果两个集合大小不一样，它们也不相等
    if (this.size !== set.size) return false;

    // 循环检查集合的元素
    for (let element of this) {
      // 只要有一个元素不在另一个集合中，它们就不相等
      if (!set.has(element)) return false;
    }

    // 元素匹配，因此两个集合相等
    return true;
  }
}

/**
 * SingletonSet 是 AbstractEnumerableSet 的一个具体子类
 * 单体集合是只有一个成员的只读集合
 */
class SingletonSet extends AbstractEnumerableSet {
  constructor(member) {
    super();
    this.member = member;
  }

  // 实现 3 个抽象方法，同时继承基于这 3 个方法实现的 isEmpty()、equals() 和 toString()
  has(x) {
    return x === this.member;
  }
  get size() {
    return 1;
  }
  *[Symbol.iterator]() {
    yield this.member;
  }
}

/**
 * AbstractWritableSet 是 AbstractEnumerableSet 的一个抽象子类
 * 这个抽象类定义了抽象方法 insert() 和 remove()，分别用于插入和删除个别集合元素
 * 然后在此基础上实现了具体的 add()、subtract()和 intersect() 方法。
 *
 * 注意，API 从这里开始偏离了标准的 JS Set 类
 */
class AbstractWritableSet extends AbstractEnumerableSet {
  insert(x) {
    throw new Error('Abstract method');
  }
  remove(x) {
    throw new Error('Abstract method');
  }

  add(set) {
    for (let element of set) {
      this.insert(element);
    }
  }

  subtract(set) {
    for (let element of set) {
      this.remove(element);
    }
  }

  intersect(set) {
    for (let element of this) {
      if (!set.has(element)) {
        this.remove(element);
      }
    }
  }
}

/**
 * Bitset 是 AbstractwritableSet 的一个具体子类
 * 这个类是非常高效的固定大小集合的实现，用于元素为小于某个最大值的非负整数集合
 */
class BitSet extends AbstractwritableSet {
  constructor(max) {
    super();
    this.max = max; // 可存储的最大整数
    this.n = 0; // 集合中整数的个数
    this.numBytes = Math.floor(max / 8) + 1; // 需要多少字节
    this.data = new Unit8Array(this.numBytes); // 实际的字节
  }

  // 内部方法，检测一个值是否为当前集合的合法成员
  _valid(x) {
    return Number.isInteger(x) && x >= 0 && x <= this.max;
  }

  // 测试数据数组中指定字节的指定位是否有值，返回 true 或 false
  _has(byte, bit) {
    return (this.data[byte] & BitSet.bits[bit]) !== 0;
  }

  // x 在这个 BitSet 中吗?
  has(x) {
    if (this._valid(x)) {
      let byte = Math.floor(x / 8);
      let bit = x % 8;
      return this._has(byte, bit);
    } else {
      return false;
    }
  }

  // 把 x 插入当前 BitSet
  insert(x) {
    // 如果这个值有效
    if (this._valid(x)) {
      let byte = Math.floor(x / 8); // 转换为字节和位
      let bit = x % 8;
      // 如果对应的位没有值
      if (!this._has(byte, bit)) {
        this.data[byte] |= BitSet.bits[bit]; // 则设置该位的值
        this.n++; // 并递增集合大小
      }
    } else {
      throw new TypeError('Invalid set element: ' + x);
    }
  }

  remove(x) {
    // 如果这个值有效
    if (this._valid(x)) {
      let byte = Math.floor(x / 8); // 则计算字节和位
      let bit = x % 8;
      if (this._has(byte, bit)) {
        // 如果该位已经设置了值
        this.data[byte] &= Bitset.masks[bit]; // 则取消设置的值
        this.n--; // 并递减集合大小
      }
    } else {
      throw new TypeError('Invalid set element：' + x);
    }
  }

  // 获取方法，返回集合大小
  get size() {
    return this.n;
  }

  // 迭代集合，只依次检查每一位(应该可以更聪明一点，大幅优化这里的逻辑)
  *[Symbol.iterator]() {
    for (let i = 0; i <= this.max; i++) {
      if (this.has(i)) {
        yield i;
      }
    }
  }
}

// has()、insert() 和 remove() 方法会用的几个预定义值
BitSet.bits = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
BitSet.masks = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~1281]);
```

## 十. 模块

模块化编程的目标是能够用不同作者和来源的代码模块组装成大型程序，即使不同模块的作者无法预知如何使用，代码仍然可以正确运行。**实践中，模块化的作用主要体现在封装和隐藏私有实现细节，以及保证全局命名空间清洁上，因而模块之间不会意外修改各自定义的变量、函数和类**。

### 10.1 基于类、对象和闭包的模块

**类的一个重要特性，就是它们充当了自己方法的模块**。示例 9-8 中定义了几个不同的类，这些类都有个名叫 `has()` 的方法。可以在一个程序中同时使用该示例定义的多个集合类，而不必担心 BitSet 的 `has()` 方法会被 SingletonSet 的 `has()` 方法重写。

**不相关的类的方法之所以能够相互独立，是因为每个类的方法都被定义为独立原型对象的属性**。而类之所以成为模块是因为对象是模块：给一个 JS 对象定义属性非常像声明变量，但给对象添加属性不影响程序的全局命名空间，也不影响其他对象的属性。

JS 定义了不少数学函数和常量，但并没有把它们定义在全局命名空间中，而是将它们分组作为属性定义在全局 Math 对象上。示例 9-8 也借鉴了同样的思路。例如，不是把 SingletonSet 和 Bitset 定义为全局类，而是只定义一个全局 Sets 对象，通过这个对象的属性引用不同的类。然后，这个 Sets 库的用户可以通过类似 `Sets.Singleton` 和 `Sets.Bit` 这样的方式引用这些类。

使用类和对象实现模块化是 JS 编程中常见且有用的技术，但这还不够。特别地，类和对象没有提供任何方式来隐藏模块的内部实现细节。再看看示例 9-8，如果把该示例写成一个模块，那么会希望把各种抽象类作为模块的内部代码，只对模块用户暴露具体的子类。类似地，在 BitSet 类中，`_valid()` 和 `_has()` 是内部辅助方法，也不应该暴露给类的用户。而 `Bitset.bits` 和 `Bitset.masks` 也是实现细节，最好也隐藏。

在函数中声明的局部变量和嵌套函数都是函数私有的。这意味着可以使用立即调用的函数表达式来实现某种模块化，把实现细节和辅助函数隐藏在包装函数中，只将模块的公共 API 作为函数的值返回。以 BitSet 类为例，可以像下面这样实现这个模块：

```js
// 将 BitSet 设置为这个函数的返回值
const BitSet = (function () {
  // 这里是私有实现细节
  function isValid(set, n) {}
  function has(set, byte, bit) {}
  const BITS = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
  const MASKS = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~1281]);

  // 这个模块的公共 API 就是 BitSet 类，在这里定义并返回
  // 这个类可以使用上面定义的私有函数和常量，但这些私有函数和常量对这个类的用户是不可见的
  return class BitSet extends AbstractWritableSet {
    // 省略实现
  };
})();
```

如果模块需要暴露多个值。以下代码定义了一个小型统计模块，暴露了 `mean()` 和 `stddev()` 函数，同时隐藏了实现细节：

```js
// 可以像这样定义 stats 模块
const stats = (function () {
  // 模块私有的辅助函数
  const sum = (x, y) => x + y;
  const square = x => x * x;

  //要导出的公有函数
  function mean(data) {
    return data.reduce(sum) / data.length;
  }

  // 另一个要导出的公有函数
  function stddev(data) {
    let m = mean(data);
    return Math.sqrt(
      data
        .map(x => x - m)
        .map(square)
        .reduce(sum) /
        (data.length - 1)
    );
  }

  // 将公有函数作为一个对象的属性导出出来
  return { mean, stddev };
})();

// 下面是使用这个模块的示例
stats.mean([1, 3, 5, 7, 9]); // 5
stats.stddev([1, 3, 5, 7, 9]); // Math.sqrt(10)
```

#### 10.1.1 基于闭包的自动模块化

在一个 JS 代码文件开头和末尾插入一些文本，把它转换为类似的模块是一个相当机械的过程。这里所需要的就是对 JS 代码文件设定一些规则，按照规则可以指定哪些值要导出，哪些值不导出。

可以想象有一个工具，它能解析代码文件，把每个文件的内容包装在一个立即调用的函数表达式中，还可以跟踪每个函数的返回值，并将所有内容拼接为一个大文件。结果可能类似如下所示：

```js
const modules = {};
function require(moduleName) {
  return modules[moduleName];
}

modules['sets.js'] = (function () {
  const exports = {};

  // sets.js 文件的内容在这里:
  exports.BitSet = class BitSet {};
  return exports;
})();

modules['stats.js'] = (function () {
  const exports = {};

  // stats.js 文件的内容在这里
  const sum = (x, y) => x + y;
  const square = x => x * x;
  exports.mean = function (data) {};
  exports.stddev = function (data) {};
  return exports;
})();
```

把所有模块都打包到类似上面的单个文件中之后，可以像下面这样写代码来使用它们：

```js
// 取得对所需模块(或模块内容)的引用
const stats = require('stats.js');
const BitSet = require('sets.js').BitSet;

// 接下来写使用这些模块的代码
let s = new BitSet(100);
s.insert(10);
s.insert(20);
s.insert(30);
let average = stats.mean([...s]); // 平均数是 20
```

以上代码展示了针对浏览器的代码打包工具（如 webpack 和 Parcel）的基本工作原理。也是对 Node 程序中使用的 `require()` 函数的一个简单介绍。

### 10.2 Node 中的模块

编写 Node 程序时，可以随意将程序拆分到任意多个文件中。这些 JS 代码文件被假定始终存在于一个快速文件系统中。与通过相对较慢的网络连接读取 JS 文件的浏览器不同，把所有 Node 代码都写到一个 JS 文件中既无必要也无益处。

在 Node 中，每个文件都是一个拥有私有命名空间的独立模块。在一个文件中定义的常量、变量、函数和类对该文件而言都是私有的，除非该文件会导出它们。而被模块导出的值只有被另一个模块显式导入后才会在该模块中可见。

Node 模块使用 `require()` 函数导入其他模块，通过设置 `Exports` 对象的属性或完全替换 `module.exports` 对象来导出公共 API。

#### 10.2.1 Node 的导出

Node 定义了一个全局 exports 对象，这个对象始终有定义。如果要写一个导出多个值的 Node 模块，可以直接把这些值设置为 exports 对象的属性：

```js
const sum = (x, y) => x + y;
const square = x => x * x;

exports.mean = data => data.reduce(sum) / data.length;
exports.stddev = function (d) {
  let m = exports.mean(d);
  return Math.sqrt(
    d
      .map(x => x - m)
      .map(square)
      .educe(sum) /
      (d.length - 1)
  );
};
```

不过，更多的时候只想让模块导出一个函数或类，而非一个包含很多函数或类的对象。为此，只要把想导出的值直接赋给 `module.exports` 即可：

```js
module.exports = class BitSet extends AbstractWritableSet {
  // 省略实现
};
```

`module.exports` 的默认值与 exports 引用的是同一个对象。在前面的统计模块中，实际上也可以直接把 mean 函数赋值给 `module.exports.mean`。另一种重写这个统计模块的方式是在模块末尾导出一个对象，而不是写一个函数导出一个：

```js
// 定义所有公有函数和私有函数
const sum = (x, y) => x + y;
const square = x => x * x;
const mean = data => data.reduce(sum) / data.length;
const stddev = d => {
  let m = mean(d);
  return Math.sqrt(
    d
      .map(x => x - m)
      .map(square)
      .reduce(sum) /
      (d.length - 1)
  );
};

// 最后只导出公有函数
module.exports = { mean, stddev };
```

#### 10.2.2 Node 的导入

**Node 模块通过调用 `require()` 函数导入其他模块。这个函数的参数是要导入模块的名字，返回值是该模块导出的值（通常是一个函数、类或对象）**。

如果想导入 Node 内置的系统模块或通过包管理器安装在系统上的模块，可以使用模块的非限定名，即不带会被解析为文本系统路径的 “/” 字符的模块名：

```js
// 这些都是 Node 内置的模块
const fs = require('fs'); // 内置的文件系统模块
const https = require('http'); // 内置的 HTP 模块

// Express Http 服务器框架是第三方模块不属于 Node，但已经安装在本地
const express = require('express');
```

如果想导入自己代码中的模块，则模块名应该是指向包含模块代码的模块文件的路径（相对于当前模块文件）。虽然可以使用以 “/” 开头的绝对路径，但在导入自己程序的模块时，通常都使用以 “./” 或 “../” 开头的模块名，以表示它们相对于当前的目录或父目录。例如：

```js
const stats = require('/stats.js');
const Bitset = require('./utils/bitset.js');
```

如果模块只导出一个函数或类，则只要调用 `require()` 取得返回值即可。如果模块导出一个带多个属性的对象，则有两个选择：

- 导入整个对象
- 通过解构赋值只导入打算使用的特定属性

比较一下这两种方式：

```js
// 导入整个 stats 对象，包含所有函数
const stats = require('./stats.js');

// 虽然导入了用不到的函数，但这些函数都隐藏在 "stats" 命名空间之后
let average = stats.mean(data);

// 也可以使用常见的解构赋值直接向本地命名空间中导入想用的函数
const { stddev } = require('/stats.js');

// 这样当然简洁明了，只是 stddev() 函数没有 'stats' 前缀作为命名空间，因此少了上下文信息
let sd = stddev(data);
```

### 10.3 ES6 中的模块

ES6 为 JS 添加了 `import` 和 `export` 关键字，终于将模块作为核心语言特性来支持了。**ES6 模块化与 Node 的模块化在概念上是相同的：每个文件本身都是模块，在文件中定义的常量、变量、函数和类对这个文件而言都是私有的，除非它们被显式导出**。

另外，一个模块导出的值只有在显式导入它们的模块中才可以使用。**ES6 模块与 Node 模块的区别在于导入和导出所用的语法，以及浏览器中定义模块的方式**。

**ES6 模块与常规 JS “脚本” 的区别**：

- 最明显的区别是模块化本身：在常规脚本中，顶级声明的变量、函数和类会进入被所有脚本共享的全局上下文。而在模块中，每个文件都有自己的私有上下文，可以使用 `import` 和 `export` 语句。

- ES6 模块中的代码自动应用严格模式。这意味着在使用 ES6 模块时，永远不用再写 `use strict` 了。同时也意味着模块中的代码无法使用 `with` 语句和 `arguments` 对象或未声明的变量。ES6 模块甚至比严格模式还要更严格：在严格模式下，在作为函数调用的函数中 this 是 undefined。而在模块中，即便在顶级代码中 this 也是 undefined（相对而言，浏览器和 Node 中的脚本都将 this 设置为全局对象）。

#### 10.3.1 ES6 的导出

要从 ES6 模块导出常量、变量、函数或类，只要在声明前加上 `export` 关键字即可：

```js
export const PI = Math.PI;

export function degreesToRadians(d) {
  return (d * PI) / 180;
}

export class Circle {
  constructor(r) {
    this.r = r;
  }
  area() {
    return PI * this.r * this.r;
  }
}
```

要取代使用多个 `export` 关键字的做法，可以先正常定义常量、变量、函数和类，不加 `export` 关键字。然后（通常在模块末尾）只用一个 `export` 语句声明真正要导出的值。也就是说，前面使用三个 `export` 的代码等价于下面这一行代码：

```js
export { Circle, degreesToRadians, PI };
```

这个语法看起来是 `export` 关键字后跟一个对象字面量（使用了简化写法），但这里的花括号实际上不会定义对象字面量。这个导出语法仅仅是要求在一对花括号中给出一个逗号分隔的标识符列表。

一个模块只导出一个值（通常是一个函数或类）的情况是很常见的，此时通常可以使用 `export default` 而不是 `export`：

```js
export default class BitSet {
  // 省略实现
}
```

> **注意**：
>
> 1. 使用 `export` 的常规导出只对有名字的声明有效。而使用 `export default` 的默认导出则可以导出任意表达式，包括匿名函数表达式和匿名类表达式。这意味着如果使用 `export default`，则可以导出对象字面量。因此，与 `export` 语法不同，位于 `export default` 后面的花括号是实实在在会被导出的对象字面量。
> 2. 模块中同时有一些常规导出和一个默认导出是合法的，只是不太常见。如果模块中有默认导出，那就只能有一个。
> 3. `export` 关键字只能出现在 JS 代码的顶层。不能在类、函数、循环或条件内部导出值（这是 ES6 模块系统的重要特性，用以支持静态分析：模块导出的值在毎次运行时都相同，而导出的符号可以在模块实际运行前确定）。

#### 10.3.2 ES6 的导入

导入其他模块导出的值要使用 `import` 关键字。最简单的形式是导入定义了默认导出的模块：

```js
import BitSet from './bitset.js';
```

首先是 `import` 关键字，跟着一个标识符，再跟着一个 `from` 关键字，最后的字符串字面值是要导入其默认导出的模块的名字。指定模块默认导出的值会变成当前模块中指定标识符的值。

获得导入值的标识符是一个常量，就像是使用 `const` 关键字声明的一样。与导出类似，导入也只能出现在模块顶层，不允许在类、函数、循环或条件中出现。按照惯例，一个模块所需的导入都应该放在这个模块的开头。不过，这个规则并不是强制性的。导入与函数声明类似，会被 “提升” 到顶部，因此所有导入的值在模块代码运行时都是可用的。

**从中导入值的模块**
从中导入值的模块以常量字符串字面量的形式在单引号或双引号中给出（不能使用变量或其他值作为字符串的表达式，也不能把字符串放在反引号中，因为模板字面量有可能插入变量，并非只包含常量值）。

在浏览器中，这个字符串会被解释为一个相对于导入模块位置的 URL（在 Node 中，或当使用打包工具时，这个字符串会被解释为相对于当前模块的文件名，不过这在实践中没有太大差别）。模块标识符字符串必须是一个以 "/" 开头的绝对路径，或者是一个以 "./" 或 "../" 开头的相对路径，又或者是一个带有协议及主机名的完整 URL。

ES6 规范不允许类似 "util.js" 的非限定模块标识符字符串，因为它存在歧义：它是当前模块同级目录下的一个模块呢，还是安装在特殊位置的某个系统模块呢?（webpack 等代码打包工具不会限制这种“裸模块标识符”，因为通过配置很容易在指定的库目录中找到裸模块）。JS 语言未来的某个版本可能会允许“裸模块标识符”，但现在还不允许。如果想从当前模块的同级目录导入模块，只需要在模块名前面加上 "./"，也就是使用 "./util.js" 而非 "util.js"。

导出多个值的模块导入值的语法：

```js
import { mean, stddev } from './stats.js';
```

默认导出在定义它们的模块中不需要名字，在导入这些值的时候可以再给它们提供一个局部名。但非默认导出在导出它们的模块中则是有名字的，在导入这些值时，需要通过名字引用它们。导出模块可以导出任意多个命名的值。引用该模块的 `import` 语句可以导入这些值的任意子集，只要在花括号中列出它们的名字即可。花括号让 `import` 语句看起来像是解构赋值，而解构赋值也确实是这种导入风格一个不错的类比。花括号中的标识符都会被提升到导入模块顶部，行为类似常量。

风格指南有时会推荐显式导入模块将用到的所有符号。不过在从定义了很多导出的模块导入值时，可以像下面这样以一条 `import` 语句导入所有值：

```js
import * as stats from './stats.js';
```

像这样一条 `import` 语句可以创建一个对象，并将其赋值给一个名为 `stats` 的常量。被导入模块的每个非默认导出都会变成这个 `stats` 对象的一个属性。非默认导出始终有名字，这些名字将作为这个对象的属性名。这些属性是常量，不能被重写或删除。在使用前面这个带通配符的导入语句时，导入模块需要通过 `stats` 对象使用导入的 `mean()` 和 `stddev()` 函数，即要通过 `stats.mean()` 和 `stats.stddev()` 调用它们。

模块通常要么定义一个默认导出，要么定义多个命名导出。但一个模块同时使用 `export` 和 `export default` 也合法。可以只通过以下语句同时导入默认值和命名值：

```js
import Histogram, { mean, stddev } from './histogram-stats.js';
```

`import` 语句还有另一种形式，用于导入没有任何导出的模块。要在程序中包含没有导出的模块，只要在 `import` 关键字后面直接写出模块标识符即可：

```js
import './analytics.js';
```

这样的模块会在被首次导入时运行一次（之后再导入时则什么也不做）。如果模块中只定义了一些函数，那么它至少要导出其中一个函数才能有用。而如果模块中运行一些代码，那么即便没有符号导入也会很有用。

Web 应用可以使用分析模块（如 analytics.js）运行注册各种事件处理程序的代码，然后通过这些事件处理程序在合适的时机向服务器发送遥测数据。虽然模块是自包含的，不需要导出任何值，但仍然需要通过 `import` 导入才能让它作为程序的一部分运行。

> **注意**：对那些有导出的模块也可以使用这种什么也不导入的 `import` 语法。如果模块定义了与它的导出值无关的有用行为，而程序不需要它的任何导出值，那么可以只为它的默认行为导入这个模块。

#### 10.3.3 导入和导出时重命名

- 如果两个模块使用相同的名字导出了两个不同的值，而希望同时导入这两个值，那必须在导入时对其中一个或这两个进行重命名。类似地，如果在导入某个值时发现它的名字已经被占用了，则需要重命名这个导入值。可以在命名导入时使用 `as` 关键字对导入值进行重命名：

  ```js
  import { render as renderImage } from './imageUtils.js';
  import { render as renderUI } from './ui.js';
  ```

  这两行代码向当前模块导入了两个函数。这两个函数在定义它们的模块中都被命 `render()`，但在导入时被重命名为更好理解且没有歧义的 `renderImage()` 和 `renderUI()`。

- 默认导出没有名字。导入模块在导入默认导出时始终需要选择一个名字。因此这种情况下不需要特殊语法。尽管如此，导入时重命名的机制也为同时定义了默认导出和命名导出的模块提供了另一种导入方式：

  ```js
  import { default as histogram, mean, stddev } from './histogram-stats.js';
  ```

  在这种情况下，JS 关键字 `default` 充当一个占位符，允许指明想导入模块的默认导出并为其提供一个名字。

  导出值时也可以重命名，但仅限于使用 `export` 语句的花括号形式。通常并不需要这样做，但如果在模块内部使用了简洁短小的名字，那在导出值时可能希望使用更有描述性同时也不容易与其他模块冲突的名字。与导入时重命名类似,导出时重命名也要使用 `as` 关键字：

  ```js
  export { layout as calculateLayout, render as renderLayout };
  ```

  虽然这里的花括号看起来像对象字面量，但其实并不是。而且，`export` 关键字需要 `as` 前面是一个标识符，而非表达式。这意味着不能像下面这样在导出时重命名：

  ```js
  export { Math.sin as sin, Math.cos as cos }; // SyntaxError
  ```

#### 10.3.4 再导出

- 可能会在 "./stats/mean.js" 模块中定义 mean()，在 "./stats/stddev.js" 模块中定义 stddev()。这样，程序只需导入真正要用的函数，而不会因导入不需要的代码造成体积膨胀。

  不过，就算在单独的模块里定义了这些统计函数，仍然会有很多程序需要同时使用这两个函数。这时候如果有一个方便的 "stats.js" 模块，它们只要一行代码就可以全都导入了。

  在通过独立文件实现的情况下，定义这样一个 "stats.js" 模块也很简单：

  ```js
  import { mean } from './stats/mean.js';
  import { stddev } from './stats/stddev.js';
  export { mean, stddev };
  ```

  ES6 模块预见到了这个使用场景，并为此提供了一种特殊语法。这种语法不需要先导入再导出，而是把导入和导出合二为一，通过组合 `export` 和 `from` 关键字构造一条 “再导出” 语句：

  ```js
  export { mean } from './stats/mean.js';
  export { stddev } from './stats/stddev.js';
  ```

  这里的代码并未使用名字 mean 和 stddev。如果不需要选择性地再导出，而是希望导出另一个模块的所有命名值，则可以使用通配符：

  ```js
  export * from './stats/mean.js';
  export * from './stats/stddev.js';
  ```

- 再导出语法允许使用 `as` 进行重命名，就像在常规 `import` 和 `export` 语句中一样。假设想再导出 mean() 函数，但又想用 average() 作为这个函数的另一个名字，那可以这样做：

  ```js
  export { mean, mean as average } from './stats/mean.js';
  export { stddev } from './stats/stddev.js';
  ```

  这个示例中的所有再导出语句都假定 "./stats/mean.js" 和 "./stats/stddev.js" 模块使用 `export` 而非 `export default` 导出它们的函数。不过，因为这两个模块都只有一个导出，所以实际上使用 `export default` 来定义更合理。假设已经这样做了，那么再导出语法会稍微复杂一点，因为需要为没有命名的默认导出定义名字。可以这样做：

  ```js
  export { default as mean } from './stats/mean.js';
  export { default as stddev } from '.stats/stddev.js';
  ```

- 如果想将另一个模块的命名符号再导出为当前模块的默认导出，可以在 `import` 语句后面加一个 `export default;` 或者，可以像下面这样组合这两个语句：

  ```js
  // 从 ./stats.js 中导入 mean() 函数并将其作为当前模块的默认导出
  export { mean as default } from './stats.js';
  ```

- 要把另一个模块的默认导出再导出为当前模块的默认导出（虽然这样做没有什么意义，因为可以直接导出另一个模块），可以这样写：

  ```js
  // 这个 average.js 模块只是再导出了 ./stats/mean.js 的默认导出
  export { default } from '/stats/mean.js';
  ```

#### 10.3.5 在网页中使用 JS 模块

2020 年初，使用 ES6 的产品代码仍然要通过 webpack 等工具来打包。这样做有一定的代价，但总体上来看，代码打包后的性能是比较好的。随着网络速度的提升和浏览器厂商不断优化自己的 ES6 模块实现，这种状况迟早会改变。

**`<script type="module">`**
模块代码默认在严格模式下运行，this 不引用全局对象，顶级声明默认不会全局共享。因为模块代码必须与传统非模块代码以不同方式运行，所以必须修改 HTML 和 JS 才能使用模块。如果想在浏览器中以原生方式使用 `import` 指令，必须通过 `<script type="module">` 标签告诉浏览器代码是一个模块。

ES6 模块的一个非常棒的特性是每个模块的导入都是静态的。因此只要有一个起始模块，浏览器就可以加载它导入的所有模块，然后加载第一批模块导入的所有模块，以此类推，直到加载完所有程序代码。前面已经看到，`import` 语句中的模块标识符可以被看成相对 URL。而 `<script type="module">` 标签用于标记一个模块化程序的起点。

这个起点模块导入的任何模块预期都不会出现在 `<script>` 标签中。这些依赖模块会像常规 JS 文件一样按需加载，而且会像常规 ES6 模块一样在严格模式下执行。使用 `<script type="module">` 标签定义模块化 JS 程序的主入口可以像下面这样简单：

```html
<script type="module">
  import './main.js';
</script>
```

位于行内 `<script type="module">` 标签中的代码是一个 ES6 模块，因此可以使用 `export` 语句。不过，这样做没有任何意义，因为 HTML 的 `<script>` 标签语法没有提供为行内模块定义名字的方法。因此，即便这个模块导出了值，其他模块也没有办法导入。

带有 `type="module"` 属性的脚本会像带有 `defer` 属性的脚本一样被加载和执行。HTML 解析器一碰到 `<script>` 标签，就会开始加载代码（对于模块而言，加载代码可能是个递归加载多个 JS 文件的过程）。不过，代码执行则会推迟到 HTML 解析完成才开始。HTML 解析一完成，脚本（包括模块和非模块）就会按照它们在 HTML 文档中出现的顺序执行。

添加 `async` 属性可以改变执行模块代码的时机。这个属性会像对常规脚本一样对模块起作用。添加了 `async` 属性的模块会在代码加载完毕后立即执行，而不管 HTML 解析是否完成，同时也有可能改变脚本执行的相对顺序。

支持 `<script type="module">` 的浏览器必须也支持 `<script nomodule>`。支持模块的浏览器会忽略带有 `nomodule` 属性的脚本，不执行它们。不支持模块的浏览器因为不认识 `nomodule` 属性，所以会忽略这个属性的存在而运行其脚本。这样就为兼容旧版本浏览器提供了一个强大的技术。支持 ES6 模块的浏览器也支持类、箭头函数和 for/of 循环等其他现代 JS 特性。可以使用 Babel 和 webpack 等工具把代码转换为非模块化的 ES6
代码，然后通过 `<script nomodule>` 来加载这些效率没那么高的转换代码。

**跨源加载**
常规脚本与模块脚本的另一个重要区别涉及跨源加载。常规 `<script>` 标签可以从互联网上的任何服务器加载 JS 代码文件，而互联网广告、分析和追踪代码都依赖这个事实。但 `<script type="module">` 增加了跨源加载的限制，即只能从包含模块的 HTML 文档所在的域加载模块，除非服务器添加了适当的 CORS 头部允许跨源加载。这个新的安全限制带来了一个副作用，就是不能在开发模式下使用 `file:URL` 来测试 ES6 模块。为此在使用 ES6 模块时，需要启动一个静态 Web 服务器来测试。

有些程序员喜欢使用扩展名 `.mjs` 来区分模块化 JS 文件和使用 `.js` 扩展名的常规、非模块化 JS 文件。对浏览器和 `<script>` 标签而言，文件扩展名其实无关紧要（不过，MME 类型很重要，因此如果使用 `.mjs` 文件，就需要配置 Web 服务器以跟 `.js` 文件相同的 MME 类型来发送它们）。Node 对 ES6 模块的支持则依赖文件扩展名，即要靠扩展名来区分要加载的文件使用了哪种模块系统。换句话说，如果希望自己写的 ES6 模块可以在 Node 中使用，就要考虑使用 `.mjs` 命名约定。

#### 10.3.6 通过 import() 动态导入

ES6 的 `import` 和 `export` 指令都是静态的，因此 JS 解释器和其他 JS 工具可以通过简单的文本分析确定加载之后模块之间的关系，而不必实际执行模块代码。静态导入的模块可以保证导入的值在任何模块代码运行之前就可以使用。

Web 应用中的代码必须通过网络传输，而不是从文件系统读取的。传输完成后，代码可能会在 CPU 相对较慢的移动设备上执行。这不是静态模块导入的适用场景，因为静态模块导入需要先加载完全部程序再执行。

对于 Web 应用来说，先加载足够的代码用于渲染用户可见的第一个页面是很常见的。这样，当用户有了可以交互的预备内容后，可以再开始加载 Web 应用所需的其他（通常更庞大的）代码。使用浏览器提供的 DOM API 向当前 HML 文档注入新 `<script>` 标签可以方便地动态加载代码，Web 应用在很多年前就已经开始这么做了。

虽然浏览器很早就可以动态加载脚本了，但 JS 语言本身却一直不支持动态导入。随着 ES2020 引入 `import()`，这个局面终于被扭转了（2020 年年初，所有支持 ES6 模块的浏览器都支持动态导入）。传给 `import()` 一个模块标识符，它就会返回一个期约对象，表示加载和运行指定模块的异步过程。动态导入完成后，这个[期约](#十三-异步-js)会 “兑现” 并产生一个对象，与使用静态导入语句 `import * as` 得到的对象类似。

也就是说，如果是静态导入 "./stats.js" 模块，要这样写：

```js
`import as stats from "./stats.js"`;
```

如果要动态导入并使用这个模块，那就要这样写：

```js
import('./stats.js').then(stats => {
  let average = stats.mean(data);
});
```

或者，在一个 `async` 函数中，可以通过 `await` 简化代码：

```js
async function analyzeData(data) {
  let stats = await import('./stats.js');

  return {
    average: stats.mean(data),
    stddev: stats.stddev(data)
  };
}
```

> **注意**：传给 `import()` 的参数应该是一个模块标识符，与使用静态 `import` 指令时完全一样。但对于 `import()`，则没有使用常量字符串字面量的限制。换句话说，任何表达式只要可以求值为一个字符串且格式正确，就没问题。

动态 `import()` 虽然看起来像函数调用，但其实并不是。事实上，**`import()` 是一个操作符，而圆括号则是这个操作符语法必需的部分**。之所以使用如此特别的语法，是因为 `import()` 需要将模块标识符作为相对于当前运行模块的 URL 来解析，而这在实现上需要一些特殊处理，这些特殊处理在 JS 函数中是不合法的。实践中，这个函数与操作符的区别极少显现，只有在编写类似 `console.log(import);` 或 `let require = import;` 这样的代码时才会被注意到。

> 动态 `import()` 不仅在浏览器中有，webpack 等打包工具也在积极地利用它。使用打包工具最简单的方式是告诉它程序的主入口，让它找到所有静态 `import` 指令并把所有代码汇总为一个大文件。而通过有意识地使用动态 `import()` 调用，可以把这样一个大文件拆分成多个小文件，**实现按需加载**。

#### 10.3.7 import.meta.url

在 ES6 模块（而非常规 `<script>` 或通过 `require()` 加载的 Node 模块）中，`import.meta` 这个特殊语法引用一个对象，这个对象包含当前执行模块的元数据。其中，这个对象的 `url` 属性是加载模块时使用的 URL（在 Node 中是 fie://URL）。

**`import.meta.url` 的主要使用场景是引用与模块位于同一（或相对）目录下的图片、数据文件或其他资源**。使用 `URL()` 构造函数可以非常方便地相对于 `import.meta.url` 这样的绝对 URL 来解析相对 URL。

例如，要写一个模块，其中包含需要本地化的字符串，而相关的本地化文件保存在 `l10n/` 目录下，这个目录也保存着模块本身。模块也可以使用通过下面的函数常见的 URL 来加载其他字符串：

```js
function localStringsURL(locale) {
  return new URL(`l10n/${locale}.json`, import.meta.url);
}
```

## 十一. JS 标准库

某些数据类型，比如数值和字符串、对象和数组对 JS 而言非常之基础，因此可以将其看作这门语言的一部分。本章介绍另外一些重要但却没那么基础的 API，可以把它们看作 JS 的 “标准库”，包括 JS 内置的、在浏览器和 Node 中对所有 JS 程序都可用的类和函数。内容包括：

- 表示值的集合的 `Set` 和一组值到另一组值映射的 `Map`;

- 用于表示二进制数据的数组、被称为定型数组(Typed Array)的类数组对象，以及从非数组二进制数据中提取值的相关类;

- 正则表达式和 `RegExp` 类，这个类定义用于处理文本的文本模式

- 表示和操作日期与时间的 `Date` 类;

- `Error` 类及其子类，JS 程序在出错时会抛出这些类的实例;

- `JSON` 对象，其方法支持 JS 对象、数组、字符串、数值和布尔值等复合数据结构的序列化和反序列化;

- `Intl` 对象以及它定义的类，可用于 JS 程序本地化;

- `Console` 对象，其方法以各种方式输出字符串，对调试程序和记录程序行为特别有用

- `URL` 类，用于简化解析和操作 URL 的任务，也用于编码和解码 URL 及其组件的全局函数;

- `setTimeout()` 和用于指定在一段时间后再执行代码的相关函数。

### 11.1 集合与映射

JS 的 `Object` 类型是一种万能数据结构，可用于把字符串（对象的属性名）映射为任意值。当被映射的值是固定值（如 true）时，对象实际上是一组字符串。

对象在 JS 编程中经常被用作映射和集合，但却要受到对字符串约束的限制。另外，由于对象正常都会继承带名字（如 toString）的属性，而这些属性明显也不是为映射和集合而准备的。为此，ES6 新增了真正的 `Set` 和 `Map` 类。

#### 11.1.1 Set 类

集合就是一组值，与数组类似。但与数组不同的是，集合没有索引或顺序，也不允许重复：**一个值要么是集合的成员，要么不是；这个值不可能在一个集合中出现多次**。

可以使用 `Set()` 构造函数创建集合对象：

```js
let s = new Set(); // 一个新的、空集合
let t = new set([1, s]); // 一个有两个成员的新集合
```

`Set()` 构造函数的参数不一定是数组，但**必须是一个可迭代对象**（包括其他集合）：

```js
let t = new Set(s); // 一个复制了 s 元素的新集合
let unique = new Set('Mississippi'); //4 个元素："M" "i" "s" 和 "p"
```

集合的 `size` 属性类似数组的 `length` 属性，保存着集合包含多少个值：

```js
unique.size; // 4
```

集合不一定在创建时初始化，可以在创建之后再通过 `add()`、`delete()` 和 `clear()` 方法给它添加元素或从中删除元素。集合不能包含重复的值，因此添加集合中已经存在的值没有效果：

```js
let s = new Set(); // 创建空集合
s.size; // 0
s.add(1); // 添加一个数值
s.size; // 1。现在集合有了一个成员
s.add(1); // 再次添加相同的数值
s.size; // 1。大小并没有变
s.add(true); // 添加另一个值;注意，混合值的类型没间题
s.size; // 2
s.add([1,2,3]); // 添加一个数组值
s.size // 3。添加的是数组，而非数组的元素
s.delete(1) // true，成功删除元素1
s.size // 2：大小回到2
s.delete("test") // false："test"不是成员，删除失败
s.delete(true) // true：删除成功
s delete([1,2,3]) // false：集合中包含的是另一个数组
s.size // 1：集合中还有一个数组
s.clear() // 清空集合
s.size // 0
```

关于这段代码有几个地方需要着重说明一下：

- `add()` 方法接收一个参数，如果传入一个数组，它会把数组而不是数组的元素添加到集合中。`add()` 始终返回调用它的集合，因此如果想给集合添加多个值，可以连缀调用 `add()`，如 `s.add('a').add('b').add('c')`;

- `delete()` 方法一次也只删除一个集合元素。不过，与 `add()` 不同，`delete()` 返回一个布尔值。如果指定的值确实是一个集合成员，那么 `delete()` 删除它并返回 true；否则，`delete()` 什么也不做并返回 false。

- 集合成员是根据严格相等来判断是否重复的，类似于使用 `===` 操作符。给集合添加的是一个数组，而传给 `delete()` 方法的则是另一个不同的数组（尽管两个数组包含相同的元素）。如果真想删除第一个数组，必须传入该数组的引用。

实践中，使用集合时最重要的不是添加和删除元素，而是检查某个值是不是集合的成员。为此要使用 `has()` 方法：

```js
let oneDigitPrimes = new Set([2, 3, 5, 7]);
oneDigitPrimes.has(2); // true：2 是一位数字的素数
oneDigitPrimeshas.has(3); // true：3 也是
oneDigitPrimes.has(4); // false，4 不是素数
oneDigitPrimes.has('5'); // false："5" 不是数值
```

**集合专门为成员测试做了优化，无论集合有多少成员，`has()` 方法都非常快**。数组的 `includes()` 方法也执行成员测试，但其执行速度与数组大小成反比。因此，使用数组作为集合比使用真正的 `Set` 对象要慢得多。

`Set` 类是可迭代的，这意味着可以使用 `for/of` 循环枚举集合的所有元素:

```js
let sum = 0;
// 循环遍历一位数字的素数
for (let p of oneDigitPrimes) {
  sum += p; // 求它们的和
}
sum; // 17：2 + 3 + 5 + 7
```

因为 Set 对象是可迭代的，所以可以使用扩展操作符 `...` 把集合转换为数组或参数：

```js
[...oneDigitPrimes]; // [2, 3, 5, 7]：把集合转换为数组
Math.max(...oneDigitPrimes); // 7：把集合元素作为参数传给函数
```

集合经常被称为 “无序集合”，但对 JS 的 Set 类而言，这并不正确。JS 集合是无索引的：不能像对数组那样取得集合的第一个或第三个元素。但 JS 的 Set 类会记住元素的插入顺序，而且始终按该顺序迭代集合：第一个元素第一个迭代（假定之前没有删除它），刚刚添加的元素最后一个迭代。

除了可以迭代，Set 类也实现了一个 `forEach()` 方法，与数组的同名方法类似：

```js
let product = 1;
oneDigitPrimes.forEach(n => {
  product * n;
});
product; // 210：2 * 3 * 5 * 7
```

> 数组的 `forEach()` 方法把数组索引作为回调函数的第二个参数。但集合没有索引，所以这个方法的 Set 类版本传给回调的第一个和第二个参数都是元素的值。

#### 11.1.2 Map 类

**Map 对象表示一组被称为键的值，其中每个键都关联着（或映射到）另一个值**。从某种角度看，映射类似数组，只不过它并不局限于用连续的整数作为键，而是允许使用任何值作为 “索引”。同样与数组类似，映射速度也很快：无论映射有多大，查询与某个键关联的值都很快（虽然没有通过索引访问数组那么快）。

可以使用 `Map()` 构造函数创建映射对象：

```js
let m = new Map(); // 创建一个新的、空映射

// 初始化新映射，包含字符串到数值的映射
let n = new Map([
  ['one', 1],
  ['two', 2]
]);
```

Map() 构造函数的可选参数应该是一个可迭代对象，产出值为包含两个元素的数组 `[key， value]`。实践中，这意味着如果想在创建映射时初始化它，通常需要把关联的键和值写成数组的数组的形式。不过，也可以使用 Map() 构造函数复制其他映射，或者从已有对象复制属性名和值：

```js
let copy = new Map(n); // 一个新映射，与映射 n 拥有相同的键和值
let o = { x: 1, y: 2 }; // 一个有两个属性的对象
let p = new Map(Object.entries(o)); // 相当于 new Map(["x", 1], ["y", 2])
```

创建 Map 对象后，可以使用 `get()` 方法和键来查询关联的值，使用 `set()` 方法添加新的键/值对。不过，映射是一组键，每个键关联一个值。这跟一组键/值对不完全一样。如果调用 `set()` 传入一个映射中已经存在的键，将会修改与该键关联的值，而不是添加新的键/值映射。除了 `get()` 和 `set()`，Map 类也定义了与 Set 类似的方法，包括检查映射中是否包含指定键的 `has()`、从映射中删除指定键（及其关联值）的 `remove()`、删除映射中所有键/值对的 `clear()` 和保存映射中有多少个键的 `size` 属性。

```js
let m = new Map(); // 开始先创建一个空映射
m.size; // 0：空映射，还没有键
m.set('one', 1); // 映射键 "one" 和值 1
m.set('two', 2); // 添加键 "two" 和值 2
m.size; // 2：现在映射有两个键
m.get('two'); // 2：返回与键 "two" 关联的值
m.get('three'); // undefined：这个键不存在
n.set('one', true); // 修改与已有的键关联的值
m.size; // 2：大小没有变
m.has('one'); // true：映射有键 "one"
m.has(true); // false:映射没有键 true
m.delete('one'); // true：键 "one" 存在且删除成功
m.size; // 1
m.delete('three'); // false：删除不存在的键失败
m.clear(); // 删除映射中所有的键和值
```

与集合的 `add()` 方法类似，映射的 `set()` 方法可以连缀调用：

```js
let m = new Map().set('one', 1).set('two', 2).set('three', 3);
m.size; // 3
m.get('two'); // 2
```

与集合一样，任何 JS 值都可以在映射中作为键或值。这包括 null、undefined 和 NaN，以及对象和数组等引用类型。同样与集合类一样，映射按照全等性而非相等性比较键。因此如果在映射中使用对象或数组作为键，那么这样的键与任何其他对象或数组都不一样，即便它们有完全一样的属性或元素：

```js
// 开始先创建一个空映射
let m = new Map();
m.set({}, 1); // 映射空对象到值
m.set({}, 2); // 映射另一个空对象到值
m.size; // 这个映射中有两个键
m.get({}); // undefined：但这个空对象不是映射的键
m.set(m, undefined); // 把映射自身映射到值 undefined
m.has(m); // true：m 是自己的一个键
m.get(m); // undefined：与 m 不是键时取得的值一样
```

映射对象是可迭代的，迭代的每个值是一个两个元素的数组，其中第一个元素是键，第二个元素是与该键关联的值。如果对映射对象使用扩展操作符，会得到一个数组的数组，就像传给 Map() 构造函数的一样。在使用 `for/of` 循环迭代映射时，习惯上通过解构赋值把键和值赋给不同的变量:

```js
let m = new Map([
  ['x', 1],
  ['y', 2]
]);
[...m]; // [['x', 1], ['y', 2]]
for (let [key, value] of m) {
  // 第一次迭代，键是 "x" 值是 1
  // 第二次迭代，键是 "y" 值是 2
}
```

与 Set 类一样，Map 类也是按照插入顺序迭代的，即迭代的第一个键/值对是最早添加到映射中的，最后一个键/值对是最晚添加的。

如果只想迭代映射的键或关联的值，可以使用 `keys()` 和 `values()` 方法。这两个方法返回的可迭代对象可用于按照插入顺序迭代键和值（另外，`entries()` 方法返回的可迭代对象用于迭代键/值对，与直接迭代映射一样）。

```js
[...m.keys()] // ['x', 'y']：只有键
[...m.values()] // [1, 2]：只有值
[...m.entries()] // [["x", 1], ["y", 2]：等价于 [...m]
```

映射也实现了 `forEach()` 方法，通过这个最早由 Array 类实现的方法也可以迭代映射：

```js
// 注意：是 (value, key) 而不是 (key, value)
m.forEach((value, key) => {
  // 第一次迭代，值是 1 键是 "x"
  // 第二次迭代，值是 2 键是 "y"
});
```

这里传给回调的参数值在前、键在后，而 for/of 循环则是键在前、值在后。可以把映射想象成一种通用数组，只不过整数索引被替换为任何键值。数组的 `forEach()` 方法是先传数组元素，后传数组索引。同样地，映射的 `forEach()` 方法也先传映射的值，后传映射的键。

#### 11.1.3 WeakMap 和 WeakSet

**WeakMap**
**WeakMap（弱映射）类是 Map 类的一个变体（不是子类），它不会阻止键值被当作垃圾收集**。垃圾收集是 JS 解释器收回内存空间的过程，凡是已经 “无法访问” 因而无法被程序使用的对象，都会被当作垃圾收回。常规映射对自己的键值保持着 “强” 引用，即使对它们的所有其他引用都不存在了，仍然可以通过映射访问这些键。相对而言，WeakMap 保持着对它们键值的 “弱” 引用，因此无法通过 WeakMap 访问这些键。也就是说，WeakMap 的存在并不妨碍它们的键值被回收。

WeakMap() 构造函数与 Map() 构造函数类似，但 WeakMap 与映射则有明确区别：

- WeakMap 的键必须是对象或数组，原始值不受垃圾收集控制，不能作为键。

- WeakMap 只实现了 `get()`、`set()`、`has()` 和 `delete()` 方法。特别地，WeakMap 不是可迭代对象，所以没有定义 `keys()`、`values()` 和 `forEach()` 方法。如果 WeakMap 是可迭代的，那么它的键就是可访问的，也就谈不上 “弱” 了。

- 类似地，WeakMap 没有实现 `size` 属性，因为弱映射的大小可能随着对象被当作垃圾收集而随时改变。

**WeakMap 的主要用途是实现值与对象的关联而不导致内存泄漏**。例如，假设要写一个接收对象参数的函数，然后需要基于这个对象执行某些耗时操作。考虑到效率，会缓存计算后的值以备将来使用。如果使用 Map 对象实现这个缓存，就会阻止其中的对象被当作垃圾回收。而使用 WeakMap 则可以避免这个问题（使用一个[私有的 Symbol 属性](#6103-符号作为属性名)直接在对象上缓存计算后的值通常也可以实现类似的效果）。

**WeakSet**
**WeakSet（弱集合）实现了一组对象，不会妨碍这些对象被作为垃圾收集**。WeakSet() 构造函数与 Set() 构造函数类似，但正如弱映射与映射一样，弱集合与集合也有着类似的区别。

- WeakSet 不允许原始值作为成员。
- WeakSet 只实现了 `add()`、`has()` 和 `delete()` 方法，而且不可迭代。
- WeakSet 没有 `size` 属性。

WeakSet 的使用场景不多，其主要应用场景与 WeakMap 类似。例如，如果想把一个对象标记（或标注）为具有特殊属性或类型，可以把它添加到一个 WeakSet 中。然后，无论在哪里，只要想检查该属性或类型，就可以测试该 WeakSet 是否包含相应成员。如果使用常规集合来保存这些被标记的对象，就会妨碍它们被当作垃圾收集，而使用 WeakSet 则没有这个问题。

### 11.2 定型数组与二进制数据

常规 JS 数组可以包含任意类型的元素，可以动态扩展或收缩。JS 实现进行了很多优化，因此 JS 数组在典型的使用场景下速度非常快。然而，这种数组与 C 和 Java 等较低级语言的数组类型还是有很大区别。

ES6 新增了定型数组（typed array），与这些语言的低级数组非常接近。定型数组严格来讲并不是数组（Array.isArray() 对它们返回 false），但它们实现了几乎所有数组方法，外加几个自己的方法。定型数组与常规数组存在如下几个非常重要的区别：

- 定型数组的元素全部都是数值。与常规 JS 数组不同，定型数组允许指定存储在数组中的数值的类型（有符号和无符号数组以及 IEEE-754 浮点数）和大小（8 位到 64 位）。

- 创建定型数组时必须指定长度，且该长度不能再改变。

- 定型数组的元素在创建时始终都会被初始化为 0。

#### 11.2.1 定型数组的类型

JS 并未定义 TypedArray 类，而是定义了 11 种定型数组，每种都有自己类型和构造函数：

| 构造函数            | 数值类型                         |
| ------------------- | -------------------------------- |
| Int8Array()         | 有符号字节                       |
| Uint8Array()        | 无符号字节                       |
| Uint8ClampedArray() | 无符号字节（上溢不归零）         |
| Int16Array()        | 有符号 16 位短整数               |
| Uint16Array()       | 无符号 16 位短整数               |
| Int32Array()        | 有符号 32 位整数                 |
| Uint32Array()       | 无符号 32 位整数                 |
| BigInt64Array()     | 有符号 64 位 Bigint 值（ES2020） |
| BigUint64Array()    | 无符号 64 位 Bigint 值（ES2020） |
| Float32Array()      | 32 位浮点值                      |
| Float64Array()      | 64 位浮点值：常规 JS 数值        |

名字以 Int 开头的类型保存有符号 1、2、4 字节（8、16、32 位）整数。名字以 Uint 开头的类型保存相同长度的无符号整数。Bigint 和 BigUnit 类型保存 64 位整数，以 JS 的 BigInt 值表示。名宇以 Float 开头的类型保存浮点数。Float64Array 的元素与常规 JS 数值是同一种类型。Float32Array 的元素精度较低、表示的范围也较小，但只占用一半内存（这个类型对应 C 和 Java 中的 float）。

Uint8ClampedArray 是 Uint8Array 的一种特殊变体。这两种类型都保存无符号字节，可表示的数值范围是 0 到 255。对 Unit8Array 来说，如果要存储到数组元素的值大于 255 或小于 0，这个值会“翻转”为其他值。这涉及计算机内存的底层工作机制，速度非常快。Unit8ClampedArray 还会额外做一些类型检查，如果要存储的值大于 255 或小于 0，那它会 “固定” 为 255 或 0，而不会翻转（这种固定行为对 HTML `<canvas>` 元素的低级 API 操作像素颜色是必需的）。

> 上面每种定型数组构造函数都有一个 `BYTES_PER_ELEMENT` 属性，根据类型不同，这个属性的值可能是 1、2、4、8。

#### 11.2.2 创建定型数组

- 创建定型数组最简单的方式就是调用相应的构造函数，并传入一个表示数组元素个数的数值参数：

  ```js
  let bytes = new Unit8Array(1024); // 1024 字节
  let matrix = new Float64Array(9); // 3 x 3 矩阵
  let point = new Int16Array(3); // 3D 空间中的一个点
  let rgba = new Uint8ClampedArray(4); // 4 字节的 RGBA 像素值
  let sudoku = new Int8Array(81); // 9 x 9 的数独网格
  ```

  如果以这种方式创建定型数组，则数组元素一定会全部初始化为 0、0n 或 0.0。不过假如知道想要通过定型数组保存的值，也可以在创建它们时指定这些值。每种定型数组构造函数都有静态的工厂方法 `from()` 和 `of()`，类似于 `Array.from()` 和 `Array.of()`：

  ```js
  let white = Uint8ClampedArray.of(255, 255, 255, 0); // RGBA 不透明白色
  ```

- `Array.from()` 工厂方法期待一个类数组或可迭代对象作为其第一个参数。定型数组的这个方法也一样，但期待这个可迭代或类数组对象还必须拥有数值类型的元素。比如，字符串是可迭代的，但把字符串传给 `from()` 工厂方法显然不妥。

  如果只使用带一个参数的 `from()`，可以把 `.from` 去掉而直接把可迭代或类数组对象传给构造函数，结果完全相同。

  > **注意**：构造函数和 `from()` 工厂方法都支持复制已有的定型数组，尽管类型可能会改变：

  ```js
  let ints = Uint32Array.from(white); // 同样 4 个数值，但变成了整数
  ```

  在通过已有数组、可迭代或类数组对象创建新定型数组时，为适应类型限制，已有的值可能被截短。在此过程中，不会有警告，也不会报错：

  ```js
  // 浮点数被截短为整数，长整数被截短为 8 位
  Uint8Array.of(1.23, 2.99, 45000); // new Uint8Array([1, 2, 200])
  ```

- 还有一种创建定型数组的方式，该方式要用到 `ArrayBuffer` 类型。`ArrayBuffer` 是对一块内存的不透明引用。可以通过构造函数创建 ArrayBuffer，只要传入想分配内存的字节数即可：

  ```js
  let buffer = new ArrayBuffer(1024 * 1024);
  buffer.byteLength; // 1024*1024，1兆内存
  ```

  ArrayBuffer 类不允许读取或写入分配的任何字节。但是可以创建使用该缓冲区内存的定型数组，通过这个数组来读取或写入该内存。为此，在调用定型数组的构造函数时需要将 ArrayBuffer 作为第一个参数，将该缓冲区内的字节偏移量作为第二个参数，将数组的长度（单位是元素而非字节）作为第三个参数。第二个参数和第三个参数是可选的。如果省略第二个和第三个参数，则数组会使用缓冲区的所有内存。如果只省略长度参数，则数组会使用从起点位置到缓冲区结束的所有可用内存。关于这种形式的定型数组构造函数，还要记住一点：数组的内存必须是对齐的，所以如果指定了字节偏移量，那么这个值应该是类型大小的倍数。例如，Int32Array() 构造函数要求必须是 4 的倍数，而 Float64Array() 则要求必须是 8 的倍数。

  以前面创建的 ArrayBuffer 为例，可以像下面这样创建定型数组：

  ```js
  let asbytes = new Uint8Array(buffer); // 按字节查看
  let asints = new Int32Array(buffer); // 按 32 位有符号整数查看
  let lastK = new Uint8Array(buffer, 1023 * 1024); // 按字节查看最后 1 千字节
  let ints2 = new Int32Array(buffer, 1024, 256); // 按 256 位整数查看第二个 1 千字节
  ```

  这 4 个定型数组提供了对 ArrayBuffer 所表示内存的 4 个不同视图。关键是要知道，所有定型数组底层都有 ArrayBuffer，即便没有明确指定。如果调用定型数组构造函数时没有传缓冲区对象，则会自动以适当大小创建一个缓冲区。所有定型数组都有一个 `buffer` 属性，引用自己底层的 ArrayBuffer 对象。之所以需要直接使用 ArrayBuffer 对象，是因为有时候可能需要一个缓冲区的多个定型数组视图。

#### 11.2.3 使用定型数组

创建定型数组后，可以通过常规的中括号语法读取或写入其元素，与操作其他类数组对象一样：

```js
// 返回小于 n 的最大素数，使用埃拉托斯特尼筛法
function sieve(n) {
  let a = new Uint8Array(n + 1); // 如果 x 是合数，a[x] 等于 1
  let max = Math.floor(Math.sqrt(n)); // 不分解大于这个数的数
  let p = 2; // 2 是第一个素数
  // 对小于 max 的素数
  while (p <= max) {
    // 将 p 的倍数标记为合数
    for (let i = 2 * p; i <= n; i += p) a[i] = 1;
    while (a[++p]); /*空循环*/ // 下一个未标记的索引是素数
  }
  while (a[n]) n--; // 向后循环查找最后一个素数
  return n; // 返回它
}
```

这个函数用于计算小于指定数值的最大素数。代码中如果使用常规 JS 数组也没问题，但使用 Uint8Array() 而非 Array() 可以让代码快 4 倍以上，且占用内存少 8 倍。

定型数组并不是真正的数组，但它们重新实现了多数数组方法，因此几乎可以像使用常规数组一样使用它们：

```js
let ints = new Int16Array(10); // 10个短整数
ints
  .fill(3)
  .map(x => x * x)
  .join(''); // 9999999999
```

记住，定型数组的长度是固定的，因此 length 属性是只读的，而定型数组并未实现改变数组长度的方法（如 push()、pop()、unshift()、shift() 和 splice()），但实现了修改数组内容而不改变长度的方法（如 sort()、 reverse() 和 fill()）。诸如 map() 和 slice() 等返回新数组的方法，则返回与调用它们的定型数组相同类型的数组。

#### 11.2.4 定型数组的方法与属性

除了标准的数组方法，定型数组也实现了它们自己的一些方法。其中，`set()` 方法用于一次性设置定型数组的多个元素，即把其他常规数组或定型数组的元素复制到当前定型数组中：

```js
let bytes = new Uint8Array(1024); // 1K 缓冲区
let pattern = new Uint8Array([0, 1, 2, 3]); // 4 字节的数组
bytes.set(pattern); // 把它们复制到另一个字节数组的开头
bytes.set(pattern, 4); // 使用不同的偏移量再复制一次
bytes.set([0, 1, 2, 3], 8); // 或者直接从一个常规数组复制值
bytes.slice(0, 12); // new Uint8Array([0,1,2,3,0,1,2,3,0,1,2,3])
```

`set()` 方法以一个数组或定型数组作为其第一个参数，以一个元素偏移量作为其可选的第二个参数，如果不指定则默认为 0。如果是从一个定型数组向另一个定型数组复制值，那么操作可能极快。

定型数组也有一个 subarray 方法，返回调用它的定型数组的一部分：

```js
let ints = new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // 10 个短整数
let last3 = ints.subarray(ints.length - 3, ints.length); // 其中最后 3 个
last3[0]; // 7：与 ints[7] 相同
```

subarray() 接收与 slice() 方法相同的参数，而且看起来行为方式也相同。但有一点重要区别：slice() 以新的、独立的定型数组返回指定的元素，不与原始数组共享内存；而 subarray() 则不复制内存，只返回相同底层值的一个新视图：

```js
ints[9] = -1; // 修改原始数组中的一个值
last3[2]; // -1：子数组中也会反映这个变化
```

说到 subarray() 方法返回已有数组的新视图，就要再次提到 ArrayBuffer 每个定型数组都有 3 个属性与底层的缓冲区相关：

```js
last3.buffer; // 定型数组的 ArrayBuffer 对象
last3.buffer === ints.buffer; // true：都是同一个缓冲区的视图
last3.byteOffset; // 14：这个视图从缓冲区的字节 14 开始
last3.byteLength; // 6：这个视图长度为 6 字节（3 个 16 位整数长）
last3.buffer.byteLength; // 20：但底层缓冲区长度为 20 字节
```

`buffer` 属性是数组的 ArrayBuffer，`byteOffset` 是数组数据在这个底层缓冲区的起点位置，而 `byteLength` 是数组数据的字节长度。对于任何定型数组 a，以下不变式都成立：

```js
a.length * a.BYTES_PER_ELEMENT === a.byteLength; //  true
```

ArrayBuffer 只是不透明的字节块。通过定型数组可以访问其中的字节，但 ArrayBuffer 本身并不是定型数组。

> **注意**：可以像对任何 JS 对象一样对 ArrayBuffer 使用数值索引。但这样做并不会访问缓冲区中的字节，只会导致难解的 bug。

```js
let bytes = new Uint8Array(8);
bytes[0] = 1; // 将第 1 个字节设置为 1
bytes.buffer[0]; // undefined：缓冲区没有索引 θ
bytes.buffer[1] = 255; // 尝试错误地设置缓冲区的字节
bytes.buffer[1]; // 255：实际上这只是设置了一个常规 JS 属性
bytes[1]; // 0：上面那一行并未设置字节
```

可以通过 ArrayBuffer() 构造函数创建 ArrayBuffer，然后再使用这个缓冲区来创建定型数组。另一种方式是先创建一个初始化的定型数组，然后使用该数组的缓冲区创建其他视图：

```js
let bytes = new Uint8Array(1024); // 1024 字节
let ints = new Uint32Array(bytes.buffer); // 或者 256 个整数
let floats = new Float64Array(bytes.buffer); // 或者 128 个双精度浮点数
```

#### 11.2.5 Date View 与字节序

使用定型数组可以查看相同字节序列的 8、16、32 或 64 位视图。这就涉及 “字节序” 问题了。所谓**字节序，就是多个字节排列为更长机器字的顺序**。为效率考虑，定型数组使用底层硬件的原生字节序。在小端系统中，ArrayBuffer 中的字节排列顺序为低字节到高字节。在大端系统中，字节排列顺序为高字节到低字节。可以使用以下代码确定底层平台的字节序：

```js
// 如果整数 0x000001 在内存中排列为 01 00 00 00，则底层平台使用小端字节序。在大端字节序平台中，看到的字节排列应该是 00 00 00 01
let littleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;
```

今天，市面上常见的 CPU 都是小端字节序。很多网络协议及某些二进制文件格式则要求使用大端字节序。如果定型数组要使用来自网络或文件的数据，可以假定平台字节序与数据字节序一致。通常，在使用外部数据时，可以使用 Int8Array 和 Uint8Array 来查看数组中的单个字节，但不应该使用字大小为多字节的其他定型数组。此时，可以使用 DataView 类，这个类定义的方法可以显式指定读、写 ArrayBuffer 值时的字节序：

```js
// 假设要处理一个二进制字节的定型数组
// 首先，创建 DataView 对象，以便从字节中灵活地读取值
let view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
let int = view.getInt32(0); // 从字节开始按大端字节序读取有符号整数
int = view.getInt32(4, false); // 下一个整数还是大端字节序
int = view.getUnit32(8, true); // 下一个整数是小端字节序且无符号
view.setUint3(8, int, false); // 将其以大端字节序写回缓冲区
```

DataView 为 10 种定型数组类（不包括 Uint8ClampedArray）定义了 10 个 get 方法。这些方法的名字类似 getInt16、getUnit32()、getBigInt64() 和 getFloat64()。它们的第一个参数是 ArrayBuffer 中的字节偏移量，表示读取值的开始位置。所有这些读取方法（除 getInt8() 和 getUint8() 之外）都接收一个可选的布尔值作为第二个参数。如果第二个参数被省略或是 false，则使用大端字节序。如果第二个参数是 true，则使用小端字节序。

DataView 也定义了 10 个对应的设置方法，用于向底层 ArrayBuffer 写入值。这些方法的第一个参数是偏移量，表示写入值的开始位置。其中每个方法(除 setInt8() 和 setUnit8()之外）都接收一个可选的第三个参数。如果这个参数被省略或是 false，则以大端字节序格式写入值，即最高有效字节在前。如果这个参数是 true，则以小端字节序格式写入值，即最低有效字节在前。

> 定型数组和 DataView 提供了处理二进制数据所需的全部工具，可以编写能够解压 ZIP 文件或者从 JPEG 文件中提取元数据之类的 JS 程序。

### 11.3 正则表达式与模式匹配

正则表达式是一种描述文本模式的对象。JS 的 RegExp 类表示正则表达式，String 和 RegExp 都定义了使用正则表达式对文本执行强大模式匹配和搜索替换功能的方法。

#### 11.3.1 定义正则表达式

在 JS 中，正则表达式通过 RegExp 对象来表示。RegExp 对象可以使用 RegExp() 构造函数来创建，但更多的是通过一种特殊的字面量语法来创建。正则表达式字面量就是包含在一对斜杠（`/`）字符之间的字符。因此，可以在 JS 代码中这样声明一个正则表达式：

```js
let pattern = /s$/;
```

这行代码创建了一个新的 RegExp 对象，并将它赋值给变量 pattern。这个特殊的 RegExp 对象匹配任意以字母 “s” 结尾的字符串。同样的正则表达式也可以使用 RegExp() 构造函数像下面这样来创建：

```js
let pattern = new RegExp('s$');
```

正则表达式模式由一系列字符构成。多数字符，包括所有字母数字字符，都只用来描述直接匹配的字符。正则表达式中还有一些字符并不直接匹配字符本身，而是具有特殊的含义。例如，正则表达式 `/s$/` 包含两个字符，第一个 “s” 匹配自身，而第二个 “$” 就是一个特殊字符，匹配字符串的末尾。因此，这个正则表达式就匹配任何以字母 “s” 作为最后一个字符的字符串。

正则表达式也支持一个或多个标志字符，用于控制匹配的方式。在正则表达式字面量中，标志需要放在第二个斜杠字符后面，在 RegExp() 构造函数中，标志要作为第二个字符串参数。比如，要匹配以 “s” 或 “S” 结尾的字符串，可以给正则表达式添加标志，表示希望匹配不区分大小写：

```js
let pattern = /s$/i;
```

**字面量字符**
所有字母字符和数字在正则表达式中都匹配自身的字面值。JS 正则表达式语法通过以反斜杠（`\`）开头的转义序列也支持一些非字母字符。例如，`\n` 匹配字符串中换行字符的字面值。

表 11-1：则表达式字面量字符

| 字符         | 匹配目标                                                                                                                            |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| 字母数字字符 | 自身                                                                                                                                |
| \0           | NUL 字符（\u0000）                                                                                                                  |
| \t           | 制表符（\u0009）                                                                                                                    |
| \n           | 换行符（\000A）                                                                                                                     |
| \v           | 垂直制表符（\u000B）                                                                                                                |
| \f           | 进纸符（\u000C）                                                                                                                    |
| \r           | 回车符（\u000D）                                                                                                                    |
| \xnn         | 十六进制数值 nn 指定的拉丁字符。例如，\x0A 等同于 \n                                                                                |
| \uxxxx       | 十六进制数值 xxxx 指定的 Unicode 字符。例如，\u0009 等同于 \t                                                                       |
| \u{n}        | 码点 n 指定的 Unicode 字符，其中 n 是介于 0 到 10FFFF 之间的 1 到 6 个十六进制数字。注意，这种语法仅在使用 u 标志的正则表达式中支持 |
| \cX          | 控制字符 ^X。例如，\cJ 等价于换行符 \n                                                                                              |

有一些英文标点符号在正则表达式中具有特殊含义，它们是：

```text
^ $ . * + ? = !  : | \ / () [] {}
```

其中有的字符只在正则表达式的特定上下文中具有特殊含义，在其他上下文中仍然按字面值对待。但作为一个通用的规则，如果想在正则表达式中包含这些标点符号的字面值，必须在这些字符前面加个反斜杠（`\`）。其他标点
符号字符，如引号和 `@`，在正则表达式不具有特殊含义，仅匹配自身的字面值。

> **注意**：如果使用 RegExp() 构造函数，正则表达式中的任何反斜杠都要写两次，因为字符串也使用反斜杠作为转义字符。

**字符类**
把个别字面值字符放到方括号中可以组合成字符类。字符类匹配方括号中包含的任意字符。因此，正则表达式 `/[abc]/` 匹配 a、b 或 c 中的任意一个字母。也可以定义排除性的字符类，匹配除方括号中包含的字符之外的任意字符。排除性字符类就是把插入符号（`^`）作为方括号中的第一个字符。如正则表达式 `/[^abc]/` 匹配除 a、b 和 c 之外的任意一个字符。

字符类可以使用连字符表示字符范围。要匹配拉丁字母表中的任意一个小写字母，可以使用 `/[a-z]/` （如果想通过字符类匹配真正的连字符，只要把它放到右方括号前面，作为作为字符类的最后一个字符即可）。

某些字符类很常用，JS 正则表达式语法中包含一些特殊字符和转义序列来表示这些字符类。例如，`\s` 匹配空格字符、制表字符和其他 Unicode 空白字符。而 `\S` 匹配任何非 Unicode 空白字符。表 11-2 列出了这些特殊字符并总结了字符类语法（注意，其中一些字符类转义序列只匹配 ASCII 字符，目前尚未扩展到匹配 Unicode 字符。不过，要匹配 Unicode 字符，也可以自己定义 Unicode 宇符类。例如，要匹配任何西里尔字母，可以定义 Unicode 字符类 `/[u0400-\u04FF]/`）。

表 11-2：正则表达式字符类

| 字符   | 匹配目标                                                                                               |
| ------ | ------------------------------------------------------------------------------------------------------ |
| [...]  | 方括号中的任意一个字符                                                                                 |
| [^...] | 不在方括号中的任意一个字符                                                                             |
| .      | 除换行或其他 Unicode 行终止符之外的任意字符。如果 RegExp 使用 s 标志，则句点匹配任意字符，包括行终止符 |
| \w     | 任意 ASCII 单词字符。等价于 `[a-zA-Z0-9_]`                                                             |
| \W     | 任意非 ASCI 单词字符。等价于 `[^a-zA-Z0-9_]`                                                           |
| \s     | 任意 Unicode 空白字符                                                                                  |
| \S     | 任意非 Unicode 空白字符                                                                                |
| \d     | 任意 ASCII 数字字符。等价于 [0-9]                                                                      |
| \D     | 任意非 ASCII 数字字符。等价于 [^0-9]                                                                   |
| [\b]   | 退格字符字面值（特例）                                                                                 |

> **注意**：所有特殊字符类转义序列本身也可以出现在方括号中。`\s` 匹配任意空白字符，而 `\d` 匹配任意数字，所以 `/[\s\d]/` 匹配任意空白字符或数字。不过有一个特例，即 `\b` 转义序列有一个特殊含义。如果出现在字符类中，`\b` 表示退格字符。因此要在正则表达式中表示一个退格字符的字面值，就要使用只包含一个元素的字符类: `/[\b]/`。

**Unicode 字符类**
在 ES2018 中，如果正则表达式使用了 `u` 标志，则支持字符类 `\p{...}` 及其排除性形式 `\P{^...}`。这些字符类建立在 Unicode 标准定义的属性基础之上，它们表示的字符集可能随着 Unicode 标准的发展而变化。

`\d` 字符类只匹配 ASCII 数字。如果想从世界书写体系中匹配一个十进制数字，可以使用 `/\p{Decimal_Number}/u`。如果想匹配任意语言中的非十进制数字，可以大写 p，即写成 `/P{Decimal_Number}/u`。如果想匹配任意类数值字符，包括分数和罗马数字以使用 `/p{Number}/`。

> **注意**：“Decimal Number” 和 “Number” 并非 JS 或正则表达式语法特有的，它们是 Unicode 标准定义的字符类别的名字。

`\w` 字符类只匹配 ASCII 文本，但使用可以模拟一个这样的国际化版本：

```js
/[\p{Alphabetic}\p(Decimal_Number)\p{Mark}]/u;
```

如果真要完全兼容世界上各式各样的语言，其实还需要添加 “Connector_Punctuation” 和 “Join_Control” 两个分类。

最后一个例子要展示的是 `\p` 语法也支持定义匹配特定字母表或文字（script）中字符的正则表达式：

```js
let greekLetter = /\p{Script=Greek}/u;
let cyrillicLetter = /\p{Script=Cyrillic}/u;
```

**重复**
指定重复的字符始终跟在应用它们的模式后面。由于某些重复的形式非常常用，还会有特殊字符表示这些情况。例如，`+` 表示前面的模式出现一次或多次的情形。

表 11-3：正则表达式重复字符

| 字符   | 含义                                                   |
| ------ | ------------------------------------------------------ |
| {n, m} | 匹配前项至少 n 次，但不超过 m 次                       |
| {n,}   | 匹配前项 n 或更多次                                    |
| {n}    | 匹配前项恰好 n 次                                      |
| `?`    | 匹配前项零或一次。换句话说，前项是可选的。等价于{0，1} |
| `+`    | 配前项一或多次。等价于 {1,}                            |
| `*`    | 匹配前项零或多次。等价于 {0,}                          |

**非贪婪重复**
表 11-3 中列出的重复字符会尽可能多地匹配，同时也允许正则表达式剩余的部分继续匹配。这种重复是 “贪婪的”。在重复字符后面简单地加个问号，就可以指定非贪婪地重复，如 `??`、`+?`、`*?`，甚至 `{1, 5}?`。举个例子，正则表达式 `/a+/` 匹配一个或多个字母 “a”。在应用到字符串 “aaa” 时，它匹配全部 3 个字母。`/a+?/` 同样也匹配一个或多个字符“a”，但在应用到字符串“a”时，它只匹配第一个字母 “a”。

使用非贪婪重复不一定总能得到期待的结果。比如模式 `/a+b/` 匹配一个或多个 “a” 后跟字母 “b”。在应用到字符串 “aaab” 时，它匹配整个字符串。而使用非贪婪版本的 `/a+?b/` 时似乎应该匹配字母 “b” 前面有最少的字母“a”。在应用到同样的字符串 “aaab” 时，本意是希望它只匹配一个 “a” 和最后的字母 “b”。但事实上，这个模式也会匹配整个字符串，与贪婪的版本一样。这是因为正则表达式模式的匹配会从字符串的第一个位置开始査找匹配项。由于在字符串一开始就找到了匹配项，所以从后续字母开始的更短的匹配项就不在考虑之列了。

**任选、分组和引用**
正则表达式的语法中也包含指定任选、分组子表达式和引用前面子表达式的特殊字符。竖线字符 `|` 用于分隔任选模式。例如，`/abcd|ef/` 匹配字符串 “ab” 或字符串 “cd” 或字符串 “ef”。而 `/\d{3}|[a-z]{4}/` 匹配 3 个数字或 4 个小写字母。

> **注意**：在找到匹配项之前，会从左到右依次适配任选模式。如果左边的任选模式匹配，则忽略右边的模式，即使右边的模式可以得到 “更好” 的匹配。比如，模式 `/a|ab/` 应用到字符串 “ab” 只会匹配字母 “a”。

圆括号在正则表达式中有几种不同的作用：

- **把独立的模式分组为子表达式**
  从而让这些模式可以被 `|`、`*`、`+`、`?` 等当作一个整体。例如，`/java(script)?/` 匹配 “java” 后跟可选的 “script”。而 `/(ab|cd)+|ef/` 匹配字符串 “ef”，也匹配一个或多个字符串 "ab” 或 “cd”。

- **在完整的模式中定义子模式**
  当正则表达式成功匹配一个目标字符串后，可以从目标字符串中提取出与圆括号包含的子模式对应的部分。例如，假设要查找一个或多个小写字母后跟一个或多个数字。可以使用模式 `/[a-z]+\d+/`。但假设只关心每个匹配项中的数字部分。如果把匹配数字的模式放到一对圆括号中 `/[a-z]+(\d+)/`，那么就可以从整个模式的匹配项中提取出相应的数字。

- **与圆括号分组的子表达式相关的一个用途是在同一个正则表达式中回引子表达式**
  回引前面的子表达式要使用 `\` 字符加上数字。这里的数字指的是圆括号分组的子表达式在整个正则表达式中的位置。例如，`\1` 回引第一个子表达式，`\3` 回引第三个。

  > **注意**：由于子表达式可能会嵌套，所以它们的位置是按照左括号来计算的。例如，在下面的正则表达式中，嵌套的子表达式 `([Ss]cript)` 要使用 `\2` 来引用：

  ```js
  /([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/;
  ```

  对正则表达式中前面子表达式的引用并不会引用该子表达式的模式，而是会引用该模式匹配的文本。因此，引用可以用来强制字符串中不同的部分包含完全相同的字符。例如，下面的正则表达式匹配位于一对单或双引号间的一个或多个字符。但是，它不要求开始和结尾的引号匹配（即必须都是单引号或都是双引号）：

  ```js
  /['"][^'"]*['"]/;
  ```

  如果想要求引号必须匹配，可以使用引用：

  ```js
  /(['"])[^'"]*\1/;
  ```

  这个 `\1` 匹配第一个圆括号分组的子表达式匹配的内容。在这个例子中，它强制结尾的引号必须匹配开始的引号。这个正则表达式不允许双引号字符串中出现单引号或者单引号字符串中出现双引号（**在字符类中使用引用是不合法的**，因此不能这么写: `/(['"])[^\1]*\1/`。这种对圆括号分组子表达式的引用在正则表达式搜索替换操作中是非常强大的特性。

  如果不想让圆括号分组的子表达式生成数字引用，那么可以不用 `(` 和 `)` 分组，而是开头用 `(?:`，结尾用 `)`。来看下面的模式：

  ```js
  /([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/;
  ```

  在这个例子中，子表达式 `(?:[Ss]cript)` 仅仅是一个分组，从而让 `?` 重复字符可以应用到该组。这样修改后的圆括号不会产生引用，因此在这个正则表达式中 `\2` 引用的是 `(fun\w*)` 匹配的文本。

表 11-4 总结了正则表达式的任选、分组和引用操作符。

表 11-4：正则表达式任选、分组和引用字符

| 字符    | 含义                                                                                                                                   |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `\|`    | 任选：可以匹配左侧的子表达式，也可以匹配右侧的子表达式。                                                                               |
| (...)   | 分组：将模式分组为一个单元，以便使用 `*`、`+`、`?`、`\|` 等。同时记住与分组匹配的字符，以便在后面的引用中使用                          |
| (?:...) | 仅分组：将模式分组为一个单元，但不记住分组匹配的字符                                                                                   |
| \n      | 匹配与第 n 个分组匹配的相同字符。分组是圆括号（可能嵌套）中的子表达式。分组编号是按照左圆括号从左到右计数的。由 `(?:` 开头的分组不计数 |

**命名捕获组**
ES2018 标准化了一个新特性，让正则表达式可以自我解释且更容易理解。这个新特性被称为 “命名捕获组”（named capture group），即可以给正则表达式中的每个左圆括号指定一个关联的名字，以便后面使用这个名字而不是数字来引用匹配的文本。使用名字可以让阅读代码的人更容易理解正则表达式中该部分的用途。

要命名一个分组，使用 `(?<...>`，把分组的名字放在尖括号内。例如，下面这个正则表达式可以用来检查美国邮件地址最后一行的格式：

```js
/(?<city>\w+) (?<state>[A-Z]{2}) (?<zipcode>\d{5})(?<zip9>-\d{4})?/;
```

> **注意**：分组的名字为正则表达式提供了很多上下文信息，让它变得更容易理解了。

如果想在正则表达式中回引某个命名捕获组，可以使用名字。在前面的例子中，可以使用正则表达式的 “反向引用” 来写一个 RegExp，让它匹配单引号或双引号字符串，同时两头的引号也必须匹配。使用命名捕获组和命名反向引用，也可以把该 RegExp 重写为这样：

```js
/(?<quote>['"])[^'"]*\k<quote>/;
```

这里的 `\k<quote>` 是一个命名反向引用，引用捕获开引号的命名分组。

**指定匹配位置**
正则表达式的很多组件匹配字符串中的一个字符。还有一些正则表达式组件匹配字符间的位置而非实际的字符。例如，`\b` 匹配 ASCII 词边界，即 `\w`（ASCII 单词字符）与 `\W`（非单词字符）的边界，或者 ASCII 单词字符与字符串开头或末尾的边界。像 `\b` 这样的组件并不表示匹配的字符串中用到的任何字符，它们表示的是匹配可以发生的合法位置。有时候，这些组件也被称作正则表达式锚点，因为它们把模式锚定到被搜索字符串中特定的位置。最常用的锚点组件是 `^` 和 `$`，分别把模式锚定字符串开头和末尾的位置。

例如，要匹配独占一行的 “JavaScript” 字符串，可以使用正则表达式 `/^JavaScript$/`。如果想搜索 “Java” 这个单词（不是作为前缀，因为它在 “JavaScript” 中），可以使用模式 `/\sava\s/`，即单词前后必须有一个空格。但这个方案存在两个问题。首先，它不匹配位于字符串开头或末尾的 “Java”，只匹配两侧有空格的情况。其次，在这个模式找到匹配项之后，返回的匹配字符串前后都会带空格，这通常并不是想要的。为此，可以把匹配实际空格的 `\s` 替换成匹配（或锚定）词边界的 `\b`：`/\bJava\b/`。相应地，组件 `\B` 锚定与非词边界匹配的位置。换句话说，模式 `/\B[Ss]cript/` 匹配 “JavaScript” 和 “postscript"，但不匹配 “script” 或“Scripting”。

可以使用任意正则表达式作为锚定条件。如果在 `(?=` 和 `)` 字符之间包含一个表达式，因为这些字符构成向前查找断言，所以就意味着其中的字符必须存在，但并不实际匹配。比如，要匹配常用编程语言的名字，但必须后面跟着一个冒号，可以使用 `/[Jj]ava([Ss]cript)?(?=\:)/`。这个模式匹配 “JavaScript: The Definitive Guide” 中的 “JavaScript”，但不匹配 “Java in a nutshell” 中的 “Java”，因为它的后面没有冒号。

如果把前面提到的断言改为以 `(?!` 开头，那就变成了否定式向前查找断言，表示必须不存在断言中指定的字符。例如，`/Java(?!Script)([A-Z]\w*)/` 匹配 “Java” 后跟一个大写字母及任意数量的 ASCII 单词字符，但 “Java” 后面必须不能是 “Script”。因此它匹配 “JavaBeans”，不匹配 “Javanese”，匹配 “JavaScrip”，不匹配 “JavaScript” 或 “JavaScripter”。表 11-5 总结了正则表达式锚点字符。

表 11-5：正则表达式锚点字符

| 字符  | 含义                                                                                                                |
| ----- | ------------------------------------------------------------------------------------------------------------------- |
| ^     | 匹配字符串开头，或者在使用 m 标志时，匹配一行的开头                                                                 |
| $     | 匹配字符串末尾，或者在使用 m 标志时，匹配一行的末尾                                                                 |
| \b    | 匹配单词边界。换句话说，匹配 \w 字符和 \W 字符之间或 \w 与字符串开头或末尾之间的位置（但要注意，[\b] 匹配退格字符） |
| \B    | 匹配非单词边界的位置                                                                                                |
| (?=p) | 肯定式向前查找断言。要求后面的字符匹配模式 p，但匹配结果不包含与之匹配的字符                                        |
| (?!p) | 否定式向前查找断言。要求后面的字符不匹配模式 p                                                                      |

**向后查找断言**
ES2018 扩展了正则表达式语法，支持 “向后查找” 断言。向后查找断言与向前查找断言类似，但关注的是当前匹配位置之前的文本。肯定式向后查找断言使用 `(?<=...)`，否定式向后查找断言使用 `(?<!...)`。例如，要搜索美国邮件地址，希望从中匹配 5 位邮政编码，但仅限于前面是两位字母的州简写的情况，可以这样写：

```js
/(?<= [A-Z]{2} )\d{5}/;
```

而要匹配前面不带 Unicode 货币符号的数字字符串，可以像下面这样使用否定式向后断言：

```js
/(?<![\p{Currency_Symbol}\d.])\d+(\.\d+)?/u;
```

**标志**
每个正则表达式都可以带一个或多个标志，用于修改其行为。JS 定义了 6 个标志，每个标志都用一个字母表示。标志在正则表达式字面量中放在第二个斜杠后面，或者在使用 RegEXp() 构造函数时要以字符串形式作为第二个参数。JS 正则表达式支持的标志及含义如下所示：

- **g**
  g 标志表示正则表达式是 “全局性的”（global），换句话说，使用这个标志意味着想要找到字符串中包含的所有匹配项，而不只是找到第一个匹配项。这个标志不改变模式匹配的方式，但它会从重要的方面修改 String 的 `match()` 方法和 RegExp 的 `exec()` 方法的行为。

- **i**
  i 标志表示模式匹配应该不区分大小写。

- **m**
  m 标志表示匹配应该以 “多行”（multiline）模式进行。意思是这个 RegExp 要用于多行字符串，而且 `^` 和 `$` 锚点应该既匹配字符串的开头和末尾，也匹配字符串中任何一行的开头和末尾。

- **s**
  与 m 标志类似，s 标志同样可以用在要搜索的文本包含换行符的时候。正常情况下，`.` 在正则表达式中匹配除行终止符之外的任何字符。但在使用 s 标志时，`.` 将匹配任何字符，包括行终止符。s 标志是 ES2018 引入 JS 的。

- **u**
  u 标志代表 Unicode，可以让正则表达式匹配完整的码点而不是匹配 16 位值。这个标志是 ES6 新增的，如果没有特殊原因，应该对所有正则表达式都使用这个标志。

  如果不使用这个标志，那正则表达式将无法识别表情符号和其他需要 16 位以上表示的字符（包括很多中文字符）。没有 u 标志，`.` 字符匹配任意 1 个 UTF-16 16 位值。而有 u 标志，`.` 匹配一个 Unicode 码点，包括超过 16 位编码的值。

  在正则表达式上添加 u 标志之后，就可以使用新的 `\u{...}` 转义序列表示 Unicode 字符，同时也可以使用 `\p{...}` 表示 Unicode 字符类。

- **y**
  y 标志表示正则表达式是 “有粘性的”（sticky），应该在字符串开头匹配或在紧跟前一个匹配的第一个字符处匹配。在应用给只想查找一个匹配项的正则表达式时，这个标志的作用就类似给正则表达式加上了 `^` 锚点，将其锚定到字符串的开头。

  对于用来在字符串中反复查找所有匹配项的正则表达式，这个标志比较有用。这时候，它会导致 String 的 `match()` 方法和 RegExp 的 `exec()` 方法产生特殊行为，强制将每个后续匹配都锚定到前一个匹配（在字符串中）的结束位置。

> 以上这些标志可以任意组合，顺序也不分先后。

#### 11.3.2 模式匹配的字符串方法

String 支持 4 个使用正则表达式的方法。

**search()**
这个方法接收一个正则表达式参数，返回第一个匹配项起点字符的位置，如果没有找到匹配项，则返回 -1：

```js
'JavaScript'.search(/script/iu); // 4
'Python'.search(/script/iu); // -1
```

如果 search() 方法的参数不是正则表达式，它会先把这个参数传给 RegEXp() 构造函数，把它转换为正则表达式。search() 方法不支持全局搜索，因此其正则表达式参数中包含的 `g` 标志会被忽略。

**replace()**
replace() 方法执行搜索替换操作。它接收一个正则表达式作为第一个参数，接收一个替换字符串作为第二个参数。它搜索调用它的字符串，寻找与指定模式匹配的文本。如果正则表达式带 `g` 标志，replace() 方法会用替换字符串中的所有匹配项；否则，它只替换第一个匹配项。

如果 replace() 的第一个参数是字符串而非正则表达式，这个方法不会像 search() 那样将字符串通过 RegExp() 转换为正则表达式，而是会按照字面值搜索。比如，可以像下面这样使用 replace() 规范文本字符串中所有 “JavaScript” 的大小写：

```js
// 无论之前是什么大小形式，都替换成规范的大小写形式
text.replace(/javascript/gi, 'JavaScript');
```

不过，replace() 的能力远不止这些。正则表达式中括号分组的子表达式是从左到右编号的，而且正则表达式能够记住每个子表达式匹配的文本。如果替换字符串中出现了 `$` 符号后跟一个数字，replace() 会将这两个字符替换为与指定子表达式匹配的文本。比如，可以通过它将字符串中的引号替换成其他字符：

```js
// quote 表示一个引号后跟任意多个非引号字符，最后又是一个引号
let quote = /"([^"]*)"/g;
// 将直引号替换成书名号，同时引用的文本不变（保存在 $1 中）
'He said "stop"'.replace(quote, '《$1》'); // 'He said 《stop》'
```

如果 RegExp 中使用的是命名捕获组，可以通过名字而非数字来引用匹配的文本：

```js
let quote = /"(?<quotedText>[^"]*)"/g;
'He said "stop"'.replace(quote, '《<quotedText>》'); // 'He said 《stop》'
```

除了给 replace() 传替换字符串，还可以传一个函数，这个函数会被调用以计算替换的值。这个替换函数在被调用时会接收到几个参数。第一个是匹配的整个文本。然后，如果 RegExp 有捕获组，则后面几个参数分别是这些捕获组匹配的子字符串。再接下来的参数是在字符串找到匹配项的位置。再然后一个参数是调用 replace() 方法的整个字符串。最后，如果 RegExp 包含命名捕获组，替换函数还会收到一个参数，这个参数是一个对象，其属性名是捕获组的名字，属性值是匹配的文本。比如，下面的代码使用替换函数将字符串中的十进制整数替换成了十六进制：

```js
let s = '15 times 15 is 225';
s.replace(/\d+/gu, n => parseInt(n).toString(16)); // "f times f is e1"
```

**match()**
match() 是字符串最通用的正则表达式方法，它只有一个正则表达式参数（如果参数不是正则表达式，会把它传给 RegExp() 构造函数），返回一个数组，其中包含匹配的结果；如果没有找到匹配项，就返回 null。如果正则表达式有 `g` 标志，这个方法返回的数组会包含在字符串中找到的所有匹配项。例如：

```js
'7 plus 8 equals 15'.match(/d+/g); // ["7", "8", "15"]
```

如果正则表达式没有 `g` 标志，match() 不会执行全局搜索，只会查找第一个匹配项。在非全局搜索时，match() 仍然返回数组，但数组元素完全不同。在没有 `g` 标志的情况下，返回数组的第一个元素是匹配的字符串，剩下的所有元素是正则表达式中括号分组的捕获组匹配的子字符串。因此，如果 match() 返回一个数组 a，则 `a[0]` 包含与整个正则表达式匹配的字符串，`a[1]` 包含与第一个捕获组匹配的子字符串，以此类推。如果与 replace() 方法做个比较，则 `a[1]` 相当于 `$1`，`a[2]` 相当于 `$2`，以此类推。

比如，下面的代码是一个解析 URL 的例子：

```js
// 一个非常简单的解析 URL 的 RegExp
let url = /(\w+):\/\/([\w.]+)\/(\S*)/;
let text = 'visit my blog at http://www.example.com/~david';
let match = text.match(url);
let fullurl, protocol, host, path;
if (match !== null) {
  fullurl = match[0]; // fullurl == "http://www.example.com/~david"
  protocol = match[1]; // protocol == "http"
  host = match[2]; // host == "www.example.com"
  path = match[3]; // path == "~david"
}
```

在非全局搜索的情况下，match() 返回的数组除了可以通过数值索引的元素，也有一些对象属性。其中，`input` 属性引用调用 match() 的字符串。`index` 属性是匹配项在字符串中的起始位置。如果正则表达式包含命名捕获组，则返回的数组也有一个 `groups` 属性，其值是一个对象。这个对象的属性就是命名捕获组的名字，而属性的值就是匹配的文本。比如，可以将前面那个匹配 URL 的例子重写成下面这样：

```js
let url = /?<protocol>\w+):\/\/(?<host>[\w.]+)\/(?<path>\S*)/;
let text = 'visit my blog at http://www.example.com/~david';
let match = text.match(url);
match[0]; // http://www.example.com/~david
match.input; // text
match.index; // 17
match.groups.protocol; // "http"
match.groups.host; // "www.example.com"
match.groups.path; // "~david"
```

match() 的行为会因为 RegExp 是否带 `g` 标志而有很大不同。另外，是否设置 `y` 标志对 match() 的行为也有一些影响。`y` 标志通过控制字符串匹配的开始位置让正则表达式 “有粘性”。如果 RegExp 同时设置了 `g` 和 `y` 标志，match() 返回包含所有匹配字符串的数组，就跟只设置了 `g` 而没有设置 `y` 一样。但第一个匹配项必须始于字符串开头，每个后续的匹配项必须从前一个匹配项的后一个字符开始。

如果只设置了 `y` 而没有设置 `g` 标志，match() 会尝试找到第一个匹配项，且默认情况下，这个匹配项被限制在字符串开头。不过，这个默认的起始位置是可以修改的，设置 RegExp 对象的 `lastIndex` 属性就可以指定匹配开始的位置。如果找到了匹配项，`lastIndex` 属性会自动被更新为匹配项之后第一个字符的位置，因此如果像这里一样再次调用 match()，它会继续寻找后面的匹配项（`lastIndex` 看起来并不像是一个可以指定下一次匹配开始位置的属性）。

```js
let vowel = /[aeiou]/y; // 粘着元音匹配
'test'.match(vowel); // null："test" 开头的字符不是元音字母
voweL.lastIndex = 1; // 指定一个不同的匹配位置
'test'.match(vowel)[0]; // "e"：在位置 1 找到了元音字母
voweL.lastIndex; // 2：lastIndex 会自动更新
test.match(voweL); // null：位置 2 不是元音字母
vowel.lastIndex; // 0：匹配失败后，lastIndex 会被重置
```

> **注意**：即给字符串的 math() 方法传一个非全局正则表达式，相当于把字符串传给正则表达式的 exec() 方法。这两种情况下返回的数组及其属性都相同。

**matchAll()**
matchAll() 方法是 ES2020 中定义的。matchAll() 接收一个带 `g` 标志的正则表达式。但它并不像 match() 那样返回所有匹配项的数组，而是返回一个迭代器，每次迭代都产生一个与使用 match() 时传入非全局 RegExp 得到的匹配对象相同的对象。正因为如此，matchAll() 成为循环遍历字符串中所有匹配项最简单和最通用的方式。

可以像下面这样使用 matchAll() 遍历字符串中包含的单词：

```js
// 位于词边界之间的一个或多个 Unicode 字母字符
const words = /\b\p{Alphabetic}+\b/gu;
const text = 'This is a naive test of the matchAll() method.';
for (let word of text.matchAll(words)) {
  console.log(`Found '${word[0]}' at index ${word.index}.`);
}
```

也可以设置 RegExp 对象的 `lastIndex` 属性，告诉 matchAll() 从字符串中的哪个索引开始匹配。但是，与其他模式匹配方法不同的是，matchAll() 不会修改传入 RegExp 的 `lastIndex` 属性，这也使得它不太可能在代码中导致 bug。

**split()**
String 对象的最后一个正则表达式方法是 split()。这个方法使用传入的参数作为分隔符，将调用它的字符串拆分为子字符串保存到一个数组中。可以像这样给它传入一个字符串参数：

```js
'123,456,789'.split(','); // ['123', '456', '789']
```

split() 方法也可以接收一个正则表达式参数，这样就可以指定更通用的分隔符。下面这个例子中指定的分隔符允许逗号两侧包含任意数量的空格：

```js
'1, 2, 3,\n4, 5'.split(/\s*,\s*/); // ['1', '2', '3', '4', '5']
```

如果调用 split() 时传入 RegExp 作为分隔符，且这个正则表达式中包含捕获组，则捕获组匹配的文本也会包含在返回的数组中：

```js
const htmlTag = /<([^>]+)>/; // < 后跟一个或多个非 > 字符，再后跟 >
'Testing<br/>1,2,3'.split(htmLTag); // ["Testing", "br/", "1,2,3"]
```

#### 11.3.3 RegExp 类

RegExp() 构造函数接收一个或两个字符串参数，创建一个新 RegExp 对象。这个构造函数的第一个参数是包含正则表达式主体的表达式，即在正则表达式字面量中出现在斜杠中间的部分。

> **注意**：字符串字面量和正则表达式都使用 `\` 字符转义，因此在以字符串字面量形式给 RegExp() 传入正则表达式时，必须把所有 `\` 字符替换成 `\\`。

RegExp() 的第二个参数是可选的。如果提供了这个参数，则代表指定正则表达式的标志。这个参数应该是 `g`、`i`、`m`、`s`、`u`、`y` 或它们的任意组合。

```js
// 查找字符串中包含的所有 5 位数字。注意这里的双反斜杠 \\。
let zipcode = new RegExp('\\d{5}', 'g');
```

**RegExp() 构造函数主要用于动态创建正则表达式，即创建那些无法用正则表达式字面量语法表示的正则表达式**。例如，要搜索用户输入的字符串，就必须使用 RegExp() 在运行时创建正则表达式。

除了给 RegExp() 的第一个参数传字符串，也可以传一个 RegExp 对象。这样可以复制已有的正则表达式，并且修改它的标志：

```js
let exactMatch = /JavaScript/;
let caseInsensitive = new RegExp(exactMatch, 'i');
```

**RegExp 属性**
RegExp 对象有以下属性。

`source`
: 这是个只读属性，包含正则表达式的源文本，即出现在 RegExp 字面量的两个斜杠中间的字符。

`flags`
: 这是个只读属性，包含指定 RegExp 标题的一个或多个字母。

`global`
: 只读布尔属性，如果设置了 `g` 标志则为 true。

`ignoreCase`
: 只读布尔属性，如果设置了标志 `i` 则为 true。

`multiline`
: 只读布尔属性，如果设置了 `m` 标志则为 true。

`dotAll`
: 只读布尔属性，如果设置了 `s` 标志则为 true。

`unicode`
: 只读布尔属性，如果设置了 `u` 标志则为 true。

`sticky`
: 只读布尔属性，如果设置了 `y` 标志则为 true。

`lastIndex`
: 这是个可以读、写的整数属性。对于带有 `g` 或 `y` 标志的模式，这个属性用于指定下次匹配的起始字符位置。

**test()**
RegExp 类的 test() 方法是使用正则表达式的最简单方式。该方法接收一个字符串参数，如果字符串与模式匹配则返回 true，如果没有找到匹配项则返回 false。

test() 方法的原理很简单，它会调用下面的（更复杂的）exec()方法，如果 exec() 返回非空值就返回 true。正因为如此，如果调用 test() 的 RegExp 使用了 `g` 或 `y` 标志，则这个方法的行为取决于 RegExp 对象的 `lastIndex` 属性的值，而这个属性的值可能会被意外修改。详细信息可以参考下面的 “lastIndex 属性与重用 RegExp”。

**exec()**
RegExp 的 exec() 方法是使用正则表达式最通常、最强大的方式。该方法接收一个字符串参数，并从这个字符串寻找匹配。如果没有找到匹配项，则返回 null。而如果找到了匹配项，则会返回一个数组，跟字符串的 match() 方法在非全局搜索时返回的数组一样。这个数组的元素 0 包含匹配整个正则表达式的字符串，后面的数组元素包含与正则表达式中捕获组匹配的子字符串。这个返回的数组也有对象属性：`index` 属性包含匹配项起始字符的位置，`input` 属性包含搜索的目标字符串，而 `groups` 属性（如果有捕获组）引用一个对象，保存与每个命名捕获组匹配的子字符串。

与 String 的 match() 方法不同，exec() 方法无论正则表达式是否设置了 `g` 标志都会返回相同的数组。match() 方法在收到一个全局正则表达式时会返回所有匹配项的数组。相对而言，exec() 始终返回一个匹配项，并提供关于该匹配项的完整信息。

在通过设置了全局 `g` 或粘着 `y` 标志的正则表达式调用 exec() 时，exec() 会根据 RegExp 对象的 `lastIndex` 属性来决定从哪里开始査找匹配（如果设置了 `y` 标志，那么也会限制匹配项必须从该位置开始）。对一个新创建的 RegExp 对象来说，它的 `lastIndex` 为 0，因此搜索从字符串的起点开始。但每次 exec() 成功执行，找到一个匹配项，都会更新 RegExp 的 `lastindex` 属性，将其改写为匹配文本之后第一个字符的索引。如果 exec() 没有找到匹配项，它会将 `lastIndex` 重置为 0。这个特殊行为得以重复调用 exec()，从而逐个找到字符串中所有的匹配项（ES2020 及之后的版本为 String 新增了 catchAll() 方法。而 matchAll() 是遍历所有匹配的更简单方式）。例如，下面代码中的循环会运行两次：

```js
let pattern = /Java/g;
let text = 'JavaScript > Java';
let match;
while ((match = pattern.exec(text)) !== null) {
  console.log(`Matched ${match[0]} at ${match.index}`);
  console.log(`Next search begins at ${pattern.lastIndex}`);
}
```

**lastIndex 属性与重用 RegExp**
JS 正则表达式 API 是比较复杂的。其中配合 `g` 和 `y` 标志的 `lastIndex` 属性则是这套 API 中最费解的地方。每当使用这两个标志时，都要在调用 match()、exec() 或 test()方法时特别小心。因为这些方法的行为依赖于 `lastIndex`，而 `lastIndex` 的值依赖于之前对 RegExp 对象做了什么。这一连串的依赖很容易导致写出问题代码。

比如，假设想找到一段 HTML 文本中所有 `<p>` 标签的索引，可能会写出下面这样的代码：

```js
let match,
  positions = [];
// 可能无穷循环
while ((match = /<p>/g.exec(html)) !== null) {
  positions.push(match.index);
}
```

这段代码不会达成想要的结果。如果 html 字符串包含至少一个 `<p>` 标签，那循环将永远不会停止。问题在于 while 循环条件中使用了一个 RegExp 字面量。循环的每次选代都创建一个新的 RegExp 对象，其 lastIndex 初始值为 0。因此 exec() 每次都从字符串的开头查找，如果有匹配，那就会一遍一遍不停地匹配。解决方案当然就是只定义一次 RegExp，把它们保存在一个变量中，让循环的每次选代都使用同一个 RegExp 对象。

另一方面，有时候重用一个 RegExp 对象也是不对的。比如，假设要遍历一个词典中的所有单词，查找其中所有包含双字母的单词：

```js
let dictionary = ['apple', 'book', 'coffee'];
let doubleLetterWords = [];
let doubleLetter = /(\w)\1/g;
for (let word of dictionary) {
  if (doubleLetter.test(word)) {
    doubleLetterWords.push(word);
  }
}
doubleLetterwords; // ["apple", "coffee"]：没有 "book"!
```

由于这个 RegExp 设置了 `g` 标志，所以它的 `lastIndex` 属性会在每次成功匹配后被修改，而（基于 exec() 的）test()方法就会从 `lastIndex` 指定的位置开始下一次搜索。在匹配完 “apple” 中的 “pp” 后，`lastIndex` 值被更新为 3，因此再从位置 3 开始搜索 “book” 时就会跳过其中包含的 “oo”。

要解决这个问题，可以删除 `g` 标志（在这个特定的例子中 `g` 标志并不是必需的），也可以把 RepExp 字面量挪到循环体内，以便每次迭代时都创建一个新实例，还可以在每次调用 test() 之前把 `lastIndex` 重置为 0。

> 举上面这些例子是为了说明 lastIndex 让 RegExp API 很容易出错。因此在使用 `g` 或 `y` 标志和循环时要格外注意。在 ES2020 及之后的版本中，应该使用 String 的 `matchAll()` 方法而不是 exec() 来避开这个问题，因为 `matchAll()` 不会修改 lastIndex。

### 11.4 日期与时间

Date 类是 JS 中用于操作日期和时间的 API。使用 Date() 构造函数可以创建一个日期对象。在不传参数的情况下，这个构造函数会返回一个表示当前日期和时间的 Date 对象：

```js
let now = new Date(); // 当前时间
```

如果传入一个数值参数，Date() 构造函数会将其解释为自 1970 年至今经过的亳秒数：

```js
let epoch = new Date(0); // 格林尼治标准时间 1970 年 1 月 1 日 θ 时
```

如果传入一个或多个整数参数，它们会被解释为本地时区的年、月、日、时、分、秒和毫秒，如下所示：

```js
let century = new Date(
  2100, // 2100 年
  0, // 1 月
  1, // 1 日
  2,
  3,
  4,
  5 //本地时间 02:03:04.005
);
```

Date API 有个奇怪的地方，即每年第一个月对应数值 0，而每月第一天对应数值 1。如果省略时间字段，Date() 构造函数默认它们都为 0，将时间设置为半夜 12 点。

> **注意**：在使用多个参数调用时，Date() 构造函数会使用本地计算机的时区来解释它们。如果想以 UTC（Universal Coordinated Time，通用协调时间；也称 GMT，即 Greenwich Mean Time，格林尼治标准时间）指定日期和时间，可以使用 `Date.UTC()`。这个静态方法接收与 Date() 构造函数同样的参数，但使用 UTC 来解释它们，并返回毫秒时间戳，可以传给 Date() 构造函数：

```js
// 英格兰 2100 年 1 月 1 日半夜 12 点
let century = new Date(Date.UTC(2100, 0, 1));
```

如果要打印日期，默认会以本地时区打印。如果想以 UTC 显示日期，应该先使用 `toUTCString()` 或 `toISOString()` 转换它。

最后，如果给 Date() 构造函数传入字符串，它会尝试按照日期和时间格式来解析该字符串。这个构造函数可以解析 `toString()`、`toUTCString()` 和 `toISOString()` 方法产生的格式：

```js
let century = new Date('2100-01-01T00:00:00Z'); // ISO 格式的日期
```

有了一个 Date 对象后，可以通过很多方法获取或设置这个对象的年、月、日、时、分、秒和毫秒字段。这些方法都有两种形式：

- 使用本地时间获取和设置
- 使用 UTC 时间获取和设置

比如，要获取或设置一个 Date 对象的年份，可以使用 `getFullYear()`、`getUTCFullYear()`、`setFullYear()` 或 `setUTCFullYear()`：

```js
let d = new Date(); // 先用当前日期创建
d.setFullYear(d.getFullYear() + 1); // 增加1年
```

要获取或设置 Date 的其他字段，只要将前面方法中的 “FullYear” 替换成 “Month” “Date” “Hours” “Minutes” “Seconds” 或 “Milliseconds” 即可。其中一些日期设置方法允许一次性设置多个字段。`setFullYear()` 和 `setUTCFullYear()` 也可选地允许同时设置月和日。而 `setHours()` 和 `setUTCHours()` 除了支持小时字段，还允许指定分钟、秒和毫秒字段。

> **注意**：查询日的方法是 `getDate()` 和 `getUTCDate()`。而名字听起来更自然的函数 `getDay()` 和 `getUTCDay()` 返回的是代表周几的数值（0 表示周日，6 表示周六）。周几字段是只读的，因此没有对应的 `setDay()` 方法。

#### 11.4.1 时间戳

JS 在内部将日期表示为整数，代表自 1970 年 1 月 1 日半夜 12 点起（或之前）的毫秒数。最大支持的整数是 8640000000000000，因此 JS 表示的时间不会超过 27 万年。

对于任何 Date 对象，`getTime()` 方法返回这个内部值，而 `setTime()` 方法设置这个值。因此，可以像下面这样给一个 Date 对象添加 30 秒：

```js
d.setTime(d.getTime() + 30000);
```

这些毫秒值有时候也被称为时间戳（timestamp），有时候直接使用这些值比使用 Date 对象更方便。静态的 `Date.now()` 方法返回当前时间的时间戳，经常用于度量代码运行时间：

```js
let startTime = Date.now();
reticulateSplines(); // 执行一些耗时操作
let endTime = Date.now();
console.log(`Spline reticulation took ${endTime - startTime}ms.`);
```

**高精度时间戳**
`Date.now()` 返回的时间戳是以毫秒为单位的。毫秒对计算机来说实际上是个比较长的时间单位。有时候可能需要使用更高的精度来表示经历的时间。此时可以使用 `performance.now()`，虽然它返回的也是以毫秒为单位的时间戳，但返回值并不是整数，包含毫秒后面的小数部分。`performance.now()` 返回的值并不是像 `Date.now()` 返回的值一样的绝对时间戳，而是相对于网页加载完成后或 Node 进程启动后经过的时间。

performance 对象是 W3C 定义的 Performance API 的一部分，已经被浏览器和 Node 实现。要在 Node 中使用 performance 对象，必须先导入它：

```js
const { performance } = require('perf_hooks');
```

高精度计时可能会让一些没有底线的网站用于采集访客指纹，因此浏览器默认可能会降低 `performance.now()` 的精度。可以通过某种方式更新启用高精度计时（比如在 Firefox 中可以设置 privacy.reduceTimePrecision 为 false）。

#### 11.4.2 日期计算

Date 对象可以使用 JS 标准的 <、<=、> 和 >= 等比较操作符进行比较。可以用一个 Date 对象减去另一个以确定两个日期相关的毫秒数（这本质上是因为 Date 类定义了 valueOf() 方法，这个方法返回的是日期的时间戳）。

如果想要给 Date 对象加或减指定数量的秒、分或小时，最简单的方式就是像前面例子中（给日期加上 30 秒）那样修改时间戳。但这种方式在涉及加天时就比较麻烦了，因为这不适合所有月份和年份，不同月份和年份的天数也可能不一样。要完成涉及天数、月数和年数的计算，可以使用 `setDate()`、`setMonth()` 和 `setYear()`。比如，下面的代码给当前日期加上了 3 个月和 2 周：

```js
let d = new Date();
d.setMonth(d.getMonth() + 3, d.getDate() + 14);
```

**日期设置方法即使在数值溢出的情况下也能正确工作**。比如，在给当前月份加了 3 个月之后，最终值可能大于 11(11 表示 12 月)。setMonth() 在遇到这种情况时会按照需要增加年份。类似地，在将天数设置为超过相应月份的天数时，月份也会相应递增。

#### 11.4.3 格式化与解析日期字符串

如果使用 Date 类去记录日期和时间（而不只是度量时间），那很可能需要通过代码向用户展示日期和时间。Date 类定义了一些方法，可以将日期对象转换为字符串。下面是几个例子：

```js
let d = new Date(2020, 0, 1, 17, 10, 30); // 2020 年元旦 5:10:30pn
d.toString(); // "Wed Jan 01 2020 17:10:30 GMT+0800 (GMT+08:00)"
d.toUTCString(); // "Wed, 01 Jan 2020 09:10:30 GMT"
d.toLocaleDateString(); // "2020/1/1"
d.toLocaleTimeString(); // "下午5:10:30"
d.toISOString(); // "2020-01-01T09:10:30.000Z"
```

下面分别介绍 Date 类定义的全部字符串格式化方法。

**toString()**
: 这个方法使用本地时区但不按照当地惯例格式化日期和时间。

**toUTCString()**
: 这个方法使用 UTC 时区但不按照当地惯例格式化日期。

**toISOString()**
: 这个方法以标准的 ISO-8601 “年-月-日时:分:秒:毫秒” 格式打印日期和时间。字母 “T” 在输出中分隔日期部分和时间部分。时间以 UTC 表示，可以通过输出末尾的字母 “Z” 看出来。

**toLocaleString()**
: 这个方法使用本地时区及与用户当地惯例一致的格式。

**toDateString()**
: 这个方法只格式化 Date 的日期部分，忽略时间部分。它使用本地时区，但不与当地惯例适配。

**toLocaleDateString()**
: 这个方法只格式化日期部分。它使用本地时区，也适配当地惯例。

**toTimeString()**
: 这个方法只格式化时间部分。它使用本地时区，但不与当地惯例适配。

**toLocaleTimeString()**
: 这个方法只格式化时间部分。它使用本地时区，也适配当地惯例。

除了将 Date 对象转换为字符串的方法，还有一个静态的 `Date.parse()` 方法。该方法接收一个字符串参数，并尝试将其作为日期和时间来解析，返回一个表示该日期的时间戳。`Date.parse()` 可以像 Date() 构造函数一样解析同样的字符串，也可以解析 `toISOString()`、`toUTCString()` 和 `toString()` 的输出。

### 11.5 Error 类

JS 的 `throw` 和 `catch` 语句可以抛出和捕获任何 JS 值，包括原始值。虽然没有用来表示错误的异常类型，但 JS 定义了一个 Error 类。惯常的做法是使用 Error 类或其子类的实例作为 throw 抛出的错误。

使用 Error 对象的一个主要原因就是在创建 Error 对象时，该对象能够捕获 JS 的栈状态，如果异常未被捕获，则会显示包含错误消息的栈跟踪信息，而这对排查错误很有帮助（注意，栈跟踪信息会展示创建 Error 对象的地方，而不是 throw 语句抛出它的地方。如果始终在抛出之前创建该对象，如 throw new Error()，就不会造成任何困惑）。

Error 对象有几个属性：

- `message`
  message 属性的值是传给 Error() 构造函数的值，必须时会被转换为字符串。

- `name`
  对使用 Error() 创建的错误对象，name 属性的值始终是 “Error”。

- 还有一个 `toString()` 方法。
  `toString()` 方法返回一个字符串，由 name 属性的值后跟一个冒号和一个空格，再后跟 message 属性的值构成。

- `stack`
  虽然 ECMAScript 标准并没有定义，但 Node 和所有现代浏览器也都在 Error 对象上定义了 `stack` 属性。这个属性的值是一个多行字符串，包含创建错误对象时 JS 调用栈的栈跟踪信息。在捕获到异常错误时，可以将这个属性的信息作为日志收集起来。

除了 Error 类，JS 还定义了一些它的子类，以便触发 ECMAScript 定义的一些特殊类型的错误。这些子类包括: `EvalError`、`RangeError`、`ReferenceError`、`SyntaxError`、`TypeError` 和 `URIError`。可以按照自己认为合适的方式在代码中使用这些错误类。与基类 Error 一样，这些子类也都有一个构造函数，接收一个消息参数。每个子类的实例都有一个 `name` 属性，其值就是构造函数的名字。

可以自定义 Error 的子类，以便更好地封装自己程序的错误信息。自定义错误对象可以不限于 `message` 和 `name` 属性。在定义自己的子类时，可以任意添加新属性以提供更多的错误细节。例如，要使用 HTTP 请求，可能需要定义一个 `HttpError` 类，这个类通过 `status` 属性保存请求失败对应的 HTTP 状态码（例如 404 或 500）。

```js
class HttpError extends Error {
  constructor(status, statusText, url) {
    super(`${status} ${statusText}: ${url}`);
    this.status = status;
    this.statusText = statusText;
    this.url = url;
  }

  get name() {
    return 'HTTPError';
  }
}

let error = new HttpError(404, 'not Found', 'http://example.com/');
error.status; // 404
error.message; // "404 not Found http://example.com/"
error.name; // "HTTPError"
```

### 11.6 JSON 序列化与解析

当程序需要保存数据或需要通过网络连接向另一个程序传输数据时，必须将内存中的数据结构转换为字节或字符的序列，才可以保存或传输。而且，之后可以再被解析或恢复为原来内存中的数据结构。这个将数据结构转换为字节或字符流的方式称为序列化（serialization），也称为编排（marshaling）或制备（pickling）。

**JS 中序列化数据的最简单方式是使用一种称为 JSON 的序列化格式**。JSON 是 “JavaScript Object Notation”（JavaScript 对象表示法）的简写形式。顾名思义，这种格式使用 JS 对象和数组字面量语法，将对象和数组形式的数据结构转换为字符串。

JSON 支持原始数值和字符串，也支持 true、false 和 null 值，以及在这些原始值基础上构建起来的对象和数组。JSON 不支持其他 JS 类型，如 Map、Set、RegExp、Date 或定型数组。但实践已经证明 JSON 是一种非常通用的数据格式，就连很多非 JS 程序都支持它。

JS 通过两个函数 `JSON.stringify()` 和 `JSON.parse()` 支持 JSON 序列化和反序列化。如果一个对象或数组，不包含任何无法序列化的值，都可以把它传给 `JSON.stringify()` 进行序列化。顾名思义，`JSON. stringify()` 返回一个字符串值。而给定 `JSON.stringify()` 返回的字符串，可以把它传给 `JSON.parse()` 再重建原始的数据结构：

```js
let o = { s: '', n: 0, a: [true, false, null] };
let s = JSON.stringify(o); // s == '{"s":"","n":0,"a":[true,false,null]}'
let copy = JSON.parse(s); // copy == {s:"", n: 0, a: [true, false, null]};
```

如果不考虑将序列化之后的数据保存到文件中，或者通过网络发送出去，可以使用这对函数（以没有那么高效的方式）创建对象的深度副本：

```js
// 创建任何可序列化对象或数组的深度副本
function deepcopy(o) {
  return JSON.parse(JSON.stringify(o));
}
```

**JSON 是 JS 的子集**
数据被序列化为 JSON 格式后，结果是有效的 JS 表达式源代码，可以求值为原始数据结构的一个副本。如果在 JSON 字符串前面加上 `var data =` 并将结果传给 `eval()`，就可以把原始数据结构的一个副本赋值给变量 data。但是不要这样做，因为这是一个巨大的安全漏洞。如果攻击者可以向 JSON 文件中注入任意 JS 代码，那就可以让程序运行他们的代码。使用 `JSON.parse()` 解码 JSON 格式的数据既快也安全。

JSON 有时候也被用为人类友好的配置文件格式。JSON 格式是 JS 的严格子集。不允许有注释，属性名也必须包含在双引号中。

通常，只会给 `JSON.stringify()` 和 `JSON.parse()` 传一个参数，这两个函数其实都可以接收可选的第二个参数，能够扩展 JSON 格式。`JSON.stringify()` 还接收可选的第三个参数。如果希望 JSON 格式字符串对人类友好（比如要用作配置文件），那可以在第二个参数传 null，第三个参数传一个数值或字符串。`JSON.stringify()` 的第三个参数告诉它应该把数据格式化为多行缩进格式。如果第三个参数是个数值，则该数值表示每级缩进的空格数。如果第三个参数是空白符（如 '\t'）字符串，则每级缩进就使用该字符串。

```js
let o = { s: 'test', n: 0 };
JSON.stringify(o, null, 2); // '{\n  \"s\": \"test\",\n  \"n\": 0\n}'
```

> `JSON.parse()` 忽略空白符，因此给 `JSON.stringify()` 传第三个参数不会影响将其输出的字符串再转换为原型的数据结构。

#### 11.6.1 JSON 自定义

如果 `JSON.stringify()` 在序列化时碰到了 JSON 格式原生不支持的值，它会查找这个值是否有 `toJSON()` 方法。如果有这个方法，就会调用它，然后将其返回值字符串化以代替原始值。Date 对象实现了 `toJSON()` 方法，这个方法返回与 `toISOString()` 方法相同的值。这意味着如果序列化的对象中包含 Date，则该日期会自动转换为一个字符串。而在解析序列化之后的字符串时，重新创建的数据结构就不会与开始时的完全一样了，因为原来的 Date 值变成了字符串。

如果想重新创建这个 Date 对象（或以其他方式修改解析后的对象），可以给 `JSON.parse()` 的第二个参数传一个 “复活”（revive）函数。如果指定了这个 “复活” 函数，该函数就会在解析输入字符串中的每个原始值时被调用（但解析包含这些原始值的对象和数组时不会调用）。调用这个函数时会给它传入两个参数。第一个是属性名，可能是对象属性名，也可能是转换为字符串的数组索引。第二个参数是该对象属性或数组元素对应的原始值。而且，这个函数会作为包含上述原始值的对象或数组的方法调用，因此可以在其中通过 this 关键字引用包含对象。

复活函数的返回值会变成命名属性的新值。如果复活函数返回它的第二个参数，那么属性保持不变。如果它返回 undefined，则相应的命名属性会从对象或数组中删除，即 `JSON.parse()` 返回给用户的对象中将不包含该属性。

下面来看一个例子。这个例子调用 `JSON.parse()` 时传入了复活函数，用于过滤某些属性并重新创建 Date 对象：

```js
let data = JSON.parse(text, function (key, value) {
  // 删除以下划线开头的属性和值
  if (key[0] === '_') return undefined;

  // 如果值是 ISO 8601 格式的日期字符串，则转换为 Date。
  if (typeof value === 'string' && /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/.test(value)) {
    return new Date(value);
  }
  // 否则,返回原始值
  return value;
});
```

除了使用 `toJSON()`，`JSON.stringify()` 也支持给它传入一个数组或函数作为第二个参数来自定义其输出字符串。如果第二个参数传入的是一个字符串数组（或者数值数组，其中的数值会转换为字符串），那么这些字符串会被当作对象属性（或数组元素）的名字。任何名字不在这个数组之列的属性会被字符串化过程忽略。而且，返回字符串中包含的属性的顺序也会与它们在这个数组中的顺序相同（这在编写测试时非常有用）。

如果给 `JSON.stringify()` 的第二个参数传入一个函数，则该函数就是一个替代函数（作用与传给 `JSON.parse()` 的可选的复活函数恰好相反）。这个替代函数的第一个参数是对象属性名或值在对象中的数组索引，第二个参数是值本身。这个替代函数会作为包含要被字符串化的值的对象或数组的方法调用。替代函数的返回值会替换原始值。如果替代函数返回 undefined 或什么也不返回，则该值（及其数组元素或对象属性）将在字符串化过程中被忽略。

```js
// 指定要序列化的字段，以及序列化它们的顺序
let text = JSON.stringify(address, ['city', 'state', 'country']);

// 指定替代函数，忽略值为 RegExp 的属性
let json = JSON.stringify(o, (k, v) => (v instanceof RegExp ? undefined : v));
```

这里对 `JSON.stringify()` 的两次调用友好地使用了第二个参数，即产生的序列化输出在反序列化时不需要特殊的复活函数。但一般来说，如果为某个类型定义了 `toJSON()` 方法，或者使用替代函数将本来无法序列化的值变成了可序列化的值，应该都要写一个自定义的复活函数让 `JSON.parse()` 能够复原最初的数据结构。如果真的这样做了，那应该知道这是在自定义数据格式，因而也牺牲了可移植性以及与庞大 JSON 工具、语言生态的兼容性。

### 11.7 国际化 API

JS 国际化 API 包括 3 个类：

- Int.NumberFormat
- Intl.DateTimeFormat
- Intl.Collator

这 3 个类允许以适合当地的方式格式化数值（包括货币数量和百分数）日期和时间，以及以适合当地的方式比较字符串。这些类并不是 ECMAScript 标准定义的，而是 ECMA402 标准定义的，而且得到了浏览器的普遍支持。Node 也支持 Intl API，但 2020 年初，预构建版 Node 二进制文件中并未包含除 US English 地区之外的国际化 API 依赖的本地化数据。因此要在 Node 中使用这些类，可能需要单独下载数据包或者使用自定义构建的 Node 版本。

#### 11.7.1 格式化数值

世界各地的用户对数值格式的预期是不同的。小数点可能是句点，也可能是逗号。千分位分隔符可能是逗号，也可能是句点，而且并不是所有地区都是 3 个数字一组。某些地区的货币要以百为单位分隔，有些则以千为单位，还有的不需要分隔。虽然所谓的阿拉伯数字 0 到 9 在很多语言中使用，但其实也不是普适的，某些国家的用户期待看到以自己的文字书写的数字。

`Intl.NumberFormat` 类定义了一个 `format()` 方法，考虑到了上述所有格式化的可能性。这个构造函数接收两个参数，第一个参数指定作为数值格式化依据的地区，第二个参数是用于指定格式化细节的对象。如果第一个参数被省略，或者传入的是 undefined，则使用系统设置中的地区（假设该地区为用户偏好地区）。如果第一个参数是字符串，那它指定就是期望地区，例如 "en-U5"（美国英语）和 "fr"（法语）。第一个参数也可以是一个地区字符串数组，此时 Intl.NumberFormat 会选择支持最好的一个。

如果指定 `Intl.NumberFormat()` 构造函数的第二个参数，则该函数应该是一个对象，且包含一个或多个下列属性：

**style**
: 指定必需的数值格式类型。默认为 "decimal"，如果指定 "percent" 则按百分比格式化数值，指定 "currency" 则表示数值为货币数量。

**currency**
: 如果 style 的值为 "currency"，则这个属性是必需的，用于指定 3 个字母的 ISO 货币代码（如 "USD" 表示美元，"GBP" 表示英镑）。

**currencyDisplay**
: 如果 style 的值为 "currency"，则这个属性指定如何显示货币值。默认值为 "symbol"，即如果货币有符号则使用货币符号。值 "code" 表示使用 3 个字母的 ISO 代码，值 "name" 表示以完整形式拼出货币的名字。

**useGrouping**
: 如果不想让数值有千分位分隔符（或其他地区相关的样式），将这个属性设置为 false。

**minimumIntegerDigits**
: 数值中最少显示几位整数。如果数值的位数小于这个值，则在左侧填补 0。默认值是 1，但最高可以设置为 21。

**minimumFractionDigits、maximumFractionDigits**
: 这两个属性控制数值小数部分的格式。如果数值的小数部分位数小于最小值，则在右侧填补 0。如果大于最小值，则小数部分会被舍入。这两个属性的取值范围是 0 到 20。默认最小值为 0，最大值为 3，但格式化货币数量时是例外，此时小数部分的长度根据指定的货币会有所不同。

**minimumSignificantDigits、maximumSignificantDigits**
: 这两个属性控制数值中有效位的数量，比如让它们适合格式化科学数据。如果指定，这两个属性会覆盖前面列出的整数和小数属性。合法取值范围是 1 到 21。

以期望的地区和选项创建了 Intl.Numberformat 对象之后，可以把要格式化的数值传给这个对象的 format() 方法，该方法返回适当格式化之后的字符串。例如：

```js
let euros = Intl.NumberFormat('es', { style: 'currency', currency: 'EUR' });
euros.format(10); // "10.00 €"：10欧元，西班牙惯例

let pounds = Intl.NumberFormat('en', { style: 'currency', currency: 'GBP' });
pounds.format(1000); // "1,000.00"：1000 镑，英国格式
```

Intl.NumberFormat（及其他 Int 类）有一个很有用的特性，即它的 format() 方法会绑定到自己所属的 NumberFormat 对象。因此，不需要定义变量引用这个格式化对象，然后再在上面调用 format() 方法，而是可以直接把这个 format() 方法赋值给一个变量，然后就像使用独立的函数一样使用它，比如:

```js
let data = [0.05, 0.75, 1];
let formatData = Intl.NumberFormat(undefined, {
  style: 'percent',
  minimumFractionDigits: 1,
  maximumFractionDigits: 1
}).format;

data.map(formatData); // ["5.0%", "75.0%", "100.0%"]：地区是 en-US
```

某些语言，比如阿拉伯语，使用自己的文字表示十进制数字：

```js
let arabic = Intl.NumberFormat('ar', { useGrouping: false }).format;
arabic(1234567890);
```

其他语言，如印地语（北印度语）使用有自己数字符号的文字，但倾向于默认使用 ASCI 数字 0~9。如果想覆盖这种用于数字的默认文字，可以在地区中加上 `-u-nu-`，后面跟上简写形式的文字名。比如，可以像下面这样使用印度风格的分组和梵文字母来格式化数值：

```js
let hindi = Intl.NumberFormat('hi-IN-u-nu-deva').format;
hindi(1234567890);
```

`-u-` 在地区中表示后面是一个 Unicode 扩展。`nu` 是记数制扩展的名字，deva 则是梵文 Devanagari 的简写。Intl API 标准也为其他一些记数制定义了名字，大多数针对南亚和东南亚的印欧语系。

#### 11.7.2 格式化日期和时间

Intl.DateTimeFormat 类与 Intl.Numberformat 类很相似。`Intl.DateTimeFormat()` 构造函数与 `Intl.NumberFormat()` 接收相同的两个参数：

- 一个地区或地区数组
- 格式化选项的对象

使用 Intl.DateTimeFormat 实例的方式也是调用其 format() 方法，将 Date 对象转换为字符串。

Date 类定义了简单的 `toLocaleDateString()` 和 `toLocaleTimeString()` 方法，可以生成适合用户地区的输出。但这些方法不支持对要显示的日期和时间进行任何控制。比如，想要在输出中省略年份，同时增加一周就做不到。

Intl.DateTimeformat 类提供了细粒度的控制，通过传给构造函数的第二个选项对象的属性来实现。但是，Intl.DateTimeFormat 并不能始终严格按照要求来输出。比如，如果指定了格式化时和秒的选项，但省略了分钟的，格式化的结果仍然会包含分钟的。背后的思想是可以通过选项对象指定想向用户展示哪些日期和时间的字段，以及这些字段的展示样式（如展示名字还是数值），而格式化程序则会选择与这个选项对象含义最接近的地区格式。

选项对象中的属性如下所示：

**year**
: 年，使用 "numeric" 表示完整的 4 位数年份，或使用 "2-digit" 表示两位数简写形式。

**month**
: 月，使用 "numeric" 表示可能比较短的数字，如 “1”，或使用 "2-digit" 表示始终使用 2 位数字，如 “01”。使用 "long" 表示全名，如 “January”，使用 "short" 表示简称，如 “Jan”，而使用 "narrow" 表示高度简写的名字，如“J”，但不保证唯一。

**day**
: 日，使用 "numeric" 表示 1 位或 2 位数字，或使用 "2-digit" 表示 2 位数字。

**weekday**
： 周，使用 "long" 表示全名，如 “Monday"，或使用 "short" 表示简称，如 “Mon”，或使用 "narrow" 表示高度简写的名字，如 “M”，但不保证唯一。

**era**
: 这个属性指定日期在格式化时是否考虑纪元，例如 CE 或 BCE。这个属性在格式化很久以前的日期或者使用日文日历时有用。合法值为 "long" "short" 和 "narrow"。

**hour、minute、second**
: 这几个属性指定如何显示时间。使用 "numeric" 表示 1 位或 2 位数字，使用 "2-digit" 表示强制 1 位数值在左侧填补 0

**timeZone**
: 这个属性指定格式化日期时使用的时区。如果省略，则使用本地时区。实现可能始终以 UTC 时区为准，也可能以 IANA（Internet Assigned Numbers Authority，因特网地址分配机构）的时区（如 “America/Los——Angeles”）为准。

**timeZoneName**
: 这个属性指定在格式化的日期和时间中如何显示时区。使用 "long" 表示时区全称，而 "short" 表示简写或数值形式的时区。

**hour12**
: 这是个布尔值属性，指定是否使用 12 小时制。默认值取决于地区设置，但可以使用这个属性来覆盖。

**hourCycle**
: 这个属性允许指定半夜 12 点是写为 0 时、12 时还是 24 时。默认值取决于地区设备，但可以使用这个属性来覆盖。注意：hour12 相比这个属性具有更高的优先级。使用 "h11" 指定半夜 12 点是 0 时，而此前 1 小时是晚上 11 点。使用"h12"指定半夜是 2 点。使用 "h23“ 指定半夜是 0 时，而此前 1 小时是 23 时。最后，使用 "h24" 将半夜指定为 24 时。

下面是几个例子：

```js
let d = new Date('2020-01-02T13:14:15Z'); // Thu Jan 02 2020 21:14:15 GMT+0800 (中国标准时间)

// 没有选项对象，就是基本的数值式日期格式
Intl.DateTimeFormat('en-US').format(d); // "1/2/2020"
Intl.DateTimeFormat('fr-FR').format(d); // "02/01/2020"

// 周和月使用名字
let opts = { weekday: 'long', month: 'long', year: 'numeric', day: 'numeric' };
Intl.DateTimeFormat('en-US', opts).format(d); // "Thursday, January 2, 2020"
Intl.DateTimeFormat('es-ES', opts).format(d); // "jueves, 2 de enero de 2020"

// 纽约时间，但适合讲法语的加拿大人
opts = { hour: 'numeric', minute: '2-digit', timeZone: 'America/New_York' };
Intl.DateTimeFormat('fr-CA', opts).format(d); // "8 h 14"
```

Intl.DateTimeFormat 默认使用儒略历，但也可以使用其他日历。虽然有些地区默认可能使用非儒略历，但可以在地区中添加 `-u-ca-` 后跟日期名来明确指定要使用什么日历。可以使用的日历名包括 “buddhist” “chinese” “coptic” “ethiopic” “gregory” “hebrew” “indian” “islamic” “iso8601” “japanese” 和 “persian”。继续前面的例子，可以使用各种非公历来确定年份：

```js
let opts = { year:"numeric", era:"short"}
Intl.DateTimeFormat("en", opts) format(d) // "2020 AD"
Intl.DateTimeFormat("en-u-ca-iso8601", opts).format(d) // "2020 AD"
Intl.DateTimeFormat("en-u-ca-hebrew", opts) format(d) // "5780 AM"
Intl.DateTimeFormat("en-u-ca-buddhist", opts).format(d) // "2563 BE"
Intl.DateTimeFormat("en-U-ca-islamic", opts).format(d) // "1441 AH"
Intl.DateTimeFormat("en-u-ca-persian", opts).format(d)// "1398 AP"
Intl.DateTimeFormat("en-U-ca-indian", opts).format(d) // "1941 Saka"
Intl.DateTimeFormat("en-u-ca-chinese", opts) format(d) // "36 78"
Intl.DateTimeFormat("en-u-ca-japanese",opts).format(d) // "2 Reiwa"
```

#### 11.7.3 比较字符串

按字母顺序对字符串排序（或者更通用的说法是对非字母文字 “整理排序”）是一个经常超出英语人士预想的问题。英语的字母表相对较小，没有重音字母，而且有字符编码的优势（ASCII，已经整合到 Unicode 中），其中数字值完全匹配英语标准的字符串排序习惯。对其他语言来说就没有那么简单了。

如果想以自然的方式向用户显示字符串，只使用字符串数组的 `sort()` 方法是不够的。但如果创建一个 IntlCollator 对象，可以将这个对象的 compare() 方法传给 sort() 方法，以执行适合当地的字符串排序。Intl.Collator 对象可以配置让 compare() 方法执行不匹配大小写的比较，甚至只考虑基本字母且忽略重音和其他变音符号的比较。

与 Intl.NumberFormat() 和 Intl.DateTimeFormat() 类似，Intl.Collator() 构造函数也接收两个参数。第一个参数指定地区或地区数组，第二个参数是一个可选的对象，其属性指定具体执行哪种比较。以下是选项对象参数支持的属性。

**usage**
: 这个属性指定如何使用整理器（collator）对象，默认值为 "sort"，但也可以指定为 "search"。背后的思想是在排序字符串时，通常希望整理器区分尽可能多的字符串以产生可靠的排序。但在比较两个字符串时，某些地区可能想进行不那么严格的比较，比如忽略重音。

**sensitivity**
: 这个属性指定整理器在比较字符串时是否区分字母大小写和重音。值 "base" 意味着比较时忽略大小写和重音，只考虑每个字符的基本字母（不过要注意，某些语言认为有的重读字符不同于基本字母）。"accent" 在比较时考虑重音但忽略大小写。"case" 考虑大小写但忽略重音。而 "variant" 执行严格的比较，既区分大小写也考虑重音。这个属性的默认值在 usage 是 "sort" 时是 "variant"。如果 usage 是 "search"，默认的大小写规则取决于地区。

**ignorePunctuation**
: 将这个属性设置为 true 以便在比较字符串时忽略空格和标点符号。比如，将这个属性设置为 true 时，字符串 “any one” 和 “anyone” 会被认为相等。

**numeric**
: 如果比较的内容是整数或包含整数，而希望按照数值顺序而非字母顺序对它们进行排序，要将这个属性设置为 true。设置这个选项后，字符串 “Version9” 会排在 “Version10” 前面。

**caseFirst**
: 这个属性指定是大写字母还是小写字母应该排在前面。如果指定 "upper"，则 "A" 会排在 "a" 前面。如果指定 "lower"，则 "a" 会排在 "A" 前面。无论哪种形式优先，同一字母的大写变体和小写变体在排序中都会紧挨在一起，而不同于所有 ASCII 大写字母会位于所有 ASCII 小写字母之前的 Unicode 字典顺序（即 Array 的 sort() 方法的默认行为）。这个属性的默认值因地区而异，实现可能会忽略这个属性，不允许覆盖大小写排列的顺序。

在通过选项为目标地区创建 Intl.Collator 对象之后，可以使用它的 compare() 方法比较两个字符串。这个方法返回一个数值。如果返回的值小于 0，则第一个字符串位于第二个字符串前面。如果返回的值大于 0，则第一个字符串位于第二个字符串后面。如果 compare() 返回 0，则说明整理器认为两个字符串相等。

compare() 方法接收两个字符串参数，返回一个小于、等于或大于 0 的数值，这跟 Array 的 sort() 方法期待的可选参数和返回值特点完全一致。同样，Intl.Collator 也会自动将 compare() 方法绑定到它的实例，因此可以直接把这个方法传给 sort() 而无须编写包装函数再通过整理器调用它。下面是几个例子：

```js
// 按照用户地区排序的简单整理器
// 千万不要像这个例子这样什么也不传就对人类可读的字符串进行排序
const collator = new Intl.Collator().compare;
['a', 'z', 'A', 'Z'].sort(collator); // ["a", "A", "z", "Z"]

// 文件名经常包含数值，因此需要进行特殊排序
const filenameOrder = new Intl.Collator(undefined, { numeric: true }).compare;
['page10', 'page9'].sort(filenameOrder); // ["page9", "page10"]

// 查找大致匹配目标字符串的所有字符串
const fuzzyMatcher = new Intl.Collator(undefined, {
  sensitivity: 'base',
  ignorePunctuation: true
}).compare;

let strings = ['food', 'fool', 'Fog Bar'];
strings.findIndex(s => fuzzyMatcher(s, 'foobar') === 0); // 2
```

有些地区可能存在多种整理顺序。比如在德国，电话号码簿使用与字典顺序稍微不一样的字母发音排序。1994 年以前在西班牙，“ch” 和 “ll” 被当成两个字母，因此该国目前有一个现代排序和一个传统排序。而在中国，整理顺序可以基于字符的编码、字符的笔画或字符的拼音。这些不同的整理方式无法通过 Intl.collator 的选项对象来指定，但可以通过给地区字符串添加 `-u-co-` 及期待的变体名字来指定。比如，在德国可以使用 "de-DE-U-co-phonebk" 来指定按字母发音排序：

```js
//1994年以前，西班牙将 CH 和 LL 当成两个字母
const modernSpanish = Intl.Collator('es-ES').compare;
const traditionalspanish = Intl.Collator('es-es-u-co-trad').compare;
let palabras = ['Luz', 'llama', 'como', 'chico'];
palabras.sort(modernSpanish); // ["chico", "como", "llama", "Luz"]
palabras.sort(traditionalSpanish); // ["como", "chico", "luz", "llama"]
```

### 11.8 控制台 API

在浏览器中，console.log() 会在开发者工具面板的 “控制台” 标签页中打印字符串，这是排查问题时非常有用的功能。在 Node 中，console.log() 是通用的输出函数，可以将其参数打印到进程的标准输出流，通常会作为程序输出显示在用户的终端窗口中。

除了 console.log() 之外，控制台 API 还定义了其他几个非常有用的函数。这个 API 并不是 ECMAScript 标准，但已经被浏览器和 Node 支持，并已经正式写入标准并通过 WHATWG 标准化: [https://console.spec.whatwg.org/](https://console.spec.whatwg.org/)

控制台 API 定义了以下函数：

**console.log()**
: 这是最常用的控制台函数。它将参数转换为字符串并输出到控制台。它会在参数之间输出空格，并在输出所有参数后重新开始一行。

**console.debug()、 console.info()、 console.warn()、 console.error()**
: 这几个函数与 console.log() 几乎相同。在 Node 中 console.error() 将其输出发送到标准错误流，而不是标准输出流。除此之外的其他函数都是 console.log() 的别名。在浏览器中，这几个函数生成的输出消息前面可能会带一个图标，表示级别或严重程度。开发者控制台可能也支持开发者按照级别筛选控制台消息。

**console.assert()**
: 如果这个函数的第一个参数是真值（也就是断言通过），则这个函数什么也不做。但如果第一个参数是 false 或其他假值，则剩余参数会像被传给 console.error() 一样打印出来，且前面带一个 “Assertion failed” 前缀。注意，与典型的 assert() 函数不同，console.assert() 不会在断言失败时抛出异常。

**console.clear()**
: 这个函数在可能的情况下清空控制台。在浏览器及 Node 中通过终端显示输出时，这个函数是有效的。如果 Node 的输出被重定向到文件或管道，则调用这个函数没有任何效果。

**console.table()**
: 这个函数有一个极其强大但却鲜为人知的特性，即可以生成表列数据输出，这对于需要产生摘要数据的 Node 程序尤其有用。console.table() 尝试以表列形式显示其参数（如果无法实现，则使用常规的 console.log() 格式）。如果参数是相对比较短的对象数组，而数组中的所有对象具有（不那么多的）相同属性时，使用这个函数效果最好。在这种情况下，数组中的每个对象的信息会显示在表格的一行中，对象的每个属性就是表格的一列。也可以传入一个属性数组作为可选的第二个参数，以指定想要显示的列。如果传显示属性值入的是对象而非对象的数组，那么输出会用一列显示属性名，一列显示属性名。如果属性值本身也是对象，则它们的属性名会变成表格的列。

**console.trace()**
: 这个函数会像 console.log() 一样打印它的参数，此外在输出之后还会打印栈跟踪信息。在 Node 中，这个函数的输出会进入标准错误而不是标准输出。

**console.count()**
: 这个函数接收一个字符串参数，并打印该字符串，后面跟着已经通过该字符串调用的次数。在调试事件处理程序时，如果需要知道事件处理程序被触发的次数，可以使用这个函数。

**console.countReset()**
: 这个函数接收一个字符串参数，并重置针对该字符串的计数器。

**console.group()**
: 这个函数将它的参数像传给 console.log() 一样打印到控制台，然后设置控制台的内部状态，让所有后续的控制台消息（在下一次调用 console.groupEnd() 之前）相对刚刚打印的消息缩进。这样可以通过缩进从视觉上把相关消息分为一组。在浏览器中，开发者控制台通常支持分组后消息以组为单位折叠和扩展。console.group() 的参数通常用于为分组提供解释性的名字。

**console.groupCollapsed()**
: 这个函数与 console.group() 类似，但在浏览器中分组默认会被 “折叠”，因而其中包含的消息会隐藏，除非用户点击扩展分组。在 Node 中，这个函数与 console.group() 是同义函数。

**console.groupEnd()**
: 这个函数没有参数，本身也没有输出，只用于结束由最近一次调用 console.group() 或 console.groupCollapsed() 导致的缩进和分组。

**console.time()**
: 这个函数接收一个字符串参数，并记录以该字符串调用自身时的时间，没有输出。

**console.timeLog()**
: 这个函数接收字符串作为第一个参数。如果这个字符串之前传给过 console.time()，那么它会打印该字符串及自上次调用 console.time() 之后经过的时间。如果还有额外的参数传给 console.timeLog()，则这些参数会像被传给 console.log() 一样打印出来。

**console.timeEnd()**
: 这个函数接收一个字符串参数。如果该参数之前传给过 console.time()，则它打印该参数及经过的时间。在调用 console.timeEnd() 之后，如果不再调用 console.time()，则调用 console.timeLog() 将是不合法的。

#### 11.8.1 通过控制台格式化输出

像 console.log() 这样打印自己参数的控制台函数都有一个不太为人所知的特性：如果第一个参数是包含 `%s`、`%i`、`%d`、`%f`、`%o`、`%O` 或 `%c` 的字符串，则这个参数会被当成格式字符串，后续参数的值会被代入这个字符串，以取代这些两个字符的 `%` 序列。

这些序列的含义如下：

**%s**
: 这个参数会被转换为字符串。

**%i 和 %d**
: 这个参数会被转换为数值，然后截断为整数。

**%f**
: 这个参数会被转换为数值。

**%o 和 %O**
: 这个参数会被转换为对象，对象的属性名和值会显示出来（在浏览器中，显示结果通常是可以交互的，用户可以扩展和折叠属性以查看嵌套的数据结构）。`%o` 和 `%O` 都会显示对象细节。但大写的变体使用实现决定的输出格式，即由实现决定什么格式对软件开发者最有用。

**%c**
: 在浏览器中，这个参数会被解释为 CSS 样式字符串，用于给后面的文本添加样式（直到下一个 `%c` 序列或字符串结束）。在 Node 中，`%c` 序列及其对应的参数会被忽略。

> **注意**：在使用控制台函数时，通常并不需要格式字符串。一般来说，只要把一个或多个值（包括对象）传给这些函数，由实现决定如何以有用的方式显示它们就可以了。比如，给 console.log() 传入一个 Error 对象，它会自动在打印输出中包含栈跟踪信息。

### 11.9 URL API

由于 JS 多用于浏览器和服务器，因此 JS 代码经常需要操作 URL。URL 类可以解析 URL，同时允许修改已有的 URL（如添加搜索参数或修改路径），还可以正确处理对不同 URL 组件的转义和反转义。

URL 类并不是 ECMAScript 标准定义的，但 Node 和所有浏览器（除 IE 之外）都实现了它。这个类是在 WHATWG 中标准化的，参见 [https://url.spec.whatwg.org/](https://url.spec.whatwg.org/)

使用 URL() 构造函数创建 URL 对象时，要传入一个绝对 URL 作为参数。也可以将一个相对 URL 作为第一个参数，将其相对的绝对 URL 作为第二个参数。创建了 URL 对象后，可以通过它的各种属性查询 URL 不同部分的非转义值：

```js
let url = new URL('https://example.com:8000/path/name?q=term#fragment');
url.href; // "https://example.com:8000/path/name?q=term#fragment"
url.origin; // "https://example.com:8000"
url.protocol; // "https:"
url.host; // "example.com:8000"
url.hostname; // "example.com"
url.port; // 8080
url.pathname; // "/path/name"
url.search; // "?q=term"
url.hash; // "#fragment"
```

尽管并不常用，但 URL 可以包含用户名或者用户和密码，URL 类也可以解析这些 URL 组件：

```js
let url = new URL('ftp://admin:1337!@ftp.example.com/');
url.href; // "ftp://admin:1337!@ftp.example.com/"
url.origin; // "ftp://ftp.example.com"
url.username; // "admin"
url.password; // 1337
```

这里的 `origin` 属性就是 URL 协议和主机的组合（如果提供了端口，则也会包含在内），而且它是个只读属性。但前面例子中展示的其他属性是可读写属性，即可以通过设置这些属性来设置 URL 中对应的部分：

```js
let url = new URL('https://example.com'); // 创建服务器 URL
url.pathname = 'api/search'; // 为这个 API 添加路径
url.search = 'q=test'; // 添加查询参数
url.toString(); // "https://example.com/api/search?q=test"
```

**URL 类有一个重要特性，即它会在需要时正确地在 URL 中添加标点符号及转义特殊字符**：

```js
let url = new URL('https://example.com');
url.pathname = 'path with spaces';
url.search = 'q=foo#bar';
url.pathname; // "/path%20with%20spaces"
url.search; // "?q=foo%23bar"
url.href; // "https://example.com/path%20with%20spaces?q=foo%23bar"
```

以上例子中的 `href` 属性比较特殊，读取 `href` 属性相当于调用 toString()，即将 URL 的所有部分组合成一个字符串形式的正式 URL。将 `href` 设置为一个新字符串会返回新字符串的 URL 解析器，就好像再次调用了 URL() 构造函数一样。

在前面的例子中，使用 `search` 属性引用 URL 中的整个查询部分。查询部分从一个问号开头到 URL 末尾或第一个井字符结束。有时候，把这个部分作为一个 URL 属性就足够了。但是，HTTP 请求经常会使用 `application/x-www-form-urlencoded` 格式将多个表单字段的值或多个 API 参数编码为 URL 的查询部分。在这个格式中，URL 的查询部分以问号开头，然后是一个或多个由和号（&）分隔的名/值对。可以有多个相同的名字，此时该搜索参数就有多个值。

如果要把这种名/值对编码为 URL 的查询部分，那么 `searchParams` 属性比 `search` 属性更有用。`search` 属性是一个可读写的字符串，通过它可以获取或设置 URL 的查询部分。`searchParams` 属性则是一个对 URLSearchParams 对象的只读引用，而 URLSearchParams 对象具有获取、设置、添加、删除和排序参数（该参数编码为 URL 查询部分）的 API：

```js
let url = new URL("https://example.com/search");
url.search // "" 还没有参数
url.searchParams.append("q", "term");// 添加一个搜索参数
url.search// "?q=term"
url.searchParams.set("q","x") // 修改这个参数的值
url.search // "?q=x"
url.searchParams.get("q") // "x"：查询参数值
url.searchParams.has("q") // true：有一个 q 参数
url.searchParams.has ("p") // false：没有 p 参数
url.searchParams.append("opts","1");// 再添加一个搜索参数
url.search // "?q=x&opts=1"
url.searchParams.append("opts","&"); // 为同一个参数再添加一个值
url.search // "?q=x&opts=1&opts=%26"：有转义
url.searchParams.get("opts") // "1"：第一个值
url.searchParams.getAll("opts") // ["1", "&"]：所有值
url.searchParams.sort() // 对参数进行排序
url.search // "?opts=1&opts=%26&q=x"
url.searchParams.set("opts","y"); // 修改 opts 参数
url.search // "?opts=y&q=x"
// searchParams 是可迭代对象
[...urL.searchParams] // [["opts", "y"],["q", "x"]]
url.searchParams.delete("opts") // 删除 opts 参数
url.search // "?q=x"
url.href // "https://example.com/search?q=x"
```

`searchParams` 属性的值是一个 URLSearchParams 对象。如果想把 URL 参数编码为查询字符串，可以创建 URLSearchParams 对象，追加参数，然后再将它转换为字符串并将其赋值给 URL 的 search 属性：

```js
let url = new URL('http://example.com');
let params = new URLSearchParams();
params.append('q', 'term');
params.append('opts', 'exact');
params.toString(); // "q=term&opts=exact"
url.search = params;
url.href; // "http://example.com/?q=term&opts=exact"
```

#### 11.9.1 遗留 URL 函数

在前面介绍的 URL API 标准化之前，JS 语言也曾多次尝试支持对 URL 的转义和反转义。第一次尝试定义全局的 escape() 和 unescape() 函数，这两个函数如今已经废弃，但仍然被广泛实现了。不应该再使用这两个函数了。

在废弃 escape()和 unescape() 的同时，ECMAScript 增加了两对替代性的全局函数：

**encodeURI() 和 decodeURI()**
: encodeURI() 接收一个字符串参数，返回一个新字符串，新字符串中非 ASCII 字符及某些 ASCII 字符（如空格）会被转义。decodeURI() 正好相反。需要转义的字符首先会被转换为它们的 UTF-8 编码，然后再将该编码的每个字节替换为 `%xx` 转义序列，其中 `xx` 是两个十六进制数字。因为 encodeURI() 是要编码整个 URL，所以不会转义 URL 分隔符（如`/`、`?` 和 `#`）。但这意味着 encodeURI() 不能正确地处理其组件中包含这些字符的 URL。

**encodeURIComponent() 和 decodeURIComponent()**
: 这对函数与 encodeURI() 和 decodeURI() 类似，只不过它们专门用于转义 URL 的单个组件，因此它们也会转义用于分隔 URL 组件的 `/`、`?` 和 `#` 字符。这两个函数是最有用的遗留 URL 函数，但要注意 encodeURIComponent() 也会转义路径名中的 `/` 字符，而这可能并不是想要的。另外它也会把查询参数中的空格转换为 `%20`，而实际上查询参数中的空格应该被转义为 `+`。

> 这些遗留函数的根本问题在于它们都在寻求把一种编码模式应用给 URL 的所有部分，而事实却是 URL 的不同部分使用的是不同的编码方案。如果想正确地格式化和编码 URL，最简单的办法就是使用 URL 类完成所有 URL 相关的操作。

### 11.10 计时器

从 JS 问世开始，浏览器就定义了两个函数: `setTimeout()` 和 `setInterval()`。利用这两个函数，程序可以让浏览器在指定的时间过后调用一个函数，或者每经过一定时间就重复调用一次某个函数。这两个函数至今没有被写进核心语言标准，但所有浏览器和 Node 都支持，属于 JSON 标准库的事实标准。

setTimeout() 的第一个参数是函数，第二个参数是数值，数值表示过多少毫秒之后调用第一个函数。在经过指定时间后（如果系统忙可能会稍微晚一点），将会调用作为第一个参数的函数，没有参数。

> **注意**：setTimeout() 并不会等到指定时间之后再返回。它会立即运行并返回，只是在未到 1000 毫秒时什么也不会发生。

如果省略传给 setTimeout() 的第二个参数，则该参数默认值为 0。但这并不意味着函数会立即被调用，只意味着这个函数会被注册到某个地方，将被 “尽可能快地” 调用。如果浏览器由于处理用户输入或其他事件而没有空闲，那么调用这个函数的时机可能在 10 毫秒甚至更长时间以后。

setTimeout() 注册的函数只会被调用一次。有时候，这个函数本身会再次调用 setTimeout()，以便将来某个时刻会再有一次调用。不过，要想重复调用某个函数，通常更简单的方式是使用 setInterval()。setInterval() 接收的参数与 setTimeout() 相同，但会导致每隔指定时间（同样是个近似的毫秒值）就调用一次指定函数。

setTimeout() 和 setInterval() 都返回一个值。如果把这个值保存在变量中，之后可以把它传给 clearTimeout() 或 clearInterval() 以取消对函数的调用。在浏览器中，这个返回值通常是一个数值，而在 Node 中则是一个对象。具体什么类型其实不重要，只要把它当成一个不透明的值就行了。这个值的唯一作用就是可以把它传给 clearTimeout() 以取消使用 setTimeout() 注册的函数调用（假设函数尚未被调用），或者传给 clearInterval() 以取消对通过 setInterval() 注册的函数的重复调用。

## 十二. 迭代器与生成器

可迭代对象及其相关的迭代器是 ES6 的一个特性。数组（包括 Typed Array）是可迭代的，字符串、Set 对象和 Map 对象也是。这意味着这些数据结构的内容可以通过 for/of 循环来迭代（或循环访问）：

```js
let sum = 0;
// 对每个值都循环一次
for (let i of [1, 2, 3]) {
  sum += i;
}
sum; // 6
```

迭代器让 `...` 操作符能够展开或 “扩展” 可迭代对象：

```js
let chars = [...'abcd']; // chars == ["a", "b", "c", "d"]
let data = [1, 2, 3, 4, 5];
Math.max(...data); // 5
```

迭代器也可以用于解构赋值：

```js
let purpleHaze = Uint8Array.of(255, 0, 255, 128);
let [r, g, b, a] = purpleHaze; // a == 128
```

选代 Map 对象时，返回值是 `[key, value]` 对，在 for/of 循环中可以直接使用解构赋值：

```js
tm = new Map([
  ['one', 1],
  ['two', 2]
]);
for (let [k, v] of m) console.log(k, v); // 打印 'one 1' 和 'two 2'
```

如果只想迭代键或值，而不是键/值对，可以使用 keys() 或 values() 方法：

```js
[...m]; // [["one", 1], ["two", 2]]：默认迭代
[...m.entries()]; // [["one", 1], ["two", 2]]：entries() 方法相同
[...m.keys()]; // ["one", "tow"]：keys() 方法只迭代键
[...m.values()]; // [1,2]：values() 方法只迭代值
```

最后，有些会接收 Array 对象的内置函数和构造函数（在 ES6 及之后的版本中）可以接收任意迭代器。例如，Set() 构造函数就是这样一个 API：

```js
// 字符串是可迭代的，因此两个集合相同:
new Set('abc'); // new Set(["a", "b", "c"])
```

### 12.1 迭代器原理

要理解 JS 中的迭代，必须理解 3 个不同的类型：

- **可迭代对象**，类似于 Array、Set、Map，都是可以迭代的。
  可迭代对象指的是任何具有专用迭代器方法，且该方法返回迭代器对象的对象。

- **迭代器对象**，用于执行迭代。
  迭代器对象指的是任何具有 `next()` 方法，且该方法返回迭代结果对象的对象。

- **迭代结果对象**，保存每次迭代的结果。
  迭代结果对象是具有属性 `value` 和 `done` 的对象。

要迭代一个可迭代对象，首先要调用其迭代器方法获得一个迭代器对象。然后，重复调用这个迭代器对象的 `next()` 方法，直至返回 `done` 属性为 true 的迭代结果对象。这里比较特别的地方是，可迭代对象的迭代器方法没有使用惯用名称，而是使用了符号 `Symbol.iterator` 作为名字。因此可迭代对象 iterable 的简单 for/of 循环也可以写成如下这种复杂的形式：

```js
let iterable = [99];
let iterator = iterable[Symbol.iterator]();
for (let result = iterator.next(); !result.done; result = iterator.next()) {
  console.log(result.value); // result.value == 99
}
```

内置可迭代数据类型的迭代器对象本身也是可迭代的（也就是说，它们有一个名为 `Symbol.iterator` 的方法，返回它们自己）。在下面的代码所示的需要迭代 “部分使用” 的迭代器时，这种设计是有用的：

```js
let list = [1, 2, 3, 4, 5];
let iter = list[Symbol.iterator]();
let head = iter.next().value; // head == 1
let tail = [...iter]; // tail == [2,3,4,5]
```

### 12.2 实现可迭代对象

在 ES6 中，可迭代对象非常重要。因此，只要数据类型表示某种可迭代的结构，就应该考虑把它们实现为可迭代对象。

为了让类可迭代，必须实现一个名为 `Symbol.iterator` 的方法。这个方法必须返回一个迭代器对象，该对象有一个 next() 方法。而这个 next() 方法必须返回一个迭代结果对象，该对象有一个 `value` 属性和一个布尔值 `done` 属性。示例 12-1 实现了一个可迭代的 Range 类，演示了如何创建可迭代对象、迭代器对象和迭代结果对象：

```js
/*
 * 示例 12-1：可选代的数值 Range 类
 * Range 对象表示一个数值范围 {x : from <= x <= to}
 * Range 定义了 has() 方法用于测试给定数值是不是该范围的成员
 * Range 是可迭代的，迭代其范围内的所有整数
 */
class Range {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }

  // 让 Range 对象像数值的集合一样
  has(x) {
    return typeof x === 'number' && this.from <= x && x <= this.to;
  }

  // 使用集合表示法返回当前范围的字符串表示
  toString() {
    return `{ x | ${this.from} ≤ x ≤ ${this.to} }`;
  }

  // 通过返回一个迭代器对象，让 Range 对象可迭代
  // 注意这个方法的名字是一个特殊符号，不是字符串
  [Symbol.iterator]() {
    // 每个迭代器实例必须相互独立、互不影响地迭代自己的范围
    // 因此需要一个状态变量跟踪迭代的位置。从第一个大于等于 from 的整数开始
    let next = Math.ceil(this.from); // 这是下一个要返回的值
    let last = this.to; // 不会返回大于它的值
    // 这是迭代器对象
    return {
      // 这个 next() 方法是迭代器对象的标志，它必须返回一个迭代器结果对象
      next() {
        return next <= last // 如果还没有返回 last
          ? { value: next++ } // 则返回 next 并给它加 1
          : { done: true }; // 否则返回表示完成的对象
      },

      // 为了方便起见，让迭代器本身也可迭代
      [Symbol.iterator]() {
        return this;
      }
    };
  }
}

for (let x of new Range(1, 10)) console.log(x); // 打印数值 1 到 10
[...new Range(-2, 2)]; // [-2, -1, 0, 1, 2]
```

除了可以把类变成可迭代的类之外，定义返回可迭代值的函数也很有用。例如，下面定义了两个函数，可以代替 JS 数组的 map() 和 filter() 方法：

```js
// 返回一个可迭代对象，迭代的结果是对传入的可迭代对象的每个值应用 f() 的结果
function map(iterable, f) {
  let iterator = iterable[Symbol.iterator]();
  // 这个对象既是迭代器对象也是可迭代对象
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let v = iterator.next();
      if (v.done) {
        return v;
      } else {
        return { value: f(v.value) };
      }
    }
  };
}

// 把一个范围内的整数映射为它们的平方并转换为一个数组
[...map(new Range(1, 4), x => x * x)]; // [1, 4, 9, 16]

// 返回一个可迭代对象，只迭代 predicate 返回 true 的函数
function filter(iterable, predicate) {
  let iterator = iterable[Symbol.iterator]();

  // 这个对象既是迭代器对象也是可迭代对象
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      for (;;) {
        let v = iterator.next();
        if (v.done || predicate(v.value)) {
          return v;
        }
      }
    }
  };
}

// 筛选整数范围，只保留偶数
[...filter(new Range(1, 10), x => x % 2 === 0)]; // [2, 4, 6, 8, 10]
```

**可迭代对象与迭代器有一个重要的特点，即它们天性懒惰：如果计算下一个值需要一定的计算量，则相应计算会推迟到实际需要下一个值的时候再发生**。

假设有一个非常长的文本字符串，想对它进行分词，返回以空格分隔的单词。如果使用字符串的 split() 方法，那么哪怕一个单词都还没用也要处理整个字符串。这样可能会占用很多内存来保存返回的数组和其中的字符串。下面这个函数可以对字符串中的单词进行懒惰迭代，不必把它们全部保存在内存里（[返回迭代器的 matchAll() 方法](#1132-模式匹配的字符串方法)实现这个函数更简单，该方法是 ES2020 新增的）：

```js
function words(s) {
  var r = /\s+|$/g; // 匹配一个或多个空格或末尾
  r.lastIndex = s.match(/[^ ]/).index; // 开始匹配第一个非空格

  // 返回一个可迭代的迭代器对象
  return {
    // 这个方法是可迭代对象必需的
    [Symbol.iterator]() {
      return this;
    },

    // 这个方法是迭代器必需的
    next() {
      let start = r.lastIndex; // 从上次匹配结束的地方恢复
      // 如果还没有处理完
      if (start < s.length) {
        let match = r.exec(s); // 匹配下一个单词边界
        // 如果找到了一个单词，则返回它
        if (match) {
          return { value: s.substring(start, match.index) };
        }
      }
      return { done: true }; // 否则，返回表示处理完成的结果
    }
  };
}

[...words(' abc def ghi! ')]; // ["abc", "def", "ghi!"]
```

#### 12.2.1 “关闭” 迭代器：return() 方法

如果在服务器端实现了上面的 words() 迭代器，它不接收字符串，而是接收文件名，然后打开文件，读取行，再迭代行。在大多数操作系统中，打开文件读取内容的程序都需要记得在读取后关闭文件。因此，这个假想的迭代器需要确保在 next() 方法返回最后一个单词后关闭文件。

但迭代器有时候不一定会跑完，如 for/of 循环可能被 break、return 或异常终止。类似地，在使用迭代器进行解构赋值时，next() 方法被调用的次数取决于要赋值变量的个数。虽然迭代器可能还剩下很多值没有返回，但是已经用不到它们了。

假设，文件内单词迭代器即使永远跑不到终点，也需要关闭它打开的文件。为此，除了 next() 方法，迭代器对象还可以实现 return() 方法。如果迭代在 next() 返回 done 属性为 true 的迭代结果之前停止（最常见的原因是通过 break 语句提前退出 for/of 循环），那么解释器就会检查迭代器对象是否有 return() 方法。如果有，解释器就会调用它（不传参数），让迭代器有机会关闭文件、释放内存，或者做一些其他清理工作。这个 return() 方法必须返回一个迭代器结果对象。这个对象的属性会被忽略，但返回非对象值会导致报错。

for/of 循环和扩展操作符是 JS 中非常有用的特性，因此在创建 API 时，应该尽可能使用它们。但是可迭代对象、它的迭代器对象，加上迭代器的结果对象让事情变得有点复杂。**好在生成器可以极大地简化自定义迭代器的创建**。

### 12.3 生成器

生成器是一种使用强大的新 ES6 语法定义的迭代器，**特别适合要迭代的值不是某个数据结构的元素，而是计算结果的场景**。

要创建生成器，首先必须定义一个生成器函数。生成器函数在语法上类似常规的 JS 函数，但使用的关键字是 `function*` 而非 `function`（严格来讲，`function*` 并不是一个新关键字，只是在 function 后面、函数名前面加了个 `*`）调用生成器函数并不会实际执行函数体，而是返回一个生成器对象。这个生成器对象是一个迭代器。调用它的 next() 方法会导致生成器函数的函数体从头（或从当前位置）开始执行，直至遇见一个 `yield` 语句。`yield`（回送）是 ES6 的新特性，类似于 return 语句。`yield` 语句的值会成为调用迭代器的 next() 方法的返回值。

```js
// 这个生成器函数回送一组素数（10进制）
// 调用这个函数不会运行下面的代码，而只会返回一个生成器对象。调用该对象的 next()会开始运行，直至一个 yield 语句为 next() 方法提供返回值
function* oneDigitPrimes() {
  yield 2;
  yield 3;
  yield 5;
  yield 7;
}

// 调用生成器函数，得到一个生成器
let primes = oneDigitPrimes();

// 生成器是一个迭代器对象，可以迭代回送的值
primes.next().value; // 2
primes.next().value; // 3
primes.next().value; // 5
primes.next().value; // 7
primes.next().done; // true

// 生成器有一个 Symbol.iterator 方法，因此也是可迭代对象
primes[Symbol.iterator](); // primes

// 可以像使用其他可迭代对象一样使用生成器
[...oneDigitPrimes()]; // [2, 3, 5, 7]
let sum = 0;
for (let prime of oneDigitPrimes()) sum += prime;
sum; // 17
```

与常规函数一样，也可以使用表达式定义生成器。同样，只要在 function 关键字前面加个星号即可：

```js
const seq = function* (from, to) {
  for (let i = from; i <= to; i++) yield i;
};
[...seq(3, 5)]; // [3, 4, 5]
```

**在类和对象字面量中，定义方法时可以使用简写形式，省略 function 关键字**。在这种情况下定义生成器，只要在应该出现 function 关键字的地方（如果用的话）加一个星号：

```js
let o = {
  x: 1,
  y: 2,
  z: 3,
  // 这个生成器会回送当前对象的每个键
  *g() {
    for (let key of Object.keys(this)) {
      yield key;
    }
  }
};
[...o.g()]; //["x", "y", "z", "g"]
```

> **注意**：不能使用箭头函数语法定义生成器函数生成器。

生成器在定义可迭代类时特别有用。例如，可以把示例 12-1 中的 `[Symbol.iterator]()` 方法替换成像下面这样更简短的 `*[Symbol.iterator]()` 生成器函数：

```js
*[Symbol.iterator]() {
  for(let x = Math.ceil(this.from); x <= this.to; x++) yield x;
}
```

#### 12.3.1 生成器的示例

如果确实生成自己通过某种计算回送的值，生成器还会有更大的用处。例如，下面这个生成器函数回送的是斐波纳契数：

```js
function* fibonacciSequence() {
  let x = 0,
    y = 1;
  for (;;) {
    yield y;
    [x, y] = [y, x + y];
  }
}
```

这个 fibonacciSequence（生成器函数中有一个无限循环，永远回送值而不返回。如果通过扩展操作符 `...` 来使用它，就会一直循环到内存耗尽，程序崩溃为止。不过，通过设置退出条件，可以在 for/of 循环中使用它：

```js
// 返回第 n 个斐波纳契数
function fibonacci(n) {
  for (let f of fibonacciSequence()) {
    if (n-- <= 0) return f;
  }
}

fibonacci(20); // 10946
```

配合下面这个 take() 生成器，这种无穷生成器可以派上更大的用场：

```js
// 回送指定可迭代对象的前 n 个元素
function* take(n, iterable) {
  let it = iterable[Symbol.iterator](); // 取得可迭代对象的生成器
  // 循环 n 次
  while (n-- > 0) {
    let next = it.next(); // 从迭代器中取得下一项
    // 如果没有更多值了,直接返回
    if (next.done) return;
    else yield next.value; // 否则，回送这个值
  }
}

// 包含前 5 个斐波纳契数的数组
[...take(5, fibonacciSequence())]; // [1, 1, 2, 3, 5]
```

下面也是一个有用的生成器函数，它可以交替回送多个可迭代对象的元素：

```js
// 拿到一个可迭代对象的数组，交替回送它们的元素
function* zip(...iterables) {
  // 取得每个可迭代对象的迭代器
  let iterators = iterables.map(i => i[Symbol.iterator]());
  let index = 0;
  // 在还有迭代器的情况下
  while (iterators.length > 0) {
    // 如果到了最后一个迭代器
    if (index > iterators.length) {
      index = 0; // 返回至第一个迭代器
    }

    let item = iterators[index].next(); // 从下一个迭代器中取得下一项

    // 如果该迭代器完成
    if (item.done) {
      iterators.splice(index, 1); // 则从数组中删除它
    } else {
      // 否则，回送迭代的值
      yield item.value;
      index++; // 并前进到下一个迭代器
    }
  }
}

// 交替3个可迭代对象
[...zip(oneDigitPrimes(), 'ab', [0])]; // [2,"a",0,3,"b",5,7]
```

#### 12.3.2 `yield*` 与递归生成器

除了前面定义的交替多个可迭代对象的 zip() 生成器，按顺序回送它们的元素的生成器函数也很有用。为此，可以写出下面的函数：

```js
function* sequence(...iterables) {
  for (let iterable of iterables) {
    for (let item of iterable) {
      yield item;
    }
  }
}

[...sequence('abc', oneDigitPrimes())]; // ["a", "b", "c", 2, 3, 5, 7]
```

这种在生成器函数中回送其他可迭代对象元素的操作很常见，所以 ES6 为它定义了特殊语法。`yield*` 关键字与 `yield` 类似，但它不是只回送一个值，而是迭代可迭代对象并回送得到的每个值。使用 `yield*` 可以将前面定义的 sequence() 生成器函数简化成这样：

```js
function* sequence(...iterables) {
  for (let iterable of iterables) {
    yield* iterable;
  }
}

[...sequence('abc', o.neDigitPrimes())];
```

数组的 forEach() 方法通常是遍历数组元素的简便方式，但这样写不行：

```js
function* sequence(...iterables) {
  iterables.forEach(iterable => yield * iterable); // 错误
}
```

`yield` 和 `yield*` 只能在生成器函数中使用，而这里嵌套的箭头函数是一个常规函数，不是 `function*` 生成器函数，所以不能出现 `yield`。

`yield*` 可以用来迭代任何可迭代对象，包括通过生成器实现的。这意味着使用 `yeld*` 可以定义递归生成器，利用这个特性可以通过简单的非递归迭代遍历递归定义的树结构。

### 12.4 高级生成器特性

生成器函数最常见的用途是创建迭代器，但生成器的基本特性是可以暂停计算，回送中间结果，然后在某个时刻再恢复计算。这意味着生成器拥有超越迭代器的特性。

#### 12.4.1 生成器函数的返回值

到目前为止，看到的生成器函数都没有 return 语句，或者即便有，也用于提前退出，而不是返回值。与其他函数一样，生成器函数也可以返回值。next() 方法的返回值是一个有 value 或 done 属性的对象。

通常，无论是迭代器还是生成器，如果 value 属性有定义，那么 done 属性未定义或为 false。如果 done 是 true，那么 value 就是未定义的。但对于返回值的生成器，最后一次调用 next() 返回的对象的 value 和 done 都有定义: value 是生成器返回的值，done 是 true（表示没有可迭代的值了）。最后这个值会被 for/of 循环和扩展操作符忽略，但手工迭代时可以通过显式调用 next() 得到：

```js
function* oneAndDone() {
  yield 1;
  return 'done';
}

// 正常迭代中不会出现返回的值
[...oneAndDone()]; // [1]

// 但在显式调用 next() 时可以得到
let generator = oneAndDone();
generator.next(); // { value: 1, done: false }
generator.next(); // { value: "done", done: true }

// 如果生成器已经完成，则不会再返回值
generator.next(); // { value: undefined, done: true }
```

#### 12.4.2 yield 表达式的值

`yield` 是一个表达式（回送表达式），可以有值。调用生成器的 next() 方法时，生成器函数会一直运行直到到达一个 `yield` 表达式。

`yield` 关键字后面的表达式会被求值，该值成为 next() 调用的返回值。此时，生成器函数就在求值 yield 表达式的中途停了下来。下一次调用生成器的 next() 方法时，传给 next() 的参数会变成暂停的 yield 表达式的值。换句话说，生成器通过 yield 向调用者返回值，而调用者通过 next() 给生成器传值。生成器和调用者是两个独立的执行流，它们交替传值（和控制权）。来看下面的代码：

```js
function* smallNumbers() {
  console.log('next() 第一次被调用；参数被丢弃');
  let y1 = yield 1; // y1 == "b"
  console.log('next() 第二次被调用，参数是', y1);
  let y2 = yield 2; // y2 == "c"
  console.log('next() 第三次被调用，参数是', y2);
  let y3 = yield 3; // y3 == ""d
  console.log('next() 第四次被调用,参数是', y3);
  return 4;
}

let g = smallNumbers();
console.log('创建了生成器；代码未运行');

let n1 = g.next('a'); // n1.value = 1
console.log('生成器回送', n1.value);
let n2 = g.next('b'); // n2.value = 2
console.log('生成器回送', n2.value);
let n3 = g.next('c'); // n3.value = 3
console.log('生成器回送', n3.value);
let n4 = g.next('d'); // n4.value = 4
console.log('生成器回送', n4.value);
```

以上代码执行时，会打印下列输出，这些输出演示了两个代码块的交互过程：

```txt
创建了生成器；代码未运行
next() 第一次被调用；参数被丢弃
生成器回送 1
next() 第二次被调用，参数是 b
生成器回送 2
next() 第三次被调用，参数是 c
生成器回送 3
next() 第四次被调用，参数是 d
生成器返回 4
```

> **注意**：第一次调用 next() 启动生成器，但传入的值无法在生成器中访问到。

#### 12.4.3 生成器的 return() 和 throw() 方法

可以接收生成器函数回送或返回的值。同时，也可以通过生成器的 next() 方法给运行中的生成器传值。

除了通过 next() 为生成器提供输入之外，还可以调用它的 return() 和 throw() 方法，改变生成器的控制流。顾名思义，在生成器上调用这两个方法会导致它返回值或抛出异常，就像生成器函数中的一下条语句是 return 或 throw 一样。

如果迭代器定义了 return() 方法且迭代提前停止，解释器会自动调用 return() 方法，从而让迭代器有机会关闭文件或做一些其他清理工作。对生成器而言，无法定义这样一个 return() 方法来做清理工作，但可以在生成器函数中使用 try/finally 语句，保证生成器返回时（在 finally 块中）做一些必要的清理工作。在强制生成器返回时，生成器内置的 return() 方法可以保证这些清理代码运行（生成器也不会再被使用）。

正如 next() 方法可以给运行中的生成器传入任意值一样，生成器的 throw() 方法也提供了（以异常形式）向生成器发送任意信号的途径。调用 throw() 方法就会导致生成器函数抛出异常。如果生成器函数中有适当的异常处理代码，则这个异常就不一定致命，而是可以成为一种改变生成器行为的手段。例如，有一个计数器生成器，不断回送递增的整数。那可以把它写成一旦遇到 throw() 发送的异常就把计数器归零。

当生成器使用 `yield*` 回送其他可迭代对象的值时，调用生成器的 next() 方法会导致调用该可迭代对象 next() 方法。同样，return() 和 throw() 方法也是如此。如果一个生成器的 `yield*` 作用于一个可选代对象，而该对象定义了这两个方法，那么在生成器上调用 return() 或 throw() 会导致相应迭代器的 return() 或 throw() 方法被调用。

> 所有迭代器都必须有 next() 方法。需要在未完成迭代时做清理工作的迭代器应该定义 return() 方法。而任何迭代器都可以定义 throw() 方法，但其现实意义未知。

## 十三. 异步 JS

浏览器中的 JS 程序是典型的事件驱动型程序，即它们会等待用户单击或触发，然后才会真正执行。而基于 JS 的服务器则通常要等待客户端通过网络发送请求，然后才能执行操作。这种异步编程在 JS 中是司空见惯的。本章将介绍三种重要的语言特性，可以让编写异步代码更容易：

- ES6 新增的期约（Promise）是一种对象，代表某个异步操作尚不可用的结果。

- 关键字 `async` 和 `await` 是 ES2017 中引入的，为简化异步编程提供了新语法，它允许开发者将基于期约的异步代码写成同步的形式。

- 异步迭代器和 for/await 循环是 ES2018 中引入的，允许在看起来同步的简单循环中操作异步事件流。

讽刺的是，JS 虽然提供了这些编写异步代码的强大特性，但其核心语言特性中却没有一个是异步的。

### 13.1 使用回调的异步编程

在最基本的层面上，JS 异步编程是使用回调实现的。回调就是函数，可以传给其他函数。而其他函数会在满足某个条件或发生某个（异步）事件时调用（“回调”）这个函数。回调函数被调用，相当于通知满足了某个条件或发生了某个事件，有时这个调用还会包含函数参数，能够提供更多细节。

#### 13.1.1 事件

客户端 JS 编程几乎全都是事件驱动的。也就是说，不是运行某些预定义的计算，而是等待用户做一些事，然后响应用户的动作。用户在按下键盘按键、移动鼠标、单击鼠标或轻点触摸屏设备时，浏览器会生成事件。事件驱动的 JS 程序在特定上下文中为特定类型的事件注册回调函数，而浏览器在指定的事件发生时调用这些函数。这些回调函数叫作事件处理程序或者事件监听器，是通过 `addEventListener()` 注册的：

```js
// 要求浏览器返回一个对象，表示与下面的 CSS 选择符匹配的 HTML <button> 元素
let okay = document.querySelector('#confirmUpdateDialog button.okay');

// 接下来注册一个回调函数，当用户单击该按钮时会被调用
okay.addEventListener('click', applyUpdate);
```

在这个示例中，applyUpdate() 是一个假想的回调函数。调用 `document.querySelector()` 会返回一个对象，表示网页中单个特定的元素。在这元素上调用 `addEventListener()` 可以注册回调函数。`addEventListener()` 的第一个参数是一个字符串，指定要注册的事件类型。

#### 13.1.2 网络事件

JS 编程中另一个常见的异步操作来源是网络请求。浏览器中运行的 JS 可以通过类似下面的代码从 Web 服务器获取数据：

```js
//注意回调参数
function getCurrentVersionNumber(versionCallback) {
  // 通过脚本向后端版本 API 发送一个 HTTP 请求
  let requests = new XMLHttpRequest();
  request.open('GET', 'http://www.example.com/api/version');
  request.send();

  // 注册一个将在响应到达时调用的回调
  request.onload = function () {
    if (request.status === 200) {
      // 如果 HTTP 状态码没问题，则取得版本号并调用回调
      let currentVersion = parseFloat(request.responseText);
      versionCallback(null, currentVersion);
    } else {
      // 否则，通过回调报告错误
      versionCallback(response.statusText, null);
    }
  };
  // 注册另一个将在网络出错时调用的回调
  request.onerror = request.ontimeout = function (e) {
    versionCallback(e.type, null);
  };
}
```

> XMLHttpRequest 类与 XML 没有特殊的关系。在现代客户端 JS 中，这个类很大程度上已经被 `fetch()` <!--TODO 15.11.1-->API 所取代。

客户端 JS 代码可以使用 XMLHttpRequest 类及回调函数来发送 HTTP 请求并异步处理服务器返回的响应。这里定义的 getCurrentVersionNumber() 函数会发送 HTTP 请求并定义事件处理程序，后者在收到服务器响应或者超时或其他错误导致请求失败时会被调用。

> **注意**：如果 XMLHttpRequest 正常工作，则 getCurrentVersionNumber() 调用回调时会给第一个参数传 null，把版本号作为第二个参数。否则，如果发生错误，则 getCurrentVersionNumber() 调用回调时将错误细节作为第一个参数，将 null 作为第二个参数。

#### 13.1.3 Node 中的回调与事件

Node.js 服务器端 JS 环境底层就是异步的，定义了很多使用回调和事件的 API。例如，读取文件内容的默认 API 就是异步的，会在读取文件内容后调用一个回调函数：

```js
const fs = require('fs'); // "fs" 模块有文件系统相关的 API
// 保存程序选项的对象
let options = {
  // 默认选项可以写在这里
};

// 读取配置文件，然后调用回调函数
fs.readFile('config.json', 'utf-8', (err, text) => {
  if (err) {
    // 如果有错误，显示一条警告消息，但仍然继续
    console.warn('Could not read config file:', err);
  } else {
    // 否则，解析文件内容并赋值给选项对象
    Object.assign(options, JSON.parser(text));
  }

  // 无论是什么情况，都会启动运行程序
  startProgram(options);
});
```

Node 的 fs.readFile() 函数以接收两个参数的回调作为最后一个参数。它会异步读取指定文件，然后调用回调。如果读取文件成功，它会把文件内容传给回调的第二个参数。如果发生错误，它会把错误传给回调的第一个参数。在这个示例中，把回调写成了箭头函数，对于这种简单操作，箭头函数既简洁又自然。

Node 也定义一些基于事件的 API。下面这个函数展示了在 Node 中如何通过 HTTP 请求获取 URL 的内容。它包含两层处理事件监听器的异步代码。

> **注意**：Node 使用 `on()` 方法而非 addEventListener() 注册事件监听器。

```js
const https = require('https');

// 读取 URL 的文本内容，将其异步传给回调
function getText(url, callback) {
  // 对 URL 发送一个 HTTP GET 请求
  request = https.get(url);

  // 注册一个函数处理 "response" 事件
  request.on('response', response => {
    // 这个响应事件意味着收到了响应头
    let httpStatus = response.statusCode;

    // 此时并没有收到 HTTP 响应体
    // 因此还要再注册几个事件处理程序，以便收到响应体时被调用
    response.setEncoding('utf-8'); // 应该收到 Unicode 文本
    let body = ''; // 需要在这里累积

    // 每个响应体块就绪时都会调用这个事件处理程序
    response.on('data', chunk => {
      body += chunk;
    });

    // 响应完成时会调用这个事件处理程序
    response.on('end', () => {
      // 如果 HTTP 响应码没问题
      if (httpStatus === 200) {
        callback(null, body); // 把响应体传给回调
      } else {
        // 否则传错误
        callback(httpStatus, null);
      }
    });
  });

  // 这里也为底层网络错误注册了一个事件处理程序
  request.on('error', err => {
    callback(err, null);
  });
}
```

### 13.2 期约

**期约（Promise）是一种为简化异步编程而设计的核心语言特性。期约是一个对象，表示异步操作的结果**。这个结果可能就绪也可能未就绪。而期约 API 在这方面故意含糊：没有办法同步取得期约的值，只能要求期约在值就绪时调用一个回调函数。

假设要定义一个像上一节中 getText() 函数一样的异步 API，但希望它基于期约，没有回调参数，返回一个期约对象。然后调用者可以在这个期约对象上注册一个或多个回调，当异步计算完成时，它们会被调用。

由此，在最简单的情况下，期约就是一种处理回调的不同方式。不过，使用期约也有实际的好处：

- 基于回调的异步编程经常会出现回调多层嵌套的情形，造成代码缩进过多以致难以阅读。期约可以让这种嵌套回调以一种更线性的期约链形式表达出来，因此更容易阅读和推断。

- 回调的另一个问题是难以处理错误。如果一个异步函数（或异步调用的回调）抛出异常，则该异常没有办法传播到异步操作的发起者。异步编程的一个基本事实就是它破坏了异常处理。对此，一个补救方式是使用回调参数严密跟踪和传播错误并返回值。但这样非常麻烦，容易出错。期约则标准化了异步错误处理，通过期约链提供了一种让错误正确传播的途径。

期约表示的是一次异步计算的未来结果。不过，**不能使用它们表示重复的异步计算**。可以使用期约代替 XMLHttpRequest 对象的 “加载” 事件处理程序，因为回调只会被调用一次。但不能使用期约代替 HTML 按钮对象的 “单击” 事件处理程序，因为通常允许用户多次单击按钮。

#### 13.2.1 使用期约

自从核心 JS 语言支持期约以后，浏览器也开始实现基于期约的 API。上一节实现了一个 getText() 函数，它能发送异步 HTTP 请求，并将 HTTP 响应体传给以字符串形式指定的一个回调函数。想象一下这个函数还有一个变体叫 getJSON()，它不接收回调参数，而是把 HTTP 响应体解析成 JSON 格式并返回一个期约。先来看看怎么使用这个返回期约的辅助函数：

```js
getJSoN(url).then(jsonData => {
  // 这是一个回调函数，它会在解析得到 JSON 值之后被异步调用，并接收该 JSON 值作为参数
});
```

getJSON() 向指定的 URL 发送一个异步 HTTP 请求，然后在请求结果待定期间返回一个期约对象。这个期约对象有一个实例方法叫 `then()`。回调函数并没有被直接传给 getJSON()，而是传给了这个 then() 方法。当 HTTP 响应到达时，响应体会被解析为 JSON 格式，而解析后的值会被传给作为 then() 的参数的函数。

可以把这个 `then()` 方法想象成客户端 JS 中注册事件处理程序的 addEventListener() 方法。如果多次调用一个期约对象的 then() 方法，则指定的每个函数都会在预期计算完成后被调用。

不过，**与很多事件监听器不同，期约表示的是一次计算，每个通过 then() 方法注册的函数都只会被调用一次**。有必要指出的是，即便调用 then() 时异步计算已经完成，传给 then() 的函数也会被异步调用。

在最简单的语法层面，then() 方法是期约独有的特性，而直接把 then() 附加给返回期约的函数调用是一种惯用方法，不需要先把期约对象赋值给某个中间变量。

以动词开头来命名返回期约的函数以及使用期约结果的函数也是一种惯例。遵循这个惯例可以增加代码的可读性：

```js
// 假设有一个类似的函数可以显示用户简介
function displayUserProfile(profile) {
  /* 省略实现细节 */
}

// 下面演示了如何在返回期约的函数中使用这个函数
getJSON('/api/user/profile').then(displayUserProfile);
```

**使用期约处理错误**
异步操作，尤其是那些涉及网络的操作，通常都会有多种失败原因。健壮的代码必须处理各种无法避免的错误。

对期约而言，可以通过给 then() 方法传第二个函数来实现错误处理：

```js
getJSON("/api/user/profile").then(displayUserProfile, handleProfileError):
```

期约表示在期约对象被创建之后发生的异步计算的未来结果。因为计算是在返回期约对象之后执行的，所以没办法让该计算像以往那样返回一个值，或者抛出一个可以捕获的异常。传给 `then()` 的函数可以提供一个替代手段。同步计算在正常结束后会向调用者返回计算结果，而基于期约的异步计算在正常结束后，则会把计算结果传给作为 `then()` 的第一个参数的函数。

同步计算出错会抛出一个异常，该异常会沿调用栈向上一直传播到一个处理它的 catch 子句。而异步计算在运行时，它的调用者已经不在调用栈里，因此如果出现错误，根本没办法向调用者抛回异常。

为此，基于期约的异步计算把异常（通常是某种 Error 对象，尽管不是必需的）传给作为 then() 的第二个参数的函数。因此对于上面的代码而言，如果 getJSON() 正常结束，它会把计算结果传给 displayUserProfile()。如果出现了错误，则 getJSON() 会把 Error 对象传给 handleProfileError()。

实际开发中，很少看到给 then() 传两个函数的情况。因为在使用期约时，还有一种更好也更符合传统的错误处理方式。处理这个代码中错误的更符合传统的方式如下：

```js
getJSON('/api/user/profile').then(displayUserProfile).catch(handleProfileError);
```

这行代码意味着 getJSON() 正常返回的结果仍然会传给 displayUserProfile()，但 getJSON() 和 displayUserProfile() 在执行时发生的任何错误都会传给 handleProfileerror()。这个 catch() 方法只是对调用 then() 时以 null 作为第一个参数，以指定的错误处理函数作为第二个参数的一种简写形式。

**期约相关的术语**
在讨论 JS 期约时，“**承诺**” 对应的术语是得到 “**兑现**”（fulfill）和被 “**拒绝**”（reject）。调用一个期约的 then() 方法时传入了两个回调函数。如果第一个回调被调用，说期约得到兑现，而如果第二个回调被调用，说期约被拒绝。如果期约既未兑现，也未被拒绝，那它就是**待定**（pending）。而期约一旦兑现或被拒绝，它则已经**落定**（settle），永远不会再从兑现变成拒绝，反之亦然。

**给期约的定义是：“期约是一个对象，表示异步操作的结果。”** 关键是要记住期约不仅是在某些异步代码完成时注册回调的抽象方式，它还表示该异步代码的结果。如果异步代码正常结束（期约兑现），那这个结果基本上就是代码的返回值。如果异步代码没有正常结束（期约被拒绝），那这个结果就是一个 Error 对象或者某个其他值（如果非异步代码抛出了异常）。任何已经落定的期约都有一个与之关联的值，而这个值不会再改变。如果期约兑现，那这个值会传给作为 then() 的第一个参数注册的回调函数。如果期约被拒绝，那这个值是一个错误，会传给使用 catch() 注册的或作为 then() 的第二个参数注册的回调函数。

之所在要在这里准确定义期约相关的术语，是因为**期约也可能被解决（resolve）。这个解决状态很容易与兑现状态或落定状态混淆，但严格来讲它们并不是一回事。理解这个解决状态是深刻理解期约的一个关键**。

#### 13.2.2 期约链

**期约最重要的优点，就是以线性 `then()` 方法调用链的形式表达一连串异步操作而无须把每个操作嵌套在前一个操作的回调内部**。例如，下面是一个假想的期约链：

```js
fetch(documentURL) // 发送 HTTP 请求
  .then(response => response.json()) // 获取 JSON 格式的响应体
  // 在取得解析后的 JSON时
  .then(document => {
    return render(document); // 把文档显示给用户
  })
  // 在取得渲染的文档后
  .then(rendered => {
    cacheInDatabase(rendered); // 把它缓存在本地数据库中
  })
  .catch(error => handle(error)); // 处理发生的错误
```

前面，有一个在 JS 中使用 XMLHttpRequest 对象发送 HTTP 请求的示例。那个名字有点怪的对象有着古老而简陋的 API，很大程度上已经被更新的基于期约的 Fetch API(参见 15.11.1<!--TODO--> 节)取代。这个新 HTTP API 的最简单形式就是函数 fetch()。传给它一个 URL，它返回一个期约。这个期约会在 HTTP 响应开始到达且 HTTP 状态和头部可用时兑现：

```js
fetch('/api/user/profile').then(response => {
  // 在期约解决时可以访问 HTTP 状态和头部
  if (response.ok && response.headers.get('Content-Type') === 'application/json') {
    // 在这里可以做什么?现在还没有得到响应体
  }
});
```

在 fetch() 返回的期约兑现时，传给它的 then() 方法的函数会被调用，这个函数会收到一个 Response 对象。通过这个响应对象可以访问请求状态和头部，这个对象也定义了 text() 和 json() 等方法，通过它们分别可以取得文本和 JSON 格式的响应体。不过，虽然最初的期约兑现了，但响应体尚未到达。因此用于取得响应体的 text() 和 json() 方法本身也返回期约。下面是使用 fetch() 和 response.json() 方法取得 HTTP 响应体的幼稚方式：

```js
fetch('/api/user/profile').then(response => {
  // 获取 JSON 格式的响应体
  response.json().then(profile => {
    // 在响应体到达时，它会自动被解析为 JSON 格式并传入这个函数
    displayUserProfile(profile);
  });
});
```

说这是使用期约的幼稚方式，是因为像嵌套回调一样嵌套了它们，而这违背了期约的初衷。使用期约的首选方式是像以下代码这样写成一串期约链：

```js
fetch('/api/user/profile')
  .then(response => {
    return response.json();
  })
  .then(profile => {
    displayUserProfile(profile);
  });
```

**像这样在一个表达式中调用多个方法，称其为方法链**。fetch() 函数返回一个期约对象，而这个链上的第一个 then() 调用了返回的期约对象上的一个方法。不过链中还有第二个 then()，这意味着第一个 then() 方法调用本身必须返回一个期约。

有时候，当 API 被设计为使用这种方法链时只会有一个对象，它的每个方法都返回对象本身，以便后续调用。然而这并不是期约的工作方式。在写 then() 调用链时，并不会在一个期约上注册多个回调。相反，每个 then() 方法调用都返回一个新期约对象。这个新期约对象在传给 then() 的函数执行结束才会兑现。

#### 13.2.3 解决期约

fetch() 返回一个期约对象，在兑现时，它会把一个 Response 对象传给注册的回调函数。这个 Response 对象有 text()、json() 以及其他方法，用于获取不同格式的 HTTP 响应体。但由于响应体可能并未到达，这些方法必须返回期约对象。

下面再重写一次抓取 URL 的代码，这一次使用冗余和非惯用方法，以便回调和期约更加明显：

```js
// 回调1
function c1(response) {
  let p4 = response.json();
  return p4; // 返回期约4
}

// 回调2
function c2(profile) {
  displayUserProfile(profile);
}

let p1 = fetch('/api/user/profile'); // 期约1，任务1
let p2 = p1.then(c1); // 期约2，任务2
let p3 = p2.then(c2); // 期约3，任务3
```

为了让期约链有效工作，任务 2 的输出必须成为任务 3 的输入。在该示例中，任务 3 的输入是从 URL 抓取到响应体后又解析生成的 JSON 对象。不过，回调 c1 的返回值并不是一个 JSON 对象，而是表示该 JSON 对象的期约 p4。在 p1 兑现后，c1 被调用，任务 2 开始。而当 p2 兑现时，c2 被调用，任务 3 开始。不过，c1 被调用时任务 2 开始并不意味着任务 2 一定在 c1 返回时结束。期约是用于管理异步任务的，任务 2 是异步的，那么它在回调返回时就不会结束。

当把回调 c 传给 then() 方法时，then() 返回期约 p，并安排好在将来某个时刻异步调用 c。届时，这个回调执行某些计算并返回一个值 v。当这个回调返回值 v 时，p 就以这个值得到解决。当期约以一个非期约值解决时，就会立即以这个值兑现。因此如果 c 返回非期约值，则该返回值就变成了 p 的值，然后 p 兑现，结束。可是，如果这个返回值 v 是一个期约，那么 p 会得到解决但并未兑现。此时，p 要等到期约 ν 落定之后才能落定。如果 ν 兑现了，那么 p 也会以相同的值兑现。如果 ν 被拒绝了，那么 p 也会以相同的理由被拒绝。这就是**期约 “解决” 状态的含义，即一个期约与另一个期约发生了关联。并不知道 p 将会兑现还是被拒绝。但回调 c 已经无法控制这个结果了。说 p 得到了 “解决”，意思就是现在它的命运完全取决于期约 v 会怎么样**。

再回到抓取 URL 的示例。当 c1 返回 p4 时，p2 得到解决。但解决并不等同于兑现，因此任务 3 还不会开始。当 HTTP 响应体全部可用时，json() 方法才可以解析它并以解析后的值兑现 p4。p4 兑现后，p2 也会自动以该解析后的 JSON 值兑现。此时，解析后的 JSON 对象被传给 c2，任务 3 开始。

![通过期约抓取URL.png](./image/通过期约抓取URL.png)

#### 13.2.4 再谈期约和错误

细致的错误处理在异步编程中是非常重要的。在同步代码中，如果不编写错误处理逻辑，至少会看到异常和栈追踪信息，从而能够查找出错的原因。而在异步代码中，未处理的异常往往不会得到报告，错误只会静默发生，导致它们更难调试。好消息是 catch() 方法可以让处理期约错误更容易。

**catch 和 finally 方法**
**期约的 `catch()` 方法实际上是对以 null 为第一个参数、以错误处理回调为第二个参数的 then() 调用的简写**。对于任何期约 p 和错误回调 c，以下两行代码是等价的：

```js
p.then(null, c);
p.catch(c);
```

应该首选 catch() 简写形式：

- 它更简单
- 它的名字对应 try/catch 异常处理语句的 catch 子句。

传统的异常处理在异步代码中并不适用。当同步代码出错时，一个异常会 “沿着调用栈向上冒泡”，直到碰上一个 catch 块。而对于异步期约链，类似的比喻可能是一个错误 “沿着期约链向下流淌”，直到碰上一个 catch() 调用。

在 ES2018 中，期约对象还定义了一个 finally() 方法，其用途类似 try/catch/finally 语句的 finally 子句。如果在期约链中添加一个，finally() 调用，那么传给 finally() 的回调会在期约落定时被调用。无论这个期约是兑现还是被拒绝，回调都会被调用，而且调用时不会给它传任何参数，因此也无法知晓期约是兑现了还是被拒绝了。

但假如需要在任何情况下都运行一些清理代码（如关闭打开的文件或网络连接），那么 finally() 回调是做这件事的理想方式。与 then() 和 catch() 一样，finally() 也返回一个新期约对象。但 finally() 回调的返回值通常会被忽略，

而解决或拒绝调用 finally() 的期约的值一般也会用来解决或拒绝 finally() 返回的期约。不过，如果 finally() 回调抛出异常，就会用这个错误值拒绝 finally() 返回的期约。

前几节展示的 URL 抓取代码并没有做任何错误处理。下面将其重构为一个更接近现实的版本：

```js
fetch('/api/user/ profile') // 发送HTP请求
  .then(response => {
    // 在状态和头部就绪时调用
    if (!response.ok) {
      // 如果遇到 404 Not Found 或类似的错误
      return null; // 可能用户未登录;返回空简介
    }

    // 检查头部以确保服务器发送的是 JSON
    // 如果不是说明服务器坏了，这是一个严重错误
    let type = response.headers.get('content-type');
    if (type !== 'application/json') {
      throw new TypeError('Expected JSON, got ${type}');
    }
    // 如果到这里了，说明状态码是 2xx，内容类型也是 JSON
    // 因此可以安心地返回一个期约，表示解析响应体之后得到的50N对象

    return response.json();
  })
  .then(profile => {
    // 调用时传入解析后的响应体或 null
    if (profile) {
      displayUserProfile(profile);
    } else {
      displayLoggedoutProfilePage();
    }
  })
  .catch(err => {
    if (e instanceof NetworkError) {
      // fetch() 在互联网连接故障时会走到这里
      displayErrorMessage('Check your internet connection.');
    } else if (e instanceof TypeError) {
      // 在上面抛出 TypeError 时会走到这里
      displayErrorMessage('Something is wrong with our server!');
    } else {
      // 走到这里说明发生了意料之外的错误
      console.error(e);
    }
  });
```

下面通过分析不同的错误来理解以上代码。使用之前用过的命名模式：p1 是 fetch() 调用返回的期约。p2 是第一个 then() 调用返回的期约，而 c1 是传给该 then() 调用的回调。p3 是第二个 then() 调用返回的期约，而 c2 是传给该调用的回调。最后，c3 是传给 catch()调用的回调（这个调用也返回一个期约，但不用给它命名）。

第一种可能失败的情况是 fetch() 请求本身。如果网络连接出现故障（或由于其他因素无法发送 HTP 请求），那么期约 p1 会以一个 NetworkError 对象被拒绝，并没有给 then() 调用传错误处理回调函数作为第二个参数，因此 p2 也会以同一个 NetworkError 对象被拒绝（如果给第一个 then() 调用传了错误处理程序，该程序就会被调用。如果它正常返回，p2 会以该处理程序返回的值解决或兑现）。不过，并未传这个处理程序，因此 p2 被拒绝，而 p3 也会以同样的理由被拒绝。此时，c3 错误处理回调会被调用，其中特定于 NetworkError 的代码会运行。

代码的另一种失败方式是 HTTP 请求返回了 404 Not Found 或其他 HTTP 错误。这些都是有效的 HTTP 响应，因此 fetch() 调用不会认为它们是错误。此时，fetch()会把 404 Not Found 封装在一个 Response 对象中并以该对象兑现 p1。p1 兑现导致 c1 被调用。c1 中的代码会检查 Response 对象的 ok 属性，如果检测到它并未收到一个正常的 HTTP 响应，就会简单地返回 null。因为这个返回值并不是期约，所以它会立即兑现 p2，从而导致 c2 被以这个值调用。c2 中的代码显式检查了输入值是否为假，据此向用户显示不同的结果。这是将反常条件作为非错误且实际上不使用错误处理程序来处理的一个示例。

在 c1 中，如果拿到了正常的 HTTP 响应码，但 Content-Type 头部设置得不对，则会发生更严重的错误。代码期待 JSON 格式的响应，因此如果服务器发送的是 HTML、XML 或纯文本，那么后续处理就会出问题。c1 中包含检查 Content-Type 头部的代码。如果这个头部不对，它会将其视为一个不可恢复问题，抛出 TypeError。如果传给 then()（或 catch()）的回调抛出一个值，则这个 then() 返回的期约会以这个抛出的值被拒绝。在这里，c1 的代码抛出 TypeError 会导致 p2 以该 TypeError 对象被拒绝。因为没有给 p2 指定错误处理程序，所以 p3 也会被拒绝。此时不会调用 c2，TypeError 会直接传给 c3，其中包含显式检查和处理这种错误的代码。

> 这个错误对象是以常规、同步 throw 语句抛出的，而该错误最终在期约链中被一个 catch() 方法调用处理。这充分说明了为什么应该尽量使用这种简写形式，而不是给 then() 传第二个参数。同时也说明了为什么在期约链末尾添加一个 catch() 调用是个惯例。

尽管在期约链末尾加上一个 catch() 来清理（或至少记录）链调用中发生的任何错误是一个惯例，在期约链的任何地方使用 catch() 也是完全有效的。如果期约链的某一环会因错误而失败，而该错误属于某种可恢复的错误，不应该停止后续环节代码的运行，那么可以在链中插入一个 catch() 调用，得到类似如下所示的代码：

```js
startAsyncOperation()
  .then(doStageTwo)
  .catch(recoverFromStageTwoError)
  .then(doStageThree)
  .then(doStageFour)
  .catch(logStageThreeAndFourErrors);
```

传给 catch() 的回调只会在上一环的回调抛出错误时才会被调用。如果该回调正常返回，那么这个 catch() 回调就会被跳过，之前回调返回的值会成为下一个 then() 回调的输入。还有 catch() 回调不仅仅可以用于报告错误，还可以处理错误并从错误中恢复。一个错误只要传给了 catch()回调，就会停止在期约链中向下传播。catch() 回调可以抛出新错误，但如果正常返回，那这个返回值就会用于解决或兑现与之关联的期约，从而停止错误传播。

在刚才的代码示例中，无论 startAsyncOperation() 还是 doStageTwo() 抛出错误，都会调用 recoverFromStageTwoError() 函数。如果 recoverFromStageTwoError() 正常返回，那么它的返回值会传给 doStageThree()，异步操作将正常继续。而如果 recoverFromStageTwoError() 不能恢复，它自己应该抛出一个错误（或者把传给它的错误再抛出来）。此时，doTageThree() 和 doStageFour() 都不会被调用，recoverFromStageTwoError()
抛出的错误会直接传给 logStageThreeAndFourErrors()。

有时候，在复杂的网络环境下，错误可能多少会以某种概率随机发生。处理这些错误时，可以简单地重新发送异步请求。假设写了一个基于期约的操作来查询数据库：

```js
queryDatabase().then(displayTable).catch(displayDatabaseError);
```

现在假设瞬间网络负载问题会导致这个查询有 1% 的失败概率。一个简单的解决方案是通过 catch() 调用来重新发送请求：

```js
queryDatabase()
  .catch(e => wait(500).then(queryDatabase)) // 如果失败，等待并重试
  .then(displayAble)
  .catch(displayDatabaseError);
```

#### 13.2.5 并行期约

有时候，希望并行执行多个异步操作。函数 `Promise.all()` 可以做到这一点。`Promise.all()` 接收一个期约对象的数组作为输入，返回一个期约。如果输入期约中的任意一个拒绝，返回的期约也将拒绝；否则，返回的期约会以每个输入期约兑现值的数组兑现。例如，想抓取多个 URL 的文本内容，可以使用如下代码：

```js
// 先定义一个URL数组
const urls = [
  /* 零或多个URL */
];

// 然后把它转换为一个期约对象的数组
promises = urls.map(url => fetch(url).then(r => r.text()));
// 现在用一个期约来并行运行数组中的所有期约
Promise.all(promises)
  .then(bodies => {
    /* 处理得到的字符串数组 */
  })
  .catch(e => console.error(e));
```

Promise.all() 实际上比刚才描述的稍微更灵活一些。其输入数组可以包含期约对象和非期约值。如果这个数组的某个元素不是期约，那么它就会被当成一个已兑现期约的值，被原封不动地复制到输出数组中。

由 Promise.all() 返回的期约会在任何一个输入期约被拒绝时拒绝。这会在第一个拒绝发生时立即发生，此时其他期约的状态可能还是待定。在 ES2020 中，Promise.allSettled() 也接收一个输入期约的数组，与 Promise.all() 一样。但是，Promise.allSettled() 永远不拒绝返回的期约，而是会等所有输入期约全部落定后兑现。这个返回的期约解决为一个对象数组，其中每个对象都对应一个输入期约，且都有一个 status 属性，值为 fulfilled 或 rejected。如果 status 属性值为 fulfilled，那么该对象还会有一个 value 属性，包含兑现的值。而如果 status 属性值为 rejected，那么该对象还会有一个 reason 属性，包含对应期约的错误或拒绝理由：

```js
Promise.allSettled([Promise.resolve(1), Promise.reject(2), 3]).then(results => {
  results[0]; // { status: "fulfilled", value: 1 }
  results[1]; // { status: "rejected", reason: 2 }
  results[2]; // { status: "fulfilled", value:3 }
});
```

可能想同时运行多个期约，但只关心第一个兑现的值。此时，可以使用 Promise.race() 而不是 Promise.all()。Promise.race() 返回一个期约，这个期约会在输入数组中的期约有一个兑现或拒绝时马上兑现或拒绝（或者，如果输入数组中有非期约值，则直接返回其中第一个非期约值）。

#### 13.2.6 创建期约

在前面的几个示例中，一直使用返回期约的函数 fetch()，因为它是浏览器内置返回期约的一个最简单的函数。关于期约的讨论也建立在假想的返回期约的函数 getJSON() 和 wait() 上。

**基于其他期约的期约**
如果有其他返回期约的函数，那基于这个函数写一个返回期约的函数很容易，给定一个期约，调用 then() 就可以创建（并返回）一个新期约。因此，如果以已有的 fetch() 函数为起点，可以以像下面这样实现 getJSON()：

```js
function getJSON(url) {
  return fetch(url).then(response => response.json());
}
```

fetch() API 的 Response 对象有一个预定义的 json() 方法。这个 json() 方法返回一个期约，这个期约又通过回调返回。所以，getJSON() 返回的期约会解决为 response.json() 返回的期约。当该期约兑现时，getJSON() 返回的期约也会以相同的值兑现。

> **注意**：getJSON() 的实现没有错误处理。没有检查 response.ok 和 Content-Type 头部，只是简单地让 json() 方法在响应体无法解析为 JSON 时以 SyntaxError 拒绝返回的期约。

下面再写另一个返回期约的函数，这一次把 getJSON() 作为初始期约的来源：

```js
function getHighScore() {
  return getJSON('/api/user/profile').then(profile => profile.highScore);
}
```

**基于同步值的期约**
有时候，可能需要实现一个已有的基于期约的 API，并从一个函数返回期约、尽管要执行的计算实际上并不涉及异步操作。在这种情况下，静态方法 Promise.resolve() 和 Promise.reject() 可以帮助达成目的。Promise.resolve() 接收一个值作为参数并返回一个会立即（但异步）以该值兑现的期约。类似地，Promise.reject() 也接收一个参数，并返回一个以该参数作为理由拒绝的期约（明确一下：这两个静态方法返回的期约在被返回时并未兑现或拒绝，但它们会在当前同步代码块运行结束后立即兑现或拒绝。通常，这会在几毫秒之后发生，除非有很多待定的异步任务等待运行）。

解决期约并不等同于兑现期约。调用 Promise.resolve() 时，通常会传入兑现值，创建一个很快就兑现为该值的期约对象。如果把期约 p1 传给 Promise.resolve()，它会返回一个新期约 p2，p2 会立即解决，但要等到 p1 兑现或被拒绝时才会兑现或被拒绝。

写一个基于期约的函数，其中值是同步计算得到的，但使用 Promise.resolve() 异步返回是可能的，但不常见。不过在一个异步函数中包含同步执行的代码，通过 Promise.resolve() 和 Promise.reject() 来处理这些同步操作的值倒是相当常见。特别地，如果在开始异步操作前检测错误条件（如坏参数值），那可以通过返回 Promise.reject() 创建的期约来报告该错误（这种情况下也可以同步抛出一个错误，但这种做法并不推荐，因为这样一来，函数的调用者为了处理错误既要写同步的 catch 子句，还要使用异步的 catch() 方法）。最后，Promise.resolve() 有时候也可以用来创建一个期约链的第一个期约。

**从头开始创建期约**
对于 geJSON() 和 getHighScore()，都是一开始先调用一个现有函数得到初始期约，然后再通过调用该期约的 then() 方法创建并返回新期约。如果不能使用一个返回期约的函数作为起点，那么怎么写一个返回期约的函数呢？这时候，可以使用 Promise() 构造函数来创建一个新期约对象，而且可以完全控制这个新期约。过程如下：

1. 调用 Promise() 构造函数，给它传一个函数作为唯一参数。传的这个函数需要写成接收两个参数，按惯例要将它们命名为 resolve 和 reject。
2. 构造函数同步调用函数并为 resolve 和 reject 参数传入对应的函数值。
3. 调用函数后，Promise() 构造函数返回新创建的期约。这个返回的期约由传给 Promise() 构造函数的函数控制。传的函数应该执行某些异步操作，然后调用 resolve 函数解决或兑现返回的期约，或者调用 reject 函数拒绝返回的期约。函数不一定非要执行异步操作，可以同步调用 resolve 或 reject，但此时创建的期约仍会异步解决、兑现或拒绝。

下面是前面几个示例中用到的基于期约的 wait() 函数的实现：

```js
// 创建并返回新期约
function wait(duration) {
  // 这两个函数控制期约
  return new Promise((resolve, reject) => {
    // 如果参数无效，拒绝期约
    if (duration < 0) {
      reject(new Error('Time travel not yet implemented'));
    }
    // 否则，异步等待，然后解决期约
    // setTimeout 调用 resolve() 时未传参，这意味着新期约会以 undefined 值兑现
    setTimeout(resolve, duration);
  });
}
```

> **注意**：用来控制 Promise() 构造函数创建的期约命运的那对函数叫 resolve() 和 reject()，不是 fulfill() 和 reject()。

如果把一个期约传给 resolve()，返回的期约将会解决为该新期约。不过，通常在这里都会传一个非期约值，这个值会兑现返回的期约。

示例 13-1 是另一个使用 Promise() 构造函数的示例。这个示例实现了在 Node 中使用的 getJSON() 函数，而 Node 并没有内置的 fetch() API。这个示例中也用到了回调和事件处理程序，因此它很好地示范了如何在其他异步编程风格基础上实现基于期约的 API：

```js
// 示例 13-1：异步 getJSON() 函数
const http = require('http');

function getJSON(url) {
  // 创建并返回一个新期约
  return new Promise((resolve, reject) => {
    // 向指定的 URL 发送一个 HTTP GET 请求
    // 收到响应时调用
    request = http.get(url, response => {
      // 如果HTTP状态码不对，拒绝这个期约
      if (response.statusCode !== 200) {
        reject(new Error(`HTTP status ${response.statusCode}`));
        response.resume(); // 这样不会导致内存泄漏
      }
      // 如果响应头不对同样拒绝
      else if (response.headers['content-type'] !== 'application/json') {
        reject(new Error('Invalid content-type'));
        response.resume(); // 不会造成内存泄漏
      } else {
        // 否则，注册事件处理程序读取响应体
        let body = '';
        response.setEncoding('utf-8');
        response.on('data', chunk => {
          body + chunk;
        });
        response.on('end', () => {
          // 接收完全部响应体后，尝试解析它
          try {
            let parsed = JSON.parse(body);
            // 如果解析成功，兑现期约
            resolve(parsed);
          } catch (e) {
            // 如果解析失败，拒绝期约
            reject(e);
          }
        });
      }
    });

    // 如果收到响应之前请求失败，也会拒绝期约
    request.on('error', error => {
      reject(error);
    });
  });
}
```

#### 13.2.7 串行期约

使用 Promise.all() 可以并行执行任意数量的期约，而期约链则可以表达一连串固定数量的期约。不过，按顺序运行任意数量的期约有点棘手。假设有一个要抓取的 URL 数组，但为了避免网络过载，想一次只抓取一个 URL。假如这个数组是任意长度，内容也未知，那就不能提前把期约链写出来，而是要像以下代码这样动态构建：

```js
function fetchSequentially(urls) {
  // 抓取 URL 时，要把响应体保存在这里
  const bodies = [];

  // 这个函数返回一个期约，它只抓取一个 URL 响应体
  function fetchOne(url) {
    return fetch(url)
      .then(response => response.text())
      .then(body => {
        // 把响应体保存到数组，这里故意省略了返回值（返回 undefined）
        bodies.push(body);
      });
  }

  // 从一个立即（以 undefined 值）兑现的期约开始
  let p = Promise.resolve(undefined);

  // 现在循环目标 URL，构建任意长度的期约链
  // 链的每个环节都会拿取一个 URL 的响应体
  for (url of urls) {
    p = p.then(() => fetchOne(url));
  }

  // 期约链的最后一个期约兑现后，响应体数组（bodies）也已经就绪。
  // 因此，可以将这个 bodies 数组通过期约返回。
  // 注意，这里并未包含任何错误处理程序，希望把错误传播给调用者
  return p.then(() => bodies);
}
```

有了这个 fetchSequentially() 函数定义，就可以像使用前面演示的 Promise.all() 并行抓取一样，按顺序依次抓取每个 URL：

```js
fetchSequentially(urls)
  .then(bodies => {
    /* 处理抓到的字符串数组 */
  })
  .catch(e => console.error(e));
```

fetchSequentially() 函数首先会创建一个返回后立即兑现的期约。然后基于这个初始期约构建一个线性的长期约链并返回链中的最后一个期约。这有点类似摆好一排多米诺骨牌，然后推倒第一张。

还有一种（可能更简练）的实现方式。不是事先创建期约，而是让每个期约的回调创建并返回下一个期约。换句话说，不是创建并连缀一串期约，而是创建解决为其他期约的期约。这种方式创建的就不是多米诺骨牌形式的期约链了，而是像俄罗斯套娃那样一系列相互嵌套的期约。此时，代码可以返回第一个（最外层的）期约，知道它最终会兑现（或拒绝）为序列中最后一个（最内层的）期约兑现（或拒绝）的值。下面这个 promiseSequence() 函数是一个通用函数，不限于抓取 URL。

> **注意**：promiseSequence() 内部的那个函数，看起来它是在递归地调用自身，但因为这个 “递归” 调用是通过 then() 方法完成的，所以不会有任何传统递归的行为发生。

```js
// 这个函数接收一个输入值数组和一个 promiseMaker 函数
// 对输入数组中的任何值 x，promiseMaker(x) 都应该返回一个兑现为输出值的期约。
// 这个函数返回一个期约，该期约最终会兑现为一个包含计算得到的输出值的数组

// promiseSequence() 不是一次创建所有期约然后让它们并行运行，而是每次只运行一个期约，直到上一个期约兑现之后，才会调用 promiseMaker() 计算下一个值
function promiseSequence(inputs, promiseMaker) {
  // 为数组创建一个可以修改的私有副本
  inputs = [...inputs];

  // 这是要用作期约回调的函数，它的伪递归魔术是核心逻辑
  function handleNextInput(outputs) {
    if (inputs.length === 0) {
      // 如果没有输入值了，则返回输出值的数组
      // 这个数组最终兑现这个期约，以及所有之前已经解决但尚未兑现的期约
      return outputs;
    } else {
      // 如果还有要处理的输入值，那么将返回一个期约对象，把当前期约解决为一个来自新期约的未来值
      let nextInput = inputs.shift(); // 取得下一个输入值
      return (
        promiseMaker(nextInput) // 计算下一个输出值
          // 然后用这个新输出值创建一个新输出值的数组
          .then(output => outputs.concat(output))
          // 然后 “递归”，传入新的、更长的输出值的数组
          .then(handleNextInput)
      );
    }
  }
}

// 从一个以空数组兑现的期约开始使用上面的函数作为它的回调
return Promise.resolve([]).then(handleNextInput);
```

这个 promiseSequence() 故意写成了通用的。可以像下面这样使用它抓取多个 URL 的响应：

```js
// 传入一个 URL，返回一个以该 URL 的响应体文本兑现的期约
function fetchBody(url) {
  return fetch(url).then(r => r.text());
}

// 使用它依次抓取一批 URL 的响应体
promiseSequence(urls, fetchBody)
  .then(bodies => {
    /* 处理字符串数组 */
  })
  .catch(console.error);
```

### 13.3 async 和 await

ES2017 新增了两个关键字：`async` 和 `await`，代表异步 JS 编程范式的迁移。这两个新关键字极大简化了期约的使用。虽然理解期约的工作原理仍然很重要，但在通过 async 和 await 使用它们时，很多复杂性（有时候甚至连期约自身的存在感）都消失了。async 和 await 接收基于期约的高效代码并且隐藏期约，让异步代码像低效阻塞的同步代码一样容易理解和推理。

#### 13.3.1 await 表达式

**`await` 关键字接收一个期约并将其转换为一个返回值或一个抛出的异常**。给定 p，表达式 await p 会一直等到 p 落定。如果 p 兑现，那么 await p 的值就是兑现 p 的值。如果 p 被拒绝，那么 await p 表达式就会抛出拒绝 p 的值。通常并不会使用 await 来接收一个保存期约的变量，更多的是把它放在一个会返回期约的函数调用前面：

```js
let response = await fetch('/api/user/profile');
let profile = await response.json();
```

这里的关键是要明白，`await` 关键字并不会导致程序阻塞或者在指定的期约落定前什么都不做。代码仍然是异步的，而 await 只是掩盖了这个事实。这意味着任何使用 await 的代码本身都是异步的。

#### 13.3.2 async 函数

因为任何使用 `await` 的代码都是异步的，所以有一条重要的规则：**只能在以 `async` 关键字声明的函数内部使用 `await` 关键字**。以下是使用 async 和 await 将前面的 getHighScore() 函数重写之后的样子：

```js
async function getHighScore() {
  let response = await fetch('/api/user/profile');
  let profile = await response.json();
  return profile.highScore;
}
```

把函数声明为 `async` 意味着该函数的返回值将是一个期约，即便函数体中不出现期约相关的代码。如果 `async` 函数会正常返回，那么作为该函数真正返回值的期约对象将解决为这个明显的返回值。如果 `async` 函数会抛出异常，那么它返回的期约对象将以该异常被拒绝。

这个 getHighScore() 函数前面加了 async，因此它会返回一个期约。由于它返回期约，所以可以对它使用 await 关键字：

```js
displayHighScore(await getHighScore());
```

> **注意**：这行代码只有在它位于另一个 `async` 函数内部时才能运行！可以在 `async` 函数中嵌套 `await` 表达式，多深都没关系。但如果是在顶级或因为某种原因在一个非 async 函数内部，那么就不能使用 `await` 关键字，而是必须以常规方式来处理返回的期约。

```js
getHighScore().then(displayScore).catch(console.error);
```

> **可以对任何函数使用 `async` 关键字**。例如，可以在 function 关键字作为语句和作为表达式时使用，也可以对箭头函数和类及对象字面量中的简写方法使用。

#### 13.3.3 等候多个期约

使用 `async` 重写了 getJSON( )函数：

```js
async function getJSON(url) {
  let response = await fetch(url);
  let body = await response.json();
  return body;
}
```

再假设想使用这个函数抓取两个 JSON 值：

```js
let value1 = await getJSON(url1);
let value2 = await getJSON(url2);
```

以上代码的问题在于它不必顺序执行。这样写就意味着必须等到抓取第一个 URL 的结果之后才会开始抓取第二个 URL 的值。如果第二个 URL 并不依赖从第一个 URL 抓取的值，那么应该可以尝试同时抓取两个值。这个示例显示了 `async` 函数本质上是基于期约的。要等候一组并发执行的 async 函数，可以像使用期约一样直接使用 Promise.all()：

```js
let [value1, value2] = await Promise.all([getJSoN(url1), getJSoN(url2)]);
```

#### 13.3.4 实现细节

假设写了一个这样的 async 函数：

```js
async function f(x) {
  /* 函数体 */
}
```

可以把这个函数想象成一个返回期约的包装函数，它包装了原始函数的函数体：

```js
function f(x) {
  return new Promise(function (resolve, reject) {
    try {
      resolve(function (x) {
        /* 函数体 */
      })(x);
    } catch (e) {
      reject(e);
    }
  });
}
```

像这样以语法转换的形式解释 await 关键宇比较困难。但可以把 await 关键字想象成分隔代码体的记号，它们把函数体分隔成相对独立的同步代码块。ES2017 解释器可以把函数体分割成一系列独立的子函数，每个子函数都将被传给位于它前面的以 await 标记的那个期约的 then() 方法。

### 13.4 异步迭代

本章开始先讨论了基于回调和事件的异步编程，之后在介绍期约时，也强调过它只适合单次运行的异步计算，不适合与重复性异步事件来源一起使用。由于一个期约无法用于连续的异步事件，也不能使用常规的 async 函数和 await 语句来处理这些事件。

ES2018 为此提供了一个解决方案。异步迭代器与[迭代器](#十二-迭代器与生成器)类似，但它们是基于期约的，而且使用时要配合一个新的 fo/of 循环：for/await。

#### 13.4.1 for/await 循环

Node 12 的可读流实现了异步可选代。这意味着可以像下面这样使用 for/await 循环从个流中读取连续的数据块：

```js
const fs = require('fs');
async function parseFile(filename) {
  let stream = fs.createReadStream(filename, { encoding: 'utf-8' });
  for await (let chunk of stream) {
    parseChunk(chunk); // 假设 parseChunk() 是在其他地方定义的
  }
}
```

与常规的 await 表达式类似，for/await 循环也是基于期约的。大体上说，这里的异步迭代器会产生一个期约，而 for/await 循环等待该期约兑现，将兑现值赋给循环变量，然后再运行循环体。之后再从头开始，从迭代器取得另一个期约并等待这个新期约兑现。

```js
// 假设有如下 URL 数组
const urls = [url1, url2, url3];

// 可以对每个 URL 调用 fetch() 以取得一个期约的数组
const promises = urls.map(url => fetch(url));
```

此时可以使用 Promise.all() 来等待数组中的所有期约兑现。但假设希望第一次抓取的结果尽快可用，不想因此而等待抓取其他 URL。数组是可迭代的，因此可以使用常规的 for/of 循环来迭代这个期约数组：

```js
for (const promise of promises) {
  response = await promise;
  handle(response);
}
```

这个示例代码使用了常规的 for/of 循环和一个常规迭代器。但由于这个迭代器返回期约，所以也可以使用新的 for/await 循环让代码更简单：

```js
for await (const response of promises) {
  handle(response);
}
```

这里的 for/await 循环只是把 await 调用内置在循环中，从而让代码稍微简洁了一点。但这两个示例做的事情是一样的。关键在于，这两个示例都只能在以 async 声明的函数内部才能使用。从这方面来说，for/await 循环与常规的 await 表达式没什么不同。

不过，最重要的是应该知道，在这个示例中是对一个常规的迭代器使用了 for/wait。如果是完全异步的迭代器，那么还会更有意思。

#### 13.4.2 异步迭代器

可迭代对象是可以在 for/of 循环中使用的对象。它以一个符号名字 Symbol.iterator 定义了一个方法，该方法返回一个迭代器对象。这个迭代器对象有一个 next() 方法，可以反复调用它获取可迭代对象的值。迭代器对象的这个 next()方法返回迭代结果对象。迭代结果对象有一个 value 属性或一个 done 属性。

异步迭代器与常规迭代器非常相似，但有两个重要区别：

- 异步可迭代对象以符号名字 Symbol.asyncIterator 而非 Symbol.iterator 实现了一个方法（如前所示，for/await 与常规迭代器兼容，但它更适合异步可迭代对象，因此会在尝试 Symbol.iterator 方法前先尝试 Symbol.asyncIterator 方法）。

- 异步迭代器的 next() 方法返回一个期约，解决为一个迭代器结果对象，而不是直接返回一个迭代器结果对象。

上一节，当对一个常规同步可迭代的期约数组使用 for/await 时，操作的是同步迭代器结果对象。其中，value 属性是一个期约对象，但 done 属性是一个同步值。真正的异步迭代器返回的是迭代结果对象的期约，其中 value 和 done 都是异步值。两者的区别很微妙：对于异步迭代器，关于迭代何时结束的选择可以异步实现。

#### 13.4.3 异步生成器

实现迭代器的最简单方式通常是使用生成器。同理，对于异步迭代器也是如此，可以使用声明为 async 的生成器函数来实现它。声明为 async 的异步生成器同时具有异步函数和生成器的特性，即可以像在常规异步函数中一样使用 await，也可以像在常规生成器中一样使用 yield。但通过 yield 生成的值会自动包装到期约中。就连异步生成器的语法也是 `async function` 和 `function *` 的组合：`async function *`。下面这个示例展示了使用异步生成器和 for/await 循环，通过循环代码而非 setInterval() 回调函数实现以固定的时间间隔重复运行代码：

```js
// 一个基于期约的包装函数，包装 setTimeout() 以实现等待，返回一个期约，这个期约会在指定的毫秒数之后兑现
function elapsedTime(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 一个异步迭代器函数，按照固定的时间间隔递增并生成指定（或无穷）个数的计数器
async function* clock(interval, max = Infinity) {
  // 常规for循环
  for (let count = 1; count <= max; count++) {
    await elapsedTime(interval); // 等待时间流逝
    yield count; // 生成计数器
  }
}

// 一个测试函数，使用异步迭代器和 for/await
// 使用 async 声明，以便使用 for/await
async function test() {
  // 循环100次，每次间隔 30 ms
  for await (let tick of clock(300, 100)) {
    console.log(tick);
  }
}
```

#### 13.4.4 实现异步迭代器

除了使用异步生成器实现异步迭代器，还可以直接实现异步迭代器。这需要定义一个包含 Symbol.asyncIterator() 方法的对象，该方法要返回一个包含 next() 方法的对象，而这个 next() 方法要返回解决为一个迭代器结果对象的期约。在下面的代码中，重新实现了前面示例中的 clock() 函数。但它在这里并不是一个生成器，只是会返回一个异步可迭代对象。

> **注意**：这个示例中的 next() 方法，它并没有显式返回期约，只是把它声明为了 `async next()`。

```js
function clock(interval, max = Infinity) {
  // 一个 setTimeout 的期约版，可以实现等待
  // 注意：参数是一个绝对时间而非时间间隔
  function until(time) {
    return new Promise(resolve => setTimeout(resolve, time - Date.now()));
  }

  // 返回一个异步可迭代对象
  return {
    startTime: Date.now(), // 记住开始时间
    count: 1, // 记住第几次迭代
    async next() {
      // 方法使其成为迭代器
      if (this.count > max) {
        // 该结束了吗
        return { done: true }; //表示结束的迭代结果
      }
      // 计算下次迭代什么时间开始
      let targetTime = this.startTime + this.count * interval;
      // 等待该时间到来
      await until(targetTime);
      // 在迭代结果对象中返回计数器的值
      return { value: this.count++ };
    },
    // 这个方法意味着这个迭代器对象同时也是一个可迭代对象
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
```

这个基于迭代器的 clock() 函数修复了基于生成器版本的一个缺陷。在这个更新的代码中，使用的是每次迭代应该开始的绝对时间减去当前时间，得到要传给 setTimeout() 的时间间隔。如果在 for/await 循环中使用 clock()，这个版本会更精确地按照指定的时间间隔运行循环迭代。因为这个时间间隔包含了循环体运行的时间。不过这个修复并不仅仅与计时精度有关。for/await 循环在开始下一次迭代之前，总会等待一次迭代返回的期约兑现。但如果不是在 for/await 循环中使用异步迭代器，那可以在任何时候调用 next() 方法。对于基于生成器的 clock() 版本，如果连续调用 3 次 next()方法，就可以得到 3 个期约，而这 3 个期约将几乎同时兑现，而这可能并非是想要的。在这里实现的这个基于迭代器的版本则没有这个问题。

**异步迭代器的优点的是它允许表示异步事件流或数据流**。前面讨论的 clock() 函数写起来相当简单，因为其中的异步性源于由我们决定的 setTimeout() 调用。但是，在面对其他异步源时，比如事件处理程序的触发，要实现异步迭代器就会困难很多。因为通常只有一个事件处理程序响应事件，但每次调用迭代器的 next() 方法都必须返回一个独一无二的期约对象，而在第一个期约解决之前很有可能出现多次调用 next() 的情况。这意味着任何异步迭代器方法都必须能在内部维护一个期约队列，让这些期约按照异步事件发生的顺序依次解决。如果把这个期约队列的逻辑封装到一个 AsyncQueue 类中，再基于这个类编写异步迭代器就会简单多了。

下面定义的这个 AsyncQueue 类包含一个队列类应有的 enqueue() 和 dequeue() 方法。其中，dequeue() 方法返回一个期约而不是一个实际的值。这意味着在尚未调用 enqueue() 之前调用 dequeue() 是没有问题的。这个 AsyncQueue 类也是一个异步迭代器，有意设计为与 for/await 循环配合使用，其循环体会在每次入队一个新值时运行一次（AsyncQueue 类有一个 close()方法，一经调用就不能再向队列中加入值了。当一个关闭的队列变空时，for/await 循环会停止循环）。

> **注意**：AsyncQueue 类的实现没有使用 async 和 await，而是直接使用期约。

```js
/**
 * 一个异步可迭代队列类。使用 enqueue() 添加值，
 * 使用 dequeue()移除值。dequeue() 返回一个期约
 * 这意味着，值可以在入队之前出队。这个类实现了 [Symbol.asyncIterator] 和 next()
 * 因而可以与 for/await 循环一起配合使用（这个循环在调用 close() 方法前不会终止）
 **/
class AsyncQueue {
  constructor() {
    // 已经入队尚未出队的值保存在这里
    this.values = [];
    // 如果期约出队时它们对应的值尚未入队，就把那些期约的解决方法保存在这里
    this.resolvers = [];
    // 一旦关闭，任何值都不能再入队，也不会再返回任何未兑现的期约
    this.closed = false;
  }

  enqueue(value) {
    if (this.closed) {
      throw new Error('AsyncQueue closed');
    }
    if (this.resolvers.length > 0) {
      // 如果这个值已经有对应的期约，则解决该期约
      const resolve = this.resolvers.shift();
      resolve(value);
    } else {
      // 否则，让它去排队
      this.values.push(value);
    }
  }

  dequeue() {
    if (this.values.length > 0) {
      // 如果有一个排队的值，为它返回一个解决期约
      const value = this.values.shift();
      return Promise.resolve(value);
    } else if (this.closed) {
      // 如果没有排队的值，而且队列已关闭
      // 返回一个解决为 EOS（流终止）标记的期约
      return Promise.resolve(AsyncQueue, EOS);
    } else {
      // 否则，返回一个未解决的期约将解决方法排队，以便后面使用
      return new Promise(resolve => {
        this.resolvers.push(resolve);
      });
    }
  }

  close() {
    // 一旦关闭，任何值都不能再入队
    // 因此以 EOS 标记解决所有待决期约
    while (this.resolvers.length > 0) {
      this.resolvers.shift()(AsyncQueue.EOS);
    }
    this.closed = true;
  }

  // 定义这个方法，让这个类成为异步可迭代对象
  [SymboL.asyncIterator]() {
    return this;
  }

  // 定义这个方法，让这个类成为异步迭代器 dequeue() 返回的期约会解决为一个值，
  // 或者在关闭时解决为 EOS 标记。这里，需要返回一个解决为迭代器结果对象的期约
  next() {
    return this.dequeue().then(value =>
      value === AsyncQueue.EOS ? { value: undefined, done: true } : { value: value, done: false }
    );
  }
}

// dequeue() 方法返回的标记值，在关闭时表示 “流终止”
AsyncQueue.EOS = Symbol('end-of-stream');
```

因为这个 AsyncQueue 类定义了异步迭代的基础，所以可以创建更有意思的异步迭代器，只要简单地对值异步排队即可。下面这个示例使用 AsyncQueue 产生了一个浏览器事件流，可以通过 for/await 循环来处理：

```js
// 把指定文档元素上指定类型的事件推入一个 AsyncQueue 对象，然后返回这个队列，以便将其作为事件流来使用
function eventStream(elt, type) {
  const q = new AsyncQueue(); // 创建一个队列
  elt.addEventlistener(type, e => q.enqueue(e)); // 入队事件
  return q;
}

async function handleKeys() {
  // 取得一个 keypress 事件流，对每个事件都执行一次循环
  for await (const event of eventStream(document, 'keypress')) {
    console.log(event.key);
  }
}
```

## 十四. 元编程

本章介绍一些高级 JS 特性，这些特性日常使用不多，但是对编写可重用的库极其有用。这里的很多特性都可以宽泛地归类为 “元编程” 特性。如果说常规编程是写代码去操作数据，那么元编程就是写代码去操作其他代码。在像 JS 这样的动态语言中，编程与元编程之间的界限是模糊的。在更习惯于静态语言的程序员眼里，即便是迭代对象属性的 for/in 循环这个小小的能力都可能被打上 “元” 标签。

主要介绍的元编程特性如下：

- 控制对象属性的可枚举、可删除和可配置能力。
- 控制对象的可扩展能力，以及创建 “封存”（sealed）和 “冻结”（frozen）对象。
- 查询和设置对象的原型。
- 使用公认符号（well-know symbol）调优类型的行为。
- 使用模板标签函数创建 DSL（Domain-Specific Language，领域专用语言）
- 通过反射 API 探究对象。
- 通过代理控制对象行为。

### 14.1 属性的特性

**JS 的属性有名字和值，但每个属性也有 3 个关联的特性，用于指定属性的行为以及可以对它执行什么操作**。

- **可写**（writable）特性指定是否可以修改属性的值。
- **可枚举**（enumerable）特性指定是否可以通过 for/in 循环和 object.keys() 方法枚举属性。
- **可配置**（configurable）特性指定是否可以删除属性，以及是否可以修改属性的特性。

对象字面量中定义的属性，或者通过常规赋值方式给对象定义的属性都可写、可枚举和可配置。但 JS 标准库中定义的很多属性并非如此。

本节讲解与查询和设置属性的特性有关的 API。这个 API 对库作者来说尤其重要，因为：

- 它允许库作者给原型对象添加方法，并让它们像内置方法一样不可枚举

- 它允许库作者 “锁住” 自己的对象，定义不能修改或删除的属性

“数据属性” 有一个值，而 “访问器属性” 有一个获取方法和设置方法。对于本节而言，可以把访问器属性的获取方法（get）和设置方法（set）作为属性的特性来看待。按照这个逻辑，也可以把数据属性的值（value）当成一个特性。这样就可以说一个属性有一个名字和 4 个特性：

- 数据属性的 4 个特性是 `value`、`writable`、`enumerable` 和 `configurable`。

- 访问器属性没有 `value` 特性或 `writable` 特性，它们的可写能力取决于是否存在设置方法。因此访问器属性的 4 个特性是 `get`、`set`、`enumerable` 和 `configurable`。

**用于查询和设置属性特性的 JS 方法使用一个被称为属性描述符（proper descriptor）的对象，这个对象用于描述属性的 4 个特性。属性描述符对象拥有与它所描述的属性的特性相同的属性名**。因此，数据属性的属性描述符有如下属性：`value`、`writable`、`enumerable` 和 `configurable`。而访问器属性的属性描述符没有 value 和 writable 属性，只有 `get` 和 `set` 属性。其中，writable、enumerable 和 configurable 属性是布尔值，而 get 和 set 属性是函数值。

要获得特定对象某个属性的属性描述符，可以调用 `Object.getOwnProperDescriptor()`：

```js
// 返回 {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({ x: 1 }, 'x');

// 这个对象有一个只读的访问器属性
const random = {
  get octet() {
    return Math.floor(Math.random() * 256);
  }
};

// 返回 {get: /*func*/, set: undefined, enumerable: true, configurable: true}
Object.geOownPropertyDescriptor(random, 'octet');

// 对继承的属性或不存在的属性返回 undefined
Object.getOwnPropertyDescriptor({}, 'x'); // undefined；没有这个属性
Object.getOwnPropertyDescriptor({}, 'toString'); // undefined；继承的属性
```

顾名思义，Object.getOwnProperDescriptor() 只对自有属性有效。要查询继承属性的特性，必须自己沿原型链上溯（可以参考 [Object.getPrototypeOf()](#143-prototype-特性) 或 [Reflect.getPrototypeOf()](#146-反射-api)）。

**要设置属性的特性或者要创建一个具有指定特性的属性，可以调用 `Object.defineProperty()` 方法**，传入要修改的对象、要创建或修改的属性的名字，以及属性描述符对象：

```js
let o = {}; // 一开始没有任何属性
// 创建一个不可枚举的数据属性 x，值为 1
Object.defineProperty(o, 'x', {
  value: 1,
  writable: true,
  enumerable: false,
  configurable: true
});

// 确认已经有了这个属性，而且不可枚举
o.x; // 1
Object.keys(o); // []

// 现在，修改属性 x，把它设置为只读
Object.defineProperty(o, 'x', { writable: false });

// 试着修改这个属性的值
o.x = 2; // 静默失败或在严格模式下抛出 TypeError
o.x; // 1

// 这个属性依然是可以配置的，因此可以像这样修改它的值
Object.defineProperty(o, 'x', { value: 2 });
o.x; // 2

// 把 x 由数据属性修改为访问器属性
Object.defineProperty(o, 'x', {
  get: function () {
    return 0;
  }
});
```

传给 `Object.defineProperty()` 的属性描述符不一定 4 个特性都包含。如果是创建新属性，那么省略的特性会取得 false 或 undefined 值。如果是修改已有的属性，那么省略的特性就不用修改。

> **注意**：这个方法只修改已经存在的自有属性，或者创建新的自有属性，不会修改继承的属性。也可以参考 [Reflect.defineproperty()](#146-反射-api)。

**如果想一次性创建或修改多个属性，可以使用 `Object.defineProperties()`**。第一个参数是要修改的对象，第二个参数也是一个对象，该对象将要创建或修改的属性的名称映射到这些属性的属性描述符。例如：

```js
let p = Object.defineProperties(
  {},
  {
    x: { value: 1, writable: true, enumerable: true, configurable: true },
    y: { value: 1, writable: true, enumerable: true, configurable: true },
    r: {
      get() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      enumerable: true,
      configurable: true
    }
  }
);

p.r; // Math.SORT2
```

这段代码操作的是一个空对象，为该对象添加了两个数据属性和一个只读的访问器属性。它依赖的事实是 `Object.defineProperties()`（与 `Object.defineProperty()` 一样）返回修改后的对象。

`Object.create()` 方法的第一个参数是新创建对象的原型对象。这个方法也接收第二个可选的参数，该参数与 `Object.defineProperties()` 的第二个参数一样。给 `Object.create()` 传入一组属性描述符，可以为新创建的对象添加属性。

如果创建或修改属性的行为是不被允许的，`Object.defineProperty()` 和 `Object.defineProperties()` 会抛出 TypeError。比如给一个不可扩展的对象[添加新属性](#142-对象的可扩展能力)。导致这两个方法抛出 TypeError 的其他原因涉及特性本身。`writable` 特性控制对 `value` 属性的修改，而 `configurable` 特性控制对其他特性的修改（也控制是否可以删除某个属性）。

不过，这里的规则并非直观明了。比如，虽然某个属性是不可写的，但如果它是可以配置的，仍然可以修改它的值。再比如，即使某个属性是不可配置的，但仍然可以把该属性由可写修改为不可写。下面给出了全部规则，在调用 `Object.defineProperty()` 或 `Object.defineProperties()` 时如果违反这些规则就会抛出 TypeError：

- 如果对象不可扩展，可以修改其已有属性，但不能给它添加新属性。

- 如果属性不可配置，不能修改其 `configurable` 或 `enumerable` 特性。

- 如果访问器属性不可配置，不能修改其获取方法或设置方法，也不能把它修改为数据属性。

- 如果数据属性不可配置，不能把它修改为访问器属性。

- 如果数据属性不可配置，不能把它的 `writable` 特性由 false 修改为 true，但可以由 true 修改为 false。

- 如果数据属性不可配置且不可写，则不能修改它的值。不过，如果这个属性可配置但不可写，则可以修改它的值（相当于先把它配置为可写，然后修改它的值，再把它配置为不可写）。

`Object.assign()` 函数可以把一个或多个源对象的属性值复制到目标对象。Object.assign() 只复制可枚举属性和属性值，但不复制属性的特性。这个结果通常都是想要的，但是也要清楚这个结果意味着什么。比如，它意味着如果源对象有一个访问器属性，那么复制到目标对象的是获取函数的返回值，而不是获取函数本身。示例 14-1 演示了如何使用 `Object.getOwnPropertyDescriptor()` 和 `Object.defineProperty()` 创建 Object.assign() 的一个变体，让这个变体能够复制全部属性描述符而不仅仅复制属性的值：

```js
// 示例 14-1：从一个对象向另一个对象复制属性及它们的特性
/*
 * 定义一个新的 Object.assignDescriptors() 函数
 * 这个函数与 Object.assign() 类似，只不过会从源对象向目标对象复制属性描述符，而不仅仅复制属性的值
 * 这个函数会复制所有自有属性，包括可枚举和不可枚举的
 * 因为是复制描述符，它也会从源对象复制获取方法并重写目标对象的设置方法，而不是调用相应的获取方法和设置方法
 *
 * Object.assignDescriptors() 会将自己代码中封装的 Object.defineProperty() 抛出的 TypeError 传播出来
 * 如果目标对象被封存或冻结，或者如果有任何来源属性尝试修改目标对象上已有的不可配置属性，就会发生错误
 *
 * 注意，这里是使用 Object.defineProperty() 把属性 assignDescriptors 添加给 Object 的，因此可以把这个新函数像 Object.assign() 一样设置为不可枚举属性
 */
Object.defineProperty(Object, 'assignDescriptors', {
  // 与调用 Object.assign() 时的特性保持一致
  writable: true,
  enumerable: false,
  configurable: true,
  // 这个函数是 assignDescriptors 属性的值
  value: function (target, ...sources) {
    for (let source of sources) {
      for (let name of Object.getOwnPropertyNames(source)) {
        let desc = Object.getownPropertyDescriptor(source, name);
        Object.defineProperty(target, name, desc);
      }

      for (let symbol of Object.getownPropertySymbols(source)) {
        let desc = Object.getownPropertyDescriptor(source, symbol);
        Object.defineProperty(target, symbol, desc);
      }
    }
    return target;
  }
});

// 定义包含获取方法的对象
let o = {
  c: 1,
  get count() {
    return this.c++;
  }
};
let p = Object.assign({}, o); // 复制属性的值
let q = Object.assignDescriptors({}, o); // 复制属性描述符
p.count; // 1 这只是一个数据属性
p.count; // 1：因此它的值并不递增
q.count; // 2：复制的时候就会递增
q.count; // 3：复制的是获取方法，因此每次访问都会递增
```

### 14.2 对象的可扩展能力

**对象的可扩展（extensible）特性控制是否可以给对象添加新属性，即是否可扩展**。普通 JS 对象默认是可扩展的，但可以使用下面介绍的方法修改。

要确定一个对象是否可扩展，把它传给 `Object.isExtensible()` 即可。要让一个对象不可扩展，把它传给 `Object.preventExtensions()` 即可。如此，如果再给该对象添加新属性，那么在严格模式下就会抛出 TypeError，而在非严格模式下则会静默失败。此外，修改不可扩展对象的原型始终都会抛出 TypeError。

> **注意**：把对象修改为不可扩展是不可逆的（即无法再将其改回可扩展）。也要注意，调用 `Object.preventExtensions()` 只会影响对象本身的可扩展能力。如果给一个不可扩展对象的原型添加了新属性，则这个不可扩展对象仍然会继承这些新属性。

[反射 API](#146-反射-api)还介绍了两个类似的函数：`Reflect.isExtensible()` 和 `Reflect.preventExtensions()`。

这个 `extensible` 特性的作用是把对象 “锁定” 在已知状态，阻止外部篡改。对象的 `extensible` 特性经常需要与属性的 `configurable` 和 `writable` 特性协同发挥作用。JS 为此还定义了可以一起设置这些特性的函数：

- `Object.seal()` 类似 `Object.preventExtensions()` 但除了让对象不可扩展，它也会让对象的所有自有属性不可扩展。这意味着不能给对象添加新属性，也不能删除或配置已有属性。不过，可写的已有属性依然可写。没有办法 “解封” 已被 “封存” 的对象。可以使用 `Object.isSealed()` 确定对象是否被封存。

- `Object.freeze()` 会更严密地 “锁定” 对象。除了让对象不可扩展，让它的属性不可配置，该函数还会把对象的全部自有属性变成只读的（如果对象有访问器属性，且该访问器属性有设置方法，则这些属性不会受影响，仍然可以调用它们给属性赋值）。使用 `Object.isFrozen()` 确定对象是否被冻结。

**`Object.seal()` 和 `Object.freeze()`，它们只影响传给自己的对象，而不会影响该对象的原型**。如果想彻底锁定一个对象，那可能也需要封存或冻结其原型链上的对象。

`Object.preventExtensions()`、`Object.seal()` 和 `Object.freeze()` 全都返回传给它们的对象，这意味着可以在嵌套函数调用中使用它们：

```js
// 创建一个原型被冻结的封存对象，它有一个不可枚举的自有属性
let o = Object.seal(Object.create(Object.freeze({ x: 1 }), { y: { value: 2, writable: true } }));
```

> 如果编写的 JS 库要把某些对象传给用户写的回调函数，为避免用户代码修改这些对象，可以使用 `Object.freeze()` 冻结它们。这样做虽然简单方便，但也有弊端。比如被冻结的对象可能影响常规的 JS 测试策略。

### 14.3 prototype 特性

对象的 `prototype` 特性指定对象从哪里继承属性。由于这个特性实在太重要了，平时只会说 “o 的原型”，而不说 “o 的 prototype 特性”。但也要记住，当 `prototype` 以代码字体出现时，它指的是一个普通对象的属性，而不是 prototype 特性。构造函数的 `prototype` 属性用于指定通过该构造函数创建的对象的 `prototype` 特性。

> 对象的 `prototype` 特性是在对象被创建时设定的。使用对象字面量创建的对象使用 `Object.prototype` 作为其原型。使用 new 创建的对象使用构造函数的 `prototype` 属性的值作为其原型。而使用 `Object.create()` 创建的对象使用传给它的第一个参数（可能是 null）作为其原型。

要查询任何对象的原型，都可以把该对象传给 `Object.getPrototypeOf()`：

```js
Object.getPrototypeOf(0); // Object.prototype
Object.getPrototypeOf([]); // Array.prototype
Object.getPrototypeOf(() => {}); // Function.prototype
```

> [反射 API](#146-反射-api)介绍了一个非常类似的函数：`Reflect.getPrototypeOf()`。

要确定一个对象是不是另一个对象的原型（或原型链中的一环），可以使用 `isPrototypeOf()` 方法：

```js
let p = { x: 1 }; // 定义一个原型对象
let o = Object.create(p); // 用该原型创建一个对象
p.isPrototypeOf(o); // true：o 继承 p
Object.prototype.isPrototypeOf(p); // true：p 继承 Object.prototype
Object.prototype.isPrototypeOf(o); // true：o 也继承 Object.prototype
```

> **注意**：`isPrototypeOf()` 的功能与 [`instanceof` 操作符](#444-instanceof-操作符)类似。

对象的 `prototype` 特性在它创建时会被设定，且通常保持不变。不过，可以使用 `Object.setPrototypeOf()` 修改对象的原型：

```js
let o = { x: 1 };
let p = { y: 2 };
Object.setPrototypeOf(o, p); // 把 o 的原型设置为 p
o.y; // 2：o 现在继承了属性 y
let a = [1, 2, 3];
Object.setPrototypeOf(a, p); // 把数组 a 的原型设置为 p
a.join; // undefined：a 不再有 join() 方法
```

一般来说很少需要使用 `Object.setPrototypeOf()`。JS 实现可能会基于对象原型固定不变的假设实现激进的优化。这意味着如果调用过 `Object.setPrototypeOf()`，那么任何使用该被修改对象的代码都可能比正常情况下慢很多。

> [反射 API](#146-反射-api)介绍了一个非常类似的函数：`Reflect.setPrototypeOf()`。

JS 的一些早期浏览器实现通过 `__proto__`（前后各有两个下划线）属性暴露了对象的 `prototype` 特性。这个属性很早以前就已经被废弃了，但网上仍然有很多已有代码依赖 `__proto__`。ECMAScript 标准为此也要求所有浏览器的 JS 实现都必须支持它（尽管标准并未要求，但 Node 也支持它）。在现代 JS 中，`__proto__` 是可读且可写的，可以（但不应该）使用它代替 `Object.getPrototypeOf()` 和 `Object.setPrototypeOf()`。`__proto__` 的一个有意思的用法是通过它定义对象字面量的原型：

```js
let p = { z: 3 };
let o = {
  x: 1,
  y: 2,
  __proto__: p
};
o.z; // 3：o 继承 p
```

### 14.4 公认符号

Symbol 类型是在 ES6 中添加到 JS 中的。之所以增加这个新类型，主要是为了便于扩展 JS 语言，同时又不会破坏对 Web 上已有代码的向后兼容性。[迭代器与生成器](#十二-迭代器与生成器)介绍了一个符号的例子，通过该例子知道一个类只要实现 “名字” 为 `Symbol.iterator` 符号的方法，这个类就是可迭代的。

`Symbol.iterator` 是最为人熟知的 “公认符号”（well-known symbol）。所谓 “公认符号” 其实就是 Symbol() 工厂函数的一组属性，也就是一组符号值。通过这些符号值，可以控制 JS 对象和类的某些底层行为。

#### 14.4.1 Symbol.iterator 和 Symbol.asyncIterator

[`Symbol.iterator`](#十二-迭代器与生成器) 和 [`Symbol.asyncIterator`](#1342-异步迭代器) 符号可以让对象或类把自己变成可迭代对象和异步可迭代对象。

#### 14.4.2 Symbol.hasInstance

`instanceof` 操作符其右侧必须是一个构造函数，而表达式 `o instanceof f` 在求值时会在 o 的原型链中查找 f.prototype 的值，这是没有问题的，但在 ES6 及之后的版本中，`Symbol.hasInstance` 提供了一个替代选择。在 ES6 中，如果 instanceof 的右侧是一个有 `[Symbol.hasInstance]` 方法的对象，那么就会以左侧的值作为参数来调用这个方法并返回这个方法的值，返回值会被转换为布尔值，变成 `instanceof` 操作符的值。当然，如果右侧的值没有 `[Symbol.hasInstance]` 方法且是个函数，则 `instanceof` 操作符仍然照常行事。

`Symbol.hasInstance` 意味着可以使用 `instanceof` 操作符对适当定义的伪类型对象去执行通用类型检查。例如：

```js
// 定义一个作为 “类型” 的对象，以便与 instanceof 一起使用
let uint8 = {
  [Symbol.hasInstance](x) {
    return Number.isInteger(x) && x >= 0 && x <= 255;
  }
};
128 instanceof uint8; // true
256 instanceof uint8; // false：太大
Math.PI instanceof uint8; // false：不是整数
```

> **注意**：这个例子很巧妙，但却让人困惑。因为它使用了不是类的对象，而正常情况下应该是一个类。实际上，要写一个不依赖 `Symbol.hasInstance` 的 isUnit8()` 函数也很容易（而且对读者来说代码也更清晰）。

#### 14.4.3 Symbol.toStringTag

调用一个简单 JS 对象的 `toString()` 方法会得到字符串 "[object Object]"：

如果调用与内置类型实例的方法相同的 `Object.prototype.toString()` 函数，则会得到些有趣的结果：

```js
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(/./); // "[Object RegEXp]"
Object.prototype.toString.call(() => {}); // "[object Function]"
Object.prototype.toString.call(''); // "[object String]"
Object.prototype.toString.call(0); // "[object Number]"
Object.prototype.tostring.call(false); // "[object Boolean]"
```

这说明，使用这种 `Object.prototype.toString.call()` 技术检查任何 JS 值，都可以从一个包含类型信息的对象中获取以其他方式无法获取的 “类特性”。下面这个 classOf() 函数无论怎么说都比 typeof 操作符更有用，因为 typeof 操作符无法区分不同对象的类型：

```js
function classOf(o) {
  return Object.prototype.toString.call(o).slice(8, -1);
}

classOf(null); // "Null"
classOf(undefined); // "Undefined"
classOf(1); // "Number"
classOf(10n ** 100n); // "BigInt"
classOf(''); // "String"
classOf(false); // "Boolean"
classOf(Symbol()); // "Symbol"
classOf({}); // "Object"
classOf([]); // "Array"
classOf(/./); // "RegExp"
classOf(() => {}); // "Functionf"
classOf(new Map()); // "Map"
classOf(new Set()); // "Set"
classOf(new Date()); // "Date"
```

在 ES6 之前，`Object.prototype.toString()` 这种特殊的用法只对内置类型的实例有效。如果对自己定义的类的实例调用 classOf()，那只能得到 “Object”。而在 ES6 中，`Object.prototype.toString()` 会查找自己参数中有没有一个属性的符号名是 `Symbol.toStringTag`。如果有这样一个属性，则使用这个属性的值作为输出。这意味着如果自己定义了一个类，那很容易可以让它适配 classOf() 这样的函数：

```js
class Range {
  get [Symbol.toStringTag]() {
    return 'Range';
  }
  // 省略这个类其余的代码
}
let r = new Range(1, 10);
Object.prototype.toString.call(r); // "[object Range]"
classOf(r); // "Range"
```

#### 14.4.4 Symbol.species

在 ES6 之前，JS 没有提供任何实际的方式去创建内置类的子类。但在 ES6 中，使用 [`class` 和 `extends` 关键字](#952-通过-extends-和-super-创建子类)就可以方便地扩展任何内置类。使用下面这个简单的 Array 子类演示了这一点：

```js
// Array 的一个简单子类，为第一个和最后一个元素添加了获取函数
class EZArray extends Array {
  get first() {
    return this[0];
  }
  get last() {
    return this[this.length - 1];
  }
}
let e = new EZArray(1, 2, 3);
let f = e.map(x => x * x);
r.last; // 3：EZArray 实例 e 的最后一个元素
f.last; // 9：f 也是 EZArray 的实例，有 last 属性
```

Array 定义了 `concat()`、`filter()`、`map()`、`slice()` 和 `splice()` 方法，这些方法仍然返回数组。在创建类似 EZArray 的数组子类时也会继承这些方法，这些方法应该返回 Array 的实例，还是返回 EZArray 的实例？两种结果似乎都有其合理的一面，但 ES6 规范认为这 5 个数组方法（默认）将返回子类的实例。

以下是实现过程：

- 在 ES6 及之后版本中，Array() 构造函数有一个名字为 `Symbol.species` 符号属性（注意：这个符号是构造函数的属性名。这里介绍的其他大多数公认符号都是原型对象的方法名）。

- 在使用 `extends` 创建子类时，子类构造函数会从超类构造函数继承属性（这是除子类实例继承超类方法这种常规继承之外的一种继承）。这意味着 Array 的每个子类的构造函数也会继承名为 `Symbol.species` 的属性（如果需要，子类也可以用同一个名字定义自有属性）。

- 在 ES6 及之后的版本中，map() 和 slice() 等创建并返回新数组的方法经过了一些修改。修改后它们不仅会创建一个常规的 Array，还会调用 `new this.constructor[Symbol.species]()` 创建新数组。

接下来是最有意思的部分。假设 `Array[Symbol.species]` 仅仅是一个常规数据属性，是按如下的方式定义的：

```js
Array[Symbol.species] = Array;
```

那么子类构造函数将作为它的 “物种”（species）继承 Array() 构造函数，在数组子类上调用 map() 将返回这个超类的实例而不返回子类实例。但 ES6 中实际结果并非如此。原因在于 `Array[Symbol.species]` 是一个只读的访问器属性，其获取函数简单地返回 this。子类构造函数继承了这个获取函数，这意味着默认情况下，每个子类构造函数都是它自己的 “物种”。

不过，有时候可能需要修改这个默认行为。如果想让 EZArray 继承的返回数组的方法都返回常规 Array 对象，只需将 ·EZArray[Symbol.species]`设置为 Array 即可。但由于这个继承的属性是一个只读的访问器，不能直接用赋值操作符来设置这个值。此时可以使用`defineProperty()`：

```js
EZArray[Symbol.species] = Array; // 尝试设置只读属性会失败
// 可以使用 defineProperty()
Object.defineProperty(EZArray, Symbol.species, { value: Array });
```

最简单的做法其实是在一开始创建子类时就定义自己的 `Symbol.species` 获取方法：

```js
class EZArray extends Array {
  static get [Symbol.species]() {
    return Array;
  }
  get first() {
    return this[0];
  }
  get last() {
    return this[this.length - 1];
  }
}

let e = new EZArrray(1, 2, 3);
let f = e.map(x => x - 1);
e.last; // 3
f.last; // undefined：f 是一个常规数组，没有 last 获取方法
```

**增加 `Symbol.species` 的主要目的就是允许更灵活地创建 Array 的子类**，但这个公认符号的用途并不局限于此。定型数组与 Array 类一样，也以同样的方式使用了这个符号。类似地，ArrayBuffer 的 slice() 方法也会查找 this.constructor 的 `Symbol.species` 属性，而不是简单地创建新 ArrayBuffer。而返回新 Promise 对象的方法（比如 then()）同样也是通过这个 “物种协议” 来创建返回的期约。最后，如果某一天会创建 Map 的子类，并且会定义返回新 Map 对象的方法，那么为这个子类的子类考虑，或许会用到 `Symbol.species`。

#### 14.4.5 Symbol.isConcatSpreadable

Array 的方法 concat() 是使用 `Symbol.species` 确定对返回的数组使用哪个构造函数的方法之一。但 concat() 也使用 `Symbol.isConcatSpreadable`。

数组的 concat() 方法对待自己的 this 值和它的数组参数不同于对待非数组参数。换句话说，非数组参数会被简单地追加到新数组末尾，但对于数组参数，this 数组和参数数组都会被打平或 “展开”，从而实现数组元素的拼接，而不是拼接数组参数本身。

在 ES6 之前，concat() 只使用 Array.isArray() 确定是否将某个值作为数组来对待。在 ES6 中，这个算法进行了一些调整：如果 concat() 的参数（或 this 值）是对象且有一个 `Symbol.isConcatSpreadable` 符号属性，那么就根据这个属性的布尔值来确定是否应该 “展开” 参数。如果这个属性不存在，那么就像语言之前的版本一样使用 Array.isArray()。

在两种情况下可能会用到这个 Symbol：

- 如果创建了一个[类数组对象](#79-类数组对象)，并且希望把它传给 concat() 时该对象能像真正的数组一样，那可以给这个对象添加这么一个符号属性：

  ```js
  let arrayLike = {
    length: 1,
    0: 1,
    [Symbol.isConcatSpreadable]: true
  };
  [].concat(arraylike); // [1]：(如果不展，这里就是[[1]])
  ```

- Array 的子类默认是可展开的，因此如果定义了一个数组的子类，但不希望它在传给 concat() 时像数组一样，那么可以像下面这样给这个子类添加一个获取方法：

  ```js
  class NonSpreadableArray extends Array {
    [Symbol.isConcatSpreadable]() {
      return false;
    }
  }
  let a = new NonSpreadableArray(1, 2, 3);
  [].concat(a).length; // 1；(如果 a 被展开，这里将是3个元素)
  ```

#### 14.4.6 模式匹配符号

[模式匹配的字符串方法](#1132-模式匹配的字符串方法)记述了使用 RegExp 参数执行模式匹配操作的 String 方法。在 ES6 及之后的版本中，这些方法都统一泛化为既能够使用 RegExp 对象，也能使用任何通过具有符号名的属性定义了模式匹配行为的对象。match()、matchAll()、search()、replace() 和 split() 这些字符串方法中的任何一个，都有一个与之对应的公认符号：Symbol.match、Symbol.search，等等。

RegExp 是描述文本模式的一种通用且强大的方式，但同时它们也比较复杂，而且也不太适合模糊匹配。有了泛化之后的字符串方法，可以使用公认的符号方法定义自己的模式类，提供自定义匹配。例如，可以使用 [Intl.Collator](#1173-比较字符串) 执行字符串比较，从而在比较时忽略重音。或者，可以基于 Soundex 算法实现一个模式类，从而根据读音的近似程度匹配单词或者近似地匹配到某个给定的莱文斯坦（Levenshtein）距离。

一般来说，在像下面这样调用上面 5 个字符串方法时：

```js
string.method(pattern, arg);
```

该调用会转换为对模式对象上相应符号化命名方法的调用：

```js
pattern[symbol](string, arg);
```

以下面这个模式匹配类为例。这个类使用文件系统中的 `*` 和 `?` 通配符实现了模式匹配。这种风格的模式匹配可以追溯到 Unix 操作系统诞生之初，而模式也被称为 glob：

```js
class Glob {
  constructor(glob) {
    this.glob = glob;

    // 内部使用 RegExp 实现 glob 匹配
    // ? 匹配除 / 之外的任意字符，* 匹配 0 或多个这样的字符
    // 每个匹配都使用一个捕获组
    let regexpText = glob.replace('?', '[^/]').replace('*', '([^/]*)');

    // 使用 u 标签表示支持 Unicode 的匹配
    // glob 是要匹配整个字符串，所以使用 ^ 和 $ 锚点
    // 这里没有实现 search() 和 catchAll()，因为它们对这样的模式没有用
    this.regexp = new RegExp(`^${regexpText}$`, 'u');
  }

  toString() {
    return this.glob;
  }
  [Symbol.search](s) {
    return s.search(this.regexp);
  }
  [Symbol.match](s) {
    return s.match(this.regexp);
  }
  [Symbol.replace](s, replacement) {
    return s.replace(this.regexp, replacement);
  }
}

let pattern = new Glob('docs/*.txt');
'docs/js.txt'.search(pattern); // 0：从第 0 个字符开始匹配
'docs/js.htm'.search(pattern); // -1：不匹配
let match = 'docs/js.txt'.match(pattern);
match[0]; // "docs/js.txt"
match[1]; // "js"
match.index; // 0
'docs/js.txt'.replace(pattern, 'web/$1.htm'); // "web/js.htm"
```

#### 14.4.7 Symbol.toPrimitive

JS 有 3 个稍微不同的算法，用于将对象转换为原始值：

- 对于预期或偏好为字符串值的转换，JS 会先调用对象的 toString() 方法。如果 toString() 方法没有定义或者返回的不是原始值，还会再调用对象的 valueOf() 方法。

- 对于偏好为数值的转换，JS 会先尝试调用 valueOf() 方法，然后在 valueOf() 没有定义或者返回的不是原始值时再调用 toString()。

- 如果没有偏好，JS 会让类来决定如何转换。Date 对象首先使用 toString()，其他所有类型则首先调用 valueOf()。

在 ES6 中，公认符号 `Symbol.toPrimitive` 允许覆盖这个默认的对象到原始值的转换行为，可以完全控制自己的类实例如何转换为原始值。为此，需要定义一个名字为这个符号的方法。这个方法必须返回一个能够表示对象的原始值。这个方法在被调用时会收到一个字符串参数，用于告诉 JS 打算对对象做什么样的转换。

- 如果这个参数是 "string"，则表示 JS 是在一个预期或偏好（但不是必需）为字符串的上下文中做这个转换。比如，把对象作为字符串插值到一个模板字面量中。

- 如果这个参数是 "number"，则表示 JS 是在一个预期或偏好（但不是必需）为数值的上下文中做这个转换。在通过 `<` 或 `>` 操作符比较对象，或者使用算术操作符 `-` 或 `*` 来计算对象时属于这种情况。

- 如果这个参数是 "default"，则表示 JS 做这个转换的上下文可以接受数值也可以接受字符串。在使用 `+`、`==` 或 `!=` 操作符时就是这样。

> 很多类都可以忽略这个参数，在任何情况下都返回相同的原始值。如果希望自己类的实例可以通过 `<` 或 `>` 来比较，那么就需要给这个类定义一个 `[Symbol.toPrimitive]` 方法。

#### 14.4.8 Symbol.unscopables

最后一个要介绍的公认符号不好理解，它是针对废弃的 with 语句所导致的兼容性问题而引入的一个变通方案。with 语句会取得一个对象，而在执行语句体时，就好像在相应的作用域中该对象的属性是变量一样。但这样一来如果再给 Array 类添加新方法就会导致兼容性问题，有可能破坏某些既有代码。`Symbol.unscopables` 应运而生。

在 ES6 及之后的版本中，with 语句被稍微进行了修改。在取得对象 o 时，with 语句会计算 `Object.keys(o[Symbol.unscopables]||{})` 并在创建用于执行语句体的模拟作用域时，忽略名字包含在结果数组中的那些属性。ES6 使用这个机制给 Array.prototype 添加新方法，同时又不会破坏线上已有的代码。这意味着可以通过如下方式获取最新 Array 方法的列表：

```js
let newArrayMethods = Object.keys(Array.prototype[Symbol.unscopables]);
```

### 14.5 模板标签

位于反引号之间的字符串被称为 “模板字面量”，如果一个求值为函数的表达式后面跟着一个模板字面量，那就会转换为一个函数调用，称其为 “标签化模板字面量”。可以把定义使用标签化模板字面量的标签函数看成是元编程，因为标签化模板经常用于定义 DSL（Domain-Specific Language，领域专用语言）。而定义新的标签函数类似于给 JS 添加新语法。标签化模板字面量已经被很多前端 JS 包采用了。GraphQL 查询语言使用 **gql``** 标签函数支持在 JS 代码中嵌入查询。

标签函数并没有什么特别之处，它们就是普通的 JS 函数，定义它们不涉及任何特殊语法。当函数表达式后面跟着一个模板字面量时，这个函数会被调用。第一个参数是一个字符串数组，然后是 0 或多个额外参数，这些参数可以是任何类型的值。

参数的个数取决于被插值到模板字面量中值的个数。如果模板字面量就是一个字符串，没有插值的位置，那么标签函数在被调用时只会收到一个该字符串的数组，没有额外的参数。如果模板字面量包含一个要插入的值，那么标签函数被调用时会收到两个参数：

- 第一个是包含两个字符串的数组，一个是插入值左侧的字符串，另一个是插入值右侧的字符串。这两个字符串都可能是空字符串。

- 第二个是被插入的值。

如果模板字面量包含两个要插入的值，那么标签函数在被调用时会收到三个参数：

- 一个包含三个字符串的数组，数组中的三个字符串（其中任何一个甚至全部都可能是空字符串）分别是第一个插入值左侧、两个插入值之间和最后一个插入值右侧的字符串。

- 两个要插入的值。

推而广之，如果模板字面量有 n 个插值，那么标签函数在被调用时会收到 n+1 个参数。第一个参数是一个 n+1 个字符串的数组，其余 n 个参数是要插入的值，顺序为它们在模板字面量中出现的顺序。

模板字面量的值始终是一个字符串。但标签化模板字面量的值则是标签函数返回的值。这个值可能是字符串，但在标签函数被用于实现 DSL 时，返回的值通常是一个非字符串数据结构或者说是对字符串进行解析之后的表示。

作为一个返回字符串的标签函数的例子，可以看看下面这个 html`` 模板。这个模板可以保证向 HTML 字符串中安全地插值。在使用要插入的值构建最终字符串之前，标签会先对它们进行 HTML 转义：

```js
function html(strings, ...values) {
  // 把每个值都转换为字符串并转义特殊 HTML 字符
  let escaped = values.map(v =>
    String(v)
      .replace('&', '&amp;')
      .replace('<', '&lt;')
      .replace('>', '&gt;')
      .replace('"', '&quot;')
      .replace("'", '&#39;')
  );

  // 返回拼接在一起的字符串和转义值
  let result = strings[0];
  for (let i = 0; i < escaped.length; i++) {
    result += escaped[i] + strings[i + 1];
  }
  return result;
}

let operator = '<';
html`<b>x ${operator} y</b>`; // "<b>x &lt; y</b>"
let kind = 'game',
  name = 'D&D';
html`<div class="${kind}">${name}</div>`; // '<div class="game">D&amp;D</div>'
```

下面这个例子是一个不返回字符串而返回字符串解析后表示的标签函数，其中用到了[模式匹配符号](#1446-模式匹配符号)定义的 Glob 模式类。由于 Glob() 构造函数只接收一个字符串参数，可以定义一个标签函数来创建新 Glob 对象：

```js
function glob(strings, ...values) {
  // 把 strings 和 values 装配成一个字符串
  let s = strings[0];
  for (let i = 0; i < values.length; i++) {
    s += values[i] + strings[i + 1];
  }
  // 返回解析该字符串之后的表示
  return new Glob(s);
}

let root = '/tmp';
let filePattern = glob`${rot}/*.htmL`; // RegExp 的替代
'/tmp/test.html'.match(filePattern)[1]; //"test"
```

String.raw`` 标签函数，这个函数返回字符串 “未处理”（raw）的形式，不会解释任何反斜杠转义序列。这个函数使用了当时还没有讨论的标签函数调用特性实现。当标签函数被调用时，知道它的第一个参数是一个字符串数组。不过这个数组也有一个名为 raw 的属性，该属性的值是另一个字符串数组，数组的元素个数相同。参数数组中包含的字符串已经跟往常一样解释了转义序列。而未处理数组中包含的字符串并没有解释转义序列。如果想定义 DSL，而文法中会使用反斜杠，那么这个不起眼的特性很重要。

例如，想让 glob`` 标签函数支持匹配 Windows 风格路径（使用反斜杠而不是正斜杠）的模式，也不希望用户双写每个反斜杠，那可以使用 strings.raw[] 取代 strings[] 来重写该函数。当然，这样做的问题在于不能再在 glob 字面量中使用类似 \u 的转义序列。

### 14.6 反射 API

与 Math 对象类似，Reflect 对象不是类，它的属性只是定义了一组相关函数。这些 ES6 添加的函数为 “反射” 对象及其属性定义了一套 API。这里有一个小功能：Reflect 对象在同一个命名空间里定义了一组便捷函数，这些函数可以模拟核心语言语法的行为，复制各种既有对象功能的特性。

Reflect 函数虽然没有提供新特性，但它们用一个方便的 API 筛选出了一组特性。重点在于，**这组 Reflect 函数一对一地映射 [Proxy 处理器方法](#147-代理对象)**。

反射 API 包括下列函数：

**Reflect.apply(f, o, args)**
: 这个函数将函数 f 作为 o 的方法进行调用（如果 o 是 null，则调用函数 f 时没有 this 值），并传入 args 数组的值作为参数。相当于 `f.apply(o, args)`。

**Reflect.construct(c, args, newTarget)**
: 这个函数像使用了 new 关键字一样调用构造函数 c，并传入 args 数组的元素作为参数。如果指定了可选的 newTarget 参数，则将其作为构造函数调用中的值。如果没有指定，则 new.target 的值是 c。

**Reflect.defineProperty(o, name, descriptor)**
: 这个函数在对象 o 上定义一个属性，使用 name（字符串或符号）作为属性名。描述符对象 descriptor 应该定义这个属性的值（或获取方法、设置方法）和特性。Reflect.defineProperty() 与 Object.defineProperty() 非常类似，但在成功时返回 true，失败时返回 false（Object.defineProperty() 成功时返回 o，失败时抛出 TypeError）。

**Reflect.deleteProperty(o, name)**
: 这个函数根据指定的字符串或符号名 name 从对象 o 中删除属性。如果成功（或指定属性不存在）则返回 true，如果无法删除该属性则返回 false。调用这个函数类似于执行 `delete o[name]`。

**Reflect.get(o, name, receiver)**
: 这个函数根据指定的字符串或符号名 name 返回属性的值。如果属性是一个有获取方法的访问器属性，且指定了可选的 receiver 参数，则将获取方法作为 receiver 而非 o 的方法调用。调用这个函数类似于求值 `o[name]`。

**Reflect.getOwnPropertyDescriptor(o, name)**
: 这个函数返回描述对象 o 的 name 属性的特性的描述符对象。如果属性不存在则返回 undefined。这个函数基本等于 Object.getOwnPropertyDescriptor()，只不这个反射 API 的版本要求第一个参数必须是对象，否则会抛出 TypeError。

**Reflect.getPrototypeOf(o)**
: 这个函数返回对象 o 的原型，如果 o 没有原型则返回 null。如果 o 是原始值而非对象，则抛出 TypeError。这个函数基本等于 Object.getPrototypeOf()，只不过 Object.getPrototypeOf() 只对 null 和 undefined 参数抛出 TypeError，且会将其他原始值转换为相应的包装对象。

**Reflect.has(o, name)**
: 这个函数在对象 o 有指定的属性 name（必须是字符串或符号）时返回 true。调用这个函数类似于求值 `name in o`。

**Reflect.inExtensible(o)**
: 这个函数在对象 o [可扩展](#142-对象的可扩展能力)时返回 true，否则返回 false。如果。不是对象则抛出 TypeError。Object.isExtensible() 与这个函数类似，但在参数不是
对象时只会返回 false。

**Reflect.ownKeys(o)**
: 这个函数返回包含对象 o 属性名的数组，如果 o 不是对象则抛出 TypeError。返回数组中的名字可能是字符串或符号。调用这个函数类似于调用 Object.getOwnPropertyNames() 和 Object.getOwnPropertySymbols() 并将它们返回的结果组合起来。

**Reflect.preventExtensions(o)**
: 这个函数将对象 o 的[可扩展特性](#142-对象的可扩展能力)设置为 false，并返回表示成功的 true。如果 o 不是对象则抛出 TypeError。Object.preventExtenstons() 具有相同的效果，但返回对象 o 而不是 true，另外对非对象参数也不抛出 TypeError。

**Reflect.set(o, name, value, receiver)**
: 这个函数根据指定的 name 将对象 o 的属性设置为指定的 value。如果成功则返回 true，失败则返回 false（如属性是只读的）。如果 o 不是对象则抛出 TypeError。如果指定的属性是一个有设置方法的访问器属性，且如果指定了可选的 receLver 参数，则将设置方法作为 receiver 而非 o 的方法进行调用。调用这个函数类似于求值 `o[name] = value`。

**Reflect.setPrototypeOf(o, p)**
: 这个函数将对象 o 的原型设置为 p，成功返回 true，失败返回 false（如果 o 不可扩展或操作本身会导致循环原型链）。如果 o 不是对象或 p 既不是对象也不是 null 则抛出 TypeError。Object.setPrototypeOf() 与这个函数类似，但在成功时返回 o，在失败时抛出 TypeError。注意，调用这两个函数中的任何一个都可能导致代码变慢，因为它们会破坏 JS 解释器的优化。

| 常规语法                                                    | 反射 API                                    |
| ----------------------------------------------------------- | ------------------------------------------- |
| f.apply(o, args)                                            | Reflect.apply(f, o, args)                   |
| new c(...args)                                              | Reflect.construct(c, args, newTarget)       |
| Object defineProperty(o, name, descriptor)                  | Reflect.defineProperty(o, name, descriptor) |
| delete o[name]                                              | Reflect.deleteProperty(o, name)             |
| o[name]                                                     | Reflect.get(o, name, receiver)              |
| Object.getownPropertyDescriptor(o, name)                    | Reflect.getOwnPropertyDescriptor(o, name)   |
| Object.getPrototypeOf(o)                                    | Reflect.getPrototypeOf(o)                   |
| name in o                                                   | Reflect.has(o, name)                        |
| Object.isExtensible(o)                                      | Reflect.isExtensible(o)                     |
| Object.getOwnPropertyNames() Object.getOwnPropertySymbols() | Reflect.ownKeys(o)                          |
| Object.preventExtensions(o)                                 | Reflect.preventExtensions(o)                |
| o[name] = value                                             | Reflect.set(o, name, value, receiver)       |
| Object.setPrototypeOf(o, p); o = Object.create(p)           | Reflect.setPrototypeOf(o,p)                 |

### 14.7 代理对象

ES6 及之后版本中的 Proxy 类是 JS 中最强大的元编程特性。使用它可以修改 JS 对象的基础行为。上节介绍的反射 API 是一组函数，通过它们可以直接对 JS 对象执行基础操作。而 **Proxy 类则提供了一种途径，能够自己实现基础操作，并创建具有普通对象无法企及能力的代理对象**。

**创建代理对象时，需要指定另外两个对象，即目标对象（target）和处理器对象（handlers）**：

```js
let proxy = new Proxy(target, handlers);
```

得到的代理对象没有自己的状态或行为。每次对它执行某个操作（读属性、写属性、定义新属性、查询原型、把它作为函数调用）时，它只会把相应的操作发送给处理器对象或目标对象。

代理对象支持的操作就是反射 API 定义的那些操作。假设 p 是一个代理对象，想执行 `delete p.x`。而 `Reflect.deleteProperty()` 函数具有与 delete 操作符相同的行为。当使用 delete 操作符删除代理对象上的一个属性时，代理对象会在处理器对象上査找 deleteProperty() 方法。如果存在这个方法，代理对象就调用它。如果不存在这个方法，代理对象就在目标对象上执行属性删除操作。

对所有基础操作，代理都这样处理：如果处理器对象上存在对应方法，代理就调用该方法执行相应操作（这里方法的名字和签名与反射函数完全相同）。如果处理器对象上不存在对应方法，则代理就在目标对象上执行基础操作。这意味着代理可以从目标对象或处理器对象获得自己的行为。如果处理器对象是空的，那代理本质上就是目标对象的一个透明包装器：

```js
let t = { x: 1, y: 2 };
let p = new Proxy(t, {});
p.x; // 1
delete p.y; // true：从代理上删除属性 y
t.y; // undefined：也就从目标对象上删除了它
p.z = 3; // 在代理上定义一个新属性
t.z; // 3 也就在目标上定义了这个属性
```

这种透明包装代理本质上就是底层目标对象，这意味着没有理由使用代理来代替包装的对象。然而，透明包装器在创建 “可撤销代理” 时有用。创建可撤销代理不使用 Proxy() 构造函数，而要使用 `Proxy.revocable()` 工厂函数。这个函数返回一个对象，其中包含代理对象和一个 revoke() 函数。一旦调用 revoke() 函数，代理立即失效：

```js
function accessTheDatabase() {
  /*省略访问数据库的代码*/ return 42;
}
let { proxy, revoke } = Proxy.revocable(accessTheDatabase, {});
proxy(); // 42：可以通过代理访问底层的目标函数
revoke(); // 但可以随时关闭这个访问通道
proxy(); // !TypeError：不能再调用底层的函数了
```

> **注意**：除了演示可撤销代理，前面的代码也演示了代理既可以封装目标函数也可以封装目标对象。但这里的关键是可撤销代理充当了某种代码隔离的机制，而这可以在使用不信任的第三方库时派上用场。如果必须向一个不受自己控制的库传一个函数，则可以给它传一个可撤销代理，然后在使用完这个库之后撤销代理。这样可以防止第三方库持有对函数的引用，在不知道的时候调用它。这种防御型编程并非 JS 程序特有的，但 Proxy 类让它成为可能。

如果给 Proxy() 构造函数传一个非空的处理器对象，那定义的就不再是一个透明包装器对象了，而是要在代理中实现自定义行为。有了恰当自定义的处理器，底层目标对象本质上就变得不相干了。

例如，在下面的代码中，实现了一个对象，让它看起来好像有无数个只读属性，而每个属性的值就是属性的名字：

```js
// 使用代理创建一个对象，让它看起来似乎什么属性都有，只不过每个属性的值就是这个属性的名字
let identity = new Proxy(
  {},
  {
    // 每个属性都以自己的名字作为值
    get(o, name, target) {
      return name;
    },

    // 每个属性的名字都有定义
    has(o, name) {
      return true;
    },

    // 因为可枚举的属性太多，所以干脆抛出错误
    ownKeys(o) {
      throw new RangeError('Infinite number of properties');
    },

    // 所有属性都有,且不可写、不可配置、不可枚举
    getOwnPropertyDescriptor(o, name) {
      return {
        value: name,
        enumerable: false,
        writable: false,
        configurable: false
      };
    },
    // 所有属性都是只读的，因此不能设置
    set(o, name, value, target) {
      return false;
    },
    // 所有属性都不可配置，因此不能删除
    deleteProperty(o, name) {
      return false;
    },
    // 所有属性都有但都不可配置，因此不能定义新属性
    defineProperty(o, name, desc) {
      return false;
    },
    // 实际上，这就意味着这个对象不能扩展
    isExtensible(o) {
      return false;
    },
    // 所有属性都定义在这个对象上，因此即便它有原型也不需要再从中继承什么
    getPrototypeOf(o) {
      return null;
    },
    // 这个对象不可扩展，因此不能修改它的原型
    setPrototypeOf(o, proto) {
      return false;
    }
  }
);

identity.x; // "x"
identity.toString; // "toString“
identity[0]; // "0"
identity.x = 1; // 设置属性没有效果
identity.x; // "x"
delete identity.x; // false：也不能删除属性
identity.x; // "x"
Object.keys(identity); // !RangeError：无法列出全部属性
for (let p of identity); // !RangeError
```

代理对象可以从目标对象和处理器对象获得它们的行为，到目前为止看到的示例都只用到它们其中一个。而同时用到这两个对象的代理通常才更有用。例如，下面的代码为目标对象创建了一个只读包装器。当代码尝试从该对象读取值时，读取操作会正常转发给目标对象。但当代码尝试修改对象或它的属性时，处理器对象的方法会抛出 TypeError。类似这样的代理在编写测试的时候有用。假设写了一个函数，它接收一个对象参数，希望这个函数不会以任何方式修改它收到的参数。如果测试接收只读的包装器对象，那么任何写入操作都会抛出异常从而导致测试失败：

```js
function readonlyProxy(o) {
  function readonly() {
    throw new TypeError('Readonly');
  }

  return new Proxy(o, {
    set: readonly,
    defineProperty: readonly,
    deleteProperty: readonly,
    setPrototypeOf: readonly
  });
}

let o = { x: 1, y: 2 }; // 普通可写对象
let p = readonlyProxy(o); // 它的只读版本
p.x; // 1：读取属性正常
p.x = 2; // !TypeError：不能修改属性
delete p.y; // !TypeError：不能删除属性
p.z = 3; // !TypeError：不能添加属性
p.__proto__; // !TypeError：不能修改原型
```

**另一种使用代理的技术是为它定义处理器方法，拦截对象操作，但仍然把操作委托给目标对象**。[反射 API](#146-反射-api)的函数与处理器方法具有完全相同的签名，从而实现这种委托也很容易。

例如，下面这个函数返回的代理会把所有操作都委托给目标对象，只通过处理器方法打印出执行了什么操作：

```js
/*
 * 返回一个封装 o 的代理对象，对于任何操作都打印一条日志
 * 然后把操作委托给该对象。objname 是一个字符串，它会出现在日志消息中作为对象的标识。
 * 如果 o 的自有属性的值是对象或函数，那么在查询这些属性的值时会得到一个新的 loggingProxy，这样可以保证代理打印日志的行为能够 “持续” 下去
 */
function loggingProxy(o, objname) {
  // 为日志代理对象定义处理器
  // 每个处理器都先打印一条消息，再委托到目标对象
  const handlers = {
    // 这个处理器比较特殊，因为对于值为对象或函数的自有属性，它会返回一个值的代理，而不是值
    get(target, property, receiver) {
      // 打印 get 操作
      console.log(`Handler get(${objname},${property.toString()})`);

      // 使用反射 API 获取属性值
      let value = Reflect.get(target, property, receiver);

      // 如果属性是目标的自有属性，而且值为对象或函数，则返回这个值的代理
      if (
        Reflect.ownKeys(target).includes(property) &&
        (typeof value === 'object' || typeof value === 'function')
      ) {
        return loggingProxy(value, `${objname}.${property.toString()}`);
      }
      // 否则原封不动地返回值
      return value;
    },

    // 下面这三个方法没什么特别之处
    // 它们打印各自的操作，然后委托到目标对象
    // 如果说它们有什么特别之外，那仅仅是都不会打印 recelver 对象，否则会导致无穷递归
    set(target, prop, value, receiver) {
      console.log(`Handler set(${objname},${prop.toString()}, ${value})`);
      return Reflect.set(target, prop, value, receiver);
    },
    apply(target, receiver, args) {
      console.log(`Handler ${objname}(${args})`);
      return Reflect.apply(target, receiver, args);
    },
    construct(target, args, receiver) {
      console.log(`Handler ${objname}(${args})`);
      return Reflect.construct(target, args, receiver);
    }
  };

  // 剩下的其他处理器都可以自动生成
  Reflect.ownKeys(Reflect).forEach(handlerName => {
    if (!(handlerName in handlers)) {
      handlers[handlerName] = function (target, ...args) {
        // 打印操作日志
        console.log(`Handler ${HandlerName}(${objname},${args})`);
        // 委托操作
        return Reflect[handlerName](target, ...args);
      };
    }
  });

  // 返回使用日志处理器为对象创建的代理
  return new Proxy(o, handlers);
}
```

前面定义的 loggingProxy() 函数创建的代理可以把使用对象的各种操作打印出来。如果想知道某个没有文档的函数怎么使用传给它的对象，那就创建这样一个日志代理。

来看下面的例子，通过日志可以看到数组迭代的真正过程：

```js
// 定义一个数据数组和一个带有函数属性的对象
let data = [10, 20];
let methods = { square: x => x * x };

// 为个数组和对象创建日志代理
let proxyData = loggingProxy(data, 'data');
let proxyMethods = loggingProxy(methods, 'methods');

// 假设想了解 Array.map() 方法的执行过程
data.map(methods.square); // [100, 400]

// 首先，先看看日志代理数组
proxyData.map(methods.square); // [100, 400]

// 它会打印如下日志：
// Handler get(data, map)
// Handler get(data, length)
// Handler get(data, constructor)
// Handler has(data, 0)
// Handler get(data, 0)
// Handler has(data, 1)
// Handler get(data, 1)

// 接着再试试代理方法对象
data.map(proxyMethods.square); // [100, 400]
// 日志输出
// Handler get(methods, square)
// Handler methods.square(10, 0, 10, 20)
// Handler methods.square(20, 1, 10, 20)

// 最后，再通过日志代理来了解一下迭代协议
for (let x of proxyData) console.log('Datum', x);
// 日志输出
// Handler get(data, Symbol(Symbol.iterator))
// Handler get(data, length)
// Handler get(data, 0)
// Datum 10
// Handler get(data, length)
// Handler get(data, 1)
// Datum20
// Handle get(data, length)
```

根据第一段日志输出，知道 Array.map() 方法会先检查每个数组元素是否存在（因为调用了 has() 处理器），然后才真正读取元素的值（此时触发 get() 处理器）。由此可以推断，它能够区分不存在的和存在但值为 undefined 的数组元素。

第二段日志输出可以知道，传给 Array.map() 的函数在被调用时会收到 3 个参数：元素的值、元素的索引和数组本身（这个日志输出有个问题：Array.toString() 方法的返回值不包含方括号，如果输出的参数列表是(10, 0, [10, 20])就更清楚了）。

第三段日志输出可以知道，for/of 循环依赖于一个符号名为 `[Symbol.iterator]` 的方法。同时也表明，Array 类对这个迭代器方法的实现在每次迭代时都会检查数组长度，并没有假定数组长度在迭代过程中保持不变。

#### 14.7.1 代理不变式

前面定义的 readOnlyProxy() 函数创建的代理对象实际上是冻结的，即修改属性值或属性特性，添加或删除属性，都会抛出异常。但是，只要目标对象没有被冻结，那么通过 Reflect.isExtensible() 和 Reflect.getOwnPropertyDescriptor() 查询代理对象，都会告诉应该可以设置、添加或删除属性。也就是说，readonlyProxy() 创建的对象与目标对象的状态不一致。为此，可以再添加 isExtensible() 和 getOwnPropertyDescriptor() 处理器来消除不一致，或者也可以保留这种轻微的不一致。

代理处理器 API 允许定义存在重要不一致的对象，但在这种情况下，Proxy 类本身会阻止创建不一致得离谱的代理对象。代理是一种没有自己的行为的对象，因为它们只负责把所有操作转发给处理器对象和目标对象。其实这么说也不全对：**转发完操作后，Proxy 类会对结果执行合理性检查，以确保不违背重要的 JS 不变式（invariant）。如果检查发现违背了，代理会抛出 TypeError（不让操作继续）**。

如果为一个不可扩展对象创建了代理，而它的 isExtensible() 处理器返回 true，代理就会抛出 TypeError：

```js
let target = Object.preventExtensions({});
let proxy = new Proxy(target, {
  isExtensible() {
    return true;
  }
});
Reflect.isExtensible(proxy); // !TypeError：违背了不变式
```

相应地，不可扩展目标的代理就不能定义返回目标真正原型之外其他值的 getPrototypeOf() 处理器。同样，如果目标对象的某个属性不可写、不可配置，那么如果 get() 处理器返回了跟这个属性的实际值不一样的结果，Proxy 类也会抛出 TypeError：

```js
let target = Object.freezed({ x: 1 });
let proxy = new Proxy(target, {
  get() {
    return 99;
  }
});
proxy.x; // !TypeError：get() 返回的值与目标不匹配
```

> Proxy 还遵循其他一些不变式，几乎都与不可扩展的目标对象和目标对象上不可配置的属性有关。

## 十五. 浏览器中的 JS

JS 创造于 1994 年，其明确的目的就是为浏览器显示的文档赋予动态行为。自此以后，这门语言经过了多次重大改进，而与此同时，Web 平台的范围与能力也出现了爆炸式增长。今天，Web 对 JS 程序员而言已经是一个完善的应用开发平台。浏览器专注于格式化文本与图片的显示，但与原生操作系统一样，浏览器也提供了其他服务，包括图形、视频、音频、网络、存储和线程。JS 这门语言能够使 Web 应用使用 Web 平台提供的服务。

### 15.1 web 编程基础

#### 15.1.1 HTML `<script>` 标签中的 JS

浏览器显示 HTML 文档。如果想让浏览器执行 JS 代码，那么必须在 HTML 文档中包含（或引用）相应代码，这时候就要用到 HTML `<script>` 标签。

虽然 JS 代码可直接嵌入 `<script>` 标签中，但更常见的方式是使用 `<script>` 标签的 `src` 属性指定 JS 代码文件的 URL（绝对 URL 或者相对于当前 HTML 文件的相对 URL）。

JS 文件只包含纯 JS 代码，不包含 `<script>` 或其他 HTML 标签。按照约定，JS 代码文件以 _.js_ 结尾。

> **注意**：即便指定了 `src` 属性，后面的 `</script>` 标签也是 HTML 文件必需的，HTML 不支持 `<script/>` 标签。

使用 `src` 有如下优点：

- 简化 HTML 文件，因为可以把大段的 JS 代码从中移走。换句话说，这样可以实现内容与行为分离。

- 在多个网页共享同一份 JS 代码时，使用 `src` 属性可以只维护一份代码，而无须在代码变化时修改多个 HTML 文件。

- 如果一个 JS 文件被多个页面共享，那它只会被使用它的第一个页面下载一次，后续页面可以从浏览器缓存中获取该文件。

- 因为 `src` 以任意 URL 作为值，所以来自一个 Web 服务器的 JS 程序或网页可以利用其他服务器暴露的代码。很多互联网广告就依赖这个事实。

**模块**
[JS 模块](#103-es6-中的模块)介绍了 `import` 和 `export` 指令。如果用模块写了一个 JS 程序（且没有使用代码打包工具把所有模块都整合到一个非 JS 模块文件中），那必须使用一个带有 `type="module"` 属性的 `<script>` 标签来加载这个程序的顶级模块。这样，浏览器会加载指定的模块，并加载这个模块导入的所有模块，以及（递归地）加载所有这些模块导入的模块。

**指定脚本类型**
在 web 的早期，人们认为浏览器将来有一天可能实现 JS 以外的语言。为此，需要给 `<script>` 标签添加 `language="javascript"` 或 `type="application/javascript"` 属性。这些完全是没有必要的。JS 本来就是 web 的默认（也是唯一）语言。因此 `language` 属性被废弃了，而 `type` 属性也只有两个使用场景：

- 用于指定脚本是模块
- [在网页中嵌入数据但不会显示](#1534-元素内容)

**脚本运行时机：async 与 defer**
在浏览器引入 JS 语言之初，还没有任何 API 可以遍历和操作已经渲染好的文档的结构或内容。JS 代码能够影响文档内容的唯一方式，就是在浏览器加载文档的过程中动态生成内容。为此，要使用 `document.write()` 方法在脚本所在的位置向 HTML 中注入文本。

虽然现在已经不再提倡使用 `document.write()` 生成内容了，但由于还存在这种可能，浏览器在解析遇到的 `<script>` 元素时的默认行为是必须要运行脚本，就是为了确保不漏掉脚本可能输出的 HTML 内容，然后才能再继续解析和渲染文档。这有可能严重拖慢网页的解析和渲染过程。

好在默认的这种同步或阻塞式脚本执行模式并非唯一选项。`<script>` 标签也支持 `defer` 和 `async` 属性，这两个属性会导致脚本以不同的方式执行。这两个是布尔值属性，没有值，因此只要它们出现在 `<script>` 标签上就会生效。

> **注意**：这两个属性只对使用 `src` 属性的 `<script>` 标签起作用。

`defer` 和 `async` 属性都会明确告诉浏览器，当前链接的脚本中没有使用 `document.write()` 生成 HTML 输出。因此浏览器可以在下载脚本的同时继续解析和渲染文档。其中，`defer` 属性会让浏览器把脚本的执行推迟到文档完全加载和解析之后，此时已经可以操作文档了。而 `async` 属性会让浏览器尽早运行脚本，但在脚本下载期间同样不会阻塞文档解析。如果 `<script>` 标签上同时存在这两个属性，则 `async` 属性起作用。

> **注意**：推迟（defer）的脚本会按照它们在文档中出现的顺序运行。而异步（async）脚本会在它们加载完毕后运行，所以其运行顺序无法预测。

带有 `type="module"` 属性的脚本默认会在文档加载完毕后执行，就好像有一个 `defer` 属性一样。可以通过 `async` 属性来覆盖这个默认行为，这样会导致代码在模块及其所有依赖加载完毕后就立即执行。

如果不使用 `async` 和 `defer` 属性（特别是对那些直接包含在 HTML 中的代码），也可以选择把 `<script>` 标签放在 HTML 文件的末尾。这样，脚本在运行的时候就知道自己前面的文档内容已经解析，可以操作了。

**按需加载脚本**
有时，文档在刚刚加载完成时可能并不需要某些 JS 代码，只有当用户执行了某些操作，比如单击某个按钮或打开某个菜单时才需要。如果代码是以模块形式写的，则可以使用 [`import()`](#1036-通过-import-动态导入) 来按需加载。如果没有使用模块，可以通过向文档中动态添加 `<script>` 标签的方式按需加载脚本。

#### 15.1.2 文档对象模型

**客户端 JS 编程中最重要的一个对象就是 Document 对象，它代表浏览器窗口或标签页中显示的 HTML 文档。用于操作 HTML 文档的 API 被称为[文档对象模型](#153-操作-dom)**（Document Object Model，DOM）。

HTML 文档包含一组相互嵌套的 HTML 元素，构成了一棵树。DOM API 与 HTML 文档的树形结构是一一对应的。文档中的每个 HTML 标签都有一个对应的 JS Element 对象，而文档中的每一行文本也都有一个与之对应的 Text 对象。Element 和 Text 类，以及 Document 类本身，都是一个更通用的 Node 类的子类。各种 Node 对象组合成一个树形结构，JS 可以使用 DOM API 对其进行查询和遍历。

DOM API 包含创建新 Element 和 Text 节点的方法，也包含把它们作为其他 Element 对象的子元素插入文档的方法。还有用来在文档中移动元素的方法，以及把它们从文档中彻底删除的方法。服务器端应用可以通过 console.log() 产生纯文本输出，而客户端 JS 应用则可以使用 DOM API 通过构建或操作文档树产生格式化的 HTML 输出。

每个 HTML 标签类型都有一个与之对应的 JS 类，而文档中出现的每个标签在 JS 中都有对应类的一个实例表示。例如，`<body>` 标签由 HTMLBodyElement 的实例表示，而 `<table>` 标签则由 HTMLTableElement 的实例表示。JS 中这些元素对象都有与 HTML 标签的属性对应的属性。例如，表示 `<img>` 标签的 HTMLImageElement 对象有一个 `src` 属性，对应着标签的相应属性。这个属性的初始值就是 HTML 标签中相应属性的值。在 JS 中修改这个属性的值，也会改变 HTML 属性的值（并导致浏览器加载和显示新图片）。多数 JS 元素类都只是镜像 HTML 标签的属性，但有些也定义了额外的方法。比如， HTMLAudioelement 和 HTMLVideoElement 类都、定义了 play() 和 pause() 方法，用于控制音频和视频文件的回放。

#### 15.1.3 浏览器中的全局对象

每个浏览器窗口或标签页都有一个全局对象。在一个窗口中运行的所有 JS 代码（不包括在工作线程中运行的代码，参见 15.13 <!--TODO-->节）都共享一个全局对象。无论文档中包含多少脚本或模块，这个事实都不会改变：文档中的所有脚本和模块共享同一个全局对象，如果有脚本在该对象上定义了一个属性，则该属性也将对所有其他脚本可见。

全局对象上定义了 JS 标准库，比如 parseInt() 函数、Math 对象、Set 类等。在浏览器中，全局对象也包含各种 Web API 的主入口。例如，document 属性表示当前显示的文档，fetch() 方法用于发送 HTTP 网络请求，而 Audio() 构造函数允许 JS 程序播放声音。

**在浏览器中，全局对象具有双重角色。它既是定义 JS 语言内置类型和函数的地方，也代表当前浏览器窗口定义了 history（表示浏览器浏览历史，参见 15.10.2 节）和 innerWidth（表示窗口的像素宽度）等 Web APl 的属性。全局对象的属性中有一个属性叫 `window`，它的值就是全局对象本身**。这意味着在客户端代码中可以直接通过 `window` 引用全局对象。在使用窗口特定的功能时，最好加上 `window` 前缀。比如，写 window.innerwidth 比只写 innerwidth 更明确。

#### 15.1.4 脚本共享一个命名空间

在模块中，定义在模块顶级（即位于任何函数或类定义之外）的常量、变量、函数和类是模块私有的，除非它们被明确地导出。被导出时，这些模块成员可以被其他模块有选择地导入（注意，模块的这个性质使用代码打包工具时也得到了维护）。

不过在非模块脚本中，情况完全不同。如果在顶级脚本中定义了一个常量、变量、函数或类，则该声明将对同一文档中的所有脚本可见。如果一个脚本定义了函数 f()，另一个脚本定义了类 C，第三个脚本无须采取任何导入操作即可调用该函数和实例化该类。

因此如果没有使用模块，同一个文档中共享同一个命名空间的独立脚本就如同它们是一个更大脚本的组成部分一样。这对于小程序或许会很方便，但在大型程序中避免命名冲突则会变成一件麻烦事，特别是在某些脚本还是第三方库的情况下。

这个共享的命名空间在运行时有一些历史遗留问题。比如，顶级的 var 和 function 声明会在共享的全局对象上创建属性。如果一个脚本定义了顶级函数 f()，那么同一个文档中的另一个脚本可以用 f() 或者 window.f() 调用该函数。而使用 ES6 中 const、let 和 class 的顶级声明则不会在全局对象上创建属性。但是，它们仍然会定义在一个共享的命名空间内。如果一个脚本定义了类 C，另一个脚本也可以通过 new C()（但不能通过 `new window.C()`）创建该类的实例。

简单来说，**在模块中，顶级声明被限制在模块内部，可以明确导出。而在非模块脚本中，顶级声明被限制在包含文档内部，顶级声明由文档中所有的脚本共享**。以前的 var 和 function 声明是通过全局对象的属性共享的，而现在的 const，let 和 class 声明也会被共享且拥有相同的文档作用域，但它们不作为 JS 可以访问到的任何对象的属性存在。

#### 15.1.5 JS 程序的执行

客户端 JS 中没有程序的正式定义，但可以说 JS 程序由文档中包含和引用的所有 JS 代码组成。这些分开的代码共享同一个全局 Window 对象，它们可以通过这个对象访问表示 HTML 文档的同一个底层 Document 对象。不是模块的脚本还额外共享同一个顶级命名空间。

如果网页中包含嵌入的窗格（`<iframe>`元素），被嵌入文档与嵌入它的文档中的 JS 代码拥有不同的全局对象和 Document 对象，可以看成两个不同的 JS 程序。

> **注意**：关于 JS 程序的边界在哪里并没有正式的定义。如果包含文档与被包含文档是从同一个服务器加载的，则一个文档中的代码就能够与另一个文档中的代码交互。此时，如果愿意，可以把它们看成一个程序整体的两个互操作的部分。15.13.6<!--TODO--> 节将解释 JS 程序如何与在 `<iframe>` 中运行的 JS 代码相互发送和接收消息。

可以把 JS 程序的执行想象成发生在两个阶段：

1. 在第一阶段，文档内容加载完成 `<script>` 元素指定的（内部和外部）代码运行。脚本通常按照它们在文档中出现的顺序依次执行，不过也可以使用 `async` 和 `defer` 属性来修改。任何一个脚本中的 JS 代码都自上而下运行，当然还要服从 JS 的条件、循环和其他控制语句。有的脚本在这个阶段并不真正做任何事，仅仅是定义供第二阶段使用的函数和类。而有的脚本在第一阶段可能会做很多重要的事情，而在第二阶段则什么也不做。

2. 当文档加载完毕且所有脚本都运行之后，JS 执行就进入了第二阶段。这个阶段是异步的、事件驱动的。如果脚本要在第二阶段执行，那么它在第一阶段必须要做一件事，就是至少要注册一个将被异步调用的事件处理程序或其他回调函数。在事件驱动的第二阶段，作为对异步事件的回应，浏览器会调用事件处理程序或其他回调。[事件处理程序](#152-事件)通常是为响应用户操作（如鼠标点击、敲击键盘等）而被调用的，但也可能会被网络活动、文档和资源加载事件、流逝的时间或者 JS 代码中的错误触发。

事件驱动阶段发生的第一批事件主要有 “DOMContentLoaded” 和 “load”。“DOMContentLoaded” 在 HTML 文档被完全加载和解析后触发。而 “load” 事件在所有文档的外部资源（如图片）都完全加载后触发。JS 程序经常使用这两个事件作为触发器或启动信号。经常可以看到某些程序的脚本定义了一些函数，但除了注册会被事件驱动阶段开始时的 “load” 事件触发的事件处理程序之外，其他什么也不做。而负责操作文档、执行程序预定逻辑的正是这个 “load” 事件处理程序。

> **注意**：在 JS 编程中，类似的 “1oad” 事件处理程序再去注册其他事件处理程序也是很常见的。JS 程序的加载阶段相对比较短，理想情况下少于 1 秒。文档加载一完成，事件驱动阶段将在浏览器显示文档的过程中一直持续。因为这个阶段是异步的和事件驱动的，所以可能会有很长一段时间什么也不会发生，也不会执行任何 JS 代码。而这个过程时不时地会被用户操作或网络事件打断。

**客户端 JS 的线程模型**
JS 是单线程的语言，而单线程执行让编程更容易：可以保证自己写的两个事件处理程序永远不会同时运行。在操作文档内容时，敢肯定不会有别的线程会同时去修改它。而且，在写 JS 代码时，永远不需要关心锁、死锁或者资源争用。

单线程执行意味着浏览器会在脚本和事件处理程序执行期间停止响应用户输入。程序员为此有责任确保 JS 脚本和事件处理程序不会长时间运行。如果脚本执行计算量大的任务，就会导致文档加载延迟，用户在脚本执行结束前将看不到文档内容。如果事件处理程序执行计算密集型任务，浏览器可能会变得没有响应。

Web 平台定义了一种受控的编程模型，即 Web 工作线程（Web worker）。**工作线程是一个后台线程，可以执行计算密集型任务而不冻结用户界面。工作线程中运行的代码无权访问文档内容，不会与主线程或其他工作线程共享任何状态，只能通过异步消息事件与主线程或其他工作线程通信。因此这种并发对主线程没有影响，工作线程也不会改变 JS 程序的单线程执行模型**。要全面了解 Web 的安全线程机制，请参考 15.13 节<!--TODO-->。

**客户端 JS 时间线**
JS 程序会从脚本执行阶段开始，然后过渡到事件处理阶段。这两个阶段可以进一步分成下列步骤：

1. 浏览器创建 Document 对象并开始解析网页，随着对 HTML 元素及其文本内容的解析，不断向文档中添加 Element 对象和 Text 节点。此时，document.readyState 属性的值是 “loading”。

2. HTML 解析器在碰到一个没有 `async`、`defer` 或 `type="module"` 属性的 `<script>` 标签时，会把该标签添加到文档中，然后执行其中的脚本。脚本是同步执行的，而且在脚本下载（如果需要）和运行期间，HTML 解析器会暂停。类似这样的脚本可以使用 document.write() 向输入流中插入文本，而该文本在解析器恢复时将成为文档的一部分。类似这样的脚本经常只会定义函数和注册事件处理程序，以便后面使用，但它也可以遍历和操作当时已经存在的文档树。换句话说，不带 `async` 成 `defer` 属性的非模块脚本可以看到它自己的 `<script>` 标签及该标签之前的文档内容。

3. 解析器在碰到一个有 `async` 属性集的 `<script>` 元素时，会开始下载该脚本的代码（如果该脚本是模块，也会递归地下载模块的所有依赖）并继续解析文档。脚本在下载完成后会尽快执行，但解析器不会停下来等待它下载。异步（async）脚本必须不使用 document.write() 方法。它们可以看到自己的 `<script>` 标签及该标签之前的文档内容，同时也有可能访问更多文档内容。

4. 当文档解析完成后，document.readState 属性变成 “interactive”。

5. 任何有 `defer` 属性集的脚本（以及任何没有 async 属性的模块脚本）都会在按照它们在文档中出现的顺序依次执行。异步脚本也有可能在此时执行。延迟脚本可以访问完整的文档，必须不使用 document.write() 方法。

6. 浏览器在 Document 对象上派发 “DOMContentLoaded” 事件。这标志着程序执行从同步脚本执行阶段过渡到异步的事件驱动阶段。但要注意，此时仍然可能存在尚未执行的 `async` 脚本。

7. 此时文档已经解析完全，但浏览器可能仍在等待其他内容（如图片）加载。当所有外部资源都加载完成，且所有 async 脚本都加载并执行完成时，document.readyState 属性变成 “complete"，浏览器在 Window 对象上派发“load” 事件。

8. 从这一刻起，作为对用户输入事件、网络事件、定时器超时等的响应，浏览器开始异步调用事件处理程序。

#### 15.1.6 程序输入与输出

与任何程序一样，客户端 JS 程序也处理输入数据，产生输出数据。输入的来源有很多种：

- **文档的内容本身**，JS 代码可以通过 [DOM API](#153-操作-dom) 来访问。

- **[事件形式的用户输入](#152-事件)**。

- 当前显示文档的 URL 可以在客户端 JS 中通过 `document.URL` 读到。如果把这个字符串传给 [URL() 构造函数](#119-url-api)，则可以方便地取得 URL 的路径查询字符串和片段值。

- HTTP “Cookie” 请求头的内容在客户端代码中可以通过 `document.cookie` 读到。Cookie 通常被服务器端代码用来维持用户会话，但需要时客户端代码也可以读取（和写入） Cookie。更多内容可以参见 15.12.2<!--TODO--> 节。

- **全局 `navigator` 属性暴露了关于浏览器、操作系统以及它们能力的信息**。例如：`navigator.userAgent` 是标识浏览器身份的字符串，`navigator.Language` 是用户偏好语言，而 `navigator.hardwareConcurrency` 返回浏览器可用的逻辑 CPU 的个数。类似地，全局 `screen` 属性暴露了用户显示器尺寸的信息，比如 `screen.width` 和 `screen.height` 分别是显示器的宽度和高度。从某种意义上看，这些 navigator 和 screen 的值对浏览器而言就相当于 Node 程序中的环境变量。

客户端 JS 通常以借助 [DOM API](#153-操作-dom) 操作 HTML 文档的形式（或者通过使用 React 或 Angular 等高级框架操作文档）产生输出。

#### 15.1.7 程序错误

与直接运行在操作系统上的应用程序（例如 Node 应用程序）不同，在浏览器中运行的 JS 程序不会真正 “崩溃”。如果 JS 程序在运行期间出现异常，且代码中没有 catch 语句处理它，开发者控制台将会显示一条错误消息，但任何已经注册的事件处理程序照样会继续运行和响应事件。

如果想定义一个终极错误处理程序，希望在出现这种未捕获异常时调用，那可以把 Window 对象的 `onerror` 属性设置为一个错误处理函数。当未捕获异常沿调用栈一路向上传播，错误消息即将显示在开发者控制台中时，`window.onerror` 函数将会以三个字符串参数被调用。`window.onerror` 收到的第一个参数是描述错误的消息。第二个参数是一个字符串，包含导致错误的 JS 代码的 URL。第三个参数是文档中发生错误的行号。如果 onerror 处理程序返回 true，意味着通知浏览器它已经处理了错误，不需要进一步行动了，换句话说，也就是浏览器不应该再显示自己的错误消息了。

如果期约被拒绝而没有 catch() 函数处理它，那么这种情况非常类似未处理异常，也就是程序中意料之外的错误或逻辑错误。可以通过定义 `window.onunhandledrejection` 函数或者使用 window.addEventlistener() 为 “unhandledrejection” 事件注册一个处理程序来发现它。传给这个处理程序的事件对象会有一个 `promise` 属性，其值为被拒绝的 Promise 对象，还有一个 `reason` 属性，其值为本来要传 catch() 函数的拒绝理由。与前面介绍的错误处理程序类似，如果在这个未处理拒绝事件对象上调用 `preventDefault()`，浏览器就会认为错误已经处理，而不会在开发者控制台中显示错误消息了。

> 虽然定义 `onerror` 和 `onunhandledrejection` 处理程序经常不是必需的，但如果想知道用户浏览器中发生了哪些意外错误，则作为一种 “遥感” 机制，可以利用它们把客户端错误上报给服务器（比如使用 fetch()函数发送 HTTP POST 请求）。

#### 15.1.8 Web 安全模型

由于网页可以在私人设备上执行任意 JS 代码，因此存在明显的安全隐患。浏览器厂商一直在努力平衡两个相互制约的目标：

- 定义强大的客户端 API，让 Web 应用用途更广。
- 防止恶意代码读取或修改用户数据、侵犯用户隐私、欺诈用户或浪费用户的时间。

**JS 不能做什么**
**浏览器对恶意代码的第一道防线就是不支持某些能力**。例如，客户端 JS 不能向客户端计算机中写入或删除任何文件，也不能展示任意目录的内容。这意味着 JS 程序不能删除数据，也不能植入病毒。

类似地，客户端 JS 没有通用网络能力。客户端 JS 程序可以发送 HTTP 请求(参见 15.11.1 节<!--TODO-->)。而另一个标准，即 Web Socket(参见 15.1.3 节)，定义了一套类似套接口的 API，用于跟特定的服务器通信。但这些 API 都无法随意访问任意服务器。使用客户端 JS 写不出通用互联网客户端和服务器。

**同源策略**
**同源策略指的是对 JS 代码能够访问和操作什么 web 内容的一整套限制**。通常在页面中包含 `≤iframe>` 元素时就会涉及同源策略。此时，同源策略控制着一个窗格中的 JS 与另一个窗格中的 JS 的交互。比如，脚本只能读取与包含它的文档同源的 Window 和 Document 对象的属性。

文档的源就是文档 URL 的协议、主机和端口。从不同服务器加载的文档是不同源的，从相同主机的不同端口加载的文档也是不同源的。而且，对于通过 http: 协议加载的文档与通过 https: 协议加载的文档来说，即便它们来自同一台服务器，也是不同源的。浏览器通常把每个 `file:URL` 看成一个独立的源，这意味着如果写的程序会显示同台服务器上的多个文档，则可能无法使用 `file:URL` 在本地测试它，而必须在开发期间运行一个静态 Web 服务器。

有一点非常重要，就是应该知道脚本自身的源与同源策略不相关，相关的是包含脚本的文档的源。比如，假设主机 A 上有一个脚本，而主机 B 上的一个网页包含了这个脚本。则该脚本的源是主机 B，且该脚本对包含它的文档具有完全访问权。如果文档中嵌入的 `<iframe>` 包含另一个来自主机 B 的文档，则该脚本同样拥有对这个文档的完全访问权。但是，如果顶级文档包含另一个 `<iframe>`，其中显示的文档来自主机 C（或者甚至来自主机 A），则同源策略就会起作用，并阻止该脚本访问这个嵌入的文档。

同源策略也会应用到脚本发起的 HTTP 请求(参见 15.11.1 节<!--TODO-->)中。JS 代码可以向托管其包含文档的服务器发送任意 HTTP 请求，但不能与其他服务器通信（除非那些服务器开启了后面介绍的 CORS）。

同源策略对使用多子域的大型网站造成了麻烦。比如，来自 _orders.example.com_ 的脚本可能需要读取 _example:com_ 上文档的属性。为了支持这种多子域名网站，脚本可以通过把 **document.domain** 设置为一个域名后缀来修改自己的源。因此，源为 `https://orders.example.com` 的脚本通过把 **document.domain** 设置为 “example.com”，可以把自己的源修改为 `https://example.com`。但是，该脚本不能把 **document.domain** 设置为 “orders.example” “ample.com” 或 “com”。

第二种缓解同源策略的技术是跨源资源共享（Cross-Origin Resource Sharing，CORS），它允许服务器决定对哪些源提供服务。CORS 扩展了 HTTP，增加了一个新的 `Origin:` 请求头和一个新的 `Access-Control- Allow-Origin` 响应头。服务器可以使用这个头部明确列出对哪些源提供服务，或者使用通配符表示可以接收任何网站的请求。浏览器会根据这些 CORS 头部的有无决定是否放松同源限制。

**跨站点脚本**
跨站点脚本（Cross-Site-Scripting，XSS）是一种攻击方式，指攻击者向目标网站注入 HTML 标签或脚夲。客户端 JS 程序员必须了解并防范跨站点脚本。如果网页的内容是动态生成的，比如根据用户提交的数据生成内容，但却没有提前对那些数据 “消毒”（删除嵌入的 HTML 标签等），那就可能成为跨站点脚本的攻击目标。下面看一个非常简单的示例，这个示例使用 JS 根据用户输入的名字给出问候：

```html
<script>
  let name = new URL(document.URL).searchParams.get('name');
  document.querySelector('h1').innerHTML = 'Hello' + name;
</script>
```

这两行脚本会从文档 URL 中提取 “name” 这个查询参数，然后使用 DOM API 把一个 HTML 字符串注入文档的第一个 `<h1>` 标签中。页面期望的调用方式是使用类似下面这样的 URL：

```text
http://www.example.com/greet.html?name=david
```

对于这个 URL，网页会显示文本 “Hello david”。但是，如果查询参数是下面这样的，会发生什么呢?

```text
name=%3Cimg%20src=%22x.png%22%20onload=%22alert(%27hacked%27)%22/%3E
```

把这个经过 URL 转义的参数解码后，就会导致下面的 HTML 被注入文档：

```html
Hello <img src="x.png" onload="alert('hacked')" />
```

于是，在图片加载后，`onload` 属性中的 JS 字符串就会执行。全局 alert() 函数将显示一个模态对话框。显示一个对话框没什么大不了，但这演示了在这个网站上显示未经处理的 HTML 会导致任意代码执行的可能性。

之所以称其为跨站点脚本攻击，是因为会涉及不止一个网站。网站 B 包含一个特殊编制的链接（类似前面示例中的 URL），指向网站 A。如果网站 B 能够说服用户点击该链接，用户就会导航到网站 A，但网站 A 此时会运行来自网站 B 的代码。该代码可能会破坏网站 A 的页面，或者导致它功能失效。更危险的是，恶意代码可能读取网站 A 存储的 cookie（可能包含个人账号或其他用户身份信息）并将该数据发送回网站 B。这种注入的代码甚至可以跟踪用户的键盘输入，并将该数据发送回网站 B。一般来说，防止 XSS 攻击的办法是从不可信数据中删除 HTML 标签，然后再用它去动态创建文档内容。对于前面展示的 _greet.html_，可以通过把不可信输入中的特殊 HTML 字符替换成等价的 HTML 实体来解决问题：

```js
name = name
  .replace(/&/g, '&amp;')
  .replace(/</g, '&lt;')
  .replace(/>/g, '&gt;')
  .replace(/"/g, '&quot;')
  .replace(/'/g, '&#x27;')
  .replace(/\//g, '&#x2F;');
```

应对 XSS 攻击的另一个思路是让 Web 应用始终在一个 `<iframe>` 中显示不可信内容，并将这个 `<iframe>` 的 sandbox 属性设置为禁用脚本和其他能力。

跨站点脚本作为一种有害的漏洞，其根源可以追溯到 web 的架构设计。

### 15.2 事件

客户端 JS 程序使用异步事件驱动的编程模型。在这种编程风格下，浏览器会在文档、浏览器或者某些元素或与之关联的对象发生某些值得关注的事情时生成事件。例如，浏览器会在它加载完文档时生成事件，在用户把鼠标移到超链接上时生成事件。如果 JS 应用关注特定类型的事件，那它可以注册一个或多个函数，让这些函数在该类型事件发生时被调用。

> **注意**：这并非 Web 编程的专利，任意具有图形用户界面的应用都是这样设计的。换句话说，界面就在那里等待用户与之交互（也可以说，它们在等待事件发生），然后给出响应。

在客户端 JS 中，事件可以在 HTML 文档中的任何元素上发生，这也导致了浏览器的事件模型比 Node 的事件模型明显更复杂。下面是事件模型的几个重要的定义：

_事件类型_
: **事件类型是一个字符串，表示发生了什么事件**。例如，“mousemove” 表示用户移动了鼠标，“keydown” 表示用户按下了键盘上的某个键，而 “load” 表示文档（或其他资源）已经通过网络加载完成。因为事件类型是字符串，所以有时也称它为事件名称。

_事件目标_
: **事件目标是一个对象，而事件就发生在该对象上或者事件与该对象有关**。说到某个事件，必须明确它的类型和目标。Window、Document 和 Element 对象是客户端 JS 应用中最常见的事件目标，不过也有一些事件会在其他对象上发生。例如，Worker 对象(15.13<!--TODO--> 节介绍的一种线程)是 “message” 事件的目标，这种事件在工作线程向主线程发消息时发生。

_事件处理程序或事件监听器_
: **事件处理程序或事件监听器是一个函数，负责处理或响应事件**。应用通过浏览器注册自己的事件处理程序，指定事件类型和事件目标。当事件目标上发生指定类型的事件时，浏览器会调用这个处理程序。当事件处理程序在某个对象上被调用时，浏览器 “触发” “派发” 或 “分派” 了该事件。注册事件处理程序有不同的方式，[注册](#1522-注册事件处理程序)和[调用](#1523-调用事件处理程序)。

_事件对象_
: **事件对象是与特定事件关联的对象，包含有关该事件的细节**。事件对象作为事件处理程序的参数传入。所有事件对象都有 `type` 和 `target` 属性，分别表示事件类型和事件目标。每种事件类型都为相关的事件对象定义了一组属性。比如，与鼠标事件相关的事件对象包含鼠标指针的坐标，与键盘事件相关的事件对象包含与被按下的键以及按住不放的修饰键的信息。很多事件类型只定义几个标准属性（包括 type 和 target），并没有其他有用信息。对这些事件，重要的是它们发生了，而不是事件的细节。

_事件传播_
: **[事件传播](#1524-事件传播)是一个过程，浏览器会决定在这个过程中哪些对象触发事件处理程序**。对于 Window 对象上的 “load” 或 Worker 对象上的 “message” 等特定于一个对象的事件，不需要传播。但对于发生在 HTML 文档中的某些事件，则会 “冒泡”（bubble）到文档根元素。如果用户在一个超链接上移动鼠标，这个鼠标事件首先会在定义该超链接的 `<a>` 元素上触发，然后在包含元素上触发，可能经过一个 `<p>` 元素、一个 `<section>` 元素，然后到达文档对象本身。有时，只给文档或包含元素注册一个事件处理程序，比给关心的每个元素都分别注册一个处理程序更方便。事件处理程序可以阻止事件传播，从而让事件不再冒泡，也就不会在包含元素上触发处理程序。为此，事件处理程序需要调用事件对象上的一个方法。在另外一种事件传播形式，即事件捕获（event capturing）中，注册在包含元素上的处理程序在事件被发送到实际目标之前，有机会先拦截（或捕获）事件。有些事件有与之关联的默认动作（default action）。比如，单击一个超链接，默认动作是让浏览器跟随链接，加载一个新页面。事件处理程序可以通过调用事件对象的一个方法来阻止这个默认动作。对此，有时也称为 [“取消” 事件](#1525-事件取消)。

#### 15.2.1 事件类别

客户端 JS 支持的事件类型非常多，本章不可能全部介绍。不过，可以将这些事件分成通用的类别，从而了解它们的范围和差异。

_设备相关输入事件_
: **这类事件直接与特定输入设备（例如鼠标或键盘）相关**。这类事件类型包括 “mousedown” “mousemove” “mouseup” “touchstart” “touchmove” “touchend” “keydown” “keyup” 等等。

_设备无关输入事件_
: **这类输入事件并不与特定输入设备直接相关**。比如，“click” 事件表示一个链接或按钮（或其他文档元素）已经被激活。一般来说，这个事件是通过鼠标触发的，但也可能是通过键盘或（在触屏设备上）通过轻击触发的。而“input” 事件是对 “keydown” 事件的设备无关的替代，既支持键盘输入，也支持剪切粘贴和表意文字的输入法。“pointerdown” “countermove” 和 “pointerup”事件是对鼠标和触摸事件的设备无关的替代。它们既适用于鼠标类型的指针，也适用于触屏，以及手写笔输入。

_用户界面事件_
: **UI 事件是高级事件，通常在定义应用界面的 HTML 表单元素上触发**。这类事件包括 “focus”（当文本输入字段获得键盘焦点时）、“change”（当用户修改了表单元素显示的值时）和 “submit”（当用户单击表单中的“提交”按钮时）。

_状态变化事件_
: **有些事件并不直接由用户活动触发，而是由网络或浏览器活动触发。这类事件表示某种生命期或状态相关的变化**。其中，分别由 Window 和 Document 对象在文档加载结束时触发的 “load” 和 “DOMContentLoaded” 事件可能是这类事件中最常用的两个事件。浏览器会在网络连接变化时在 Window 对象上触发 “online” 和 “offline” 事件。浏览器的历史管理机制（见 15.10.4 节）<!--TODO-->会触发 “popstate” 事件作为对浏览器 “后退” 按钮的回应。

_API 特定事件_
: **有一些 HTML 及相关规范定义的 Web API 包含自己的事件类型**。HTML 的 `<video>` 和 `<audio>` 元素定义了一系列事件，比如 “waiting” “playing” “seeking” “volumechange”，等等。可以使用这些事件自定义媒体播放。一般来说，在 JS 支持期约以前定义的异步 Web 平台 API 都是事件驱动的，会定义 API 特定事件。比如，IndexedDB API(见 15.12.3 节<!--TODO-->)在数据库请求成功和失败时分别触发 “success” 和 “error” 事件。虽然用于发送 HTTP 请求的新 fetch()API(见 15.11.1 节)是基于期约的，但它取代的 XMLHttpRequest API 则定义了一些 API 特定事件。

#### 15.2.2 注册事件处理程序

有两种注册事件处理程序的方式：

- Web 早期就有的，即设置作为事件目标的对象或文档元素的一个属性。

- 更新也更通用的是把处理程序传给这个对象或元素的 addEventListener() 方法

**设置事件处理程序属性：JavaScript**
注册事件处理程序最简单的方式就是把事件目标的一个属性设置为关联的事件处理程序函数。按照惯例，事件处理程序属性的名字都由 “on” 和事件名称组成。

> **注意**：这些属性名是区分大小写的，必须全部小写，即便事件类型包含多个单词。

使用事件处理程序属性有一个缺点，即这种方式假设事件目标对每种事件最多只有一个处理程序。一般来说，**使用 addEventlistener() 注册事件处理程序更好，因为该技术不会重写之前注册的处理程序**。

**设置事件处理程序属性：HTML**
文档元素的事件处理程序属性也可以直接在 HTML 文件中作为对应 HTML 标签的属性来定义（在 JS 中注册在 Window 元素上的处理程序在 HTML 中可以定义为 `<body>` 标签的属性）。现代 Web 开发中通常不提倡使用这种技术，但它是可能的。

在使用 HTML 属性定义事件处理程序时，属性的值应该是一段 JS 代码字符串。这段代码应该是事件处理程序函数的函数体，不是完整的函数声明。换句话说，HTML 事件处理程序的代码应该没有外围的大括号，前面也没有 function 关键字。例如：

```js
<button onclick="console.log('Thank you');">Please Click</button>
```

如果一个 HTML 事件处理程序属性包含多条 JS 语句，则必须用分号分隔这些语句，或者用回车把这个属性值分成多行。

在给 HTML 事件处理程序属性指定 JS 代码字符串时，浏览器会把这个字符串转换为一个函数，这个函数类似如下所示：

```js
function (event) {
  with (document) {
    with (this.form || {}) {
      with (this) {
        /* 代码在这里 */
      }
    }
  }
}
```

这个 `event` 参数意味着处理程序代码可以通过它引用当前的事件对象。而 with 语句意味着处理程序可以直接引用目标对象乃至 Document 对象的属性，就像它们都是作用域内的变量一样。严格模式下是禁止使用 with 语句的，但 HTML 属性中的 JS 代码没有严格这一说。这样定义的事件处理程序将在一个可能存在意外变量的环境中执行，因此可能是一些讨厌的 bug 的来源，也是避免在 HTML 中编写事件处理程序的一个充分理由。

**addEventListener()**
**任何可以作为事件目标的对象（包括 Window 和 Document 对象以及所有文档元素），都定义了一个名为 `addEventListener()` 的方法，可以使用它来注册目标为调用对象的事件处理程序**。addEventListener() 接收 3 个参数：

- 第一个参数是注册处理程序的事件类型。事件类型（或名称）是一个字符串，不包含作为 HTML 元素属性使用时的前缀 “on”。

- 第二个参数是当指定类型的事件发生时调用的函数。

- 可选的第三个参数是一个布尔值或对象。

> **可以多次调用 `addEventlistener()` 在同一个对象上为同一事件类型注册多个处理程序**。当对象上发生该事件时，所有为这个事件而注册的处理程序都会按照注册它们的顺序被调用。在同一个对象上以相同的参数多次调用 `addEventlistener()` 没有作用，同一个处理程序只能注册一次，重复调用不会改变处理程序被调用的顺序。

**与 `addEventlistener()` 对应的是 `removeEventListener()` 方法，它们的前两个参数是一样的（第三个参数也是可选的），只不过是用来从同一个对象上移除而不是添加事件处理程序**。

`addEventlistener()` 可选的第三个参数是一个布尔值或对象。如果传入 true，函数就会被注册为捕获事件处理程序，从而在事件派发的另一个阶段调用它。15.2.4 节<!--TODO-->将介绍事件捕获。如果在注册事件监听器时给第三个参数传了 true，那么要移除该事件处理程序，必须在调用 `removeEventListener()` 时也传入 true 作为第三个参数。

注册捕获事件处理程序只是 `addEventlistener()` 支持的 3 个选项之一。如果要传入其他选项，可以给第三个参数传一个对象，显式指定这些选项：

```js
document.addEventListener('click', handleClick, {
  capture: true,
  once: true,
  passive: true
});
```

如果这个 Options（选项）对象的 `capture` 属性为 true，那么函数就会被注册为捕获处理程序。如果这个属性为 false 或省略该属性，那么处理程序就不会注册到捕获阶段如果选项对象有 `once` 属性且值为 true，那么事件监听器在被触发一次后会自动移除。如果这个属性为 false 或省略该属性，那么处理程序永远不会被自动移除。

如果选项对象有 `passive` 属性且值为 true，则表示事件处理程序永远不调用 [`preventDefault()` 取消默认动作](#1525-事件取消)。这对于移动设备上的触摸事件特别重要。如果 “touchmove” 事件可以阻止浏览器的默认滚动动作，那浏览器就不能实现平滑滚动。`passive` 属性提供了一种机制，即在注册一个可能存在破坏性操作的事件处理程序时，让浏览器知道可以在事件处理程序运行的同时安全地开始其默认行为（如滚动）。平滑滚动对保证良好的用户体验非常重要，因此 Firefox 和 Chrome 都默认把 “touchmove” 和 “mousewheel” 事件设置为 “被动式”（passive: true）。如果确实想为这两个事件注册一个会调用 preventDefault() 的事件处理程序，应该显式地将 `passive` 属性设置为 false。

可以把选项对象传给 `removeEventListener()`，但其中只有 `capture` 属性才是有用的。

#### 15.2.3 调用事件处理程序

注册事件处理程序后，浏览器会在指定对象发生指定事件时自动调用它。本节介绍调用事件处理程序的细节，解释事件处理程序的参数、调用上下文（this 值）和事件处理程序返回值的含义。

**事件处理程序的参数**
事件处理程序被调用时会接收到一个 Event 对象作为唯一的参数。这个 Event 对象的属性提供了事件的详细信息。

type
: 发生事件的类型。

target
: 发生事件的对象。

currentTarget
: 对于传播的事件，这个属性是注册当前事件处理程序的对象。

timeStamp
: 表示事件发生时间的时间戳（毫秒），不是绝对时间。可以用第二个事件的时间戳减去第一个事件的时间戳来计算两个事件相隔多长时间。

isTrusted
: 如果事件由浏览器自身派发，这个属性为 true；如果事件由 JS 代码派发，这个属性为 false。

**事件处理程序的上下文**
在通过设置属性注册事件处理程序时，看起来就像为目标对象定义了一个新方法：

```js
target.onclick = function () {
  /* 处理程序的代码 */
};
```

因此，没有意外，这个事件处理程序将作为它所在对象的方法被调用。换句话说，在事件处理程序的函数体中，this 关键字引用的是注册事件处理程序的对象。

> 即便使用 `addEventlistener()` 注册，处理程序在被调用时也会以目标作为其 this 值。不过，这不适用于箭头函数形式的处理程序。箭头函数中 this 的值始终等于定义它的作用域的 this 值。

**处理程序的返回值**
**在现代 JS 中，事件处理程序不应该返回值**。在比较老的代码中，还可以看到返回值的事件处理程序，而且返回的值通常用于告诉浏览器不要执行与事件相关的默认动作。比如，如果一个表单 Submit 按钮的 onclick 处理程序返回 false，浏览器将不会提交表单。

**阻止浏览器执行默认动作的标准且推荐的方式，是调用 Event 对象的 [`preventDefault()`](#1525-事件取消) 方法**(参见 15.2.5 <!--TODO-->节)。

**调用顺序**
一个事件目标可能会为一种事件注册多个处理程序。当这种事件发生时，浏览器会按照注册处理程序的顺序调用它们。有意思的是，即便混合使用 addEventListener() 注册的事件处理程序和在对象属性 onclick 上注册的事件处理程序，结果仍然如此。

#### 15.2.4 事件传播

如果事件的目标是 Window 或其他独立对象，浏览器对这个事件的响应就是简单地调用该对象上对应的事件处理程序。如果事件目标是 Document 或其他文档元素，就没有那么简单了。

注册在目标元素上的事件处理程序被调用后，多数事件都会沿 DOM 树向上 “冒泡”。目标父元素的事件处理程序会被调用。然后注册在目标祖父元素上的事件处理程序会被调用。就这样一直向上到 Document 对象，然后到 Window 对象。由于事件冒泡，可以不用给个别文档元素注册很多事件处理程序，而是只在它们的公共祖先元素上注册个事件处理程序，然后在其中处理事件。

多数在文档元素上发生的事件都会冒泡。明显的例外是 “focus” “blur” 和 “scroll” 事件。文档元素的 “load” 事件冒泡，但到 Document 对象就会停止冒泡，不会传播到 Window 对象（Window 对象的 “load”事件处理程序只会在整个文档加载完毕后才被触发）。

事件冒泡是事件传播的第三个 “阶段”。调用目标对象本身的事件处理程序是第二个阶段。第一阶段，也就是在目标处理程序被调用之前的阶段，叫作 “捕获” 阶段。如果 addEventlistener() 接收的第三个可选参数是 true 或 `{capture:true}`，那么就表明该事件处理程序会注册为捕获事件处理程序，将在事件传播的第一阶段被调用。事件传播的捕获阶段差不多与冒泡阶段正好相反。最先调用的是 Window 对象上注册的捕获处理程序，然后才调用 Document 对象的捕获处理程序，接着才是 `<body>` 元素。然后沿 DOM 树一直向下，直到事件目标父元素的捕获事件处理程序被调用。注册在事件目标本身的捕获事件处理程序不会在这个阶段被调用。

**事件捕获提供了把事件发送到目标之前先行处理的机会**。捕获事件处理程序可用于调试，或者使用下一节介绍的事件取消技术过滤事件，让目标事件处理程序永远不会被调用。事件捕获最常见的用途是处理鼠标拖动，因为鼠标运动事件需要被拖动的对象来处理，而不是让位于其上的文档元素来处理。

#### 15.2.5 事件取消

- **preventDefault()**
  浏览器对很多用户事件都会作出响应，无论是否在代码中指定。比如用户在触摸屏上滑动手指，浏览器就会滚动。如果为这些事件注册了事件处理程序，那么就可以阻止浏览器执行其默认动作，为此要调用事件对象的 `preventDefault()` 方法（除非注册处理程序时传入了 `passive` 选项，该选项会导致 `preventDefault()` 无效）。

- **stopPropagation()**
  取消与事件关联的默认动作只是事件取消的一种情况。除此之外，还可以调用事件对象的 `stopPropagation()` 方法，取消事件传播。使用 `preventDefault()`，如果同一对象上也注册了其他处理程序，则这些处理程序仍然会被调用。但是，在这个对象上调用 `stopPropagation()` 方法之后，其他对象上的事件处理程序都不会再被调用。`stopPropagation()` 可以在捕获阶段、在事件目标本身，以及在冒泡阶段起作用。

  > `stopImmediatePropagation()` 与 `stopPropagation()` 类似，只不过它**会阻止在同一个对象上注册的后续事件处理程序的执行**。

#### 15.2.6 派发自定义事件

客户端 JS 事件 API 相对比较强大，可以使用它定义和派发自己的事件。比如，程序需要周期性地执行耗时计算或者发送网络请求，而在执行此操作期间，不能执行其他操作。想在此时显示一个转轮图标，告诉用户应用程序正忙。但忙碌的模块不需要知道应该在哪里显示转轮图标，它只需要派发一个事件，宣布自己正忙，然后在自己不忙的时候再派发另一个事件即可。UI 模块可以为这两个事件注册处理程序，然后以适当的方式在 UI 上告知用户即可。

如果一个 JS 对象有 `addEventlistener()` 方法，那它就是一个 “事件目标”。这意味着该对象也有一个 `dispatchEvent()` 方法。可以通过 `CustomEvent()` 构造函数创建自定义事件对象，然后再把它传给 `dispatchEvent()`。`CustomEvent()` 的第一个参数是一个字符串，表示事件类型；第二个参数是一个对象，用于指定事件对象的属性。可以将这个对象的 `detail` 属性设置为一个字符串、对象或其他值，表示事件的上下文。如果想在一个文档元素上派发自己的事件，并希望它沿文档树向上冒泡，则要在第二个参数中添加 `bubbles:true`。下面看一个例子：

```js
// 派发一个自定义事件，通知 UI 自已正忙
document.dispatchEvent(new CustomEvent('busy', { detail: true }));

// 执行网络操作
fetch(url)
  .then(handleNetworkResponse)
  .catch(handleNetworkError)
  .finally(() => {
    // 无论网络请求成功还是失败，都再派发一个事件，通知 UI 现在已经不忙了
    document.dispatchEvent(new CustomEvent('busy', { detail: false }));
  });

// 在代码其他地方为 “busy” 事件注册一个处理程序并通过它显示或隐藏转轮图标，告知用户忙与闲
document.addEventListener('busy', e => {
  if (e.detail) {
    showSpinner();
  } else {
    hideSpinner();
  }
});
```

### 15.3 操作 DOM

客户端 JS 存在的目的就是把静态 HTML 文档转换为交互式 Web 应用。因此通过脚本操作网页内容无疑是 JS 的核心目标。

每个 Window 对象都有一个 document 属性，引用一个 Document 对象。这个 Document 对象代表窗口的内容。不过，Document 对象并不是孤立存在的，它是 DOM 中表示和操作文档内容的核心对象。本节详细讲解 DOM API，包括以下内容：

- 如何查询或选择文档中特定的元素。
- 如何遍历文档，如何查找任何文档元素的祖先、兄弟元素和后代。
- 如何查询和设置文档元素的属性。
- 如何查询、设置和修改文档的内容。
- 如何修改文档的结构，包括创建、插入和删除节点

#### 15.3.1 选择 Document 元素

客户端 JS 程序经常需要操作文档中的一个或多个元素。全局 document 属性引用 Document 对象，而 Document 对象有 `head` 和 `body` 属性，分别引用 `<head>` 和 `<body>` 标签对应的 Element 对象。但一个程序要想操作文档中嵌入层级更多的元素，必须先通过某种方式获取或选择表示该元素的 Element 对象。

**通过 CSS 选择符选择元素**
CSS 样式表有一个非常强大的语法，就是它的选择符（selector）。选择符用来描述文档中元素或元素的集合。DOM 方法 `querySelector()` 和 `querySelectorAll()` 能够在文档中找到与指定选择符匹配的元素。

CSS 选择符可以通过元素类型（标签）、ID、类名、属性，以及元素在文档中的位置来引用元素。`querySelector()` 方法接收一个 CSS 选择符字符串作为参数，返回它在文档中找到的第一个匹配的元素；如果没有找到，则返回 null。

`querySelectorAll()` 也类似，只不过返回文档中所有的匹配元素，而不是只返回第一个。

`querySelectorAll()` 的返回值不是 Element 对象的数组，而是一个类似数组的 NodeList 对象。NodeList 对象有一个 `length` 属性，可以像数组一样通过索引访问，因此可以使用传统的 for 循环遍历。Nodelist 也是可迭代对象，因此也可以在 for/of 循环中使用它们。如果想把 NodeList 转换为真正的数组，只要把它传给 Array.from() 即可。

如果文档中没有与指定选择符匹配的元素，则 `querySelectorAll()` 返回的 NodeList 的 length 属性为 0。

Element 类和 Document 类都实现了 `querySelector()` 和 `querySelectorAll()`。当在元素上调用时，这两个方法只返回该元素后代中的元素。

CSS 也定义了 `::first-line` 和 `::first-letter` 伪元素。在 CSS 中，它们只匹配文本节点的一部分，而不匹配实际的元素。在 `querySelector()` 或 `querySelectorAll()` 中使用它们什么也找不到。而且，很多浏览器也拒绝对 `:link` 和 `:visited` 伪类返回匹配结果，因为这有可能暴露用户的浏览历史。

还有一个基于 CSS 的元素选择方法：`closest()`。这个方法是 Element 类定义的，以一个选择符作为唯一参数。如果选择符匹配那个调用它的元素，则返回该元素，否则就返回与选择符匹配的最近祖先元素；如果没有匹配，则返回 null。某种意义上看，`closest()` 是 `querySelector()` 的逆向操作：`closest()` 从当前元素开始，沿 DOM 树向上匹配；而 `querySelector()` 则从当前元素开始，沿 DOM 树向下匹配。如果在文档树中某个高层级注册了事件处理程序，`closest()` 通常能派上用场。比如，在处理一个单击事件时，可能想知道该事件是否发生在一个超链接上。事件对象会告诉事件目标，但该目标也许是超链接的文本而非 a 标签本身。为此，可以让事件处理程序像这样查找最近的超链接：

```js
// 查找有 href 属性的最近的外围 <a> 标签
let hyperlink = event.target.closest('a[href]');
```

下面是使用 closest() 的另一个例子：

```js
// 如果 e 被包含在一个 HTML 列表元素内则返回 true
function insideList(e) {
  return e.closest('ul, ol, dl') !== null;
}
```

另一个相关的方法 `matches()` 既不返回祖先，也不返回后代，只会检查元素是否与选择符匹配。如果匹配，返回 true；否则，返回 false：

```js
// 如果 e 是一个 HTML 标题元素则返回 true
function isHeading(e) {
  return e.matches('h1, h2, h3, h4, h5, h6');
}
```

**其他选择元素的方法**
除了 `querySelector()` 和 `querySelectorAll()`，DOM 也定义了一些[其他的元素选择方法](/front_end/浏览器的实现原理与API/浏览器实现原理与API.md#214-查找元素)。

**预选择的元素**
由于历史原因，Document 类定义了一些快捷属性，可以通过它们直接访问某种节点。例如，通过 images、forms 和 links 属性可以直接访问文档中的 `<img>`、`<form>` 和 `<a>`元素（但只有 `<a>` 标签有 href 属性）。这些属性引用的是 HTMLCollection 对象，与 Nodelist 对象非常相似，只是还可以通过元素 ID 或名字来索引其中的元素。

例如，使用 `document.forms` 属性，可以像下面这样访问 `<form id="address">` 标签：

```js
document.forms.address;
```

#### 15.3.2 文档结构与遍历

从 Document 中选择一个 Element 之后，常常还需要査找文档结构中相关的部分（父元素、兄弟元素、子元素）。如果只关心文档中的 Element 而非其中的文本（以及元素间的空白，其实也是文本），有一个遍历 API 可以把文档作为一棵 Element 对象树，树中不包含同样属于文档的 Text 节点。这个遍历 API 不涉及任何方法，而只是 Element 对象上的一组属性。使用这些属性可以引用当前元素的父元素、子元素和兄弟元素：

parentNode
: **这个属性引用元素的父节点**，也就是另一个 Element 对象，或者 Document 对象。

children
: **这个属性是 Nodelist，包含元素的所有子元素**，不含非 Element 节点，如 Text 节点（也不含 Comment 节点）。

childElementCount
: **这个属性是元素所有子元素的个数**。与 children.length 返回的值相同。

firstElementchild、lastElementChild
: **这两个属性分别引用元素的第一个子元素和最后一个子元素**。如果没有子元素，它们的值为 null。

**previousELementSibling、nextELementSibling**
: **这两个属性分别引用元素左侧紧邻的兄弟元素和右侧紧邻的兄弟元素**，如果没有相应的兄弟元素则为 null。

使用这些 Element 属性，可以用下面任意一个表达式引用 Document 第一个子元素的第二子元素：

```js
// 在标准 HTML 文档中，这两个表达式引用的都是文档的 `<body>` 标签。
document.children[0].children[1];
document.firstElementChild.firstELementChild.nextElementSibling;
```

下面这两个函数演示了如何使用这些属性对文档执行深度优先的遍历，并对文档的每个元素都调用一次指定的函数：

```js
// 递归遍历 Document 或 ELement e
// 在 e 和每个后代元素上调用函数 f
function traverse(e, f) {
  f(e); // 在 e 上调用 f()
  // 迭代所有子元素
  for (let child of e.children) {
    traverse(child, f); // 每个孩子递归
  }
}

function traverse(e, f) {
  f(e); // 在 e 上调用 f()
  let child = e.firstElementChild; // 链表式迭代子元素
  while (child !== null) {
    traverse(child, f); // 并在这里递归
    child = child.nextELementSibling;
  }
}
```

**作为节点树的文档**
如果在遍历文档或文档中的某些部分时不想忽略 Text 节点，可以使用另一组在所有 Node 对象上都有定义的属性。通过这些属性可以看到 Element、Text 节点，甚至 Comment 节点（表示文档中的 HTML 注释）。

所有 Node 对象都定义了以下属性：

parentNode
: 当前节点的父节点，对于没有父节点的节点或 Document 对象则为 null。

childNodes
: 只读的 NodeList 对象，包含节点的所有子节点（不仅仅是 Element 子节点）。

firstChild、lastChild
: 当前节点的第一个子节点和最后一个子节点，如果没有子节点则为 null。

previousSibling、nextSibling
: 当前节点的前一个兄弟节点和后一个兄弟节点。这两个属性通过双向链表连接节点。

nodeType
: 表示当前节点类型的数值。Document 节点的值为 9，Element 节点的值为 1，Text 节点的值为 3，Comment 节点的值为 8。

nodeValue
: Text 或 Comment 节点的文本内容。

nodeName
: Element 节点的 HTML 标签名，会转换为全部大写。

#### 15.3.3 属性

**HTML 元素由标签名和一组称为属性的名/值对构成**。

Element 类定义了通用的 `getAttribute()`、`setAttribute()`、`hasAttribute()` 和 `removeAttribute()` 方法，用于査询、设置、检测和删除元素的属性。但 HTML 元素的属性（指所有标准 HTML 元素的标准属性）同时也在表示这些元素的 HTMLElement 对象上具有相应的属性。而作为 JS 属性来存取它们，通常要比调用 getAttribute() 及其他方法来得更便捷。

**作为元素属性的 HTML 属性**
表示 HTML 文档中元素的 Element 对象通常会定义读/写属性，镜像该元素的 HTML 属性。HTMLElement 为通用 HTML 属性（如 id、title、lang 和 dir）和事件处理程序属性（如 onclick）定义了属性。特定的 Element 子类型则定义了特定于相应元素的属性。

对于某些元素（比如 `<input>`)，有的 HTML 属性名会映射到不同的 JS 属性。比如，`<input>` 元素在 HTML 中的 value 属性是由 JS 的 defaultValue 属性镜像的。JS 的 value 属性包含的是用户当前在 `<input>` 元素中输入的值。但是修改这个 value 属性，既不会影响 JS 的 defaultValue 属性，也不会影响 HTML 的 value 属性。

HTML 属性是不区分大小写的，但 JS 属性名区分大小写。要把 HTML 属性转换为 JS 属性，全部小写即可。如果 HTML 属性包含多个单词，则从第二个单词开始，每个单词的首字母都大写。比如，defaultChecked 和 tabIndex。不过，**事件处理程序属性是例外，需要全部小写**。

有些 HTML 属性名是 JS 中的保留字。对于这些属性，通用规则是对应的 JS 属性包含前缀 “html”。比如，`<labeL>` 元素在 HTML 中的 `for` 属性，变成了 JS 的 `htmlFor` 属性。“class” 也是 JS 的保留字，但这个非常重要的 HTML `class` 属性是个例外，它在 JS 代码中会变成 `className`。

JS 中表示 HTML 属性的这些属性通常都是字符串值。但是当 HTML 属性是布尔值或数字值时（如`<input>`元素的 defaultChecked 和 maxLength 属性），相应的 JS 属性则是布尔值或数值，不是字符串。事件处理程序属性的值则始终是函数（或 null）。

> **注意**：这个基于属性的 API 只能获取和设置 HTML 中对应的属性值，并没有定义从元素中删除属性的方式。特别地，不能用 delete 操作符来删除 HTML 属性。如果真想删除 HTML 属性，可以在 JS 中调用 `removeAttribute()` 方法。

**class 属性**
HTML 元素的 `class` 属性特别重要。它的值是空格分隔的 CSS 类名的列表，用于给元素应用 CSS 样式。由于 `class` 在 JS 中是保留字，所以这个 HTML 属性是通过 Element 对象上的 `className` 属性反映出来的。

`className` 属性可用于设置或返回 HTML 中 class 属性的字符串值。但 class 属性这个名字并不恰当，因为它的值是一个 CSS 类名的列表。在这个列表中添加或删除某个类名（而不是把列表作为整个字符串来操作）在客户端 JS 编程中非常常见。

为此，Element 对象定义了 `classList` 属性，支持将 `class` 属性作为一个列表来操作。`classList` 属性的值是一个迭代的类数组对象。虽然这个属性的名字叫 `classList`，但它的行为更像类名的集合，而且定义了 `add()`、`remove()`、`contains()` 和 `toggle()` 方法。

**dataset 属性**
有时候在 HTML 元素上附加一些信息很有用，因为 JS 代码在选择并操作相应的元素时可以使用这些信息。在 HTML 中，任何以前缀 `data-` 开头的小写属性都被认为是有效的，可以将它们用于任何目的。这些 “数据集”（ dataset）属性不影响它们所在元素的展示，在保证文档正确性的前提下定义了一种附加额外数据的标准方式。

在 DOM 中，Element 对象有一个 `dataset` 属性，该属性引用的对象包含与 HTML 中的 `data-` 属性对应的属性，但不带这个前缀。也就是说，`dataset.x` 中保存的是 HTML 中 `data-x` 属性的值。连字符分隔的属性将映射为驼峰式属性名：HTML 中的 data-sectlon-number 会变成 JS 中的 dataset.sectionNumber。

#### 15.3.4 元素内容

接下来几小节介绍如何操作元素内容的 HTML 表示和纯文本表示。

**作为 HTML 的内容**
读取一个 Element 的 `innerHTML` 属性会返回该元素内容的标记字符串。在元素上设置这个属性会调用浏览器的解析器，并以新字符串解析后的表示替换元素当前的内容。浏览器非常擅长解析 HTML，设置 `innerHTML` 通常效率很高。

> **注意**：通过 `+=` 操作符给 `innerHTML` 追加文本的效率不高。因为这个操作既会涉及序列化操作，也会涉及解析操作：先把元素内容转换为字符串，然后再把新字符串转换回元素内容。

Element 的 `outerHTML` 属性与 `innerHTML` 属性类似，只是返回的值包含元素自身。在读取 `outerHTML` 时，该值包含元素的开始和结束标签。而在设置元素的 `outerHTML` 时，新内容会取代元素自身。

> **注意**：在使用这些 HTML API 时，一定要永远不要把用户输入直接插到文档中。如果这样做，恶意用户可能会将他们的脚本[插入应用](#1518-web-安全模型)。

另一个相关的 Element 方法是 `insertAdjacentHTML()`，用于插入与指定元素 “相邻”（adjacent）的任意 HTML 标记字符串。要插入的标签作为第二个参数传入，而 “相邻” 的精确含义取决于第一个参数的值。第一个参数可以是以下字符串值中的一个：“beforebegin” “afterbegin” “beforeend” “afterend”。图 15-2 展示了这几个值对应的插入位置。

![insertAdjacentHTML()的插入位置](<./image/insertAdjacentHTML()的插入位置.jpg>)

**作为纯文本的内容**
有时候，希望得到元素的纯文本内容，或者向文档中插入纯文本（不转义 HTML 中使用的尖括号和 & 字符）。这样做的标准方式是使用 `textContent` 属性。

这个 `textContent` 属性是由 Node 类定义的，因此在 Text 节点和 Element 节点上都可以使用。对于 Element 节点，它会找到并返回元素所有后代中的文本。

> Element 类定义了一个 `innerText` 属性，与 `textContent` 类似。但 `innerText` 有一些少见和复杂的行为，如试图阻止表格格式化。这个属性的定义不严谨，浏览器间的实现也存在兼容性问题，因此不应该再使用了。

**`<script>` 元素中的文本**
行内（即那些没有 src 属性的）`<script>` 元素有一个 `text` 属性，可以用于获取它们的文本。浏览器永远不会显示 `<script>` 元素的内容，HTML 解析器会忽略脚本中的尖括号和 & 字符。这就让 `<script>` 元素成为在 Web 应用中嵌入任意文本数据的理想场所。只要把这个元素的 `type` 属性设置为某个值（如 text/x-custom-data），明确它不是可执行的 JS 代码即可。这样，JS 解释器将会忽略这个脚本，但该元素还会出现在文档树中，它的 `text` 属性可以返回在其中保存的数据。

#### 15.3.5 创建、插入和删除节点

Document 类还定义了创建 Element 对象的方法，而 Element 和 Text 对象拥有在树中插入、删除和替换节点的方法。

使用 Document 类的 `createELement()` 方法可以创建一个新元素，并通过自己的 `append()` 和 `prepend()` 方法为自己添加文本或其他元素：

```js
let paragraph = document.createELement('p'); // 创建一个空的<p>元素
let emphasis = document.createELement('em'); // 创建一个空的<em>元素
emphasis.append('World'); // 向<em>元素中添加文本
paragraph.append('Hello', emphasis, '!'); // 向<p>中添加文本和<em>
paragraph.prepend('i'); // 在<p>的开头再添加文本
paragraph.innerHTML; // "iHello <em>World</em>!"
```

`append()` 和 `prepend()` 接收任意多个参数，这些参数可以是 Node 对象或宇符串。字符串参数会自动转换为 Text 节点（也可以使用 document.createTextNode() 来创建 Text 节点，但很少需要这样做）。`append()` 把参数添加到子元素列表的末尾。`prepend()` 把参数添加到子元素列表的开头。

如果想在包含元素的孩子列表中间插入 Element 或 Text 节点，那 `append()` 和 `prepend()` 都派不上用场。这时候，应该先获取对一个兄弟元素节点的引用，然后调用 `before()` 在该兄弟元素前面插入新内容，或调用 `after()` 在该兄弟元素后面插入新内容。

与 append() 和 prepend() 类似，after() 和 before() 也接收任意个数的字符串和元素参数，在将字符串转换为 Text 节点后把它们全部插入文档中。append() 和 prepend() 只在 Element 对象上有定义，但 after() 和 before() 同时存在于 Element 和 Text 节点上，因此可以使用它们相对于 Text 节点插入内容。

> **注意**：元素只能被插入到文档中的一个地方。如果某个元素已经在文档中了，又把它插入到了其他地方，那它会转移到新位置，而不会复制一个新的过去。

如果确实想创建一个元素的副本，可以使用 `cloneNode()` 方法，传入 true 以复制其全部内容：

```js
// 创建 paragraph 的一个副本，再把它插入到 greetings 元素后面
greetings.after(paragraph.cloneNode(true));
```

调用 `remove()` 方法可以把 Element 或 Text 节点从文档中删除，或者可以调用 `replaceWith()` 替换它。`remove()` 不接收参数，`replaceWith()` 与 `before()` 和 `after()` 一样，接收任意个数的字符串和元素：

```js
// 从文档中删除 greetings 元素，并代之以 paragraph 元素（如果 paragraph 已经在文档中了，则把它从当前位置移走）
greetings.replaceWith(paragraph);
// 删除 paragraph 元素
paragraph.remove();
```

> DOM API 也定义了插入和删除内容的老一代方法。比如，appendChild()、insertBefore()、replaceChild() 和 removeChild()，都比这里介绍的方法难用，因此不应该再使用它们了。

#### 15.3.6 示例：生成目录

示例 15-1 展示了如何动态为文档创建目录。这个示例演示了前几节介绍的很多操作 DOM 的技术。

```js
/**
 * 示例15-1：使用 DOM API 生成目录
 * TOC.js：为文档创建一个目录
 *
 * 这个脚本在 DOMContentLoaded 事件触发时运行，将自动为文档生成一个目录。它没有定义任何全局符号，因此不会与其他脚本发生冲突。
 *
 * 脚本在运行时，首先会查找一个 id 为 “TOC” 的文档元素。如果没有这个元素，它就会在文档开头创建一个。
 * 然后，它会找到所有 <h2> 到 <h6> 标签，将它们当作每一节的标题，并在 TOC 元素中创建一个目录。
 * 脚本还会给每个节标题添加一个节号，并将标题包装在一个用 name 属性定义的锚元素中，以便 TOC 可以链接到它们。
 * 生成的锚元素有 “TOC” 开头的名字，因此不应该在自己的 HTML 中再使用它。
 *
 * 生成的 TOC 条目可以通过 CSS 添加样式。所有条目都有一个 TOCEntry 类，而且每个条目还有一个与节标题级别对应的类：
 * <h1> 生成的条目有 TOCLevel1，<h2> 生成的条目有 TOCLevel2，……。插入到标题中的节号有类 TOCSectNum。
 *
 * 使用这个脚本时，可以使用以下样式表：
 * #TOC { border: solid black 1px; margin: 10px; padding: 10px; }
 * .TOCEntry { margin: 5px 0; }
 * .TOCEntry a { text-decoration: none; }
 * .TOCLevel1 { font-size: 16pt; font-weight: bold; }
 * .TOCLevel2 { font-size: 14pt; margin-left: .25in; }
 * .TOCLevel3 { font-size: 12pt; margin-left: .5in; }
 * .TOCSectNum::after { content: ": "; }
 * 要隐藏节号，可以加上
 * .TOCSectNum { display: none }
 **/
document.addEventListener('DOMContentLoaded', () => {
  // 查找 TOC 容器元素
  // 如果没找到，则在文档开头创建一个
  let toc = document.querySelector('#TOC');
  if (!toc) {
    toc = document.createELement('div');
    toc.id = 'TOC';
    document.body.prepend(toc);
  }

  // 查找所有节标题元素。这里假设文档的标题使用 <h1>，文档中的各节使用 <h2> 到 <h6>
  let headings = document.querySelectorAll('h2, h3, h4, h5, h6');

  // 数组化一个数组，用来跟踪节号
  let sectionNumbers = [0, 0, 0, 0, 0];

  // 遍历找到的节标题元素
  for (let heading of headings) {
    // 如果标题位于 TOC 容器中则跳过
    if (heading.parentNode === toc) {
      continue;
    }

    // 确定标题的级别减 1，因为 <h2> 算 1 级标题
    let level = parseInt(heading.tagName.charAt(1)) - 1;

    // 递增这个标题级别的节号并把所有低级编号重置为 0
    sectionNumbers[level - 1]++;
    for (let i = level; i < sectionNumbers.length; i++) {
      sectionNumbers[i] = 0;
    }

    // 现在组合所有标题级别的节号以产生类似 2.3.1 这样的节号
    let sectionNumber = sectionNumbers.slice(0, level).join('.');

    // 把节号添加到节标题中，把编号放在 <span> 中方便添加样式
    let span = document.createELement('span');
    span.className = 'TOCSectNum';
    span.textContent = sectionNumber;
    heading.prepend(span);

    // 把标题包装在一个命名的锚元素中，以便可以链接到它
    let anchor = document.createELement('a');
    let fragmentName = `TOC${sectionNumber}`;
    anchor.name = fragmentName;
    heading.before(anchor); // 在标题前插入锚元素
    anchor.append(heading); // 把标题移到锚元素内

    // 接下来创建对这一节的链接
    let link = document.createELement('a');
    link.href = `#${fragmentName}`; // 链接目标

    // 把标题文本复制到链接中。此时可以放心使用 innerHTML，因为没有插入任何不可信字符串
    link.innerHTML = heading.innerHTML;

    // 把链接放到一个 div 中，以便根据级别添加样式
    let entry = document.createElement('div');
    entry.classList.add('TOCEntry', `TOCLevel${level}`);
    entry.append(link);

    // 把 div 添加到 TOC 容器中
    toc.append(entry);
  }
});
```

### 15.4 操作 CSS

JS 可以控制 HTML 文档的逻辑结构和内容。通过对 CSS 编程，JS 也可以控制文档的外观和布局。接下来几节讲解几种 JS 可以用来操作 CSS 的不同技术。

#### 15.4.1 CSS 类

使用 JS 影响文档内容样式的最简单方式是给 HTML 标签的 `class` 属性添加或删除 CSS 类名。Element 对象的 `classList` 属性可以用来方便地实现此类操作。

#### 15.4.2 行内样式

假设文档的结构中只包含一个提示条元素，而想在显示它之前先动态把它定位好。不可能针对提示条的所有可能位置都创建一个类，因此 `classList` 属性不能用于定位。

这种情况下，需要用程序修改提示条在 HTML 中的 `style` 属性，设置只针对它自己的行内样式。DOM 在所有 Element 对象上都定义了对应的 style 属性。但与大多数镜像属性不同，这个 style 属性不是字符串，而是 CSSStyleDeclaration 对象，是对 HTML 中作为 style 属性值的 CSS 样式文本解析之后得到的一个表示。要在 JS 中显示和设置提示条的位置，可以使用类似下面的代码：

```js
function displayAt(tooltip, x, y) {
  tooltip.style.display = 'block';
  tooltip.style.position = 'absolute';
  tooltip.style.left = `${x}px`;
  tooltip.style.top = `${x}px`;
}
```

**命名约定：JS 中的 CSS 属性**
很多 CSS 样式属性的名字中都包含连字符。连字符在 JS 中被会解释为减号，因此不允许出现在属性名其他标识符中。为此，CSSStyleDeclaration 对象的属性名与实际的 CSS 属性名稍微有点不一样。如果 CSS 属性名包含一个或多个连字符，对应的 CSSStyleDeclaration 属性名将剔除连字符，并将每个连字符后面的字母变成大写。例如，JS 会使用 borderLeftwidth 属性访问 border-Left-width 这个 CSS 属性。

> **注意**：
>
> 1. 在使用 CSSStyleDeclaration 的样式属性时，要记住所有值都必须是字符串。
> 2. 分号不包含在字符串中，它们只是普通的 JS 分号。在 CSS 样式表中使用的分号在通过 JS 设置字符串值时并不是必需的。
> 3. 很多 CSS 属性要求包含单位，如 “px” 表示像素，“pt” 表示点。

有些 CSS 属性是其他属性的简写形式，比如 margin 是 margin-top、margun-right、margun-bottom 和 margin-left 的简写。 CSSStyleDeclaration 对象上也有与这些简写属性对应的属性。例如，可以像这样设置 margin 属性：

```js
e.style.margin = `${top}px ${right}px ${bottom}px ${left}px`;
```

有时候，以字符串而非 CSSStyleDeclaration 对象形式设置和读取行内样式会更方便。为此，可以使用 Element 的 `getAttribute()` 和 `setAttribute()` 方法，或者也可以使用 CSSStyleDeclaration 对象的 cssText 属性：

```js
// 把元素 e 的行内样式复制给元素 f
f.setAttribute.style('style', e.getAttribute('style'));
// 或者，这样也可以
f.style.cssText = e.style.cssText;
```

在读取元素的 `style` 属性时，应该知道它只表示元素的行内样式，而多数元素的多数样式都是在样式表中指定的，不是写在行内的。并且，通过 style 属性读到的任何单位和简写属性，都是对应 HTML 属性中实际使用的格式，代码可能必须进行复杂解析才能解释它们。一般来说，如果想知道一个元素的样式，那需要的可能是计算样式。

#### 15.4.3 计算样式

元素的计算样式（computed style）是浏览器根据一个元素的行内样式和所有样式表中适用的样式规则导出（或计算得到）的一组属性值，浏览器实际上使用这组属性值来显示该元素。与行内样式类似，计算样式同样以 CSSStyleDeclaration 对象表示。但与行内样式不同的是，计算样式是只读的，不能修改计算样式，但表示一个元素计算样式的 CSSStyleDeclaration 对象可以知道浏览器在渲染该元素时，使用了哪些属性和值。

使用 Window 对象的 `getComputedStyle()` 方法可以获取一个元素的计算样式。这个方法的第一个参数是要查询的元素，可选的第二个参数用于指定一个 CSS 伪元素：

```js
let title = document.querySelector('#section1title');
let styles = window.getComputedStyle(title);
let beforeStyles = window.getComputedStyle(title, '::before');
```

`getComputedStyle()` 的返回值是一个 CSSStyleDeclaration 对象，该对象包含应用给指定元素（或伪元素）的所有样式。这个 CSSStyleDeclaration 对象与表示行内样式的 CSSStyleDeclaration 对象有一些重要的区别：

- 计算样式的属性是只读的。

- 计算样式的属性是绝对值，百分比和点等相对单位都被转换成了绝对值。任何指定大小的属性（如外边距大小和字体大小）都将以像素度量。相应的值会包含 “px” 后缀，虽然还需要解析，但不用考虑解析或转换其他单位。值为颜色的属性将以 “rgb()” 或 “rgba()” 格式返回。

- 简写属性不会被计算，只有它们代表的基础属性会被计算。例如，不能查询 margin 属性，而要查询 marginLeft、marginTop 等。

- 计算样式的 `cssText` 属性是 undefined。

`getComputedStyle()` 返回的 CSSStyleDeclaration 对象中包含的属性，通常要比行内 style 属性对应的 CSSStyleDeclaration 对象多很多。但计算样式比较难说，查询它们并不一定总能得到想要的信息。以 font-family 属性为例，它接收逗号分隔的字体族的列表，以实现跨平台兼容。在查询计算样式的 fontFamily 属性时，只是得到应用给元素的最特定于 font-family 样式的值，这可能会返回类似 “arial,helvetica,sans-serif” 这样的值，并不说明实际使用了哪种字体。再比如，如果某元素没有被绝对定义，通过计算样式查询其 top 和 left 属性经常会返回 auto。这是个合法的 CSS 值，但却不一定是想找的。

尽管 CSS 可以精确指定文档元素的位置和大小，查询元素的计算样式并非确定该元素大小和位置的理想方式。有一个更简单易用的[替代方案](#1552-查询元素的几何大小)。

#### 15.4.4 操作样式表

除了操作 `class` 属性和行内样式，JS 也可以操作样式表。样式表是通过 `<style>` 标签或 `<link rel="stylesheet">` 标签与 HML 文档关联起来的。这两个标签都是普通的 HTML 标签，因此可以为它们指定一个 id 属性，然后使用 document.querySelector() 找到它们。

`<style` >和 `<link>` 标签对应的 Element 对象都有 `disabled` 属性，可以用它禁用整个样式表。比如，可以像下面这样使用这个属性：

```js
// 这个函数可以实现 “light” 和 “dark” 主题的切换
function toggleTheme() {
  let lightTheme = document.querySelector('#light-theme');
  let darkTheme = document.querySelector('#dark-theme');
  // 当前是浅色主题，切换到深色主题
  if (darkTheme.disabled) {
    lightTheme.disabled = true;
    darkTheme.disabled = false;
  }
  // 当前是深色主题，切换到浅色主题
  else {
    lightTheme.disabled = false;
    darkTheme.disabled = true;
  }
}
```

另一个操作样式表的简单方式是使用前面介绍的 DOM API 向文档中插入新样式表。

虽然算不上巧妙，但也可以向文档中插入一段包含 `<style>` 标签的 HTML 字符串。这是种好玩的技术，例如：

```js
document.head.insertAdjacentHTML('beforeend', '<style>body{transform: rotate(180deg)}</style>');
```

浏览器定义了一套 API，以便 JS 能够在样式表中查询、修改、插入或删除样式规则。这套 API 太专业了，可以在 MDN 上搜索 “CSSObject Model” 或 “CSSStyleSheet”。

#### 15.4.5 CSS 动画与事件

假设样式表中定义了下面两个 CSS 类：

```css
.transparent {
  opacity: 0;
}
.fadeable {
  transition: opacity 0.5s ease-in;
}
```

如果把第一个样式应用给某个元素，该元素会变成完全透明，不可见。而第二个样式中的过渡属性（transition）会告诉浏览器当元素的不透明度（ opacity）变化时，该变化应该在 0.5 秒的时间内以动画的形式呈现。其中的 ease-in 要求不透明度的变化动画应该先慢后快。

现在假设 HTML 文档中包含一个有 “fadeable” 类的元素：

```html
<div id="subscribe" class="fadeable notification">...</div>
```

在 JS 中，可以为它添加 “transparent” 类：

```js
document.querySelector('#subscribe').classList.add('transparent');
```

这个元素是为不透明度动画而配置的。给它添加 “transparent” 类，改变不透明度，会触发一次动画：浏览器会在半秒内让元素 “淡出” 为完全透明。
相反的过程也能触发动画：如果删除 “fadable” 元素的 “transparent” 类，又会改变不透明度，因此元素将淡入，变得再次可见。

这个过程不需要 JS 做任何事情，是纯粹的 CSS 动画效果。但 JS 可以用来触发这种动画。

JS 也可以用来监控 CSS 过渡动画的进度，因为浏览器在过渡动画的开始和结束都会触发事件。首次触发过渡时，浏览器会派发 “transitionrun” 事件。这时候可能刚刚指定 transition-delay 样式，而视觉上还没有任何变化。当发生视觉变化时，又会派发 “transitionstart” 事件，而当动画完成时，则会派发 “transitionend” 事件。当然，所有这些事件的目标都是发生动画的元素。这些事件传给处理程序的事件对象是一个 TransitionEvent 对象。该对象的 `propertyName` 属性是发生动画的 CSS 属性而 “transitionend” 事件对应的事件对象的 `elapsedTime` 属性是从 “transitionstart” 事件开始经过的秒数。

除了过渡之外，CSS 也支持更复杂的动画形式，可以称其为 “CSS 动画”。这会用到 `animation-name`、`animation-duration` 和特殊的`@keyframes` 规则来定义动画细节。

与 CSS 过渡类似，CSS 动画也触发事件，可以供 JS 代码监听。动画开始时触发 “animationstart” 事件，完成时触发 “animationend” 事件。如果动画会重复播放，则每次重复（不包括最后一次）都会触发 “animationiteration” 事件。事件目标是发生动画的元素，而传给处理程序的事件对象是 AnimationEvent 对象。这个对象的 `animationName` 属性是定义动画的 `animation-name` 属性，而 `elapsedTime` 属性反映了自动画开始以后经过了多少秒。

### 15.5 文档几何与滚动

本章到现在，一直把文档想象成元素和文本节点的抽象树。但当浏览器在窗口中渲染文档时，它会创建文档的一个视觉表示，其中每个元素都有自己的位置和大小。有时候，Web 应用可以把文档看成元素的树，不考虑这些元素在屏幕上如何展示。但有时候，又必须知道某个元素精确的几何位置。例如，要使用 CSS 动态把一个元素（如提示条）定位到某个常规定位的元素旁边，必须先知道这个常规定位元素的位置。

接下来几节将介绍如何在基于树的抽象文档模型和基于几何坐标系的文档视图之间切换。

#### 15.5.1 文档坐标与视口坐标

文档元素的位置以 CSS 像素度量，其中 x 坐标向右表示增大，y 坐标向下表示增大。但是有两个点可以用作坐标原点：元素的 x 和 y 坐标可以相对于文档的左上角，也可以相对于显示文档的视口（viewport）的左上角。在顶级窗口和标签页中，“视口” 就是浏览器窗口中实际显示文档内容的区域。因此不包含浏览器的 “外框”（chrome），如菜单、工具条和标签。对于显示在 `<iframe>` 标签中的文档，由 DOM 中的内嵌窗格（iframe）元素定义嵌套文档的视口。无论哪种情况，说到元素位置，必须首先搞清楚是使用文档坐标还是视口坐标（有时候，视口坐标也被称为 “窗口坐标”）。

如果文档比视口小，或者如果文档没有被滚动过，则文档左上角就位于视口左上角，文档和视口坐标系是相同的。但通常情况下，要实现这两种坐标系的转换，都必须加上或减去滚动位移（scroll offset）。如果元素在文档坐标中的 y 坐标是 200 像素，用户向下滚动了 75 像素，则元素在视口坐标中的 y 坐标是 125 像素。类似地，如果用户在视口中水平滚动 200 像素之后元素在视口坐标中的 x 坐标是 400 像素，则元素在文档坐标中的 x 坐标是 600 像素。

如果以打印的纸质文档做比喻，则任由用户怎么上下左右移动文档，其中每个元素在文档坐标中都拥有不变的位置。纸质文档具有的这种性质也适用于简单的网页文档，但一般来说，文档坐标并不真正适合网页。问题在于 CSS 的 overflow 属性允许文档中的元素包含比它能显示的更多的内容。元素可以有自己的滚动条，并作为它们所包含内容的视口。Web 允许在滚动文档中存在滚动元素，意味着不可能只使用一个(x，y)点描述元素在文档中的位置。

既然文档坐标实际上没有什么用，客户端 JS 更多地会使用视口坐标。接下来介绍的 `getBoundingClientRect()` 和 `elementFromPoint()` 方法使用的就是视口坐标，而鼠标和指针事件对象的 `clientX` 和 `clientY` 属性使用的也是这个坐标。

在使用 CSS 的 `position:fixed` 显式定位元素时，top 和 1eft 属性相对于视口坐标来解释。如果使用 `position:relative`，则元素会相对于没给它设置 position 属性时的位
置进行定位。如果使用 `position:absolute`，则 top 和 1eft 相对于文档或者最近的包含定位元素。这意味着，如果一个相对定位元素中包含一个绝对定位元素，则绝对定位元素会相对于这个相对定位的包含元素而不是整个文档定位。实践中，经常会把元素设置为相对定位，同时将其 top 和 left 设置为 0（这样作为容器它的布局没有变化），从而为它包含的绝对定位元素建立一个新的坐标系统。可以把这个新的坐标系统称为 “容器坐标”，以便区分于文档坐标和视口坐标。

#### 15.5.2 查询元素的几何大小

调用 `getBoundingClientRect()` 方法可以确定元素的大小（包括 CSS 边框和内边距，不包括外边距）和位置（在视口坐标中）。这个方法没有参数，返回一个对象，对象有 left、right、top、bottom、width 和 height 属性。其中，left 和 top 属性是元素左上角的 x 和 y 坐标，right 和 bottom 属性是右下角的坐标。这两对属性值的差就是 wight 和 height 属性。

块级元素（如图片、段落和 `<div>` 元素）在浏览器的布局中始终是矩形。行内元素（如 `<span>`、`<code>`和`<b>`元素）则可能跨行，因而包含多个矩形。比如，`<em>` 和 `</em>` 标签间的文本显示在了两行上，则它的矩形会包含第一行末尾和第二行开头。如果在这个元素上调用 `getBoundingClientRect()`，则边界矩形将包含两行的整个宽度。如果想查询行内元素中的个别矩形，可以调用 `getClientRects()` 方法，得到一个只读的类数组对象，其元素为类似 `getBoundingClientRect()` 返回的矩形对象。

#### 15.5.3 确定位于某一点的元素

使用 `getBoundingClientRect()` 方法可以确定视口中某个元素的当前位置。有时候，想从另一个方向出发，确定在视口中某个给定位置上的是哪个元素。为此可以使用 Document 对象的 `elementFromPoint()` 方法。调用这个方法并传入一个点的 x 和 y 坐标（视口坐标，而非文档坐标。比如，可以使用鼠标事件中的 clientX 和 clientY 坐标）。

`elementFromPoint()` 返回一个位于指定位置的 Element 对象。选择元素的碰撞检测（hitdetection）算法并没有明确规定，但这个方法的意图是返回相应位置上最内部（嵌套最
深）、最外层（最大的 CSS z-index 属性）的元素。

#### 15.5.4 滚动

Window 对象的 `scrollTo()` 方法接收一个点的 x 和 y 坐标（文档坐标），并据以设置滚动条的位移。换句话说，这个方法会滚动窗口，从而让指定的点位于视口的左上角。如果这个点太接近文档底部或右边，浏览器会尽可能让视口左上角接近这个点，但不可能真的移动到该点。以下代码会滚动浏览器让文档最底部的页面显示出来：

```js
// 取得文档和视口的高度
let documentHeight = document.documentElement.offsetHeight;
let viewportHeight = window.innerHeight;
// 滚动到最后一“页”在视口中可见
window.scrollTo(0, documentHeight - viewportHeight);
```

Window 对象的 `scrollBy()` 方法与 `scrollTo()` 类似，但它的参数是个相对值，会加在当前滚动位置之上：

```js
// 每 500 毫秒向下滚动 50 像素。注意，没有办法停止
setInterval(() => {
  scrollBy(0, 50);
}, 500);
```

如果想让 `scrollTo()` 和 `scrollBy()` 平滑滚动，需要传入一个对象，而不是两个数值，比如：

```js
window.scrollTo({
  left: 0,
  top: documentHeight - viewportHeight,
  behavior: 'smooth'
});
```

有时候，不是想让文档滚动既定的像素距离，而是想滚动到某个元素在视口中可见。此时可以在相应 HTML 元素上调用 `scrollIntoView()` 方法。这个方法保证在上面调用它的那个元素在视口中可见。默认情况下，滚动后的结果会尽量让元素的上边对齐或接近视口上沿。如果给这个方法传入唯一的参数 false，则滚动后的结果会尽量让元素的底边对齐视口下沿。为了让元素可见，浏览器也会水平滚动视口。

同样可以给 `scrollIntoView()` 传入一个对象，设置 `behavior:"smooth"` 属性，以实现平滑滚动。而设置 `block` 属性可以指定元素在垂直方向上如何定位，设置 `inline` 属性可以指定元素在水平方向上如何定位（假设需要水平滚动）。这两个属性的有效值均包括 start、end、nearest 和 center。

#### 15.5.5 视口大小、内容大小和滚动位置

前面说过，浏览器窗口和一些 HTML 元素可以显示滚动的内容。在这种情况下，有时候需要知道视口大小、内容大小和视口中内容的滚动位移。本节介绍这些细节。

对浏览器窗口而言，视口大小可以通过 `window.innerWidth` 和 `window.innerHeight` 属性获得（针对移动设备优化的网页通常会在 `<head>` 中使用 `<meta name="viewport">` 标签为页面设置想要的视口宽度）。文档的整体大小与 `<html>` 元素，即 `document.documentELement` 的大小相同。要获得文档的宽度和高度，可以使用 `document.documentELement`
的 `getBoundingClientRect()` 方法，也可以使用 `document.documentElement` 的 `offsetWidth` 和 `offsetHeight` 属性。文档在视口中的滚动位移可以通过 `window.scrollX` 和 `window.scrollY` 获得。这两个属性都是只读的，因此不能通过设置它们的值来滚动文档。滚动文档应该使用 `window.scrollTo()`。

对元素来说，问题稍微复杂一点。每个 Element 对象都定义了下列三组属性：

| offset       | client       | scroll       |
| ------------ | ------------ | ------------ |
| offsetWidth  | clientWidth  | scrollWidth  |
| offsetHeight | clientHeight | scrollHeight |
| offsetLeft   | clientLeft   | scrollLeft   |
| offsetTop    | clientTop    | scrollTop    |
| offsetParent | -            | -            |

元素的 `offsetWidth` 和 `offsetHeight` 属性返回它们在屏幕上的 CSS 像素大小。这个大小包含元素边框和内边距，但不包含外边距。元素的 `offsetLeft` 和 `offsetTop` 属性返回元素的 x 和 y 坐标。对很多元素来说，这两个值都是文档坐标。但对定位元素的后代或者另一些元素（如表格单元）来说，这两个值是相对于祖先元素而非文档的坐标。而 `offsetParent` 属性保存着前述坐标值相对于哪个元素。这一组属性都是只读的。

元素的 `clientWidth` 和 `clientHeight` 属性与 `offsetWidth` 和 `offsetHeight` 属性类似，只是它们不包含元素边框，只包含内容区及内边距。`clientLeft` 和 `clientTop` 属性没有多大用处，它们是元素内边距外沿到边框外沿的水平和垂直距离。一般来说，这两个值就等于左边框和上边框的宽度。这一组属性都是只读的。对于行内元素，这些属性的值全为 0。

元素的 `scrollWidth` 和 `scrollHeight` 属性是元素内容区大小加上元素内边距，再加上溢出内容的大小。在内容适合内容区而没有溢出时，这两个属性等同于 `clientWidth` 和 `clientHeight`。但在有溢出时，这两个属性还包含溢出内容，因此它们的值大于 `clientWidth` 和 `clientHeight`。`scrollLeft` 和 `scrollTop` 是元素内容在元素视口中的滚动位移。与本节介绍的其他属性不同，`scrollLeft` 和 `scrollTop` 是可写属性，因此可以通过设置它们的值滚动元素中的内容（在多数浏览器中，Element 对象也跟 Window 对象一样有 `scrollTo()` 和 `scrollBy()` 方法，但并非所有浏览器都支持）。

### 15.6 Web 组件

HTML 是一种文档标记语言，为此也定义了丰富的标签。过去 30 年，HTML 已经变成 Web 应用描述用户界面的语言，但 `<input>` 和 `<button>` 等简单的 HTML 标签并不能满足现代 UI 设计的需要。Web 开发者可以凑合着使用它们，但必须以 CSS 和 JS 来增强这些 HTML 标签的外观和行为。

很多 Web 开发者使用 React、Angular 等框架，这些框架支持创建可重用的用户界面组件。Web 组件是浏览器原生支持的替代这些框架的特性，主要涉及相对比较新的三个 Web 标准。这些 Web 标准允许 JS 使用新标签扩展 HTML，扩展后的标签就是自成一体的、可重用的 UI 组件。

接下来几小节将展示如何在自己的网页中使用其他开发者定义的 Web 组件，然后解释构成 Web 组件的这三个技术，最后通过一个示例将这三个技术整合在一起。

#### 15.6.1 使用 Web 组件

Web 组件是在 JS 中定义的，因此要在 HTML 中使用 Web 组件，需要包含定义该组件的 JS 文件。Web 组件是相对比较新的技术，经常以 JS 模块形式写成，因此需要在 HTML 中像下面这样包含 Web 组件：

```html
<script type="module" src="components/search-box.js">
```

Web 组件要定义自己的 HTML 标签名，但有一个重要的限制就是标签名必须包含一个连字符（这意味着未来的 HTML 版本可以增加没有连字符的新标签，而这些标签不会跟任何人的 Web 组件冲突）。要使用 Web 组件，只要像下面这样在 HTML 文件中使用其标签即可：

```js
<search-box placeholder="Search..."></search-box>
```

Web 组件可以像常规 HTML 标签一样具有属性。使用组件的文档应该告诉它支持哪些属性。Web 组件不能使用自关闭标签定义。HTML 文件必须既包含开标签也包含闭标签与常规 HTML 元素类似，有的 Web 组件需要子组件，而有的 Web 组件不需要（也不显示）子组件。还有的 Web 组件可选地接收有标识的子组件，这些子组件会出现在命名的 “插槽”（slot）中。

这个 `slot` 属性是对 HTML 的一个扩展，用于指定把哪个子元素放到哪里。而插槽的名字 “left” 和 “right” 是由这个 Web 组件定义的。如果使用的组件支持插槽，其文档中应该说明。

前面提到过 Web 组件经常以 JS 模块来实现，因此可以通过 `<script type="module">` 标签引入 HTML 文件中。模块就像添加了 `defer` 属性一样，会在文档内容解析之后加载。这意味着浏览器通常会在运行定义 Web 组件的代码之前，就要解析和渲染 Web 组件。这在使用 Web 组件时是正常的。浏览器中的 HTML 解析器很灵活，对自己不理解的输入非常宽容。当在 Web 组件还没有定义就遇到其标签时，浏览器会向 DOM 树中添加一个通用的 HTMLElement，即便它们不知道要对它做什么。之后，当自定义元素有定义之后，这个通用元素会被 “升级”，从而具备预期的外观和行为。

如果 Web 组件包含子元素，那么在组件有定义之前它们可能会被不适当地显示出来。可以使用 CSS 将 Web 组件隐藏到它们有定义为止。

与常规 HTML 元素一样，Web 组件可以在 JS 中使用。如果在网页中包含 `<search-box>` 标签，就可以通过 `querySelector()` 和适当的 CSS 选择符获得对它的引用，就像对任何其他 HTML 标签一样。一般来说，只有在定义这个组件的模块运行之后这样做才有意义。因此在查询 Web 组件时要注意不要过早地做这件事。

Web 组件实现通常都会（但并非必须）为它们支持的每个 HTML 属性都定义一个 JS 属性。另外，与 HTML 元素相似，它们也可能定义有用的方法。同样，所使用 Web 组件的文档应该指出可以在 JS 中使用什么属性和方法。

知道了如何使用 Web 组件，接下来三节将介绍用于实现 Web 组件的三个浏览器特性。

**DocumentFragment 节点**
DOM API 将文档组织成一个 Node 对象树，其中 Node 可以是 Document、Element、Text 节点，或者 Comment 节点。但这些节点类型都不能用来表示一个文档片段，或者一组没有父节点的同辈节点。这时候就要用到 DocumentFragment 了。

DocumentFragment 也是一种 Node 类型，可以临时充当一组同辈节点的父节点，方便将这些同辈节点作为一个单元来使用。可以使用 `document.createDocumentFragment()` 来创建 DocumentFragment 节点。创建 DocumentFragment 节点后，就可以像使用 Element 一样，通过 `append()` 为它添加内容。

DocumentFragment 与 Element 的区别在于它没有父节点。但更重要的是，**当向文档中插入 DocumentFragment 节点时 DocumentFragment 本身并不会被插入，实际上插入的是它的子节点**。

#### 15.6.2 HTML 模板

HTML 的 `<template>` 标签跟 Web 组件的关系虽然没那么密切，但通过它确实可以对网页中频繁使用的组件进行优化。`<template>` 标签及其子元素永远不会被浏览器渲染，只能在使用 JS 的网页中使用。这个标签背后的思想是，当网页包含多个重复的基本 HTML 结构时（比如表格行或 Web 组件的内部实现），就可以使用 `<template>` 定义次该结构，然后通过 JS 按照需要任意重复使用该结构。

在 JS 中，`<template>` 标签对应的是一个 HTMLTemplateElement 对象。这个对象只定义了一个 `content` 属性，而这个属性的值是包含 `<template>` 所有子节点的 DocumentFragment。可以克隆这个 DocumentFragment，然后把克隆的副本插入文档中需要的地方。这个片段自身不会被插入，只有其子节点会。假设文档中包含一个 `<table>` 和 `<template id="row">` 标签，而后者作为模板定义了表格中行的结构，那可以像下面这样使用模板

```js
let tableBody= document.querySelector("tbody");
let template = document.querySelector("#row")；
let clone = template.content.cloneNode(true);// 深度克隆
// 先使用 DOM 把内容插入克隆的 <td> 元素，然后把克隆且已初始化的表格行插入表格体
tableBody.append(clone);
```

这个模板元素并非只有出现在 HTML 文档中才可以使用。也可以在 JS 代码中创建一个模板，通过 `innerHTML` 创建其子节点，然后再按照需要克隆任意多个副本。这样还不必每次都解析 `innerHTML`。而且这也是 Web 组件中使用 HTML 模板的方式，示例 15-3 演示了这个技术。

#### 15.6.3 自定义元素

实现 Web 的第二个浏览器特性是 “自定义元素”，即可以把一个 HTML 标签与一个 JS 类关联起来，然后文档中出现的这个标签就会在 DOM 树中转换为相应类的实例。创建自定义元素需要使用 `customElements.define()` 方法，这个方法以一个 Web 组件的标签名作为第一个参数（记住这个标签名必须包含一个连字符），以一个 HTMLElement 的子类作为其第二个参数。文档中具有该标签名的任何元素都会被 “升级” 为这个类的一个新实例。如果浏览器将来再解析 HTML，都会自动为遇到的这个标签创建一个这个类的实例。

传给 `customElements.define()` 的类应该扩展 HTMLElement，且不是一个更具体的类型（如 HTMLButtonElement）。当一个 JS 类扩展另一个类时，构造函数必须先调用 super() 然后才能使用 this 关键字。因此如果自定义元素类有构造器，应该先调用 super()（没有参数），然后再干别的。

浏览器会自动调用自定义元素类的特定 “生命期方法”。当自定义元素被插入文档时，会调用 `connectedCallback()` 方法。很多自定义元素通过这个方法来执行初始化。还有个 `disconnectedCallback()` 方法，会在自定义元素从文档中被移除时调用，但用得不多。

如果自定义元素类定义了静态的 `observedAttributes` 属性，其值为一个属性名的数组，且如果任何这些命名属性在这个自定义元素的一个实例上被设置（或修改），浏览器就会调用 `attributeChangedCallback()` 方法，传入属性名、旧值和新值。这个回调可以根据属性值的变化采取必要的步骤以更新组件自定义元素类也可以按照需要定义其他属性和方法。通常，它们都会定义设置方法和获取方法，让元素的属性可以暴露为 JS 属性。

下面举一个自定义元素的例子。假设想在一个常规文本段落中显示圆圈。希望可以像下面这样写 HTML：

```html
<p>
  The document has one marble: <inline-circle></inline-circle>
  The HTML parser instantiates two more marbles:
  <inline-circle diameter="1.2em" color="blue"></inline-circle>
  <inline-circle diameter=".6em" color="gold"></inline-circle>
  How many marbles does The document contain now?
</p>
```

```js
// 示例 15-2: <inline-circle> 自定义元素
customELements.define(
  'inline-circle',
  class InlineCircle extends HTMLElement {
    // 浏览器会在一个 <inline-circle> 元素被插入文档时调用这个方法。还有一个 disconnectedCallback() 方法，但这个例子中没有用到。
    connectedCallback() {
      // 设置创建圆圈所需的样式
      this.style.display = 'inline-block';
      this.style.borderRadius = '50%';
      this.style.border = 'solid black 1px';
      this.style.transform = 'translateY(10%)';
      // 如果没有定义大小，则基于当前字体大小来设置一个默认大小
      if (!this.style.width) {
        this.style.width = '0.8em';
        this.style.height = '0.8em';
      }
    }

    // 这个静态的 observedAttributes 属性用于指定想在哪个属性变化时收到通知（这里使用了获取方法，是因为只能对方法使用 static 关键字）
    static get observedAttributes() {
      return ['diameter', 'color'];
    }

    // 这个回调会在上面列出的属性变化时被调用，从自定义元素被解析开始，包括之后的变化
    attributeChangedCallback(name, oldValue, newValue) {
      switch (name) {
        case 'diameter':
          // 如果 diameter 属性改变了，更新大小样式
          this.style.width = newValue;
          this.style.height = newValue;
          break;
        case 'color':
          // 如果 color 属性改变了，更新颜色样式
          this.style.backgroundColor = newValue;
          break;
      }
    }

    // 定义与元素的标签属性对应的 JS 属性
    // 这些获取和设置方法只是获取和设置底层属性
    // 如果设置了 JS 的属性，则修改底层的属性会触发调用 attributeChangedCallback 进而更新元素的样式
    get diameter() {
      return this.getAttribute('diameter');
    }
    set diameter(diameter) {
      this.setAttribute('diameter', diameter);
    }
    get color() {
      return this.getAttribute('color');
    }
    set color(color) {
      this.setAttribute('color', color);
    }
  }
);
```

#### 15.6.4 影子 DOM

示例 15-2 定义的自定义元素并没有恰当地封装。比如，设置其 diameter 或 color 属性会导致其 style 属性被修改，而对于一个真正的 HTML 元素，这并不是希望看到的行为。要把一个自定义元素转换为真正的 Web 组件，还需要使用一个强大的封装机制：影子 DOM（shadow DOM）。

影子 DOM 允许把一个 “影子根节点”（shadow root）附加给一个自定义元素（也可以附加给 `<div>`、`<span>`、`<body>`、`<article>`、`<main>`、`<nav>`、`<header>`、`<footer>`、`<section>`、`<p>`、`<blockquote>`、`<aside>` 或 `<h>` 到 `<h6>` 元素），而后者被称为 “影子宿主”（shadow host）。影子宿主元素与所有 HTML 元素一样，随时可以作为包含后代元素和文本节点的正常 DOM 树的根。影子根节点则是另一个更私密的后代元素树的根，这些元素从影子根节点上生长出来，可以把它们当成一个迷你文档。

“影子 DOM” 中的 “影子” 指的是作为影子根节点后代的元素 “藏在影子里”。也就是说，这个子树并不属于常规 DOM 树，不会出现在它们宿主元素的 `children` 数组中，而且对 `querySelector()` 等常规 DOM 遍历方法也不可见。相对而言，影子宿主的常规、普通 DOM 子树有时候也被称为 “阳光 DOM”（light DOM）。

要理解影子 DOM 的用途，可以想象一下 HTML 的 `<audio>` 和 `<video>` 元素。这两个元素都会显示一个并不简单的用户界面，用于控制媒体播放，但播放和暂停按钮以及其他 UI 元素都不属于 DOM 树，不能通过 JS 操控。既然浏览器是设计用来显示 HTML 的，那浏览器厂商只有使用 HTML 来显示这样的内部 UI 才是最自然的。事实上，多数浏览器很早就实现了这样的机制，只不过影子 DOM 让它成为 Web 平台的标准而已。

**影子 DOM 封装**
影子 DOM 的关键特性是它所提供的封装。影子根节点的后代对常规 DOM 树而言是隐藏且独立的，几乎就像它们是在一个独立的文档中一样。影子 DOM 提供了三种非常重要的封装：

- 影子 DOM 中的元素对 `querySelectorAll()` 等常规 DOM 方法是不可见的。在创建影子根节点并将其附加于影子宿主时，可以指定其模式是 “开放”（open）还是 “关闭”（closed）。关闭的影子根节点将被完全封闭，不可访问。不过，影子根节点更多地是以 “开放” 模式创建的，这意味着影子宿主会有一个 `shadowRoot` 属性，如果需要，JS 可以通过这个属性来访问影子根节点的元素。

- 在影子根节点之下定义的样式对该子树是私有的，永远不会影响外部的阳光 DOM 元素（影子根节点可以为其宿主元素定义默认样式，但这些样式可以被阳光 DOM 样式覆盖）。类似地，应用给影子宿主元素的阳光 DOM 样式也不会影响影子根节点。影子 DOM 中的元素会从阳光 DOM 继承字体大小和背景颜色等，而影子 DOM 中的样式可以选择使用阳光 DOM 中定义的 CSS 变量。不过在大多数情况下，阳光 DOM 的样式与影子 DOM 的样式是完全独立的。因此 Web 组件的作者和 Web 组件的用户不用担心他们的样式会冲突或抵触。可以像这样限定 CSS 的范围或许是影子 DOM 最重要的特性。

- 影子 DOM 中发生的某些事件（如 “load”）会被封闭在影子 DOM 中。另外一些事件，像 focus、mouse 和键盘事件则会向上冒泡、穿透影子 DOM。当一个发源于影子 DOM 内的事件跨过了边界开始向阳光 DOM 传播时，其 `target` 属性会变成影子宿主元素，就好像事件直接起源于该元素一样。

**影子 DOM 插槽和阳光 DOM 子元素**
作为影子宿主的 HTML 元素有两个后代子树。一个是 `children[]` 数组，即宿主元素常规的阳光 DOM 后代；另一个则是影子根节点及其后代。位于同一宿主元素中的两个完全不同的内容树是怎么显示的呢?下面是它们的工作原理：

- 影子根节点的后代始终显示在影子宿主内

- 如果这些后代中包含一个 `<slot>` 元素，那么宿主元素的常规阳光 DOM 子元素会像它们本来就是该 `<slot>` 的子元素一样显示，替代该插槽中的任何影子 DOM 元素。如果影子 DOM 不包含 `<slot>`，那么宿主的阳光 DOM 内容永远不会显示。如果影子 DOM 有一个 `<slot>`，但影子宿主没有阳光 DOM 子元素，那么该插槽的影子 DOM 内容作为默认内容显示。

- 当阳光 DOM 内容显示在影子 DOM 插槽中时，说那些元素 “已分配”（distributed），此时关键要理解：那些元素实际上并未变成影子 DOM 的一部分。使用 `querySelector()` 依旧可以查询它们，它们仍然作为宿主元素的子元素或后代出现在阳光 DOM 中。

- 如果影子 DOM 定义了多个 `<slot>`，且通过 `name` 属性为它们命名，那么影子宿主的阳光 DOM 后代可以通过 `slot="slotname"` 属性指定自己想出现在哪个插槽中。

**影子 DOM API**
就其强大的能力而言，影子 DOM 并未提供太多 JS API。要把一个阳光 DOM 元素转换为影子宿主，只要调用其 `attachShadow()` 方法，传入 `{mode:"open"}` 这个唯一的参数即可。这个方法返回一个影子根节点对象，同时也将该对象设置为这个宿主的 `shadowRoot` 属性的值。这个影子根节点对象是一个 DocumentFragment，可以使用 DOM 方法为它添加内容，也可以直接将其 `innerHTML` 属性设置为一个 HTML 字符串。

如果 Web 组件想知道影子 DOM（slot）中的阳光 DOM 内容什么时候变化，那它可以直接在该 `<slot>` 元素上注册一个 “slotchanged” 事件。

#### 15.6.5 示例：<search-box> Web 组件

这个示例用自定义元素实现了 `<search-box>` 组件，并使用 `<template>` 标签来提高效率，使用影子根节点做到了封装。

这个示例展示了如何直接使用低级 Web 组件 API。实践中，很多 Web 组件都是使用某个高级的库创建的。之所以使用库，一个原因是可重用且可定制的组件其实很难写好，很多细节都必须处理到位。示例 15-3 演示了如何实现 Web 组件并添加了一些基本的键盘焦点处理逻辑，但没有考虑无障碍，也没有使用恰当的 ARIA 属性，好让这个组件便于在屏幕阅读器和其他辅助技术中使用。

```js
/**
 * 示例 15-3：实现 Web 组件
 * 这个类定义了一个自定义的 HTML <search-box> 元素，用于显示一个 <input> 文本输入字段加两个图标或表情符号（emoji）。
 * 默认情况下，它在文本字段的左侧显示一个放大镜表情符号，在文本字段的右侧显示一个 X 表情符号（表示取消）。
 * 它会隐藏输入字段的边框，显示自己环绕一周的边框，让两个表情符号看起来位于输入字段的内部。类似地，当内部输入字段获得焦点时，焦点环也会显示在 <search-box> 的周围。
 *
 * 要覆盖默认的图标，可以让 <search-box> 包含 <span> 或 <img> 子元素，并分别指定 slot="left" 和 slot="right" 属性
 * <search-box> 支持正常的 hTML disabled 和 hidden 属性，以及 size 和 placeholder 属性，它们对这个元素具有对 <input> 元素一样的作用
 *
 * 内部 <input> 元素的输入事件会向上冒泡，事件目标会被设置为外部的 <search-box> 元素
 *
 * 当用户单击左侧绘文字（放大镜）时，这个元素会发送 “search” 事件，事件对象的 detail 属性会设置为当前输入的字符串。
 * 另外，当内部文本字段生成 “change” 事件（文本发生变化且用户按下回车或 Tab 键）时，也会派发这个 “search” 事件
 * 当用户单击右侧表情符号(X)时,这个元素会发送“ clear”事件。如果这个
 *
 * 事件的处理程序没有调用 preventDefault()，则这个元素会在事件派发完成时清除用户的输入
 *
 * 注意，HTML 和 JS 都没有 onsearch 和 onclear 属性。“search” 和 “clear” 事件的处理程序只能通过 addEventlistener() 来注册
 */
class SearchBox extends HTMLElement {
  constructor() {
    super(); // 调用超类的构造器；必须先调用
    // 创建一个影子 DOM 树并将其附加到这个元素，设置为 this.shadowRoot 的值
    this.attachShadow({ mode: 'open' });

    // 克隆模板，模板定义了这个自定义组件的后代和样式，然后把内容追加到影子根节点
    this.shadowRoot.append(SearchBox.template.content.cloneNode(true));

    // 取得对影子 DOM 中重要元素的引用
    this.input = this.shadowRoot.querySelector('#input');
    let leftSlot = this.shadowRoot.querySelector('slot[name="left"]');
    let rightSlot = this.shadowRoot.querySelector('slot[name="right"]');

    // 当内部输入字段获得或失去焦点时，设置或移除 focused 属性，以便样式表在整个组件上显示或隐藏人造的焦点环。
    // 注意，“blur” 和 “focus” 现在变量 x 的值就是 0，事件会冒泡，就像起源自 <search-box> 一样
    this.input.onfocus = () => {
      this.setAttribute('focused', '');
    };
    this.input.onblur = () => {
      this.removeAttribute('focused');
    };

    // 如果用户点击了放大镜，则触发 “search” 事件。同样在输入字发生 “change” 事件时也触发这个事件（“change” 事件不会冒泡到影子 DOM 外面）
    leftSlot.onclick = this.input.onchange = event => {
      event.stopPropagation(); // 阻止单击事件冒泡
      if (this.disabled) return; // 如果被禁用则什么也不做
      this.dispatchEvent(
        new CustomEvent('search', {
          detail: this.input.value
        })
      );
    };

    // 如果用户单击了 X，则触发 “clear” 事件。如果事件的处理程序没有调用 preventDefault()，则清除输入
    rightSlot.onclick = event => {
      event.stopPropagation(); // 不让单击事件向上冒泡
      if (this.disabled) return; // 如果被禁用则什么也不做
      let e = new CustomEvent('clear', { cancelable: true });
      this.dispatchEvent(e);
      if (!e.defaultPrevented) {
        // 如果事件没有被取消
        this.input.value = ''; // 则清除输入字段
      }
    };
  }

  // 在有些属性被设置或改变时，需要设置内部 <input> 元素对应的值。
  // 这个生命期方法与下面代码的静态属性 observedAttributes 相互配合，实现回调
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'disabled') {
      this.input.disabled = newValue !== null;
    } else if (name === 'placeholder') {
      this.input.placeholder = newValue;
    } else if (name === 'size') {
      this.input.size = newValue;
    } else if (name === 'value') {
      this.input.value = newValue;
    }
  }

  // 最后，为支持的 HTML 属性定义相应的获取方法和设置方法
  // 获取方法简单地返回属性的值（或存在与否），而设置方法也只是设置属性的值（或存在与否）。
  // 当某个设置方法修改了一个属性时，浏览器会自动调用上面的 attributeChangedCallback 回调
  get placeholder() {
    return this.getAttribute('placeholder');
  }
  get size() {
    return this.getAttribute('size');
  }
  get value() {
    return this.getAttribute('value');
  }
  get disabled() {
    return this.hasAttribute('disabled');
  }
  get hidden() {
    return this.hasAttribute('hidden');
  }
  set placeholder(value) {
    this.setAttribute('placeholder', value);
  }
  set size(value) {
    this.setAttribute('size', value);
  }
  set value(text) {
    this.setAttribute('value', text);
  }
  set disabled(value) {
    if (value) this.setAttribute('disabled', '');
    else this.removeAttribute('disabled');
  }
  set hidden(value) {
    if (value) this.setAttribute('hidden', '');
    else this.removeAttribute('hidden');
  }
}

// 这个静态属性对 attributeChangedCallback 方法是必需的
// 只有在这个数组中列出的属性名才会触发对该方法的调用
SearchBox.observedAttributes = ['disabled', 'placeholder', 'size', 'value'];

// 创建一个 <template> 元素，用于保存样式表和元素树，可以在每个 SearchBox 元素的实例中使用它们
SearchBox.template = document.createELement('template');

// 通过解析 HTML 字符串初始化模板。不过要注意，当实例化一个 SearchBox 时，可以克隆这个模板中的节点，不需要再次解析HTML。
SearchBox.template.innerHTML = `
  <style>
  /*
    * 这里的 :host 选择符引用的是阳光 DOM 中的 <search-box> 元素
    * 这些样式是默认的，<search-box> 的使用者可以通过阳光 DOM 中的样式来覆盖这些样式
    */
  :host {
    display: inline-block; /* 默认显示为行内块 */
    border: solid black 1px; /* 在 <input> 和 <slots> 周围添加圆角边框 */
    border-radius: 5px;
    padding: 4px 6px; /* 边框内部留出适当间隙 */
  }
  :host([hidden]) { /* 注意小括号：当宿主隐藏时 */
    display: none; /* 通过属性设置为不显示 */
  }
  :host([disabled]) { /* 当宿主有 disabled 属性时 */
    opacity: 0.5; /* 将其变灰 */
  }
  :host([focused]) { /* 当宿主有 focused 属性时 */
    box-shadow: 0 0 2px 2px #6AE; /* 显示人造的焦点环 */
  }

  /* 剩下的样式表只应用给影子 DOM 中的元素。*/
  input {
    border-width: 0; /* 隐藏内部输入字段的边框。*/
    outline: none; /* 也隐藏焦点环 */
    font: inherit; /* <input> 元素默认不会继承字段 */
    background: inherit; /* 背景颜色也需要明确继承 */
  }
  slot {
    cursor: default; /* 光标移到按钮上显示箭头 */
    user-select: none; /* 不让用户选择表情符号文本 */
  }
  </style>
  <div>
    <slot name="left">\u{1f50d}</slot> <!-- U+1F50D 是放大镜 -->
    <input type="text"id="input" /> <!-- 实际的输入元素 -->
    <slot name="right">\u{2573}</slot> <!-- U+2573 是 X -->
  </div>`;

// 最后，调用 customELement.define() 将 SearchBox 元素注册为 <search-box> 标签的实现。
// 自定义元素的标签名中必须包含一个连字符
customELements.define('search-box', SearchBox);
```

### 15.7 可伸缩矢量图形

SVG（Scalable Vector Graphics，可伸缩矢量图形）是一种图片格式。名字中的 “矢量” 代表着它与 GIF、JPEG、PNG 等指定像素值矩阵的光栅（raster）图片格式有着根本的不同。**SVG “图片” 是一种对绘制期望图形的精确的、分辨率无关（因而 “可伸缩”）的描述。SVG 图片是在文本文件中通过（与 HTML 类似的）XML 标记语言描述的**。

在浏览器中有几种方式使用 SVG：

- 可以在常规的 HTML `<img>` 标签中使用 svg 图片文件，就像使用 _.png_ 或 _.jpeg_ 图片一样。

- 因为基于 XML 的 SVG 格式与 HTML 很类似，所以可以直接把 SVG 标签嵌入在 HTML 文档中。此时，浏览器的 HTML 解析器允许省略 XML 命名空间，并将 SVG 标签当成 HTML 标签一样处理。

- 可以使用 DOM API 动态创建 SVG 元素，按需生成图片。

接下来几小节将演示 SVG 的第二种和第三种用法。不过，要注意 SVG 本身的语法规则很多，还是比较复杂的。除了简单的图形绘制语法，SVG 还支持任意曲线、文本和动画。SVG 图形甚至可以与 JS 脚本和 CSS 样式表组合，以添加行为和表现信息。

#### 15.7.1 在 HTML 中使用 SVG

SVG 图片可以使用 HTML 的 `<img>` 标签来显示，也可以直接在 HTML 嵌入 SVG。而且在嵌入 SVG 后，甚至可以使用 CSS 样式表来指定字体、颜色和线宽。`<svg>` 标签的后代并非标准的 HTML 标签。比如，在 HTML 中使用 SVG 显示一个模拟时钟表盘的例子：

[clock.html](./examples/clock.html)

> **注意**：CSS 简写的 font 属性对 SVG 标签不起作用，因此必须要分别设置 font-family、font-size 和 font-weight 属性。

#### 15.7.2 编程操作 SVG

直接在 HTML 文件中嵌入 SVG（而不是使用静态 `<img>` 标签）的一个原因，就是这样可以使用 DOM API 操作 SVG 图片。假设想使用 SVG 在网页中显示一个图标。可以把 SVG 嵌入一个 `<template>` 标签中，然后在需要向 UI 中插入图标副本时就克隆这个模板的内容。如果想让图标响应用户活动（比如在鼠标指针悬停在图标上时改变颜色），那通常可以使用 CSS 来实现。

操作直接嵌入在 HTML 中的 SVG 图形也是可能的。上一节中的那个表盘的示例显示的是一个静态时钟，时针和分针都指向正上方，表明时间为中午或半夜。可以在示例的 HTML 文件中通过 `<script>` 标签运行脚本，周期性地执行一个函数，该函数会检查时间并旋转时针和分针对准相应的度数，从而让时钟真正反映当前时间。

[clock.html](./examples/clock.html)

#### 15.7.3 通过 JS 创建 SVG 图片

除了使用脚本简单地操作嵌入在 HTML 文档中的 SVG 图片，还可以通过 JS 来创建 SVG 图片，这在可视化动态加载的数据时很有用。示例 15-4 展示了如何使用 JS 创建 SVG 饼图。如果想通过 JS DOM API 创建 SVG 元素，那就不能使用 `createElement()` 函数，而必须使用 `createElementNS()`，这个函数的第一个参数是 XML 命名空间文字串。对 SVG 而言，命名空间是文字串 `"http://www.w3.org/2000/svg"`。

除了使用 `createElementNS()`，示例 15-4 中绘制饼图的代码都比较容易理解。只有把要绘制的数据转换为扇形的角度时涉及一点数学，其余代码基本上都是创建 SVG 元素然后设置它们属性的 DOM 代码。

这个示例中最难理解的部分就是绘制每个扇形。用于显示每个户型的元素是 `<path>`。这个 SVG 元素可以描述由任意直线和曲线组成的形状。对形状的描述通过 `<path>` 元素的 `d` 属性来指定。这个属性的值使用字母编码和数值的简略语法，指定了坐标、角度和其他值。比如，字母 M 表示 “move to”（移动到），后面紧跟着 x 和 y 坐标。字母 L 表示 “line to”（画线到），即从当前坐标画一条直线到后面紧跟的坐标点。这个示例也使用了字母 A 来绘制弧形（arc），后面紧跟的 7 个数值描述了这个圆弧。

示例 15-4：[pieChart.html](./examples/pieChart.html)。

### 15.8 `<canvas>` 与图形

在 HTML 文档中，`<canvas>` 元素本身并不可见，它只是创建了一个绘图表面并向客户端 JS 暴露了强大的绘图 API。`<canvas>` API 与 SVG 的主要区别在于使用画布（canvas）绘图要调用方法，而使用 SVG 创建图形则需要构建 XML 元素树。

这两种绘图手段同样强大，而且可以相互模拟。但从表面上来看，这两种手段迥然不同，又有各自的优缺点。比如，修改 SVG 图形很简单，可能只需从描述中删除元素即可。而要从同样的 `<canvas>` 图形中删除元素通常需要先擦掉图形再重新绘制。由于画布绘图 API 是基于 JS 的，而且相对比较简洁（不像 SVG 语法那么复杂）。

**画布中的 3D 图形**
在调用 `getContext()` 时传入 “webgl” 也可以获取一个 3D 图形上下文，并使用 WebGL API 来绘制 3D 图形。WebGL API 是一套庞大、复杂、低级的 JS API，开发者通过它可以访问 GPU、写自定义的着色器，以及执行其他非常强大的图形操作。

大多数画布绘图 API 都没有定义在 `<canvas>` 元素上，而是定义在通过画布的 getContext() 方法获得的 “绘图上下文” 上。调用 getContext() 时传入 “2d” 可以得到一个 CanvasRenderingContext2D 对象，使用它能够在画布上绘制二维图形。

作为 Canvas API 的一个简单示例，以下 HTML 文档使用了 `<canvas>` 元素和一些 JS 展示了两个简单的形状：

```html
<p>This is a red square:</p>
<canvas id="square" width="10" height="10"></canvas>.
<p>This is a blue circle:</p>
<canvas id="circle" width="10" height="10"></canvas>.
<script>
  let canvas = document.querySelector('#square'); // 取得第一个画布元素
  let context = canvas.getContext('2d'); // 取得 2D 绘图上下文
  context.fillStyle = '#f00'; // 设置填充色为红色
  context.fillRect(0, 0, 10, 10); // 填充一个方块

  canvas = document.querySelector('#circle'); // 第二个画布元素
  context = canvas.getContext('2d'); // 取得其上下文
  context.beginPath(); // 开始一个新 “路径”
  context.arc(5, 5, 5, 0, 2 * Math.PI, true); // 为路径添加一个圆形
  context.fillStyle = '#00f'; // 设置蓝色填充色
  context.fill(); // 填充路径
</script>
```

SVG 将复杂图形描述为可以绘制和填充的直线 “路径” 或曲线。而 Canvas API 也使用了路径的概念，但它没有使用字母和数字的字符串来描述路径，而是通过一系列方法调用来定义路径。比如前面例子中的 `beginPath()` 和 `arc()` 调用。定义了路径之后，后面的方法调用（如 fill()）就会操作该路径。上下文对象的各种属性（如 fillStyle）用于指定如何执行操作。

接下来几小节将演示 2D Canvas API 的方法和属性，其中多数示例中的代码都会操作一个变量 c。这个变量保存的是画布的 CanvasRenderingContext2D 对象。不过示例中经常会省略初始化该变量的代码。为了让这些示例跑起来，读者需要自行在 HTML 中添加 `<canvas>` 元素并指定相应的 `width` 和 `height` 属性，然后再添加类似下面的代码以初始化变量 c：

```js
let canvas = document.querySelector('#my_canvas_id');
let c = canvas.getContext('2d');
```

#### 15.8.1 路径与多边形

要在画布上画线或者填充由这些线包围的区域，首先需要定义一个路径。路径是一个或多个子路径的序列。而子路径则是两个或多个通过线段（或曲线段）连接起来的点的序列。开始新路径要调用 `beginPath()` 方法，而开始定义子路径要调用 `moveTo()` 方法。

在通过 `moveTo()` 建立起子路径的起点后，可以调用 `lineTo()` 将该点连接到一个新的点。以下代码定义了一个包含两个线段的路径：

```js
c.beginPath(); // 开始一个新路径
c.moveTo(100, 100); // 开始一个子路径，起点为(100, 100)
c.lineTo(200, 200); // 用线段连接点(100, 100)和(200, 200)
c.lineTo(100, 200); // 用线段连接点(200, 200)和(100, 200)
```

这几行代码定义了一个路径，但并没有在画布上绘制任何东西。要绘制路径中的两条线段，必须调用 `stroke()` 方法，而要填充这些线段定义的区域，则要调用 `fill()` 方法。

以上代码（加上其他设置线宽和填充色的代码）可以产生一个三角形。定义的子路径是 “开放的”。整个路径只包含两条线段，而且终点并未连接到起点。这意味着图中的三角形区域并不是闭合的区域。`fill()` 方法在填充开
放路径时，就好像有一条直线连接了子路径的终点与起点一样。

如果想描画这个三角形的所有边，必须调用 `closePath()` 把子路径的终点连接到起点（也可以调用 `lineTo(100, 100)`，但这样做的结果是得到三条共享起点和终点的线段，路径并没有真正闭合。在用宽线画图时，还是使用 `closePath()` 的视觉效果更好）。

关于 `stroke()` 和 `fill()` 还有另外两个地方需要注意：

- 两个方法都作用于当前路径的所有子路径。
- 两个方法都会修改当前路径。换句话说，调用 `fill()` 之后再调用 `stroke()` 路径仍然还在那里。在操作完一条路径后，如果想开始另一条路径，必须调用 `beginPath()`。如果没有调用，则只会在已有路径上面添加子
  路径。

示例 15-5 定义了一个函数，可以用来绘制普通多边形，其中演示了 `moveTo()`、`lineTo()` 和 `closePath()` 定义子路径，以及 `fill()` 和 `stroke()` 绘制这些路径。

示例 15-5：[polygon.html](./examples/polygon.html)。

> **注意**：这个示例绘制了一个包含正方形的六边形。这个正方形和六边形是由独立的子路径组成的，但它们重叠在一起了。每当这时候（或一条子路径与自身交叉时），画布都需要确定哪个区域在路径内部，哪个区域在路径外部。为此，画布使用一种被称为 “非零环绕规则”（nonzero winding rule）的测试来确定这件事。在上面的示例中，之所以正方形内部没有被填充，是因为正方形和六边形是以相反方向来绘制的。换句话说，六边形的顶点是通过顺时针方向移动的线段连接的，而正方形的顶点是逆时针方向连接的。假如正方形也是顺时针方向绘制的，则调用 fill() 也会填充正方形的内部区域。

#### 15.8.2 画布大小与坐标

在 HTML 中通过 `<canvas>` 的 width 和 height 属性，或者在 JS 中通过画布对象的 width 和 height 属性可以指定画布的大小。画布坐标系的默认原点在画布左上角的 (0, 0) 点。x 坐标向右增大，y 坐标向下增大。画布中的点可以使用浮点值来指定。

要修改画布大小必须完全重置画布。无论设置画布对象的 width 属性还是 height 属性（即使设置为当前值），都会清除画布，擦掉当前路径，重置所有图形属性（包括当前变换和剪切区域）至其最初状态。

在 HTML 中指定 `<canvas>` 的 width 和 height 属性会确定画布的实际像素数。每个像素在内存里会分配 4 个字节，因此如果 width 和 height 都是 100，则画布在内存中会用 40000 个字节来表示 10000 个像素。

此外，HTML 的 width 和 height 属性也指定了画布在屏幕上（以 CSS 像素）显示的默认大小。如果 `window.devicePixelRatio` 是 2，则 100 × 100 CSS 像素实际上对应 40000 个硬件像素。当画布内容绘制到屏幕上时，内存中的 10000 个像素需要放大为屏幕上的 40000 个物理像素，这意味着看到的图形会变模糊。

为优化图片质量，不要在 HTML 中使用 width 和 height 属性设置画布的屏幕大小。而要使用 CSS 的样式属性 width 和 height 来设置画布在屏幕上的预期大小。然后在通过 JS 开始绘制前，再将画布对象的 width 和 height 属性设置为 CSS 像素数乘以 `window.devicePixelRatio`。以 100×100 CSS 像素大小的画布为例，这样会导致画布显示为 100×100 CSS 像素，但内存中会分配 200×200 像素（即使是这样，用户如果放大画布也可能会导致图形模糊或变成马赛克。相对而言，SVG 图形在这种情况下则会保持边缘锐利，无论屏幕显示多大或是否缩放）。

#### 15.8.3 图形属性

示例 15-5 在画布上下文对象上设置了属性 fillStyle、strokeStyle 和 lineWidth 这些属性都是图形属性，fill() 和 stroke() 会使用前两个来确定颜色，第三个决定 stroke() 在画线时线的宽度。它们并没有作为参数传给 fill() 和 stroke() 方法，而是作为画布的通用图形状态存在。如果定义了一个方法要绘制某种形状，但并未设置这些属性，那么这个方法的调用方可以在调用之前通过设置 strokeStyle 和 fillStyle 属性自定义形状的颜色。这种图形状态与绘制命令分离的思想是 Canvas API 的基础，类似于 CSS 样式表与 HTML 文档分离的理念。

上下文对象上的一些属性（和方法）都会影响画布的图形状态。下面分别介绍：

**线条样式**
`lineWidth` 属性指定 stroke() 绘制的线条有多宽，默认值为 1。这里要理解，线宽是在调用 stroke() 的时候由 `lineWidth` 属性确定的，而非在调用 lineTo() 或其他路径构建方法时确定的。要真正理解 `lineWidth` 属性，关键是要从视觉上把路径想象成无穷细的一维线条。而 stroke() 方法在画直线和曲线时会让它们在路径上面居中，两侧各画一半的 lineWidth。如果画的是一条封闭路径，只想让线条出现在路径外侧，应该先把路径的线条画出来，然后再使用不透明的颜色填充，以盖住位于路径内侧的部分线条。如果只想让封闭路径的内侧出现线条，可以先调用 `save()` 和 `clip()` 方法，然后再调用 `stroke()` 和 `restore()`。

在绘制超过两像素宽的线条时，`lineCap` 和 `lineJoin` 属性会显著影响路径两端或者两条路径交点的样式。

`lineCap` 的默认值是平头（butt），`lineJoin` 的默认值是斜接（miter）。不过如果两条线相交的角度很小，斜接会导致相交角拉得非常长，看起来不舒服。如果某个相交角斜接后长度超过线宽一半乘以 `miterLimit` 属性，则这个相交角将改为斜切（bevel）而非斜接（miter）相交。`miterLimit` 的默认值为 10。

stroke() 方法既可以画虚线、点线，也可以画实线。而画布的图形状态中也有一组数字可以用作 “虛线模式”，即通过数字描述画多少像素、忽略多少像素。与其他线条绘制属性不同，虚线模式要通过 `setLineDash()` 和 `getLineDash()` 方法而不是一个属性来设置和获取。要指定点虚线模式，可以像下面这样使用 `setLineDash()`：

```js
c.setLineDash([18, 3, 3, 3]); // 18px 虛线、3px 空格、3px 点、3px 空格
```

最后，`lineDashOffset` 属性指定虚线模式从哪里开始绘制，默认值为 0。上面示例中设置的虚线模式在绘制到封闭路径时会以 18 像素的虛线开始。但是，如果这里把 `lineDashOffset` 设置为 21，则该路径将以点开始，后跟空格和虚线。

**颜色、模式与渐变**
`fillStyle` 和 `strokeStyle` 属性指定如何填充和描绘路径。属性名中的 “style” 通常指颜色，但这些属性也可以用来指定渐变色甚至图片，用以填充或描绘路径（注意，画条线与填充这条线两端很窄的范围基本上相同，填充和描绘本质上是相同的操作）。

如果想以实色（或半透明色）填充或描绘，只要把这些属性设置为有效的 CSS 颜色字符串即可。

如果想以渐变色填充（或描绘），需要将 `fillStyle`(或 `strokeStyle`)设置为 CanvasGradient 对象，这个对象需要调用上下文的 `createLinearGradient()` 或 `createRadialGradient()` 方法返回。`createLinearGradient()` 方法的参数是定义一条直线的两个点的坐标，颜色将在这条直线的方向上渐变。`createRadialGradient()` 的参数需要指定两个圆心和半径（这两个圆不一定是同心圆，但通常第一个圆会完全落在第二个圆内部）。小圆内部区域或大圆外部区域将被实色填充，这两个区域之间的部分则会以渐变色填充。

创建了表示要填充的画布区域的 CanvasGradient 对象后，必须调用这个对象的 `addColorStop()` 方法定义渐变色。这个方法的第一个参数是一个介于 0.0 和 1.0 之间的数值，第二个参数是一个 CSS 颜色说明。为定义一个单的渐变色，至少必须调用这个方法两次，但有可能还不止两次。位于 0.0 处的颜色是渐变的起点，位于 1.0 处的颜色是渐变的终点。如果要指定更多颜色，这些颜色应该出现在渐变中特定的小数位置。在指定的这些点之间，颜色会平滑地过渡。下面是几个示例：

```js
// 画布对角方向的线性渐变（假设画布没有变形）
let bgfade = c.createLinearGradient(0, 0, canvas.width, canvas.height);
bgfade.addColorStop(0.0, '#88f'); // 左上角开始于浅蓝色
bgfade.add.Stop(1.0, '#fff'); // 渐变到右下角的白色

// 两个同心圆之间的渐变。中间完全透明渐变为半透明的灰色，再渐变为完全透明
let donut = c.createRadialGradient(300, 300, 100, 300, 300, 300);
donut.addColorStop(0.0, 'transparent'); // 透明
donut.addColorStop(0.7, 'rgba(100,100,100,.9)'); // 半透明灰
donut.addColorStop(1.0, 'rgba(0, 0, 0, 0)'); // 又透明了
```

理解渐变最重要的一点是它们是跟位置紧密相关的。每次创建渐变，都需要为它指定界限。如果想填充这些界限之外的区域，使用的将是定义该渐变两端的某个实色。

除了实色和渐变色，填充和描绘时也可以使用图片。为此，需要将 `fillStyle` 或 `strokeStyle` 设置为上下文对象的 `createPattern()` 方法返回的 CanvasPattern 对象。这个方法的第一个参数应该是 `<img>` 或 `<canvas>` 元素，其中包含填充或描绘要使用的图片（注意，在这样使用的时候图片和画布并不需要插入文档中）。`createPattern()` 的第二个参数是字符串 “repeat” “repeat-x” “repeat-y” 或 “no-repeat”，用于指定背景图片是否（以及在哪个方向上）重复。

**文本样式**
`font` 属性指定 `fillText()` 和 `strokeText()` 方法在绘制文本时使用的字体。这个属性的值应该是一个字符串，语法与 CSS 的 font 属性相同。

`textAlign` 属性指定文本的水平对齐方式，相对于传给 `fillText()` 或 `strokeText()` 的 X 坐标。合法的值包括 start、left、center、right 和 end。默认值为 start，在从左到右的文本中效果与 left 相同。

`textBaseline` 属性指定文本相对于 Y 坐标如何垂直对齐。默认值是 alphabetic，适合拉丁字母或类似文字。对于汉语或日语，应该使用 ideographic。对于（印度很多语言中使用的）梵文及类似文字，可以使用 hanging。其他比如 top、middle 和 bottom 值纯粹是几何意义上的基线，基于字体的 “em 方块”。

**阴影**
上下文对象有 4 个属性控制阴影的绘制。适当地设置这些属性，可以为绘制的任何线条、区域、文本或图片添加阴影，让它们就像悬浮在画布上方一般。

`shadowColor` 属性指定阴影颜色。默认值是完全透明的黑色，因此除非将这个属性设置为半透明或不透明，否则不会出现阴影。这个属性只能设置为颜色字符串，阴影不支持模式和渐变。使用半透明阴影色可以产生最真实的阴影效果，因为透过阴影可以看到背景。

`shadowOffsetX` 和 `shadowOffsetY` 属性指定阴影的 X 轴和 Y 轴偏移量。这两个属性的默认值都是 0，即阴影将位于绘制内容的正下方，因而不可见。如果给这两个属性正值，阴影会出现在内容下方和右侧。就像屏幕外面左上角有光源照射到画布一样。偏移量越大阴影也越大，绘制内容看起来距离画布表面也 “更高”。这些值不受坐标变换(参见 15.8.5<!--TODO--> 节)影响，即使形状旋转或缩放了，阴影方向和 “高度” 也会保持不变。

`shadowBlur` 属性指定阴影边缘的模糊程度。默认值 0 会产生锐利、丝毫不模糊的阴影。这个值越大，模糊越厉害，上限由实现定义。

**半透明与合成效果**
如果想用半透明色描绘或填充路径，可以使用类似 “rgba(...)” 这样支持半透明值的 CSS 颜色语法设置 `strokeStyle` 或 `fillStyle`。RGBA 中的 A 代表 Alpha，是一个介于 0（完全透明）和 1（完全不透明）之间的值。Canvas API 还提供了另一种使用透明色的方式。如果不想分别指定每个颜色的 Alpha 通道，或者想给不透明的图片或模型添加透明效果，可以设置 `globalAlpha` 属性。这样绘制的每个像素的透明度值都会乘上 `globalAlpha`。默认值是 1，完全不透明。如果把 `globalAlpha` 设置为 0，那么绘制的一切都会变成完全透明。如果把它设置为 0.5，那么原先不透明的像素都会变成 50% 不透明，原先 50% 不透明的像素会变成 25%不透明。

在描绘线条、填充区域、绘制文本或复制图像时，通常希望新像素绘制到画布中已存在像素上。如果绘制的是不透明像素，它们会直接替换相应位置上的已有像素。如果绘制的是半透明像素，那么新（“来源”）像素将与老（“目标”）像素组合，从而让老像素会透过新像素可见，可见度取决于新像素的透明度。

这种组合新的（可能半透明）来源像素与已有（可能半透明）目标像素的过程叫作合成（composition）。前面描述的合成过程是 Canvas API 组合像素的默认方式。通过设置 `globalCompositeOperation` 属性可以指定合成像素的其他方式。默认值是 source-over，即来源像素被绘制在目标像素 “上方”（over），如果来源像素半透明则组合它们。

如果把这个属性设置为 destination-over，则画布在合成像素时就好像新的来源像素被绘制在已有目标像素下方一样。如果目标像素是半透明或透明的，则部分或全部来源像素的颜色将在最终结果中可见。再有，如果合成模式为 source-atop，那么画布将根据目标像素的透明度组合来源像素，结果就是在画布原来完全透明的部分上什么也不会绘制。除此之外，`globalCompositeOperation` 还有其他一些合法的值，但多数只在特殊场合下才有用。

**保存和恢复图形状态**
由于 Canvas API 在上下文对象上定义图形属性，有人可能想多次调用 `getContext()` 以获得多个上下文对象。这样一来，或许可以在每个上下文上定义不同的属性。遗憾的是，这种做法对画布而言是行不通的。每个 `<canvas>` 元素只有一个上下文对象，每次调用 `getContext()` 返回的都是同一个 CanvasRenderingContext2D 对象。

尽管 Canvas API 一次只允许定义一组图形属性，但它也允许保存当前的图形状态，以便修改其中的属性，之后再恢复。`save()` 方法把当前的图形状态推到一个保存的状态栈中。`restore()` 方法从该栈中弹出状态，恢复最近一次保存的状态。所有属性都存在于保存的状态中，其中也包括当前的变换及剪切区域。重要的是，当前定义的路径和当前的点并不属于图形状态，不能保存和恢复。

#### 15.8.4 画布绘制操作

前面介绍了一些基本的画布方法，包括 `beginPath()`、`moveTo()`、`lineTo()`、`closePath()`、`fill()` 和 `stroke()`，可以用来定义、填充、绘制线条和多边形。除此之外， Canvas API 还提供其他绘制方法。

**矩形**
CanvasRenderingContext2D 定义了 4 个绘制矩形的方法。这些方法都接收 2 个参数，用于指定矩形的一个角和矩形的宽度和高度。正常情况下，都是指定矩形左上角，然后传入正值作为宽度和高度。不过也可以指定其他角，可以传入负值。

`fillRect()` 将以当前 `fillStyle` 填充指定的矩形。`strokeRect()` 使用当前 `strokeStyle` 和其他线条属性描绘指定矩形的轮廓。 `clearRect()` 与 `fillRect()` 类似，但它会忽略当前填充样式，直接以（所有空画布默认的）透明黑色像素填充矩形。这三个方法都不影响当前路径或该路径中的当前点。

最后一个矩形方法是 `rect()`，它影响当前路径。这个方法会将自己拥有的一个矩形子路径添加到当前路径。与其他路径定义方法类似，这个方法本身什么也不会填充或描绘。

**曲线**
路径由一系列子路径构成，子路径又由一系列相互连接的点构成。点和点之间都是通过直线段连接的，但实践中并非只需要直线。CanvasRenderingContext2D 对象定义了一些方法，用于将一个新点添加到子路径，然后用一条曲线来连接当前点与新点。

`arc()`
这个方法向路径中添加一个圆形或圆形的一部分（圆弧）。要绘制的弧形通过 6 个参数指定：圆心的 x 和 y 坐标、圆的半径、圆弧的起始和终止角度，以及圆弧在两个角度间的绘制方式（顺时针还是逆时针）。如果路径中有一个当前点，则这个方法用一条直线连接当前点与圆弧的起点（在绘制楔形或扇形时有用），然后用圆形的一部分连接圆弧的起点和终点，最后让圆弧的终点成为新的当前点。如果调用这个方法时没有当前点，则只向路径中添加这段圆弧。

`ellipse()`
这个方法与 arc() 非常类似，只是会向路径中添加一个椭圆形或椭圆形的一部分。另外，这个方法接收两个半径：x 轴半径和 y 轴半径。而且，因为椭圆不是径向对称的，所以这个方法也接收另外一个参数用于指定弧度数，即椭圆围绕其圆心顺时针旋转度数。

`arcTo()`
这个方法会像 arc() 一样绘制一条直线和一条圆弧，但它使用不同的参数来指定要绘制的圆弧。arcTo() 的参数指定点 PI 和 P2，以及一个半径。添加到路径的圆弧具有指定的弧度。起点是以（想象中）当前点到 P1 点连线为切线的切点，终点是以（想象中）P1 点到 P2 点连线为切线的切点。这个看似不同寻常的指定圆弧的方法实际上对绘制有圆角的形状非常有用。如果半径为 0，这个方法将只从当前点到 P1 绘制一条直线。然而对于非 0 值半径，它会从当前点朝 P1 点方向画一条直线然后围绕一个圆形弯曲这条直线，直至这条线指向 P2 点。

`bezierCurveTo()`
这个方法会向子路径中添加一个新点 P，并通过一条三次贝塞尔曲线连接当前点与这个新点。曲线形状通过两个 “控制点” C1 和 C2 来指定。在曲线的起点（当前点），曲线朝向 C1 点方向。在曲线终点（P 点），曲线自 C2 点的方向到达。在这些点之间，曲线平滑变化。点 P 最终变成子路径新的当前点。

`quadraticCurveTo()`
这个方法与 `bezierCurveTo()` 类似，但使用二次贝塞尔曲线而非三次贝塞尔曲线，且只有一个控制点。

示例 15-6：向路径中添加曲线 [curvePath.html](./examples/curvePath.html)

**文本**
要在画布中绘制文本，一般都使用 `fillText()` 方法，该方法使用 `fillStyle` 属性指定的颜色（或渐变、模式）绘制文本。对于大型文本的特效，可以使用 `strokeText()` 绘制个别字形的轮廓。这两个方法都以要绘制的文本作为第一个参数，以文本的 x 和 y 坐标作为第二和第三个参数。它们都不影响当前路径或当前点。

fillText() 和 strokeText() 还接收可选的第四个参数。如果指定，这个参数用于限制文本可以显示的最大宽度。如果在使用 font 属性绘制文本时，文本宽度超过了指定的值，为适应这个宽度，画布将缩小文本或者使用更窄或更小的字体。

如果想在绘制文本前度量其大小，可以将文本传给 `measureText()` 方法。这个方法返回个 TextMetrics 对象，该对象指定了以当前 font 属性绘制文本时的度量指标。Textmetrics 对象中包含的唯一 “度量指标” 是宽度。可以像下面这样查询文本绘制到屏幕时的宽度：

```js
let width = c.measureText(text).width;
```

**图片**
除了矢量图形（路径、线条等），Canvas APi 也支持位图图片。`drawImage()` 方法会将一张源图片（或源图片中某个矩形区域）的像素复制到画布上，并根据需要缩放和旋转图像的像素。

`drawImage()` 可以接收 3 个、5 个或 9 个参数。无论哪种情况，第一个参数都是要复制其像素的源图片。这个图片参数通常是一个 `<img>` 元素，但也可以是另一个 `<canvas>` 元素，甚至是一个 `<video>` 元素（可以复制其中一帧）。如果指定了一个还在加载数据的 `<img>` 或 `<video>` 元素，调用 `drawImage()` 什么也不会做。

- 在 3 个参数版的 `drawImage()` 中，第二和第三个参数指定 x 和 y 坐标，图片的左上角将绘制在这个点。在这个版本的方法中，整个源图片都会复制到画布上。其中 x 和 y 坐标相对于当前坐标系来解释，图片会按照需要缩放或旋转，取决于画布当前应用的变换。

- 5 个参数版的 `drawImage()` 在前面介绍的 x 和 y 参数之后，又增加了高度和宽度参数 width 和 height。这 4 个参数定义了画布中的目标区域。源图片的左上角将绘制在 (x, y) 点，右下角将绘制在 (x + width, y + height)。同样，整个源图片都会被复制。在这个版本的方法中，源图片会被缩放以适应目标矩形。

- 9 个参数版的 `drawImage()` 方法同时指定了源矩形和目标矩形，且只复制位于源矩形中的像素。参数 2 到 5 指定源矩形，以 CSS 像素度量。如果源图片是另一个画布，源矩形使用该画布的默认坐标系，忽略已经指定的变量。参数 6 到 9 指定要将源矩形中的像素绘制到其中的目标矩形，使用当前画布的坐标系，而非默认坐标系。

除了把图片绘制到画布上，还可以使用 `toDataURl()` 方法将画布内容提取为一张图片。与这里的其他方法不同，`toDataURL()` 是画布元素本身的方法，不是上下文对象的方法。通常在调用 `toDataURL()` 时不传参数，返回的值是 PNG 格式的画布内容，使用 data:URL 编码。返回的这个 URL 可以直接给到 `<img>` 元素。比如，可以像下面这样生成画布的一个静态快照：

```js
let img = document.createElement('img'); // 创建一个 <img> 元素
img.src = canvas.toDataURL(); // 设置其 src 属性
document.body.appendChild(img); // 将其添加到文档中
```

#### 15.8.5 坐标系变换

画布默认的坐标系是将原点放在左上角，x 坐标向右递增，y 坐标向下递增。在这个默认的坐标系中，一个点的坐标直接映射为一个 CSS 像素（相应地再映射到一个或多个设备像素）。某些画布操作和属性（如提取原始像素值和设置阴影偏移）始终使用这个默认坐标系。不过除了默认坐标系，每个画布的图形状态中都有一个 “当前变换矩阵”。这个矩阵定义了画布的当前坐标系。在多数画布操作中，当指定一个点的坐标时，它表示的是当前坐标系中的一个点，而不是默认坐标系中的一个点。当前变换矩阵用于将指定的坐标转换为默认坐标系中等价的坐标。

使用 `setTransFrom()` 方法可以直接设置画布的变换矩阵，但通常还是使用一系列平移、旋转和缩放操作来变换坐标系更简单。图 15-11 展示了这些操作以及它们在画布坐标系中的效果。产生这个图的程序连续 7 次绘制了同一个坐标轴。每次绘制时唯一变化的只有当前的变换矩阵。

> **注意**：变换既影响文本也影响被绘制的线条。

图 15-11：坐标系变换

![坐标系变换](./image/坐标系变换.jpg)

`translate()` 方法简单地向左、右、上、下移动坐标系原点。`rotate()` 方法按照指定的角度旋转坐标轴（Canvas API 始终以弧度指定角度。要把度数转换为弧度，先用 180 除以度数再乘以 Math.PI）。`scale()` 方法沿 x 轴或 y 轴拉伸或压缩距离。

给 `scale()` 方法传入一个负缩放因子会围绕原点翻转坐标轴，就好像镜子里的倒影一样。图 15-11 中左下角展示的就是这个效果，其中 `translate()` 用于将原点移动到画布左下角，然后 `scale()` 再翻转 y 轴使其变成向上递增。翻转后的这个坐标系对于在图表上标绘数据点比较有用。不过要注意，这样会导致文本很难分辨。

**理解变换数学**
从几何角度理解变换是最简单的，可以把 `translate()`、`rotate()` 和 `scale()` 想象成像图 15-11 中那样变换坐标轴。当然也可以从代数角度来理解变换，那么它就是把变换后坐标系中的点(x,y)映射回之前坐标系中同一个点(x,y)的方程式。

方法调用 c.translate(dx，dy) 可以使用如下方程式来描述：

```js
x1 = x + dx; // 新坐标系中的 X 坐标 0 是老坐标系中的 dx
y1 = y + dy;
```

缩放操作也有类似的简单方程式。调用 c.scale(sx,sy) 可以描述成这样：

```js
x1 = sx * x;
y1 = sy * y;
```

旋转要复杂一点。调用 c.rotate(a) 可以通过以下三角函数来描述：

```js
x1 = x * cos(a) - y * sin(a);
y1 = y * cos(a) + x * sin(a);
```

变换的顺序很重要。假设从画布的默认坐标系开始，先平移它，再缩放它。为了把当前坐标系中的点(x,y)映射回默认坐标系中的点(x',y')，必须先应用缩放的方程式，把该点映射为平移但未缩放的坐标系中的一个中间点(x', y')，然后再使用平移方程式把这个中间点映射到(x", y")。结果如下：

```js
x1 = sx * x + dx;
y1 = sy * y + dy;
```

如果在调用 translate() 之前调用 scale()，得到的方程会有所不同：

```js
x1 = sx * (x + dx);
y1 = sy * (y + dy);
```

从代数角度来理解，关键是要记住，要还原一系列变换操作，必须从最后（近）一个变换开始，逐个还原到第一个变换。而从变换坐标轴的几何角度来理解，则需要从第一个变换开始，到最后一个结束。

画布支持的变换被称为仿射变换（affine transform）。仿射变换可能修改点与点之间的距离和线与线之间的角度，但平行线在仿射变换之后依旧保持平行。比如，不可能通过仿射变换完成鱼眼镜头变形。任何仿射变换都可以通过以下方程中的 6 个参数 a 到 f 来描述：

```js
x1 = ax + cy + e;
y1 = bx + dy + f;
```

可以通过调用 `transform()` 并传入这个 6 个参数，对当前坐标系应用任意变换。图 15-11 展示的两种变换（特定点的剪切和旋转）可以像下面这样通过 `transform()` 方法实现：

```js
// 剪切（shear）变换
// x′= x + kx * y;
// y′ = ky * x + y;
function shear(c, kx, ky) {
  c.transform(1, ky, kx, 1, 0, 0);
}

// 围绕点 (x,y) 逆时针旋转 theta 弧度
// 同样也可以由平移、旋转、平移操作完成
function rotateAbout(c, theta, x, y) {
  let ct = Math.cos(theta);
  let st = Math.sin(theta);
  c.transform(ct, -st, st, ct, -x * ct - y * st + x, x * st - y * ct + y);
}
```

`setTransForm()` 方法与 `transform()` 接收的参数一样，但它不变换当前坐标系，而是忽略当前坐标系，变换默认坐标系，并将结果作为新的当前坐标系。`setTransForm()` 常用于临时将画布重置为其默认坐标系：

```js
c.save(); // 保存当前坐标系
c.setTransForm(1, 0, 0, 1, 0, 0); // 恢复到默认坐标系
// 现在变量 x 的值就是 0
c.restore(); // 恢复保存的坐标系
```

**变换举例**
示例 15-7 通过递归使用 `translate()`、`rotate()` 和 `scale()` 方法绘制科赫（Koch）雪花分形演示了坐标系变换的强大能力。这个示例的输出如图 15-12 所示，其中包含 0、1、2、3、4 级递归得到的科赫雪花。

图 15-12：科赫雪花

![科赫雪花](./image/科赫雪花.jpg)

生成这些图案的代码十分优雅，但由于用到了递归坐标系变换，所以不太好理解。注意代码中只包含对 `lineTo()` 方法的一次调用。图 15-12 中的任何一条线段都是通过类似如下的代码绘制的：

```js
c.lineTo(len, 0);
```

变量 len 的值在程序执行期间保持不变，因此每条线段的位置、方向和长度都由平移旋转和缩放操作决定。

示例 15-7：通过变换绘制科赫雪花 [KochSnowflake.html](./examples/KochSnowflake.html)

#### 15.8.6 剪切

定义了路径之后，通常会调用 `stroke()` 或 `fill()`（或两者）。但也可以调用 `clip()` 方法定义一个剪切区域。定义了剪切区域后，这个区域外部将不会被绘制。图 15-13 展示了一个使用剪切区域生成的复杂图形。位于中间垂直的竖条和位于底部的文本在被描绘时都没有应用剪切区域，然后在对它们定义了三角形剪切区域后又进行了填充。

图 15-13:未剪切的描边和剪切的填充

![未剪切的描边和剪切的填充.jpg](./image/未剪切的描边和剪切的填充.png)

图 15-13 是使用示例 15-5 定义的 polygon() 方法和 `clip()` 方法生成的。

[未剪切的描边和剪切的填充](./examples/未剪切的描边和剪切的填充.html)

> **注意**：
>
> 1. 在调用 `clip()` 时，当前路径本身会被剪切为当前的剪切区域，然后这个被剪切的路径变成了新的剪切区域。这意味着 `clip()` 方法只能缩小剪切区域，不能放大。
> 2. 没有方法重置剪切区域，因此在调用 `clip()` 之前，一般都要调用 `save()` 以便将来恢复未被剪切的区域。

#### 15.8.7 像素操作

`getImageData()` 方法返回一个 ImageData 对象，表示画布中某矩形区域中包含的原始像素（包括 R、G、B 和 A 组件）。可以使用 createImageData() 创建空的 ImageData 对象。ImageData 对象中的像素是可写的，因此可以随意修改，然后再通过 `putImageData()` 把其中的像素复制到画布上。

这些像素操作方法提供了对画布非常低级的存取操作。传给 `getImageData()` 的矩形位于默认坐标系中，其大小以 CSS 像素来度量，不会受当前变换的影响。在调用 `putImageData()` 时，指定的位置同样以默认坐标系来度量。而且，`putImageData()` 忽略所有图形属性。它不进行任何合成操作，不会给像素乘上 globalAlpha，也不会绘制阴影。

像素操作方法经常用于处理图片。示例 15-8 展示了如何创建简单的运动模糊或 “涂抹” 效果。

以下代码演示了 getImageData() 和 putImageData()，并展示了如何遍历和修改 ImageData 对象中的像素值。

```js
// 示例 15-8：操作 ImageData 实现运动模糊
// 向右涂抹矩形的像素,产生一种运动模糊的效果就像物体从右向左移动一样
// n 必须是2或更大的值。值越大产生涂抹效果越明显
// 矩形在默认坐标系中定义
function smear(c, n, x, y, w, h) {
  //  取得要涂抹其中像素的矩形所对应的 ImageData 对象
  let pixels = c.getImageData(x, y, w, h);

  // 这里的涂抹是就地完成的,只需要源 ImageData
  // 某些图像处理算法需要其他 ImageData 存储变换后的像素值
  // 如果需要输出缓冲，也可以像下面这样以相同大小创建一个新 ImageData对象
  let output_pixels = c.createImageData(pixels);

  // 取得 ImageData 对象中像素网格的大小
  let width = pixels.width,
    height = pixels.height;
  // 这是保存原始像素数据的字节数组，从左到右，从上到下每个像素占用4个连续的字节，分别是R、G、B和A
  let data = pixels.data;
  // 每行第一个像素后面的像素都会被涂抹，也就是用 n 分之一自己的值加上 n 分之 m 前一个像素的值，来替换当前的值
  let m = n - 1;
  for (let row = 0; row < height; row++) {
    // 每一行
    let i = row * width * 4 + 4; // 每行第二个像素的位置
    for (let col = 1; col < width; col++, i += 4) {
      // 每一列
      data[i] = (data[i] + data[i - 4] * m) / n; // 红像素
      data[i + 1] = (data[i + 1] + data[i - 3] * n) / n; // 绿像素
      data[i + 2] = (data[i + 2] + data[i - 2] * m) / n; // 蓝像素
      data[i + 3] = (data[i + 3] + data[i - 1] * m) / n; //ALpl
    }
  }
  // 再把涂抹后的图像复制回画布上相同的位置
  c.putImageData(pixels, x, y);
}
```

### 15.9 Audio APl

HTML 的 `<audio>` 和 `<video>` 标签可以在网页中轻松包含音频和视频。这两个元素有着重要的 API 和并不简单的用户界面。可以通过 `play()` 和 `pause()` 方法控制媒体播放。可以设置 `volume` 和 `playbackRate` 属性控制音量和播放速度。而设置 `currentTime` 属性可以跳到媒体中特定的时间点。接下来演示两种通过脚本控制网页音效的方式。

#### 15.9.1 Audio() 构造函数

要在网页中包含音效，不一定要在 HTML 文档中包含 `<audio>` 标签。可以使用常规 DOM() 方法 document.createElement() 或者直接使用 Audio() 构造函数动态创建 `<audio>` 元素。并且，要播放媒体也不一定要把创建的元素添加到文档中。只要调用它的 `play()` 方法即可：

```js
// 提前加载音效文件，准备好播放
let soundeffect = new Audio('soundeffect.mp3');
// 用户单击鼠标时播放音效
document.addEventListener('click', () => {
  soundeffect.cloneNode().play(); // 加载并播放声音
});
```

> **注意**：这里使用了 `cloneNode()`。如果用户快速单击鼠标，希望同时播放多个重叠的音效。为此，就需要有多个 Audio 元素。因为这些 Audio 元素并未添加到文档中，所以它们播放结束后就会被当作垃圾清理掉。

#### 15.9.2 WebAudio APl

除了使用 Audio 元素播放录制的声音，浏览器也可以通过 WebAudio API 生成和播放合成音效。使用 WebAudio API 就像是使用带接续柱的老式电子合成器。对于 WebAudio，要创建一组 AudioNode 对象，表示波形的来源、变换和目标，然后再将这些节点连接为个网络以产生声音。这个 API 并不很复杂，但要全面解释还需要理解电子音乐和信号处理的概念。

下面的代码使用 WebAudio API 合成了一支短和弦，在 1 秒钟之后会渐弱消失。这个示例演示了 WebAudio API 的基础：

```js
// 首先创建一个 audioContext 对象，Safari 仍然要求使用 webkitAudioContext 而不是 AudioContext
let audioContext = new (this.AudioContext || this.webkitAudioContext)();
// 定义基准声音为三个纯正弦波的组合
let notes = [293.7, 370.0, 440.0]; // D大三和弦：D、F# 和 A
// 为每个想要播放的音符创建振荡器节点
let oscillators = notes.map(note => {
  let o = audioContext.createOscillator();
  o.frequency.value = note;
  return o;
});

// 通过随时间控制音量来构造声音
// 从时间开始快速升为最大音量，然后从时间 0.1 开始缓慢降为 0
let volumeControl = audioContext.createGain();

volumeControl.gain.setTargetAtTime(1, 0.0, 0.02);
volumeControl.gain.setTargetAtTime(0, 0.1, 0.2);

// 想把这个声音发送给默认目标：用户的扬声器
let speakers = audioContext.destination;

// 把每个源音符都连接到音量控制
oscillators.forEach(o => o.connect(volumeControl));

// 再把音量控制的输出连接到扬声器
volumeControl.connect(speakers);

// 现在开始播放声音，让它们持续 1.25 秒
let startTime = audioContext.currentTime;
let stopTime = startTime + 1.25;
oscillators.forEach(o => {
  o.start(startTime);
  o.stop(stopTime);
});

// 如果想创建一系列声音，可以使用事件处理程序
oscillators[0].addEventListener('ended', () => {
  // 在音符停止播放时会调用这个事件处理程序
});
```

### 15.10 位置、导航与历史

Window 和 Document 对象的 `location` 属性引用的都是 Location 对象，该对象表示当前窗口显示文档的 URL，也提供了在窗口中加载新文档的 API。

Location 对象与 [URL 对象](#119-url-api)非常相似，可以使用 `protocol`、`hostname`、`port` 和 `path` 访问当前文档 URL 的不同部分。而 `href` 属性以字符串形式返回整个 URL，就如同 toString() 方法一样。

Location 对象的 `hash` 和 `search` 属性比较有意思。hash 属性返回 URL 的 “片段标识符” 部分（如果有），包含一个井号（`#`）和一个元素 ID。`search` 属性与之类似，返回 URL 中以问号开头的部分，通常是一些查询字符串。一般来说，URL 中的这一部分用于对 URL 进行参数化，并提供在 URL 中嵌入参数的方式。虽然这些参数通常都被服务器端脚本使用，但网页中的 JS 照样也可以使用它们。

URL 对象有一个 `searchParams` 属性，是解析 `search` 属性之后的一种表示。Location 对象没有 `searchParams` 属性，但如果想解析 `window.location.search`，可以直接使用 Location 对象创建一个 URL 对象，然后访问 URL 对象的 `searchParams`：

```js
let url = new URL(window.location);
let query = url.searchParams.get('q');
let numResults = parseInt(url.searchParams.get('n') || 10);
```

除了可以通过 `window.location` 和 `document.location` 引用的 Location 对象，以及前面使用的 URL() 构造函数，浏览器也定义了 document.URL 属性。奇怪的是，这个属性的值并非 URL 对象，而只是一个字符串，也就是当前文档的 URL。

#### 15.10.1 加载新文档

如果给 `window.location` 或 `document.location` 赋值一个字符串，则该字符串将被解释为一个 URL，且浏览器会加载它，从而用新文档替换当前文档：

```js
window.location = 'http://www.oreilly.com';
```

也可以给 location 属性赋值相对 URL，浏览器会相对于当前 URL 解析它：

```js
document.location = 'page2.html'; // 加载下一页
```

简单的片段标识符也是一种特殊的 URL，但它不会导致浏览器加载新文档，只会把文档中 `id` 或 `name` 匹配该片段的元素滚动到浏览器窗口顶部。作为一个特例，片段标识符 `#top` 会让浏览器跳到文档顶部（假设没有元素有 id="top" 属性）：

```js
location = '#top'; // 跳到文档顶部
```

location 对象的个别属性是可写的，设置它们会改变 URL，也会导致浏览器加载新文档（或者如何设置的是 hash 属性，则会在当前文档中导航）

```js
document.location.path = 'pages/3.html'; // 加载一个新页面
document.location.hash = 'TOC'; // 滚动到目录
location.search = '?page=' + (page + 1); // 以新查询字符串重新加载文档
```

给 Location 对象的 `assign()` 方法传入一个新字符串也可以加载新页面。这样做的效果与给 location 属性赋值字符串相同，因此没有太大的意思。

相对而言，Location 对象的 `replace()` 方法倒是非常有用。在给 `replace()` 传入一个字符串时，字符串会被当作 URL 解析，并导致浏览器加载新页面，跟使用 `assign()` 样。区别在于 `replace()` 会在浏览器的历史记录中替换当前文档。如果文档 A 中的脚本通过设置 `location` 属性或调用 `assign()` 加载了文档 B，然后用户单击了浏览器的 “后退” 按钮，浏览器会返回到文档 A。如果使用的是 `replace()`，则文档 A 会从浏览器历史中擦除。当用户单击 “后退” 按钮时，浏览器会返回显示文档 A 之前显示的文档。

**在脚本无条件加载一个新文档时，相比 assign()，最好还是使用 replace()**。否则，“后退” 按钮会把浏览器带回最初的文档，而同一个脚本会再次触发加载新文档。假设页面有两个版本：一个使用 JS 增强的版本和一个不使用 JS 的静态版本。如果确定用户浏览器不支持想使用的 Web 平台 API，就可以使用 `location.replace()` 加载静态版本：

```js
// 如果浏览器不支持依赖的 JS API，则重定向到不使用 JS 的静态页面
if (!isBrowserSupported()) location.replace('staticpage.html');
```

> **注意**：传给 replace() 的 URL 是相对 URL。相对 URL 是相对于它们所在的页面来解析的，就像在超链接中使用一样。

除了 `assign()` 和 `replace()` 方法，Location 对象也定义了 `reload()` 方法，调用该方法会让浏览器重新加载当前文档。

#### 15.10.2 浏览历史

Window 对象的 `history` 属性引用的是窗口的 History 对象。History 对象将窗口的浏览历史建模为文档和文档状态的列表。History 对象的 `length` 属性是浏览历史列表中元素的数量。但出于安全考虑，脚本不能访问存储的 URL（如果可以访问，任何脚本都将可以窥探你的浏览历史）。

History 对象的 `back()` 和 `forward()` 方法就像浏览器的 “后退” 和 “前进” 按钮，可以让浏览器在浏览历史中后退或前进一步。另一个方法 `go()` 接收一个整数参数，可以在历史列表中前进（正整数）或后退（负整数）任意个页面：

```js
history.go(-2); // 后退2步，如同单击两次后退按钮
history.go(); // 重新加载当前页面的另一种方式
```

> 如果窗口包含子窗口（如 `<iframe>` 元素），子窗口的浏览历史会按时间顺序与主窗口历史交替。这意味着在主窗口中调用 `history.back()`，可能导致某个子窗口后退到前一个显示的文档，而主窗口则维持当前状态不变。

History 对象可以追溯到 Web 早期，当时文档都是被动的，所有计算都在服务器中执行。今天，Web 应用经常动态生成或加载内容，显示新应用状态而并不真正加载新文档。这样的应用必须自己管理历史记录，才能让用户直观地使用 “后退” 和 “前进” 按钮（或等价手势），从应用的一个状态导航到另一个状态。有两种方式实现这个任务，接下来两节将分别介绍。

#### 15.10.3 使用 hashchange 事件管理历史

第一种管理浏览历史的技术是使用 `location.hash` 和 “hashchange” 事件。要理解这个技术需要明确以下关键事实：

- `location.hash` 属性用于设置 URL 的片段标识符，通常用于指定要滚动到的文档区域的 ID。但 `location.hash` 不一定必须是元素 ID，也可以将它设置为任意字符串只要不是某个元素碰巧有该字符串 ID，浏览器就不会在设置 `hash` 属性时滚动。

- 设置 `location.hash` 属性会更新地址栏中显示的 URL，而且更重要的是，还会在浏览器历史列表中添加一条记录。

- 只要文档的片段标识符改变，浏览器就会在 Window 对象上触发 “hashchange” 事件。显式设置 `location.hash` 也会触发 “hashchange” 事件。而且，如前所述，对 Location 对象的这个修改会在浏览器的浏览历史中创建一条新记录。因此如果用户单击了 “后退” 按钮，浏览器会返回设置 `location.hash` 之前的 URL。但这意味着片段标识符又改变了，因此又会触发另一个 “hashchange” 事件。换句话说，只要可以为应用的每个可能的状态创建唯一的片段标识符，“hashchange” 事件就能够在用户向后或向前导航浏览历史时发送通知。

要使用这种历史管理机制，需要把渲染应用 “页面” 必需的状态信息编码为一个可以作为片段标识符的短字符串。为此需要写一个函数把页面状态转换为一个字符串，再写个函数来解析该字符串并重建其代表的页面状态。

写完这两个函数之后，剩下的事情就简单了。定义一个 `window.onhashchange` 监听函数（或使用 addEventlistener() 注册 “hashchange” 监听器），读取 `location.hash`，并将该字符串转换为应用的状态的表示，再采取必要步骤显示该应用的新状态。

如果用户的交互会导致应用进入新状态，不要直接渲染新状态。而要先把新状态编码为一个字符串，并将 `location.hash` 设置为该字符串。这样就会触发 “hashchange” 事件，而为该事件注册的事件处理程序将会显示该新状态。使用这种迂回技术可以保证新状态被插入浏览历史，因而 “后退” 和 “前进” 按钮继续有效。

#### 15.10.4 使用 pushState() 管理历史

管理历史的第二种技术稍微有点复杂，但却没有 “hashchange” 事件那么绕。这种更可靠的历史管理技术是建立在 `history.pushState()` 方法和 “popstate” 事件基础上的。

当 Web 应用进入一个新状态时，它会调用 `history.pushState()`，向浏览器历史中添加一个表示该状态的对象。如果用户单击 “后退” 按钮，浏览器会触发携带该保存的状态对象的 “popstate” 事件，应用使用该对象重建其之前的状态。除了保存的状态对象，应用也可以为每个状态都保存一个 URL，这样可以方便用户将 URL 加入书签和分享应用内部状态的链接。

`pushState()` 的参数：

- **第一个参数是一个对象，包含恢复当前文档状态所需的全部状态信息**。这个对象使用 HTML 的结构化克隆算法保存，该算法相比 `JSON.stringify()` 适用范围更广，而且支持 Map、Set 和 Date 对象，以及定型数组和 ArrayBuffer。

- **第二个参数应该是与状态对应的标题字符串，但多数浏览器都不支持这个参数，所以应该只传一个空字符串**。

- **第三个参数是一个可选的 URL**，该 URL 会立即在地址栏显示出来或者也会在用户通过 “后退” “前进” 按钮返回这个状态时在地址栏显示出来。相对 URL 会基于文档的当前地址解析。给每个状态都关联一个 URL 可以让用户收藏应用的内部状态。不过要记住，如果用户保存了这样一个书签，第二天又打开这个书签，不会收到这次访问的 “popstate” 事件，而是必须通过解析 URL 来恢复应用状态。

除了 `pushState()` 方法，History 对象也定义了 `replaceState()`，它接收相同的参数，但会替换当前历史状态，而不是向浏览历史中添加新状态。当应用使用 `pushState()` 的首次加载时，一般最好调用 `replaceState()` 为应用的初始状态定义一个状态对象。

在用户使用 “后退” 或 “前进” 按钮导航到保存的历史状态时，浏览器会在 Window 对象上触发 “popstate” 事件。与之关联的事件对象有一个名为 `state` 的属性，其中包含通过 `pushState()` 传入的状态对象的副本（又一次结构化克隆）。

**结构化克隆算法**
`history.pushState()` 方法不使用 `JSON.stringify()` 来序列化状态数据，而是使用一种更可靠的序列化技术叫作 “结构化克隆算法”。这个算法由 HTML 标准定义，后面介绍的其他一些浏览器 API 也会用到。

结构化克隆算法可以涵盖 `JSON.stringify()` 能够序列化的一切值，除此之外，它还支持很多其他 JS 类型的序列化。比如 Map、Set、Date、 RegExp 和定型数组。而且，它还能处理包含循环引用的数据结构。不过结构化克隆算法不能序列化函数和类。在克隆对象时，它不会复制原型对象、获取函数和设置函数，也不会复制不可枚举的属性。尽管结构化克隆算法可以克隆大多数内置 JS 类型，但不能复制宿主环境定义的类型，例如文档的 Element 对象。

这意味着传给 history.pushState() 的状态对象不必局限于能够被 `JSON.stringify()` 序列化的对象、数组和原始值。

> **注意**：如果传入自己定义的某个类的实例，则该实例被当作普通 JS 对象被序列化，因此会丢掉其原型。

如下图示，示例 15-9 是一个简单的猜数 Web 应用。这个应用使用 pushState() 保存自己的历史，允许用户 “后退” 查看或撤销自己的猜测。

![猜数游戏](./image/猜数游戏.png)

示例 15-9：使用 pushState() 管理历史状态 [pushState.html](./examples/pushState.html)

### 15.11 网络

每次打开一个网页时，浏览器都会（使用 HTTP 或 HTTPS 协议）发送网络请求，请求 HTML 文档，也请求该文档依赖的图片、字体、脚本和样式表。除了根据用户操作发送网络请求，浏览器也暴露了相关的 JS API。

本节介绍 3 个网络 API：

- 基于期约的 `fetch()` 方法可以发送 HTTP 和 HTTPS 请求。`fetch()` API 让发送基本的 GET 请求变得很简单，同时也支持全套的特性，能够满足几乎所有 HTTP 用例。

- SSE（Server-Send Event，服务器发送事件）API 是为 HTTP “轮询” 技术提供的基于事件的便利接口，让 Web 服务器可以一直保持连接打开，以便随时向客户端发送数据。

- WebSocket 是一个网络协议，不是 HTTP 但设计时考虑了与 HTTP 互操作。它定义了一个异步消息传递 API，即客户端和服务器可以通过与 TCP 网络套接口类似的方式相互发送和接收消息。

#### 15.11.1 fetch()

要发送简单的 HTTP 请求，使用 `fetch()` 只需三步：

1. 调用 `fetch()`，传入要获取内容的 URL;

2. 在 HTTP 响应开始到达时取得第 1 步异步返回的响应对象，然后调用这个响应对象的某个方法，读取响应体

3. 取得第 2 步异步返回的响应体，按需要处理它

> `fetch()` API 完全是基于期约的，因为涉及两个异步环节，所以使用 `fetch()` 时通常要写两个 then() 或两个 await 表达式。

下面这个例子使用了 fetch() 发送请求，并使用 then() 获取服务器返回的 JSON 响应：

```js
// 发送 HTTP（或 HTTPS）请求
fetch('/api/users/current')
  .then(response => response.json()) // 把响应体解析为 JSON 对象
  .then(currentUser => {
    // 然后处理解析得到的对象
    displayUserInfo(currentUser);
  });
```

下面是一个类似的例子，但使用了 async 和 await 关键字，而且 API 返回的是纯文本，不是 JSON 对象：

```js
async function isServiceReady() {
  let response = await fetch('/api/service/status');
  let body = await response.text();
  return body === 'ready';
}
```

**HTTP 状态码、响应头和网络错误**
上面展示的三步流程没有包含任何错误处理代码。下面是一个更接近实际的版本：

```js
fetch('/api/users/current') // 发送 HTTP（或 HTTPS）请求
  .then(response => {
    // 得到响应后，首先检查响应对象的成功码和预期类型
    if (response.ok && response.headers.get('Content-Type') === 'application/json') {
      return response.json(); // 返回包含响应体的期约
    } else {
      //或者抛出错误
      throw new Error(`Unexpected response status ${response.status} or content type`);
    }
  })
  // 当 response.json() 返回的期约解决后
  .then(currentUser => {
    displayUserInfo(currentUser); // 对解析得到的对象进行处理
  })
  // 或者，如果发生了什么问题，直接把错误打印出来
  .catch(error => {
    // 如果用户的浏览器离线了，fetch() 本身会拒绝期约，如果服务器返回了意料之外的响应，上面则会抛出错误
    console.log('Error while fetching current user: ', error);
  });
```

`fetch()` 返回的期约解决为一个 Response 对象。这个对象的 `status` 属性是 HTTP 状态码，如表示成功的 200 或表示 “Not Found” 的 404（`statusText` 中则是与数值状态码对应的标准英文描述）。更方便的是 Response 对象的 `ok` 属性，它在 `status` 为 200 或在 200 和 299 之间时是 true，在其他情况下是 false。

当服务器开始发送响应时，`fetch()` 只要一收到 HTTP 状态码和响应头就会解决它的期约，但此时通常还没收到完整的响应体。虽然响应体尚不完整，但已经可以在流程的第二步检查头部了。Response 对象的 `headers` 属性是一个 Headers 对象。使用它的 `has()` 方法可以测试某个头部是否存在，使用它的 `get()` 方法可以取得某个头部的值。HTTP 头部的名字是不区分大小写的，因此可以给这两个方法传入小写甚至混合大小写形式的头部名。

Headers 对象也是一个可迭代对象，需要时也可以这样用：

```js
fetch(url).then(response => {
  for (let [name, value] of response.headers) {
    console.log(`${name}: ${value}`);
  }
});
```

如果浏览器响应了 fetch() 请求，那么返回的期约就会以一个 Response 对象兑现，包括响应 404 Not Found 和 500 Internal Server Error。**fetch() 只在自己根本联系不到服务器时才会拒绝自己返回的期约**。如果用户的计算机断网了、服务器不响应了，或者 URL 指定的主机不存在，才会发生这种情况。因为这些情况对任何网络请求都可能发生，所以最好在任何 fetch() 调用后面都包含一个 catch() 子句。

**设置请求参数**
有时候，除了 URL 还需要在发送请求时传递额外的参数。此时可以在 URL 后面加个 `?`，然后以名/值对形式传递参数。[URL 和 URLSearchParams 类](#119-url-api)可以让构建这种形式的 URL 更方便，而 fetch() 函数也接收 URL 对象作为其第一个参数，因此可以像下面这样在 fetch() 请求中包含请求参数：

```js
async function search(term) {
  let url = new URL('/api/search');
  url.searchParams.set('q', term);
  let response = await fetch(url);
  if (!response.ok) throw new Error(response.statusText);
  let resultsArray = await response.json();
  return resultsArray;
}
```

**设置请求头部**
有时候，还需要为 fetch() 请求设置一些头部。比如，如果要请求的 API 校验凭据，可能需要包含 Authorization 头部，在其中附上相应的凭据。为此，可以使用两个参数版的 fetch()。与以前一样，第一个参数还是一个用于指定 URL 的字符串或 URL 对象。第二个参数用于提供额外选项，包括请求头部：

```js
let authHeaders = new Headers();
// 除非建立的是 HTTPS 连接，否则不要使用 Basic 认证。
authHeaders.set('Authorization', `Basic ${btoa(`${username}:${password}`)}`);
fetch('/api/users/', { headers: authHeaders })
  .then(response => response.json()) // 省略错误处理代码
  .then(usersList => displayAllUsers(usersList));
```

可以在 fetch() 的第二个参数中指定很多其他选项。另一种替代给 fetch() 传两个参数的方法是把同样的两个参数传给 Request() 构造函数，然后再将创建的 Request 对象传给 fetch()：

```js
let request = new Request(url, { headers });
fetch(request).then(response => response.json());
```

**解析响应体**
在前面演示的发送 fetch() 请求的三步流程中，第二步结束时调用了 Response 对象的 `json()` 或 `text()` 方法，并返回它们返回的期约对象。然后第三步从期约解决开始，直接拿到了响应体解析后的 JSON 对象或文本字符串。

这应该是两种最常见的情况，但并不是获取服务器响应体的全部方式。除了 `json()` 和 `text()`，Response 对象还有以下几个方法：

arrayBuffer()
: 这个方法返回一个期约，解决为一个 ArrayBuffer。在响应包含二进制数据时可以使用这个方法，基于得到的 ArrayBuffer 创建一个[定型数组](#112-定型数组与二进制数据)或一个 [DataView 对象](#1125-date-view-与字节序)，然后再读取二进制数据。

blob()
: 这个方法返回一个期约，解决为一个 Blob 对象。Blob，它是 “Binary Large Object”（二进制大对象）的意思，在需要处理大量二进制数据的时候会用到。把响应体转换为 Blob 时，浏览器实现可能会将响应数据流式写入一个临时文件，然后返回一个表示该临时文件的 Blob 对象。因此，Blob 对象不允许像 ArrayBuffer 那样随机访问响应体。拿到一个 Blob 后，可以通过 `URL.createObjectURL()` 创建个引用它的 URL，或者使用基于事件的 FileReader API 以字符串或 ArrayBuffer 的形式异步获取它的内容。有些浏览器也定义了基于期约的 `text()` 和 `arrayBuffer()` 方法，为获取 Blob 的内容提供了直接的手段。

formData()
: 这个方法返回一个期约，解决为一个 FormData 对象。如果 Response 响应体是以 “multipart/form-data” 格式编码的，应该使用这个方法。这种编码格式常见于向服务器发送的 POST 请求中，在服务器响应中并不常见，所以这个方法不太常用。

**流式访问响应体**
除了分别以某种形式返回完整响应体的 5 个异步响应方法，还可以流式访问响应体。在需要分块处理通过网络接收到的响应时可以采取这种方式。不过，流式访问响应体也可以用于显示进度条，以便用户看到下载进度。

Response 对象的 `body` 属性是一个 ReadableStream 对象。如果已经调用了 `text()` 或 `json()` 等读取、解析和返回响应体的方法，那么 `bodyUsed` 属性会变成 true，表示 body 流已经读完了。如果 `bodyUsed` 属性是 false，那就意味着该流尚未被读取。此时，可以在 `response.body` 上调用 `getReader()` 获取流读取器对象，然后通过这个读取器对象的 `read()` 方法异步从流中读取文本块。这个 `read()` 方法返回一个期约，解决为一个带有 `done` 和 `value` 属性的对象。如果响应体整个都读完了或者流被关闭了，`done` 会变成 true。而 `value` 要么是下一个 Uint8Array 块，要么会在没有更多块时变成 undefined。如果使用 async 和 await，流式 API 还算简单直观。如果以原始期约形式使用它，可能会复杂得吓人。

示例 15-10 通过定义一个 streamBody() 函数演示了这个 API。假设想下载一个大 JSON 文件，并向用户报告下载进度。此时不能使用 Response 对象的 json() 方法，但可以使用这个 steamBody() 函数，如下所示（假设已经定义了一个 `updateProgress()` 函数，可以用它设置 HTML `<progress>` 元素的 value 属性）：

```js
fetch('big.json')
  .then(response => streamBody(response, updateProgress))
  .then(bodyText => JSON.parse(bodyText))
  .then(handleBigJSONObject);
```

这个 streamBody() 函数可以像示例 15-10 所示的那样实现。

```js
/**
 * 示例 15-10：流式访问 fetch() 请求的响应体
 * 一个流式读取 fetch() 请求返回 Response 对象的异步函数，以 Response 对象作为第一个参数，后面是两个可选的回调。
 *
 * 如果指定了一个函数作为第二个参数，则 reportProgres 回调对于接收到的每个块都会被调用一次。
 * 调用时传入的第一个参数是已经接收到的总字节数。第二个参数是一个介于 0 和 1 之间的值，用于说明下载进度如何。
 * 如果 Response 对象没有 “Content-Length” 头部，那么这第二个参数将始终是 NaN
 *
 * 如果想在接收到块时处理其中的数据，可以指定一个函数作为第三个参数。每个块都会以 Unit8Array 对象形式传给这个名为 processChunk 的回调
 * streamBody() 返回一个期约，解决为一个字符串。如果提供了 processChunk 回调，则这个字符串将是拼接该回调返回值得到的结果。
 * 否则，这个字符串就是将每个块转换为 UTF-8 字符串后拼接起来得到的结果
 */
async function streamBody(response, reportProgress, processChunk) {
  // 期待接收多少字节，或者如果没有头部就是 NaN
  let expectedBytes = parseInt(response.headers.get('Content-Length'));
  let bytesRead = 0; // 已经接收了多少字节
  let reader = response.body.getReader(); // 通过这个函数读取字节
  let decoder = new TextDecoder('utf-8'); // 用于将字节转换为文本
  let body = ''; // 已经读取的文本
  // 循环直到在下面退出
  while (true) {
    let { done, value } = await reader.read(); // 读取一块数据
    // 如果得到一个字节数组：
    if (value) {
      // 如果传了这个回调
      if (processChunk) {
        let processed = processChunk(value); // 则用回调处理数据
        if (processed) {
          body += processed;
        }
      } else {
        // 否则，把字节转换
        body += decoder.decode(value, { stream: true }); // 为文本
      }

      // 如果传了进度回调
      if (reportProgress) {
        bytesRead += value.length; // 则调用它报告进度
        reportProgress(bytesRead, bytesRead / expectedBytes);
      }
    }
    // 如果这是最后一个块
    if (done) {
      break; // 则退出循环
    }
  }
  return body; // 返回累积的响应文本
}
```

> 流式 API 还有可能会改进。比如，有计划要将 ReadableStream 对象变成异步可迭代对象，以便在 for/await 循环中使用。

**指定请求方法和请求体**
如果想使用不同的请求方法（如 POST、PUT 或 DELETE），可以直接使用两个参数版的 fetch()，传入带 `method` 参数的选项对象：

```js
fetch(url, { method: 'POST' })
  .then(r => r.json())
  .then(handleResponse);
```

POST 和 PUT 请求通常都有一个请求体，该请求体包含要发给服务器的数据。只要 method 方法不是 GET 或 HEAD（这两个方法不支持请求体），都可以在选项对象中设置 `body` 属性指定请求体：

```js
fetch(url, {
  method: 'POST',
  body: 'hello world'
});
```

在指定请求体时，浏览器会自动添加合适的 “Content-Length” 请求头。如果请求体中是字符串，浏览器默认的 “Content-Type” 头部是“textplain;charset=UTF-8”。如果也指定一个字符串请求体，那可能需要覆盖这个头部值为它指定 “text/html” 或 “application/json” 等更具体的类型：

```js
fetch(url, {
  method: 'POST',
  headers: new Headers({ 'Content-Type': 'application/json' }),
  body: JSON.stringify(requestBody)
});
```

传给 fetch() 的选项对象的 `body` 属性不一定是字符串值。如果有保存在定型数组或 DataView 对象或 ArrayBuffer 中的二进制数据，也可以将 `body` 属性设置为相应的值，并指定恰当的 “Content-Type” 头部。如果是 Blob 中的二进制数据，可以简单地将 `body` 设置为该 Blob。Blob 自身有一个 `type` 属性，用于标明自己的上下文类型，而这个属性的值会用作 “Content-Type” 头部的默认值。

对于 POST 请求，常见的做法是在请求体中传入一组名/值参数（而不是将它们编码后作为查询参数附在 URL 后面）。为此有两种做法：

- 可以通过 URLSearchParams（[示例](#119-url-api)）指定参数的名和值，然后把这个 URLSearchParams 对象作为 `body` 属性的值。这样做，请求体将被设置为一个类似 URL 查询参数的字符串，而 “Content-Type” 头部也会自动被设置为 “application/x-www-form-urlencode;charset=UTF8”。

- 如果使用 FormData 对象指定参数的名和值，则请求体将使用更冗余的多部分编码格式，而 “Content-Type” 也将被设置为 “multipart/form-data;boundary==···”，省略号代表与请求体匹配的边界字符串。FormData 对象特别适合上传长内容，或者 File、Blob 这样可能分别有自己特定 “Content-Type” 的对象。可以通过把一个 `<from>` 元素传给 FormData() 构造函数来创建 FormData 对象，并通过其中的值初始化 FormData 对象。但是也可以调用 FormData() 构造函数而不传参数，来创建 “multipart/form-data” 请求体，然后再使用 `set()` 和 `append()` 方法来初始化它所表示的名/值对。

**通过 fetch() 上传文件**
从用户计算机向服务器上传文件是一个常见的任务，可以通过将 FormData 对象作为请求体来实现。获得 File 对象的一个常用方式是在网页上显示<input type="file"> 元素，然后监听该元素的 “change” 事件。当 “change” 事件发生时，这个输入元素的 files 数组应该至少包含一个 File 对象。File 对象也可以通过 HTML 的拖放 API 获取。也可以从传递给事件监听器（作用于 “drop” 事件）的事件对象的 `dataTransfer.files` 数组获取文件。

另外也要记住，File 对象是 Blob 的一种，有时候上传 Blob 比较有用。假设要写一个 Web 应用，允许用户在一个 `<canvas>` 元素上画画，那么可以使用类似以下代码把用户画的画以 PNG 文件形式上传：

```js
// canvas.toBlob() 函数是基于回调的
// 而这是对该方法基于期约的一个封装
async function getCanvasBlob(canvas) {
  return new Promise((resolve, reject) => {
    canvas.toBlob(resolve);
  });
}

// 这个函数可以基于画布上传 PNG 文件
async function uploadCanvasImage(canvas) {
  let pngBlob = await getCanvasBlob(canvas);
  let formdata = new FormData();
  formdata.set('canvasimage', pngBlob);
  let response = await fetch('/upload', { method: 'POST', body: formdata });
  let body = await response.json();
}
```

**跨源请求**
多数情况下，在 Web 应用中都是使用 fetch() 从自己的服务器请求数据。这种请求也被称为同源请求，因为传给 fetch() 的 URL 与包含发送请求脚本的文档是同源的（协议、主机名及端口都相同）。

出于安全考虑，浏览器通常不允许跨源网络请求（跨源请求图片和脚本是例外）。不过，利用 CORS（Cross-Origin Resource Sharing，跨源资源共享）可以实现安全的跨源请求。在通过 fetch() 请求跨源 URL 时，浏览器会为请求添加一个 “Origin” 头部（且不允许通过 `headers` 属性覆盖它的值）以告知服务器这个请求来自不同源的文档。如果服务器对这个请求的响应中包含恰当的 “Access-Control-Allow-Origin” 头部，则请求可以继续。否则，如果服务器没有明确允许请求，则 fetch() 返回的期约会被拒绝。

**中断请求**
有时候可能想中断已经发出的 fetch() 请求，比如用户单击了取消按钮或者请求时间过长。此时，fetch API 支持使用 AbortController 和 AbortSignal 类来中断请求（这两个类定义了通用的中断机制，也能在其他 API 中使用）。

如果知道可能要中断某个 fetch() 请求，那在创建请求前要先创建一个 AbortController 对象。这个控制器对象的 `signal` 属性是一个 AbortSignal 对象。在传给 fetch() 的第二个选项对象中，可以把这个信号对象以 `signal` 属性的值传进去。然后，可以在想中断请求的时候调用控制器对象的 `abort()` 方法，这样会导致与该请求相关的任何期约对象以一个异常被拒绝。

下面的例子展示了通过 AbortController 机制对 fetch() 请求超时进行强制中断：

```js
// 这个函数与 fetch() 类似，但增加了对超时的支持
// 即支持在 options 对象上设置 timeout 属性，如果在该属性指定的时间内没有完成，则会中断请求
function fetchwithTimeout(url, options = {}) {
  if (options.timeout) {
    // 如果有 timeout 属性且值不是
    let controller = new AbortController(); // 创建中断控制器
    options.signal = controller.signal; // 设置 signal 属性
    // 启动计时器，在经过指定毫秒后发送中断信号
    // 注意，这里并未考虑取消这个计时器。在请求完成后调用 abort() 没有影响
    setTimeout(() => {
      controller.abort();
    }, options.timeout);
  }
  // 现在开始正常发送请求
  return fetch(url, options);
}
```

**其他请求选项**
可以给 fetch()（或者 Request() 构造函数）传第二个参数，也就是选项对象，用于指定请求方法、请求头或请求体。这个选项对象还支持其他一些选项：

cache
: 这个属性可以用来覆盖浏览器默认的缓存行为。HTTP 缓存这个话题非常复杂。可以使用下列值来控制缓存行为：

- "default"
  这个值指定默认缓存行为。如果缓存中的响应还 “新鲜”（fresh），就直接从缓存提供响应；如果缓存中的响应已 “腐败”（stale），则在提供前先重新校验。

- "no-store"
  这个值会让浏览器忽略其缓存。发送请求时不会查看缓存，响应回来时也不更新缓存。

- "reload"
  这个值告诉浏览器始终要正常发送网络请求，忽略缓存。但是，响应回来以后，要把响应存在缓存里

- "no-cache"
  这个（名字有点误导性的）值告诉浏览器不要提供缓存中新鲜的值。无论缓存中的值新鲜还是腐败，都必须先重新校验再返回。

- "force-cache"
  这个值告诉浏览器即使缓存的值已腐败也要用缓存的值作为响应。

redirect
: 这个属性控制浏览器如何处理服务器的重定向响应。有 3 个合法的值：

- "follow"
  这是默认值，它让浏览器自动跟随重定向。如果使用这个默认值，则通过 fetch() 获取的 Response 对象的 `status` 属性应该不会是 300 到 399。

- "error"
  这个值会让 fetch() 在服务器返回重定向响应时拒绝其返回的期约。

- "manual"
  这个值表示开发者想手工处理重定向响应，而 fetch() 返回的期约可能会被解决为一个 status 在 300 到 399 之间的 Response 对象。这种情况下，必须使用 Response 的 “Location” 头部手工跟进重定向。

referrer
: 这个属性是一个包含相对 URL 的字符串，用于指定 HTTP 的 “Referer” 头部（由于历史原因，这个头部一直被错拼成包含 3 个 r 的版本）的值。如果把这个属性设置为空字符串，那么请求就会省略 “Referer” 头部。

#### 15.11.2 服务器发送事件

**HTTP 协议的一个让 Web 得以构建于其上的特性，就是客户端发起请求，服务器响应该请求**。不过，某些 Web 应用却需要在服务器发生事件时，接收来自服务器发送的通知。

HTTP 天生并不具备这个特性，但随着技术的发展，客户端向服务器发送请求之后，两端都可以不关闭连接。此时一旦服务器有事情要通知客户端，就可以把数据写入这个连接并保持其打开。效果就如同客户端发送了一次网络请求，服务器以缓慢而突发的方式响应，每次响应之间都会经历比较长的暂停。像这样的网络连接通常并不会永远打开，但如果客户端检测到连接已关闭，可以再发一次请求，重新打开一个新连接。

这种让服务器向客户端发送消息的技术效率非常高（尽管服务器端的成本可能较高，因为服务器必须对它的所有客户端都维护一个活动连接）。由于这是一个有用的编程模式，客户端 JS 以 EventSource API 的形式对其给予支持。要创建与服务器间的这种长时间存在的请求连接只要向 EventSource() 构造函数传一个 URL 即可。当服务器将（适当格式化的）数据写入这个连接时，EventSource 对象会将它们转换为客户端能够监听到的事件：

```js
let ticker = new EventSource("stockprices.php");
ticker.addEventListener("bid"，(event)=> {
  displayNewBid(event.data)
}
```

与消息事件关联的事件对象有一个 `data` 属性，保存着服务器针对这次事件发送过来的字符串。与其他事件对象一样，这个事件对象也有一个 `type` 属性，指定了这个事件的名字。服务器确定生成的事件的类型。如果服务器在写入的数据中省略了事件名，那么默认的事件类型就是 “message"。

这个 SSE（Server-Sent Event，服务器发送事件）协议很好理解。客户端（在它创建 EventSource 对象时）发起对服务器的连接，服务器保持连接打开。一旦有事件发生，服务器就向连接中写入几行文本。通过网络传送的消息大概类似如下所示（不包含注释）：

```js
event: btd; // 设置事件对象的类型
data: GOOG; // 设置data属性
data: 999; // 附加一个换行符和更多数据
// 空行表示事件结束
```

这个协议还允许为事件指定一个 ID，以便客户端重新建立连接时告诉服务器它上一次接收到的事件 ID 是什么，而服务器可以重新发送它错过的事件。不过，像这样的细节对客户端并不可见。

SSE 的一个典型应用是类似在线聊天一样的多用户协作。聊天客户端可以使用 fetch() 把消息发送到聊天室，通过 Eventsource 对象订阅聊天信息流。示例 15-11 展示了通过 EventSource 写这么一个聊天客户有多简单。

```html
// 示例 15-11：使用 EventSource 实现简单的聊天客户端
<html>
  <head>
    <title>SSE Chat</title>
  </head>
  <body>
    <!-- 聊天室的 UI 只有一个文本输入字段 -->
    <!-- 新聊天消息会插入这个输入字段前面 -->
    <input id="input" style="width: 100%; padding: 10px; border: solid black 2px" />
    <script>
      // 注重一些UI的细节
      let nick= prompt("Enter your nickname"); // 取得用户昵称
      let input= document.getElementById("input"); // 找到输入字段
      input.focus() // 设置键盘焦点

      // 使用 EventSource 注册新消息通知
      let chat = new EventSource("/chat");
      chat.addEventListener("chat", event=>{ // 收到聊天消息时
        let div= document.createElement("div");// 创建 <div> 元素
        div.append(event.data); // 添加消息的文本
        input.before(div) // 添加到输入字段前
        input.scrollIntoView(); // 确保输入元素可见
      })

      // 使用 fetch()把用户消息发送到服务器
      input.addEventListener("change",()=>{// 当用户按回车时
        // 发送HTTP请求
        fetch("/chat", {
          method :"POST", // 带主体的POST
          body:nick+": "+ input.value// 包含用户昵称和输入
        });
        .catch( e => console.error); // 忽略响应，但打印错误
        input.value= ""; // 清除输入框
      })
    </script>
  </body>
</html>
```

聊天程序的服务器端代码并不比客户端代码复杂多少。示例 15-12 是一个简单的 Node HTTP 服务器。当客户端请求根 URL “/” 时，这个服务器会发送示例 15-11 所示的客户端代码。当客户端向 URL “/chat” 发送 GET 请求时，它会保存响应对象并保持连接打开。而当客户端向 URL “/chat” 发送 POST 请求时，它会把请求体作为聊天消息并对每个保存的响应对象使用 “text/event-stream” 格式。服务器代码监听端口 8080，因此在通过 Node 运行后，在浏览器中访问 `http://localhost:8080` 即可连接到服务器，然后就可以跟自己聊天了。

```js
// 示例 15-12：SSE 聊天服务器

// 这是服务器端 JS，需要在 Node.js 环境下执行
// 这里实现了一个非常简单、完全匿名的聊天室
// POST 新消息到 /chat，或 GET 同一个 URL 得到 text/event-stream 格式的消息，GET请求返回包含客户端聊天 UI 的简单 HTML 文件
const http = require('http');
const fs = require('fs');
const url = require('url');

// 聊天客户端的HTML文件。在下面使用
const clientHTML = fs.readFileSync('chatClient.html');
// 要向其中发送事件的 ServerResponse 对象的数组
let clients = [];
// 创建一个新服务器，监听端口 8080，连接 http://localhost:8080/ 使用它
let server = new http.Server();
server.listen(8080);

// 服务器在收到新请求时，就运行这个函数
server.on('request', (request, response) => {
  // 解析请求的URL
  let pathname = url.parse(request.url).pathname;
  // 如果请求的是 "/"，发送客户端聊天 UI
  if (pathname === '/') {
    // 请求聊天UI
    response.writeHead(200, { 'Content-Type': 'text/html' }).end(clientHTML);
  }
  // 否则对于任何非 "/chat" 路径或任何非 "GET" 和 "POST" 方法，都发送 404 错误
  else if (pathname !== '/chat' || (request.method !== 'GET' && request.method !== 'POST')) {
    response.writeHead(404).end();
  }
  // 如果 /chat 请求方法是 GET，则说明有客户端连接
  else if (request.method === 'GET') {
    acceptNewClient(request, response);
  }
  // 否则 /chat 请求是 POST 的一条新消息
  else {
    broadcastNewMessage(request, response);
  }
});

// 这里处理对 /chat 端点的 GET 请求，该请求在客户端创建新 EventSource 对象（或者 EventSource 对象自动重连）时生成
function acceptNewClient(request, response) {
  // 记住这个响应对象，以便后面可以向它发送消息
  clients.push(response);
  // 如果客户端关闭了连接，就从活动客户端数组中删除相应的响应对象
  request.connection.on('end', () => {
    clients.splice(clients.indexOf(response), 1);
    response.end();
  });

  // 设置头部且只向这一个客户端发送初始的聊天事件
  response.writeHead(200, {
    'Content-Type': 'text/event-stream',
    Connection: 'keep-alive',
    'Cache-Control': 'no-cache'
  });
  response.write('event: chat\ndata: Connected\n\n');

  // 注意，这里有意没有调用 response.end() 保持连接打开是 SSR 运行的关键
}

// 这个函数在响应对 /chat 端点的 POST 请求时调用
// 每当用户输入新消息时客户端都会发送这个请求
async function broadcastNewMessage(request, response) {
  // 首先，读取请求体获取用户消息
  request.setEncoding('utf8');
  let body = '';
  for await (let chunk of request) {
    body += chunk;
  }
  // 读取完响应体后，发送一个空响应并关闭连接
  response.whiteHead(200).end();

  // 以 text/event-stream 形式来格式化消息，每行前面都加上 "data: "
  let message = 'data: ' + body.replace('\n', '\ndata: ');

  // 为消息数据添加一个前缀，将其定义为 "chat" 事件，并在后面附加两个换行符，标记该事件的结尾
  let event = `event: chat\n${message}\n\n`;

  // 下面把这个事件发送给所有监听的客户端
  clients.forEach(client => client.write(event));
}
```

#### 15.11.3 Web Socket

WebSocket API 是一个复杂、强大的网络协议对外暴露的简单接口。WebSocket 允许 JS 代码在浏览器中与服务器方便地交换文本和二进制消息。与服务器发送事件（SSE）类似，客户端必须建立连接，而连接一旦建立，服务器就可以异步向客户端发送消息。与 SSE 不同，WebSocket 支持二进制消息，而且消息可以双向发送，而不仅仅是从服务器向客户端发消息。

支撑 WebSocket 的网络协议是对 HTTP 的扩展。虽然 WebSocket API 是传统的低级网络套接口，但标识连接端点的并不是 IP 地址和端口。在使用 WebSocket 协议连接服务时，要通过 URL 指定该服务，就像使用 Web 服务一样。 WebSocket URL 以 `ws://` 而不是 `https://` 开头（浏览器通常会限制只能在安全的 https:// 连接加载的页面中使用 WebSocket）。

要建立 WebSocket 连接，浏览器首先要建立一个 HTTP 连接，并向服务器发送 `Upgrade:websocket` 请求头，请求把连接从 HTTP 协议切换为 WebSocket 协议。这意味着，要在客户端 JS 中使用 WebSocket，服务器必须遵循 WebSocket 协议，按照该协议发送和接收数据。

**创建、连接及断开连接**
如果想与支持 WebSocket 的服务器通信，需要创建一个 WebSocket 对象，指定表示服务器的 `wss://URL` 和要使用的服务

```js
let socket = new WebSocket('wss://example.com/stockticker');
```

创建 WebSocket 时，连接过程会自动开始。但新创建的 WebSocket 在第一次返回时不会建立连接。

这个套接口对象的 `readyState` 属性表明了当前的连接状态。这个属性可能包含下列值：

WebSocket.CONNECTING
: WebSocket 正在连接。

WebSocket.OPEN
: WebSocket 已经连接，可以通信了。

Websocket.CLOSING
: WebSocket 正在关闭。

WebSocket.CLOSED
: WebSocket 已经关闭，不能再通信了。初始连接失败时也是这个状态。

当 WebSocket 的状态从 CONNECTING 转变为 OPEN 时，它会触发 “open” 事件。可以通过设置 WebSocket 对象的 `onopen` 属性或调用该对象的 addEventlistener() 来监听这个事件。

如果 WebSocket 连接发生了协议错误或其他错误，WebSocket 对象会触发 “error” 事件。可以通过设置 `onerror` 来定义事件处理程序，也可以使用 addEventListener()。

在使用完 WebSocket 之后，可以调用 WebSocket 对象的 `close()` 方法关闭连接。当连接状态变成 CLOSED 时，WebSocket 对象会触发 “close” 事件，可以设置 `onclose` 属性来监听这个事件。

**通过 WebSocket 发送消息**
要向位于 WebSocket 连接另一端的服务器发送消息，调用 WebSocket 对象的 `send()` 方法。`send()` 方法接收一个消息参数，可以是字符串、Blob、 ArrayBuffer，定型数组或 DataView 对象。

send() 方法会把要发送的消息保存在缓冲区，并在实际发送前返回。WebSocket 对象的 bufferedAmount 属性保存着还在缓冲区未发送的字节数（奇怪的是，当这个值变成 0 时 WebSocket 居然不触发任何事件）。

**通过 WebSocket 接收消息**
要通过 WebSocket 从服务器接收消息，注册 “message” 事件处理程序，可以设置 WebSocket 对象的 `onmessage` 属性，也可以调用 addEventlistener()。与 “message” 事件关联的事件对象是 MessageEvent 的实例，其 `data` 属性包含服务器的消息。如果服务器发送了 UTF-8 编码的文本，`event.data` 就是保存该文本的字符串。如果服务器发送了二进制格式的消息，则 `data` 属性（默认）是表示该数据的 Blob 对象。如果希望接收 ArrayBuffer 而不是 Blob，可以把 WebSocket 对象的 `binaryType` 属性设置为 `arraybuffer`。

还有其他一些 Web API 也使用 MessageEvent 对象交换消息。其中有的使用[结构化克隆算法](#15104-使用-pushstate-管理历史)通过消息传输复杂数据结构。WebSocket 不在其列：通过 WebSocket 交换的消息要么是 Unicode 字符的字符串，要么是字节的字符串（表现为 Blob 或 ArrayBuffer）。

**协议协商**
WebSocket 协议支持文本和二进制消息交换，但并未规定这些消息的结构或含义。使用 WebSocket 的应用必须在其提供的简单消息交换机制基础上自行协商通信协议。使用 `wss://URL` 可以为此提供方便，每个 URL 通常都有自己如何交换消息的规则。

不过，协议自身也会不断改进。如果一个假想的股票报价协议更新了，可以定义一个新 URL 并连接到更新版服务，如 `wss://example.con/stockticker/v2`。但基于 URL 来区分版本还不够。对于已经随时间变化的复杂协议，最终可能出现多个版本的线上服务并存的局面，而客户端也分别支持不同版本的协议。

基于这个问题，WebSocket 协议和 API 提供了应用级消息协商功能。在调用 WebSocket() 构造函数时，`wss://URL` 是第一个参数，但也可以传一个字符串数组作为第二个参数。传入这个参数后，就相当于把客户端能够处理的应用协议提供给服务器，由服务器从中选择一个协议（如果服务器不支持其中任何一个子协议，也可以报错）。连接建立以后，WebSocket 对象的 `protocol` 属性将保存服务器选择的子协议。

### 15.12 存储

Web 应用可以使用浏览器 API 在用户计算机上本地存储数据。客户端存储的目的是让浏览器能够记住一些信息。比如，Web 应用可以存储用户偏好，或者存储他们的完成状态，以便恢复上次离开时的情境。客户端存储是按照来源隔离的，因此来自一个站点的页面不能读取来自另一个站点的页面存储的数据。但来自同一站点的两个页面可以共享存储的数据，并将其作为一种通信机制。比如，在一个网页的表单中输入的数据可以在另个页面中以表格形式显示出来。Web 应用可以选择它们存储数据的生命期。可以临时存储，只保留到窗口关闭或浏览器退出；也可以保存在用户计算机上，持久化存储数月甚至数年。

客户端存储分为如下几种形式：

_Web Storage_
Web Storage API 包含 `localStorage` 和 `sessionStorage` 对象，本质上是映射字符串键和值的持久化对象。Web Storage 很容易使用，适合存储大量（不是巨量）数据。

_Cookie_
: Cookie 是一种古老的客户端存储机制，是专门为服务端脚本使用而设计的。浏览器也提供了一种笨拙的 JS AP，可以在客户端操作 cookie。但这个 API 很难用，而且只适合保存少量数据。另外，保存在 cookie 中的数据也会随 HTTP 请求发送给服务器，哪怕这些数据只对客户端有用。

_IndexedDB_
: IndexedDB 是一种异步 API，可以访问支持索引的对象数据库。

#### 15.12.1 localStorage 和 sessionStorage

Window 对象的 `localStorage` 和 `sessionStorage` 属性引用的是 storage 对象。Storage 对象与普通 JS 对象非常类似，只不过：

- Storage 对象的属性值必须是字符串;

- Storage 对象中存储的属性是持久化的。如果设置了 localStorage 对象的一个属性，然后用户刷新了页面，的程序仍然可以访问在该属性中保存的值。

例如，可以像下面这样使用 localStorage 对象：

```js
let name = localStorage.username; // 查询存储的值
if (!name) {
  name = prompt('What is your name?'); // 问用户一个问题
  localStorage.username = name; // 存储用户的回答
}
```

可以使用 delete 操作符删除 localStorage 和 sessionStorage 的属性，可以使用 for/in 循环或 Object.keys() 枚举 Storage 对象的属性。如果想删除 Storage 对象的所有属性，可以调用 `clear()` 方法。

Storage 对象也定义了 `getItem()`、`setItem()` 和 `deleteItem()` 方法，可以用来代替直接读写属性和 delete 操作符。

> Storage 对象的属性只能存储字符串。如果想存取其他类型的数据，必须自己编码和解码。

**存储的生命期和作用域**
**localStorage 和 sessionStorage 的差异主要体现在生命期和作用域上**。通过 localStorage 存储的数据是永久性的，除非 Web 应用或用户通过浏览器（特定的界面）删除，否则数据会永远保存在用户设备上。

localStorage 的作用域为文档来源。文档来源由协议、域名和端口共同定义。所有同源文档都共享相同的 localStorage 数据（与实际访间 localStorage 的脚本的来源无关）。同源文档可以相互读取对方的数据，可以重写对方的数据。但非同源文档的数据相互之间是完全隔离的，既读不到也不能重写（即便它们运行的脚本来自同一台第三方服务器）。

通过 sessionStorage 保存的数据与通过 localStorage 保存的数据的生命期不同。sessionStorage 数据的生命期与存储它的脚本所属的顶级窗口或浏览器标签页相同。窗口或标签页永远关闭后，通过 sessionStorage 存储的所有数据都会被删除（不过要注意，现代浏览器有能力再次打开最近关闭的标签页并恢复用户上次浏览的会话，因此这些标签页以及与之关联的 sessionStorage 的生命期有可能比看起来更长）。

sessionStorage 的作用域与 localStorage 类似，都是文档来源。换句话说，不同来源的文档永远不会共享 sessionStorage。但是，sessionStorage 的作用域也在窗口间隔离。如果用户在两个浏览器标签页中打开了同一来源的文档，这两个标签页的 sessionStorage 数据也是隔离的。一个标签页中运行的脚本不能读取或重写另一个标签页中的脚本写入的数据。即便两个标签页打开的是完全相同的页面，而且运行的脚本完全相同。

**存储事件**
存储在 localStorage 中的数据每次发生变化时，浏览器都会在该数据可见的其他 Window 对象（不包括导致该变化的窗口）上触发 “storage” 事件。如果浏览器打开了两个标签页，加载了两个同源页面，其中一个页面在 localStorage 中存储了一个值则另一个标签页会收到 “storage” 事件。

要注册 “storage” 事件，可以使用 window.onstorage 事件属性，或者调用 window.addEventListener() 并传入 “storage"。

与 “storage” 事件关联的事件对象有如下一些重要属性：

key
: 写入或删除项的键或名字。如果调用了 `clear()` 方法，这个属性的值为 null。

newValue
: 保存变化项的新值（如果有）。如果调用了 `removeItem()`，这个属性不存在。

oldValue
: 保存变化的或被删除的已有项的旧值。如果添加了一个新属性（没有旧值），这个属性不存在。

storageArea
: 变化的 Storage 对象。通常是 localStorage 对象。

url
: 导致这次存储变化的脚本所在文档的 URL（字符串）。

> **注意**：localStorage 和 “storage” 事件可以作为一种广播机制，即浏览器向所有当前浏览同一网站的窗口发送消息。比如，如果用户要求网站停止执行动画，网站可以把该偏好保存在 localStorage 中，以便未来访问时遵行。通过存储这个偏好，它会生成个事件，让其他显示相同网站的窗口也能遵守这个要求。

还有一个例子，在一个 Web 版图片编辑应用中，工具面板会显示在一个分离的窗口中。当用户选择某种工具时，应用可以使用 localStorage 保存当前状态并生成一个通知告诉其他窗口用户选择了新工具。

#### 15.12.2 cookie

cookie 是浏览器为特定网页或网站保存的少量命名数据。cookie 是为服务端编程而设计的，在最低的层级上作为 HTTP 协议的扩展实现。cookie 数据会自动在浏览器与 Web 服务器之间传输，因此服务器端脚本可以读写存储在客户端的 cookie 值。本节演示客户端脚本如何使用 Document 对象的 cookie 属性操作 cookie 数据。

**为什么叫 cookie?**
cookie 这个名字并没有什么深意，而且也是有先例的。在计算的历史长河中 “cookie”或 “magic cookie” 曾被用于指代一小段数据，特别是某种特殊或保密的数据（类似于密码），可以证明身份或授权访问。在 JS 中，cookie 用于保存状态并且可以作为浏览器的某种标识。但 JS 中的 cookie 并不以任何形式进行加密，无论怎么说都是不安全的（尽管通过 HTTPS 连接发送 cookie 会安全一些）。

操作 cookie 的 API 很古老也很难用，因为没有涉及方法。查询、设置和删除 cookie，都是通过读写 Document 对象的 cookie 属性实现的，而且要使用特定格式的字符串。每个 cookie 的生命期和作用域可以通过 cookie 属性来个别指定。这些属性同样也以特定格式的字符串在同一个 cookie 属性上面设置。

接下来几个小节会讲解如何查询和设置 cookie 值以及相应的属性。

**读取 cookie**
`document.cookie` 属性返回一个包含与当前文档有关的所有 cookie 的字符串。这个字符串是一个分号和空格分隔的名/值对。cookie 的值就是名/值对中的值，不包含任何与该 cookie 关联的属性。为了使用 `document.cookie` 属性，通常必须调用 `split()` 方法把整个字符串拆分成个别的名/值对。

从 cookie 属性中提取出某个 cookie 的值之后，必须根据 cookie 创建者的格式或编码来解释该值。例如，可能需要先把 cookie 值传给 `decodeURIComponent()`，然后再传给 `JSON.parse()`。

下面的代码定义了一个 getCookie()函数，可以解析 document.cookie 属性并返回一个对象。这个对象的属性中包含文档的 cookie 的名字和值：

```js
// 返回一个包含文档 cookie 的 Map 对象
// 假设 cookie 的值是以 encodeURIComponent() 编码的
function getCookies() {
  let cookies = new Map(); // 要返回的对象
  let all = document.cookie; // 取得包含所有 cookie 的大字符串
  let list = all.split(';'); // 将字符串拆分成一个个的名/值对
  // 对于列表中的每个 cookie
  for (let cookie of list) {
    if (cookie.includes('=')) continue; // 如果没有 = 号就跳过
    let p = cookie.indexOf('='); // 找到第一个 = 号
    let name = cookie.substring(0, p); // 取得 cookie 的名字
    let value = cookie.substring(p + 1); // 取得 cookie 的值
    value = decodeURIComponent(value); // 对值进行解码
    cookies.set(name, value); // 记住 cookie 的名字和值
  }
  return cookies;
}
```

**cookie 的属性：生命期与作用域**
除了名字和值，每个 cookie 还有可选的属性，用于控制其生命期和作用域。在介绍如何使用 JS 设置 cookie 之前，必须先解释 cookie 的属性。

cookie 默认的生命期很短，它们存储的值只在浏览器会话期间存在，用户退出浏览器后就会丢失。如果想让 cookie 的生命期超过单个浏览会话，必须告诉浏览器希望保存它们多长时间（以秒为单位）。为此要指定 cookie 的 `max-age` 属性。如果指定了这样一个生命期，浏览器将把 cookie 存储在一个文件中，等时间到了再把它们删除。

与 localStorage 和 sessionStorage 类似，cookie 的可见性由文档来源决定，但也由文档路径决定。换句话说，cookie 的作用域通过 `path` 和 `domain` 属性来配置。默认情况下，cookie 关联着创建它的网页，以及与该网页位于相同目录和子目录下的其他网页，这些网页都可以访问它。比如，如果网页 _example.com/catalog/index.html_ 创建了一个 cookie，则该 cookie 对 _example.com/catalog/order.html_ 和 _example.com/catalog/widgets/index.html_ 同样可见，但对 _example.com/about.html_ 不可见。

这个默认的作用域通常也是想要的。但有时候，可能希望让 cookie 对整个网站可见，无论它是哪个页面创建的。例如，用户在某个页面的表单中输入自己的收件地址，希望保存这个地址并在用户下次再回来时将其作为默认地址，同时也将其作为另一个页面中完全无关的要求用户填写账单地址的表单的默认值。为此，可以为 cookie 指定 `path` 属性。然后来自同一服务器的任何网页，只要其 `URL` 以指定的路径前缀开头就可以共享该 cookie。例如，如果 _example.com/catalog/widgets/index.html_ 设置的 cookie 将路径设置为 “/catalog”，则该 cookie 也对 _example.com/catalog/order.html_ 可见。或者，如果将路径设置为 “/”，那么该 cookie 将对 _example.com_ 域中的任何页面都可见，此时这个 cookie 的作用域就跟 localStorage 一样。

默认情况下，cookie 的作用域按照文档来源区分。不过大网站可能需要跨子域名共享 cookie。例如，_order.example.com_ 对应的服务器可能需要读取 _catalog.example.com_ 设置的 cookie 值。这时候就要用到 `domain` 属性了。如果 cookie 是由 _catalog.example.com_ 上的页面设置的，且 `path` 属性被设置为 “/”、`domain` 属性被设置为 “.example.com”，则该 cookie 将对 _catalog.example.com_、_order.example.com_，以及任何 _example.com_ 域名下的服务器有效。

> **注意**：不能将 cookie 的域设置为服务器父域名之外的其他域名。

最后一个 cookie 属性是 `secure`，一个布尔值，用于指定如何通过网络传输 cookie 值。默认情况下，cookie 是不安全的。换句话说，它们会在普通的不安全的 HTTP 连接上传输。如果把 cookie 设置为安全的，那么就只能在浏览器与服务器通过 HTTPS 或其他安全协议连接时传输 cookie。

**Cookie 的限制**
Cookie 主要用于为服务器端脚本存储少量数据，而且该数据在每次请求相关 URL 时都会发送给服务器。定义 cookie 的标准建议浏览器厂商不限制 cookie 的数量和大小，但没有要求浏览器保留总共 300 个以上的 cookie、每个服务器 20 个 cookie 或每个 cookie 大小为 4KB（名字和值都包含在这 4KB 之内）。实践中，浏览器通常允许大大超过 300 个 cookie，但某些浏览器仍然限制 4KB 大小。

**存储 cookie**
要给当前文档关联一个短暂的 cookie，只要把 document.cookie 设置为 `name=value` 形式的字符串即可：

```js
document.cookie = `version=${encodeURIComponent(document.lastModified)}`;
```

下次在读取这个 cookie 属性时，保存的这个名/值对就会包含在文档的 cookie 列表中。cookie 值不能包含分号、逗号或空格。为此，可能需要使用核心 JS 的全局函数 `encodeURIComponent()` 先对值进行编码，然后再把它保存到 cookie 中。如果进行了编码，那么在将来读取 cookie 值时还必须使用对应的 `decodeURIComponent()` 函数来解码

简单名/值对形式的 cookie 只在当前会话期间存在，用户关闭浏览器就会丢失。要创建可以跨会话存在的 cookie，则要通过 `max-age` 属性指定其生命期（单位为秒）。此时保存在 cookie 属性中的字符串形式为 `name=value; max-age=seconds` 下面这个函数在设置 cookie 时能够可选地添加 `max-age` 属性：

```js
// 把 name/value 对存储为 cookie，使用 encodeURIComponent() 编码值，以转义
// 分号、逗号和窗格。如果 daysToLive 是个数值，则设置 max-age 属性，从而让 cookie在指定的天数之后过期。传入 0 删除 cookie
function setCookie(name, value, daysToLive = null) {
  let cookie = `${name}=${encodeURIComponent(value)}`;
  if (daysToLive !== null) {
    cookie += `; max-age=${daysToLive * 60 * 60 * 24}`;
  }
  document.cookie = cookie;
}
```

类似地，可以向 `document.cookie` 属性上追加 `;path=value` 或 `;domain=value` 这样的字符串来设置 cookie 的 `path` 和 `domain` 属性。要设置 `secure` 属性，只要追加 `;secure` 即可。

要修改 cookie 的值，需要以相同的名字、路径和域再设置一次它的值。在修改 cookie 值时，可以通过指定一个新的 `max-age` 属性修改 cookie 的值时，可以修改 cookie 的生命期。

要删除 cookie，需要以相同的名字、路径和域名再设置一次，指定一个任意值（或空值），并将 `max-age` 属性指定为 0。

#### 15.12.3 IndexedDB

IndexedDB 是一个对象数据库，不是关系型数据库，比支持 SQL 查询的数据库更简单。而且比 localStorage 提供的键/值对存储机制更强大、高效和可靠。与 localStorage 类似，IndexedDB 数据库的作用域限定为包含文档的来源。换句话说，两个同源的网页可以互相访问对方的数据，但不同源的网页则不能相互访问。

每个来源可以有任意数量的 IndexedDB 数据库。每个数据库的名字必须在当前来源下唯。在 IndexedDB API 中，数据库就是一个名为对象存储的集合。顾名思义，对象存储中存储的是对象。对象会使用[结构化克隆算法](#15104-使用-pushstate-管理历史)序列化为对象存储。这意味着存储的对象可以拥有 Map、Set 或定型数组作为属性值。每个对象必须有一个键，可以用于排序和从存储中检索。键必须唯一（相同存储中的两个对象不能使用相同的键），而且必须有自然顺序以便排序。JS 字符串、数值和 Date 对象都是有效的键。IndexedDB 数据库可以自动为插入数据库中的每个对象生成一个唯一的键。不过，通常插入对象存储中的对象都会有一个属性适合作为键。在这种情况下，可以在创建对象存储时为该属性指定一个 “键路径”。从概念上讲，键路径是一个值，它告诉数据库如何从对象中提取对象的键。

除了从对象存储中按照主键值检索对象，有时候也需要按照对象其他属性的值来搜索。为此，可以在对象存储上定义任意数量的索引（索引对象存储的能力正是 IndexedDB 名字的由来）。每个索引为存储的对象定义了一个次键。这些索引一般并不是唯一的，因此多个对象可能匹配一个键值。

IndexedDB 提供了原子保证，即查询和更新数据库会按照事务进行分组，要么全部成功，要么全部失败，永远不会让数据库处于未定义、部分更新的状态。IndexedDB 中的事务比很多数据库 API 都简单。

从概念上讲，IndexedDB API 非常简单。要查询或更新数据库，首先要打开对应的数据库（通过名字）。然后，创建一个事务对象并使用该对象查找数据库中相应的对象存储（同样通过名字）。最后，通过调用该对象存储的 `get()` 方法查询对象，或通过调用 `put()` 方法存储新对象（或者如果想避免重写已有对象，可以调用 `add()` 方法）。

如果想查询键在某个范围内的对象，需要创建一个 IDBRange 对象并指定范围的上、下边界，然后把它传给对象存储的 `getAll()` 或 `openCursor()` 方法。

如果想使用次键来查询，可以先查找对象存储的命名索引，然后调用该索引对象的 `get()`、`getAll()` 或 `openCursor()` 方法，传入一个键或一个 IDBRange 对象。

不过，由于 IndexedDB API 是异步的（因此 Web 应用可以使用它而不阻塞浏览器的主 UI 线程），所以这种概念上的简化并不容易理解。IndexedDB 是在期约得到广泛支持之前定义的，因此这个 API 是基于事件而非基于期约的。这意味着不能对它使用 `async` 和 `await`。

创建事务和查找对象存储及索引是同步操作。但打开数据库、更新对象存储和查询存储或索引全都是异步操作。这些异步方法都会立即返回一个请求对象。浏览器会在请求成功或失败时在这个请求对象上触发成功或失败事件，在代码中可以通过 `onsuccess` 和 `onerror` 属性定义处理程序。在 `onsuccess` 处理程序中，操作的结果可以通过请求对象的 `result` 属性得到。另一个有用的事件是 “complete”，它会在事务成功完成时在事务对象上派发。

这个异步 API 有个方便的特性，就是它简化了事务管理。IndexedDB API 强制创建事务对象，然后才能取得对象存储并进行查询和更新。如果是同步 API，可能调用一个 `commit()` 方法就知道事务完成了。但在 IndexedDB 中，事务是在所有 `onsuccess` 处理程序运行且没有引用该事务的更多异步请求时自动提交的（只要不显式地中断它）。

IndexedDB API 还有一个重要的事件。在第一次打开一个数据库时，或者在增大一个已有数据库的版本号时，IndexedDB 会在调用 `indexedDB.open()` 返回的请求对象上触发 “u ad eneed ed ” 事件。这个.“upgradeneeded” = 事件的处理程序要负责定义或更新这个新数据库的模式（或已有数据库的新版本）。le.IndexedD; 数据 库，这意味着创建对象存储和在这些对象存储上定义索引。而且事实上，IndexedDB API 唯一一次创建对象存储或索引，就是在响应 “upgradeneeded” 事件的时候。

在了解了 IndexedDB 的概况之后，应该可以理解示例 15-13。这个示例使用 IndexedDB 创建和査询了一个数据库，这个数据库将美国邮政编码映射到美国的城市。示例演示了很多（但不是全部） IndexedDB 的基本功能，代码有点长，但注释很多：

```js
// 示例 15-13：美国邮政编码的 IndexedDB 数据库
// 这个辅助函数异步获取数据库对象，(必要时创建并初始化数据库）并将它传给回调
function withDB(calLback) {
  let request = indexedDB.open('zipcodes', 1); // 请求数据库的 v1 版
  request.onerror = console.error; // 记录错误

  // 或者在完成时调用这个函数
  request.onsuccess = () => {
    let db = request.result; // 请求的结果是数据库
    callback(db); // 调用回调并传入数据库
  };

  // 如果数据库的 v1 版不存在，则会触发这个事件处理程序。
  // 这个处理程序会初次创建数据库时创建并初始化对象存储，或者在数据库模式切换时修改它们
  request.onupgradeneeded = () => {
    initdb(request.result, calLback);
  };
}

// withDB() 在数据库尚未初始化时会调用这个函数
// 这个函数会创建数据库并为它填充数据，然后把数据库传给回调函数
//
// 邮编数据库包含一个对象存储，对象格式为:
//
// {
// zipcode: "02134",
// city: "Allston",
// state: "MA",
// }
//
// 这里使用 zipcode 属性作为数据库键，并为城市名创建了一个索引
function initdb(db, callback) {
  // 创建对象存储，指定存储的名字和一个选项对象
  // 选项对象包含 “键路径”（key Path），指定的是这个存储的键字段的属性名
  let store = db.createObjectStore(
    'zipcodes', // store name
    { keyPath: 'zipcode' }
  );

  // 除了通过邮政编码，还通过城市名来索引这个对象存储
  // 调用这个方法时，键路径以必需的字符串参数形式直接传入，而不是通过一个选项对象来传入
  store.createIndex('cities', 'city');

  // 现在取得要用来初始化数据库的数据
  // 这个 zipcodes.json 数据文件是 CC 许可的数据,来源为 www.geonames.org:https://download.geonames.org/export/zip/US.zip
  fetch('zipcodes.json') // 发送 Http Get请求
    .then(response => response.json()) // 解析]50N响应体
    .then(zipcodes => {
      // 取得4万条邮编记录
      //  为了向数据库中插入邮政编码，需要一个事务对象。
      // 而要创建事务对象，需要指定使用哪个对象存储（只有一个），且告诉它要写入数据库，不仅是读数据
      let transaction = db.transaction(['zipcodes'], 'readwrite');
      transaction.onerror = console.error;

      // 从事务中取得对象存储
      let store = transaction.objectStore('zipcodes');

      // IndexedDB API最大的优点就是对象存储，下面就是添加（或更新）记录：
      for (let record of zipcodes) {
        store.put(record);
      }

      // 当事务成功完成，数据库就初始化完毕可以使用了
      // 此时可以调用最初传给 withDB() 的回调函数
      transaction.oncomplete = () => {
        callback(db);
      };
    });
}

// 给一个邮政编码，使用 IndexedDB API 异步查询对应的城市
// 然后将结果传给指定的回调，如果没有找，则传 null
function lookupCity(zip, callback) {
  withDB(db => {
    // 创建一个只读的事务对象用于查询
    // 参数是要使用的对象存储的数组
    let transaction = db.transaction(['zipcodes']);

    // 从事务中取得对象存储
    let zipcodes = transaction.objectStore('zipcodes');

    // 现在查找与指定邮政编码键匹配的对象，上面的代码是同步的，但这里是异步的
    let request = zipcodes.get(zip);
    request.onerror = console.error; // 记录错误
    // 或者在成功时调用这个函数
    request.onsuccess = () => {
      let record = request.result; // 这是查询的结果
      if (record) {
        // 如果找到了匹配结果，把它传给回调
        callback(`${record.city}, ${record.state}`);
      } else {
        // 否则,告诉回调查询失败了
        callback(null);
      }
    };
  });
}

// 给一个城市的名字，使用 IndexedDB API 异步查询
// （所有美国州的）所有名字相同的城市（区分大小写）对应的所有邮政编码。
function lookupZipcodes(city, callback) {
  withDB(db => {
    // 跟上面一样，先创建事务再取得对象存储
    let transaction = db.transaction(['zipcodes']);
    let store = transaction.objectStore('zipcodes');

    // 这一次也取得对象存储的城市索引
    let index = store.index('cities');

    // 从索引中查询与指定城市名匹配的所有记录，找到以后，把它们传给回调函数。
    // 如果想得到更多结果，可能要使用 openCursor()
    let request = index.getAll(city);
    request.onerror = console.error;
    request.onsuccess = () => {
      callback(request.result);
    };
  });
}
```

### 15.13 工作线程与消息传递

单线程是 JS 的一个基本特性，因此浏览器绝不会同时运行两个事件处理程序，也不会在一个事件处理程序运行的时候触发其他计时器。这样就无法并发更新应用或文档状态，而前端开发者就无须思考甚至理解并发编程。一个必然的结果就是 JS 函数不能运行太长时间，否则它们就会阻塞事件循环，而浏览器也会变得不能响应用户输入。事实上这也是 `fetch()` 被设计为异步函数的原因。

浏览器通过 Worker 类非常谨慎地放松了这种单线程的限制。这个类的实例代表与主线程和事件循环同时运行的线程。Worker 运行于独立的运行环境，有着完全独立的全局对象，不能访问 Window 或 Document 对象。 Worker 与主线程只能通过异步消息机制通信。这意味着并发修改 DOM 仍然是不可能的，但也意味可以写长时间运行的函数，而不会阻塞事件循环、卡死浏览器。创建新工作线程（worker）并不会像打开新浏览器窗口那么 “重量线”，但也并非 “轻于鸿毛”。为了执行简单的操作而创建新工作线程是完全没有必要的。复杂 Web 应用可能会创建几十个工作线程，但要创建几百或者几千个工作线程也是不切实际的。

工作线程适合执行计算密集型任务，比如图像处理。使用工作线程把这类任务从主线程转移走可以避免浏览器卡顿。而工作线程也提供了把任务分给多个线程的可能。除此之外，工作线程也适合频繁执行较密集的计算。例如，在实现一个网页版代码编辑器，想加入代码高亮功能。为了正确地高亮代码，需要毎次敲击键盘都解析一次代码。但如果在主线程做这件事，很可能会因为解析代码而导致键盘输入的事件处理程序不能迅速响应用户的击键操作，让用户输入体验变迟滞。

与任何线程 API 一样， Worker API 也有两部分。一部分是 Worker 对象，另一部分是 WorkerGlobalScope。前者是这个线程的外在部分，后者则是线程的内在部分。

接下来几小节将介绍 Worker 和 WorkerGlobalScope，也会讲解允许工作线程与主线程通信的消息传递 API。同样的通信 API 也用于文档与其包含的 `<iframe>` 元素之间的消息交换，相关内容也将在后面的小节介绍。

#### 15.13.1 Worker 对象

要创建新的工作线程，调用 Worker() 构造函数，传入一个 URL，这个 URL 用于指定线程要执行的 JS 代码：

```js
let dataCruncher = new Worker('utils/cruncher.js');
```

如果传入的是相对 URL，则会按照调用 Worker() 构造函数的脚本所在文档的位置进行解析。如果传入的是绝对 URL，则必须与包含文档同源(协议、主机和端口都相同)。

创建 Worker 对象后，可以使用 `postMessage()` 方法向工作线程发送数据。传给 `postMessage()` 的值会使用[结构化克隆算法](#15104-使用-pushstate-管理历史)被复制，得到的副本会通过消息事件发送给工作线程：

```js
dataCruncher.postMessage('/api/data/to/crunch');
```

这里只发送了一个字符串消息，也可以发送对象、数组、定型数组、映射等。通过监听 Worker 对象的 “message” 事件，可以从工作线程接收消息：

```js
dataCruncher.onmessage = function (e) {
  let stats = e.data; // 消息保存在事件对象的 data 属性中
  console.log(`Average: ${stats.mean}`);
};
```

与所有事件目标一样，Worker 对象定义了标准的 `addEventlistener()` 和 `removeEventListener()` 方法，可以用它们代替 `onmessage`。

除了 `postMessage()`，Worker 对象只有另外一个方法 `terminate()`，用于强制停止工作线程。

#### 15.13.2 工作线程中的全局对象

在通过 Worker() 构造函数创建新工作线程时，传入的 URL 指定的是一个 JS 代码文件。其中的代码会在一个新的、干净的 JS 执行环境中执行，与创建工作线程的脚本完全隔离。这个新执行环境中的全局对象是一个 WorkerGlobalScope 对象。WorkerGlobalScope 比核心 JS 全局对象多一些东西，但又比客户端中完整的 Window 对象少一些东西。

WorkerGlobalScope 对象也有 `postMessage()` 方法和 `onmessage` 事件处理程序，只是方向与 Worker 对象上的恰好相反。在工作线程内部调用 `postMessage()` 会在外部生成消息事件，而在工作线程外部发送的消息会转换为事件并发送给内部的 `onmessage` 事件处理程序。因为 WorkerGlobalScope 是工作线程的全局对象，`postMessage()` 和 `onmessage` 在工作线程的代码中看起来就像一个全局函数和一个全局变量。

如果给 Worker() 构造函数传入对象作为第二个参数，而该对象有一个 `name` 属性，则这个属性的值就会成为工作线程中全局对象的 `name` 属性的值。在通过 console.warn() 或 console.error() 打印的任何消息中，工作线程都包含这个名字（name）。

而 `close()` 函数可以让工作线程终止自己，效果与调用 Worker 对象的 `terminate()` 方法一样。

由于 WorkerGlobalScope 是工作线程的全局对象，因此它拥有核心 JS 全局对象的所有属性，如 JSON 对象、isNaN() 函数、Date() 函数。不过，除此之外，WorkerGlobalScope 也拥有下列客户端 Window 对象的属性：

- `self` 是对全局对象自身的引用。WorkerGlobalScope 不是 Window 对象，没有定义 `window` 属性。

- setTimeout()、clearTimeout()、setInterval()、clearInterval() 等定时器方法。

- `location` 属性描述传给 Worker() 构造函数的 URL。这个属性引用一个 Location 对象，就像 Window 对象上的 location 属性一样。 Location 对象有 `href`、`protocolhost`、`hostname`、`port`、`pathname`、`search` 和 `hash` 属性。但在工作线程中，这些属性**都是只读的**。

- `navigator` 属性引用的是一个类似 Window 的 Navigator 对象。工作线程的 Navigator 对象拥有 `appName`、`appVersion`、`platform`、`userAgent` 和 `onLine` 属性。

- 常用的事件目标方法 addEventlistener() 和 removeEventlistener()。

最后，WorkerGlobalScope 对象还包含重要的客户端 JS API，比如 Console 对象、fetch()函数和 IndexedDB API。WorkerGlobalScope 也包含 Worker() 构造函数，这意味着工作线程也可以创建自己的工作线程。

#### 15.13.3 在工作线程中导入代码

浏览器支持 Worker 的时候 JS 还不支持模块系统，因此工作线程有自己一套独特的系统用于导入外部代码。WorkerGlobalScope 定义了 `importScripts()` 全局函数，所有工作线程都可以使用：

```js
// 在开始之前，加载需要的类和辅助程序
importScripts('utils/Histogram.js', 'utils/BitSet.js');
```

`importScripts()` 接收一个或多个 URL 参数，每个 URL 引用一个 JS 代码文件。相对 URL 的解析相对于传给 Worker() 构造函数的 URL（而不是相对于包含文档）。importScripts() 按照传入顺序一个接一个地同步加载并执行这些文件。如果加载某个脚本时出现网络错误，或者如果执行某个脚本时抛出了任何错误，则后续脚本都不会再加载或执行。通过 importScripts() 加载的脚本自身也可以调用 importScripts() 加载自己的依赖文件。

> **注意**：`importScripts()` 不会跟踪已经下载了哪些脚本，也不会阻止循环依赖。

`importScripts()` 是同步函数，即它会在所有脚本都加载并执行完毕后返回。`importScripts()` 返回后，就可以立即使用它所加载的脚本，不需要回调、事件处理程序、then() 方法或 await。一旦习惯了客户端 js 的异步特性，再碰到简单的同步代码反而会让人觉得有点怪。但这正是线程的优点，工作线程中的任何阻塞函数都不会影响主线程的事件循环，也不会影响其他工作线程中的并行计算。

**在工作线程中使用模块**
为了在工作线程中使用模块，必须给 Worker() 构造函数传入第二个参数。这个参数必须是一个有 `type` 属性且值为 `module` 的对象。给 Worker() 构造函数传入 `type:"module"` 选项与在 HTML `<script>` 标签中添加 `type="module"` 类似，都是表示应该将当前代码作为模块来解释，并允许使用 `import` 声明。

如果工作线程加载的是模块而非常规脚本，WorkerGlobalScope 上不会再定义 importScripts() 函数。

> **注意**：截止到 2020 年初，Chrome 是唯一真正在工作线程中支持模块和 import 声明的浏览器。

#### 15.13.4 工作线程执行模型

工作线程自上而下地同步运行自己的代码（和所有导入的脚本及模块），之后就进入了异步阶段，准备对事件和定时器作出响应。如果注册了 “message” 事件处理程序，只要有收到消息事件的可能，则工作线程就不会退出。而如果工作线程没有监听消息事件，它会运行直到没有其他待决的任务（如 fetch() 期约和定时器），且所有任务相关的回调都被调用。在所有注册的回调都被调用后，工作线程已经不可能再启动新任务了，此时线程可以安全退出，而且是自动的。工作线程也可以调用全局的 `close()` 函数显式将自己终止。

> **注意**：Worker 对象上没有任何属性或方法可以告诉工作线程是否还在运行，因此除非与父线程协商一致，否则工作线程不应该主动终止自己。

**工作线程中的错误**
如果工作线程中出现了异常，而且没有被 catch 子句捕获，则会在全局对象上触发 “error” 事件。如果这个事件有处理程序，而且处理程序调用了事件对象的 `preventDefault()` 则错误会停止传播。否则，“error” 事件会在 Worker 对象上触发。如果这里调用了 preventDefault()，则传播停止。否则，开发者控制台会打印出错误消息，并调用 Window 对象的 [onerror 处理程序](#1517-程序错误)。

```js
// 在工作线程内处理未被捕的错误
self.onerror = function (e) {
  console.log(`Error in worker at ${e.filename}:${e.lineno}: ${e.message}`);
  e.preventDefault();
};

// 否则，就要在工作线程外处理未被捕获的错误。
worker.onerror = function (e) {
  console.log(`Error in worker at ${e.filename}:${e.lineno}: ${e.message}`);
  e.preventDefault();
};
```

与在 window 上类似，工作线程也可以注册一个事件处理程序，以便期约被拒绝又没有 `catch()` 函数处理它时调用。为此，可以在工作线程内定义一个 self.onunhandledrejection 函数，或者使用 addEventlistener() 为全局事件 “unhandledrejection” 注册一个全局处理程序。传给这个处理程序的事件对象有一个 `promise` 属性，值为被拒绝的期约对象，还有一个 `reason` 属性，值为传给 `catch()` 函数的值。

#### 15.13.5 postMessage()、MessagePort 和 MessageChannel

Worker 对象的 `postMessage()` 方法和工作线程内部的全局 `postMessage()` 函数，都是通过调用在创建工作线程时一起创建的一对 MessagePort(消息端口)对象的 postMessage()方法来实现通信的。客户端 Javascript 无法直接访问这两个自动创建的 MessagePort 对象，但可以通过 Message Channe1()构造函数创建一对新的关联端口:

```js
Let channel new Message Channel
Let myPort channel pe
/创建新信道
//它有两个相互
Let your Port= channel port2;
/连接的端口
Port postMessage( "Can you hear me? )
//在一个端口上发送消息
your Port. onmessage=(e)= console.log(e.data);//可以在另一个端口收到
```

Message Channel 是一个对象，有两个属性 port1 和 port2，引用一对关联的 MessagePort 对象。 MessagePort 对象有一个 posmEssage()方法和一个 message 事件处理程序属性。在一个消息端口上调用 I postMessage()2 会触发关联消息端口的“ message 事件。通过设置 onmessage 属性或调用 addEventlistener()为“ message”事件注册监听器可以收到这些“ message”事件。

发送到一个端口的消息在该端口定义 onmessage 属性或调用 start()方法之前会被放在一个队列中。这样可以防止信道一端发送的消息被另一端错过。如果调用了 MessagePort 的 addEventlistener()，不要忘了调用 start()，否则可能永远看不到发过来的消息。

前面看到的 postMessage()调用都接收一个消息参数。实际上这个方法还接收可选的第二个参数，该参数是一个数组，数组的元素不是被复制到信道另一端，而是被转移到信道另一端。像这样可以转移而非复制的值包括 MessagePort 和 Array Buffer(有些浏览器
