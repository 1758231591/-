---
title: JavaScript权威指南
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [JavaScript 权威指南](#javascript-权威指南)
  - [一. 基础](#一-基础)
    - [1.1 方法与函数的区别](#11-方法与函数的区别)
    - [1.2 JS 支持面向对象的编程风格，但与“经典的”面向对象编程语言非常不一样](#12-js-支持面向对象的编程风格但与经典的面向对象编程语言非常不一样)
    - [1.3. 使用 JS 分析文件中的字符频率](#13-使用-js-分析文件中的字符频率)
  - [二. 词法结构](#二-词法结构)
    - [2.1 字面量含义](#21-字面量含义)
    - [2.2 JS 标识符命名规则](#22-js-标识符命名规则)
    - [2.3 Unicode 转义序列](#23-unicode-转义序列)
    - [2.4 箭头函数的 `=>` 必须跟参数列表在同一行](#24-箭头函数的-必须跟参数列表在同一行)
  - [三. 类型、值和变量](#三-类型-值和变量)
    - [3.1 数值](#31-数值)
      - [3.1.1 整数字面量支持的进制表示](#311-整数字面量支持的进制表示)
      - [3.1.2 数值字面量中的分隔符](#312-数值字面量中的分隔符)
      - [3.1.3 JS 通过 Math 对象提供了一组函数和常量，以支持更复杂的数学计算](#313-js-通过-math-对象提供了一组函数和常量以支持更复杂的数学计算)
      - [3.1.4 Number ES6 新增属性](#314-number-es6-新增属性)
      - [3.1.5 通过 BigInt 表示任意精度整数](#315-通过-bigint-表示任意精度整数)
    - [3.2 文本](#32-文本)
      - [3.2.1 使用字符串](#321-使用字符串)
      - [3.2.2 模板字符串](#322-模板字符串)
    - [3.3 null 与 undefined](#33-null-与-undefined)
    - [3.4 Symbol](#34-symbol)
    - [3.5 类型转换](#35-类型转换)
      - [3.4.1 显式转换](#341-显式转换)
      - [3.4.2 对象到原始值转换](#342-对象到原始值转换)
    - [3.6 变量声明与赋值](#36-变量声明与赋值)
    - [3.7 解构赋值](#37-解构赋值)
  - [四. 表达式与操作符](#四-表达式与操作符)
    - [4.1 表达式](#41-表达式)
    - [4.2 操作符](#42-操作符)
      - [4.2.1 操作符优先级](#421-操作符优先级)
      - [4.2.2 求值顺序](#422-求值顺序)
    - [4.3 算术表达式](#43-算术表达式)
      - [4.3.1 + 操作符](#431-操作符)
      - [4.3.2 一元算术操作符](#432-一元算术操作符)
    - [4.4 关系表达式](#44-关系表达式)
      - [4.4.1 严格相等](#441-严格相等)
      - [4.4.2 比较操作符](#442-比较操作符)
      - [4.4.3 in 操作符](#443-in-操作符)
      - [4.4.4 instanceof 操作符](#444-instanceof-操作符)
    - [4.5 逻辑表达式](#45-逻辑表达式)
      - [4.5.1 逻辑与 (&&)](#451-逻辑与)
      - [4.5.2 逻辑或 (||)](#452-逻辑或)
      - [4.5.3 逻辑非 (!)](#453-逻辑非)
    - [4.6 赋值表达式](#46-赋值表达式)
    - [4.7 其他操作符](#47-其他操作符)
      - [4.7.1 空值合并运算符 (??)](#471-空值合并运算符)
      - [4.7.2 typeof 操作符](#472-typeof-操作符)
      - [4.7.3 delete 操作符](#473-delete-操作符)
      - [4.7.4 await 操作符](#474-await-操作符)
  - [五. 语句](#五-语句)

<!-- /code_chunk_output -->

# JavaScript 权威指南

## 一. 基础

### 1.1 方法与函数的区别

**在通过对象使用函数时，称其为方法**，所有的 JS 对象都有方法。

### 1.2 JS 支持面向对象的编程风格，但与“经典的”面向对象编程语言非常不一样

```js
// 定义 Point 类以表示几何平面上的一个点，作为这个类的实例的对象有一个方法，叫做 distance()，用于计算该点与原点的距离
class Point {
  // 按惯例，类名需要首字母大写
  constructor(x, y) {
    // 构造函数用于初始化新实例
    this.x = x; // this 关键字代表要初始化的新对象
    this.y = y; // 将函数参数保存为对象属性
  } // 构造函数中不需要 return 语句

  distance() {
    // 计算从原点到当前点的距离的方法
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
}

// 使用 Point() 构造函数和 new 创建Point对象
let p = new Point(1, 1); // 几何平面上的点

// 调用 Point 对象 p 的方法
p.distance(); // Math.SQRT2
```

### 1.3. 使用 JS 分析文件中的字符频率

这个 [Node 程序](./examples/charFreq.js) 使用标准输入读取文本，计算该文本的 _字符频率柱形图_ 和 _总字符数_，然后打印出来。

```js
node charFreq.js < ../JavaScript权威指南.md
```

## 二. 词法结构

编程语言的词法结构是一套基本规则，规定了如何使用这门编程语言编写程序。词法结构是一门语言最低级的语法，规定了变量如何命名、注释的界定符，以及如何分隔程序的语句。

### 2.1 字面量含义

字面量（literal）是一种直接出现在程序中的数据值。

### 2.2 JS 标识符命名规则

JS 标识符必须以字母、下划线`_` 或美元符号`$`开头。后续字符可以是字母、数字、`_` 或 `$`（**数字不能作为第一个字符，以便 JS 区分标识符和数值**）。

### 2.3 Unicode 转义序列

为了方便程序员编码和支持老技术的系统，JS 定义了转义序列，从而可以仅使用 ASCII 字符来表示 Unicode 字符。有两种方式来表示：

- 已 `\u` 开头，后跟 4 位十六进制数字（包括大小写的 A~F）
- 包含在一对花括号中内的 1~6 位十六进制数字。ES6 新增，为了更好的支持大于 16 位的 Unicode 码点，比如表情符号

  ```js
  console.log('\u{1F600}'); // 打印一个笑脸符号
  ```

### 2.4 箭头函数的 `=>` 必须跟参数列表在同一行

## 三. 类型、值和变量

### 3.1 数值

#### 3.1.1 整数字面量支持的进制表示

1. 以 `0x` 或 `0X` 开头，后跟一个十六进制数字字符串。
2. ES6 及以后的版本中，也可以通过二进制或八进制表示整数分别使用前缀 `0b` 和 `0o`。

#### 3.1.2 数值字面量中的分隔符

可以使用下划线将数值字面量分隔为容易看清的数字段。

```js
let billion = 1_000_000_000; // 以下划线作为千分位分隔符
let bytes = 0x89_ab_cd_ef; // 作为字节分隔符
let bits = 0b0001_1101_0111; // 作为半字节分隔符
let fraction = 0.123_456_789; // 也可以使用小数部分
```

> 这个特性暂时没有成为 JS 标准，但已经进入标准化流程的后期，而且已经被所有主流浏览器以及 Node 实现了。

#### 3.1.3 JS 通过 Math 对象提供了一组函数和常量，以支持更复杂的数学计算

```js
// 9007199254740992: 2的53次方
Math.pow(2, 53);
// 1.0: 舍入到最接近的整数
Math.round(0.6);
// 1.0: 向上舍入到一个整数
Math.ceil(0.6);
// 0.0: 向下舍入到一个整数
Math.floor(0.6);
// 5: 绝对值
Math.abs(-5);
// 返回最大的参数
Math.max(x, y, z);
// 返回最小的参数
Math.min(x, y, z);
// 伪随机数 x,范围 0 <= x < 1.0
Math.random();
// π 圆周率
Math.PI;
// 自然对数的底数
Math.E;
// 3**0.5: 3的平方根
Math.sqrt(3);
// 3**(1/3): 3的立方根
Math.pow(3, 1 / 3);
// 三角函数，还有 Math.cos、Math.atan 等
Math.sin(0);
// 10 的自然对数
Math.log(10);
// 以 10 为底 100 的对数
Math.log(100) / Math.LN10;
// 以 2 为底 512 的对数
Math.log(512) / Math.LN2;
// Math.E 的立方
Math.exp(3);
```

ES6 在 Math 对象上又定义了一批函数

```js
// 3: 立方根
Math.cbrt(27);
// 5: 所有参数平方和的平方根
Math.hypot(3, 4);
// 2: 以 10 为底的对数
Math.log10(100);
// 10：以 2 为底的对数
Math.log2(1024);
// (1+x) 的自然对数；精确到非常小的x
Math.log1p(x);
// Math.exp(x)-1; Math.log1p() 的逆运算
Math.expm1(1);
// 对 <、== 或 >0 的参数返回 -1、0 或 1
Math.sign(x);
// 6：优化的32位整数乘法
Math.imul(2, 3);
// 28: 32位整数中前导 0 的位数
Math.clz32(0xf);
// 3: 减掉小数部分得到整数
Math.trunc(3.9);
// 舍入到最接近的 32 位浮点数
Math.fround(x);
// 双曲线正弦，还有 Math.cosh() 和 Math.tanh()
Math.sinh(x);
// 双曲线反正弦，还有 Math.acosh() 和 Math.atanh()
Math.asinh(x);
```

#### 3.1.4 Number ES6 新增属性

```js
// 同全局 parseInt() 函数
Number.parseInt();
// 同全局 parseFloat() 函数
Number.parseFloat();
Number.isNaN(x);
Number.isFinite(x);
// 判断 x 是不是整数
Number.isInteger(x);
// -(2**53 - 1)
Number.MIN_SAFE_INTEGER;
// 2**53 -1
Number.MAX_SAFE_INTEGER;
// 数值与数值之间最小的差
Number.EPSILON;
```

#### 3.1.5 通过 BigInt 表示任意精度整数

ES2020 为 JS 定义了一种新的数值类型 BigInt。之所以增加了这个类型，**主要是为了表示 64 位整数，这对于兼容很多其他语言和 API 是必需的**。

BigInt 字面量写作一串数字后跟小写字母 `n`。默认情况下，进制是 10，但也可以通过前缀 `0b`、`0o`、`0x` 来表示二进制、八进制和十六进制 BigInt。

```js
1234n;
0b11241n; // 二进制 BigInt
0o777n; // 八进制 BigInt
```

可以使用 `BigInt()` 函数把常规 JS 数值或字符串转换为 BigInt 值。

```js
BigInt(123); // 123n
let string = '1' + '0'.repeat(100);
BigInt(string); // 10n**100n: 一个天文数字
```

> 注意：
>
> 1. 算术操作符不能 混用 BigInt 操作数和常规数值操作数。
> 2. 比较操作符允许混用操作数类型。
> 3. 位操作符通常可以用于 BigInt 操作数。
> 4. Math 对象的任何函数都不接受 BigInt 操作数。

### 3.2 文本

JS 中表示文本的类型是 String，即字符串。字符串是 16 位值的不可修改的有序序列，其中每个值都表示一个 Unicode 字符。

#### 3.2.1 使用字符串

```js
let s = 'Hello，world';

// 取得字符串的一部分
s.substring(1, 4); // "ell": 第 2~4 个字符
s.slice(1, 4); // "ell": 同上
s.slice(-3); // rld: 最后 3 个字符
s.split(', '); // ["hello", "world"]: 从界定符处拆开

// 搜索字符串
s.indexOf('l'); // 2: 第一个字母 l 的位置
s.indexOf('l', 3); // 3: 位置3后面第一个 "l" 的位置
s.indexOf('zz'); // -1: s 并不包含子串 "zz"
s.lastIndexOf('l'); // 10: 最后一个字母 "l" 的位置

// ES6 及之后版本中的布尔值搜索函数
s.startsWith('Hell'); // true：字符串是以这些字符开头的
s.endWith('!'); // false：s 不是以它结尾的
s.includes('or'); // true: s 包含子串 "or"

// 创建字符串的修改版本
s.replace('llo', 'ya'); // "Heya, world"
s.toLowerCase(); // "hello，world"
s.toUpperCase(); // "HELLO，WORLD"
s.normalize(); // Unicode NFC 归一化：ES6 新增
s.normalize('NFD'); // NFD 归一化。还有 "NFKC" "NFKD"

// 访问字符串中的个别（16位值）字符
s.charAt(0); // "H": 第一个儿字符
s.charAt(s.length - 1); // "d"：最后一个字符
s.charCodeAt(0); // 72：指定位置的16位数值
s.codePointAt(0); // 72: ES6，适用于码点大于 16 位的情况

// ES2017 新增的字符串填充函数
'x'.padStart(3); // "  x"：在左侧添加空格，让字符串长度变成 3
'x'.padEnd(3); // "x  ": 在右侧添加空格，让字符串长度变成 3
'x'.padStart(3, '*'); // "**x"：在左侧添加星号，让字符串长度变成 3
'x'.padEnd(3, '-'); // "x--"：在右侧添加破折号，让字符串长度变成 3

// 删除空格函数，trim() 是 ES5 就有的，其他是 ES2019 增加的
' test'.trim(); // "test"：删除开头和结尾的空格
' test'.trimStart(); // "test "：删除左侧空格。也叫 trimLeft
' test '.trimEnd(); // " test"：删除右侧空额。也叫 trimRight

// 未分类字符串方法
s.concat('!'); // "Hello，world!"：可以用 + 操作符代替
'<>'.repeat(3); // "<><><>"：拼接 n 次，ES6 新增
```

> 注意：JS 中的字符串是不可修改的，像 replace() 这样的方法都是返回的新字符串，它们并不会修改调用它们的字符串。

#### 3.2.2 模板字符串

**标签化模板字面量**
模板字面量有一个强大但不太常用的特性，如果在开头的反引号前面有一个函数名（标签），那么模板字面量中的文本和表达式的值将作为参数传给这个函数。

这个特性可以用于先对某些值进行 HTML 或 SQL 转义，然后在把它们插入文本中。

ES6 提供了一个内置的标签函数：`String.row()`。这个函数返回反引号中未经处理的文本，即不会处理任何反斜杠转义。

```js
`\n`.length; // 1: 字符串中只包含一个换行符
String.raw`\n`.length; // 2: 一个反写杠字符和一个字母 n
```

> 注意：即使标签化模板字面量的标签部分是函数，在调用这个函数时也没有圆括号。在这种特殊的情况下，反引号字符充当开头和结尾的圆括号。

### 3.3 null 与 undefined

- `undefined` 可以表示一种系统级别、意料之外或类似错误的没有值。
- `null` 可以表示程序级别，正常或意料之外的没有值。

### 3.4 Symbol

符号（Symbol）是 ES6 新增的一种原始类型。用作非字符串的属性名。要理解 Symbol，需要了解 JS 的基础类型 Object 是一个属性的无序集合，其中每一个属性都有一个名字和一个值。属性名通常是字符串。但在 ES6 及之后的版本中，Symbol 也可以作为属性名：

```js
let strname = 'string name'; // 可以用作属性名的字符串
let symname = Symbol('propname'); // 可以用作属性名的符号
typeof strname; // string：strname 是字符串
typeof symname; // Symbol：symname 是符号
let o = {}; // 创建一个新对象
// 使用字符串名顶一个属性
o[strname] = 1;
// 使用符号名定义一个属性
o[symname] = 2;
o[strname]; // 1
o[symname]; // 2
```

Symbol 类型没有字面量语法。要获取一个 Symbol 值，需要调用 `Symbol()` 函数。这个函数永远不会返回相同的值，即使每次传入的参数都一样。这意味着可以将调用 `Symbol()` 取得的符号值安全地用于为对象添加属性，而无需担心可能重写已有的同名属性。

如果定义了 Symbol 属性但没有共享相关 Symbol，也可以确信程序中的其他代码不会意外重写这个属性。

实践中，Symbol 通常作为一种语言扩展机制。ES6 新增了 [for/of 循环]<!--TODO 5.4.4 -->和 可迭代对象<!--TODO 第12章-->，为此就需要定义一种标准的机制让类可以实现，从而把自身变得可迭代。但选择任何特定的字符串作为这个迭代器方法的名字都有可能破坏已有的代码。

为此，Symbol 应运而生，`Symbol.iterator` 是一个符号值，可以作一个方法名，让对象变得可迭代。

`Symbol()` 函数可选地接收一个字符串参数，返回唯一的符号值。如果提供了字符串参数，那么调用返回符号值的 `toString()` 方法得到的结果中会包含该字符串。

为了定义一些可以与其他代码共享的 Symbol 值，JS 定义了一个全局符号注册表。`Symbol.for()` 函数接收一个字符串参数，返回一个与该字符串关联的符号值。如果没有 Symbol 与该字符串关联，则会创建并返回一个新 Symbol；否则，会返回已有的 Symbol。

`Symbol.for()` 与 `Symbol()` 完全不同：`Symbol()` 永远不会返回相同的值。而在以相同字符串调用 `Symbol.for()` 时始终返回相同的值。传给 `Symbol.for()` 的字符串会出现在 `toString()` 的输出中。而且，这个字符串也可以通过将返回的符号传给 `Symbol.keyFor()` 来得到：

```js
let s = Symbol.for('shared');
let t = Symbol.for('shared');
s === t; // true
s.toString(); // "Symbol(shared)"
Symbol.keyFor(t); // "shared"
```

### 3.5 类型转换

| 值                 | 转换为字符串                              | 转换为数值                                | 转换为布尔值 |
| ------------------ | ----------------------------------------- | ----------------------------------------- | ------------ |
| undefined          | "undefined"                               | NaN                                       | false        |
| null               | "null"                                    | 0                                         | false        |
| true               | "true"                                    | 1                                         | -            |
| false              | "false"                                   | 0                                         | -            |
| ""(空字符串)       | -                                         | 0                                         | false        |
| "1.2"(非空,数值)   | -                                         | 1.2                                       | true         |
| "one"(非空,非数值) | -                                         | NaN                                       | true         |
| 0                  | "0"                                       | -                                         | false        |
| -0                 | "0"                                       | -                                         | false        |
| 1(有限,非零)       | "1"                                       | -                                         | true         |
| Infinit            | "Infinity"                                | -                                         | true         |
| -Infinity          | "-Infinity""                              | -                                         | true         |
| NaN                | "NaN"                                     | -                                         | false        |
| {}(任何对象)       | [对象到原始值转换](#342-对象到原始值转换) | [对象到原始值转换](#342-对象到原始值转换) | true         |
| [](空数组)         | ""                                        | 0                                         | true         |
| [9]                | "9"                                       | 9                                         | true         |
| ["a"]              | 使用 `join()` 方法                        | NaN                                       | true         |
| Function(){}       | [对象到原始值转换](#342-对象到原始值转换) | NaN                                       | true         |

#### 3.4.1 显式转换

除了 `null` 和 `undefined` 之外的所有值都有 `toString()` 方法。

在使用金融或科学数据时,可能需要控制转换后得到的字符串的小数位的个数或者有效数字的个数,或者需要控制是否采用指数记数法。 Number 类为这些数值到字符串的转换定义了 3 种方法。

- `toFixed()` : 把数值转换为字符串时可以指定小数点后面的位数。这个方法不使用指数记数法。
- `toExponential()` : 使用指数记数法将数值转换为字符串,结果是小数点前 1 位,小数点后为指定位数(意味着有效数字个数比指定的值多 1 位)。
- `toPrecision()` : 按照指定的有效数字个数将数值转换为字符串。如果有效数字个数不足以显示数值的整数部分,它会使用指数记数法。

> 注意 : 这三种方法必要时都会舍去末尾的数字或者补零。

例子:

```js
let n = 123456.789;
n.toFixed(o); // "123457"
n.toFixed(2); // "123456.79"
n.toFixed(5); // "123456.78900"

n.toExponential(1); // "1.2e+5"
n.toExponential(3); // "1.235e+5"

n.toPrecision(4); // "1.235e+5"
n.toPrecision(7); // "123456.8"
n.toPrecision(10); // "123456.789"
```

除了这里介绍的数值格式化方法，`Intl.NumberFormat` 类定义了一个更通用、更国际化的数值格式化方法,详见 11.7.1<!--TODO--> 节。

#### 3.4.2 对象到原始值转换

JS 对象到原始值转换的复杂性,主要原因在于某些对象类型有不止一种原始值的表示。比如,Date 对象可以用字符串表示,也可以用时间戳表示。JS 规范定义了对象到原始值转换的 3 种基本算法。

_偏字符_
: 该算法返回原始值,而且只要可能就返回字符串

_偏数值_
: 该算法返回原始值,而且只要可能就返回数值

_无偏好_
: 该算法不倾向于任何原始值类型，而是由类定义自己的转换规则。**JS 内置类型除了 Date 类都实现了偏数值算法。Date 类实现了偏字符串算法**。

- **对象转换为布尔值**
  对象到布尔值的转换很简单: 所有对象都转换为 true。

  > 注意：这个转换不需要使用对象到原始值的转换算法,而是直接适用于所有对象。包括空数组,甚至包括 `new Boolean(false)` 这样的包装对象。

- **对象转换为字符串**
  在将对象转换为字符串时, JS 首先使用偏字符串算法将它转换为一个原始值，然后将得到的原始值再转换为字符串。
  这种转换会发生在把对象传给一个接收字符串参数的内置函数时,比如将 `String()` 作为转换函数,或者将对象插入模板字面量中时就会发生这种转换。

- **对象转换为数值**
  当需要把对象转换为数值时, JS 首先使用偏数值算法将它转换为一个原始值，然后将得到的原始值再转换为数值。
  接收数值参数的内置 JS 函数和方法都以这种方式将对象转换为数值,而除数值操作符之外的多数(参见下面的例外情况) JS 操作符也按照这种方式把对象转换为数值。

**操作符转换特例**
在此，只介绍那些不遵循上述基本的对象到字符串或对象到数值转换规则的操作符特例。

- JS 中的 `+` 操作符执行数值加法和字符串拼接。

  - 如果一个操作数是对象,那 JS 会使用无偏好算法将对象转换为原始值。
  - 如果两个操作数都是原始值,则会先检查它们的类型。如果有一个参数是字符串,则把另一个原始值也转换为字符串并拼接两个字符串。否则，把两个参数都转换为数值并把它们相加。

- `==` 和 `!=` 操作符以允许类型转换的宽松方式执行相等和不相等测试。
  如果一个操作数是对象，另一个操作数是原始值，则这两个操作符会使用无偏好算法将对象转换为原始值,然后再比较两个原始值。

- 关系操作符 `<`、`<=`、`>` 和 `>=` 比较操作数的顺序，既可以比较数值,也可以比较字符串。
  如果操作数中有一个是对象，则会使用偏数值算法将对象转换为原始值。

  > 注意：与对象到数值转换不同,这个偏数值算法返回的原始值不会再被转换为数值。

> 注意：Date 对象的数值表示是可以使用 `<` 和 `>` 进行有意义的比较的,但它的字符串表示则不行。对于 Date 对象,无偏好算法会将其转换为字符串，而 JS 中这两个操作符会使用偏数值算法的事实意味着可以比较两个 Date 对象的顺序。

**`toString()` 和 `valueOf()` 方法**

所有对象都会继承两个在对象到原始值转换时使用的方法,在接下来解释偏字符串、偏数值和无偏好转换算法前，必须先解释这两个方法。

- `tostring()`
  返回对象的字符串表示。默认情况下, `tostring()` 方法不会返回特别的值:

  ```js
  ({ x: 1, y: 23 }.toString()); // [object Object]
  ```

  很多类都定义了自己特有的 `toString()` 版本。比如：

  - Array 类的 `toString()` 方法会将数组的每个元素转换为字符串，然后再使用逗号作为分隔符将它们拼接起来。
  - Function 类的 `tostring()` 方法会将用户定义的函数转换为 JS 源代码的字符串。
  - Date 类定义的 `toString()` 方法返回一个人类友好(且 JS 可解析)的日期和时间字符串。
  - RegExp 类定义的 `toString()` 方法会将 RegExp 对象转换为一个看起来像 RegExp 字面量的字符串

  ```js
  [1, 2, 3].toString(); // "1,2,3"

  (function (x) {
    f(x);
  }.toString()); // "function(x) { f(x); }"

  /\d+/g.toString(); // "/\\d+/g"

  let d = new Date(2020, 0, 1);
  d.toString(); // "Wed Jan 01 2020 00:00:00 GMT+0800 (中国标准时间)"
  ```

- 另一个对象转换函数 `valueOf()`
  这个方法的任务并没有太明确的定义,大体上可为认为它是把对象转换为代表对象的原始值(如果存在这样一个原始值)。
  对象是复合值且多数对象不能真正通过一个原始值来表示，因此 `valueOf()` 方法默认情况下只返回对象本身,而非返回原始值。

  - String, Number 和 Boolean 这样的包装类定义的 `valueOf()`方法也只是简单地返回被包装的原始值。
  - Array、 Function 和 RegExp 简单地继承默认方法。在这些类型的实例上调用 `value0f()` 会返回对象本身。
  - Date 对象定义的 `valueOf()` 方法返回日期的内部表示形式: 自 1970 年 1 月 1 日至今的毫秒数:

    ```js
    Let d = new Date(2010, 0, 1);// January 1, 2010,(Pacific time)
    d.valueOf(); // 1262332800000
    ```

**对象到原始值转换算法**
解释完 `toString()` 和 `valueOf()` 方法后,现在可以大致地解释前面三个对象到原的始值转换算法的实现了(完整的细节见 14.4.7<!--TODO--> 节)。

- **偏字符串算法**，首先尝试 `toString()` 方法。

  - 如果这个方法有定义且返回原始值,则 JS 使用该原始值(即使这个值不是字符串)。
  - 如果 `toString()` 不存在，或者存在但返回对象，则 JS 尝试 `valueOf()` 方法。
  - 如果这个方法存在且返回原始值,则 JS 使用该值。否则,转换失败,报 TypeError。

- **偏数值算法**与偏字符串算法类似,只不过是先尝试 `valueOf()` 方法,再尝试 `toString()` 方法。

- **无偏好算法**取决于被转换对象的类
  如果是一个 Date 对象,则 JS 使用偏字符串算法。如果是其他类型的对象,则 JS 使用偏数值算法。

以上规则适用于所有内置 JS 类型,也是所有自定义类的默认规则。14.4.7 <!--TODO--> 解释了如何在自定义类中定义自己的对象到原始值转换算法。

### 3.6 变量声明与赋值

1. `const` 必须在声明时初始化常量。

2. 如果声明位于顶级,在任何代码块外部,则称其为**全局变量**或常量,具有全局作用域。

   - 在 Node 和客户端 JS 模块中(参见第 10 章<!--TODO-->),全局变量的作用域是定义它们的文件。
   - 在传统客户端 JS 中,全局变量的作用域是定义它们的 HTML 文档。
     如果有 `<script>` 标签声明了一个全局变量或常量,则该变量或常量在同一个文档的任何 `<script>` 元素中(或者至少在 `let` 和 `const` 语句执行之后执行的所有脚本中都有定义)

3. `var` 与 `let` 的区别

   - 使用 `var` 声明的变量不具有块作用域。这种变量的作用城仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。

   - 如果在函数体外部使用 `var`,会声明一个全局变量。但通过 `var` 声明的全局变量与通过 `let` 声明的全局变量有一个重要区别。
     通过 `var` 声明的全局变量被实现为全局对象的属性。全局对象可以通过 `globalThis` 引用。
     通过全局 `var` 创建的这个属性不能使用 delete 操作符(见 4.13.4 节<!--TODO-->)删除。

     > 通过 `let` 和 `const` 声明的全局变量和常量不是全局对象的属性。

   - 与通过 `let` 声明的变量不同,使用 `var` 多次声明同名变量是合法的。而且由于 `var` 变量具有函数作用域而不是块作用域，这种重新声明实际上是很常见的。
     变量 i 经常用于保存整数值，特别是经常用作 for 循环的索引变量。在有多个 for 循环的函数中,每个循环通常都以 `for(var i=0;...` 开头。因为 var 并不会把这些变量的作用域限定在循环体内，每次循环都会(无害地)重新声明和重新初始化同一个变量。

   - `var` 声明的一个**最不同寻常的特性**是作用域提升(hoisting)。
     在使用 `var` 声明变量时,该声明会被提高(或提升)到包含函数的顶部。但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。因此对使用 `var` 声明的变量，可以在包含函数内部的任何地方使用而不会报错。
     如果初始化代码尚未运行，则变量的值可能是 undefined，但在初始化之前是可以使用变量而不报错的(这会成为一个 bug 来源,也是 **`Let` 要纠正的一个最重要的错误特性**。如果使用 `let` 声明了一个变量,但试图在 `let` 语句运行前使用该变量则会导致错误,而不是得到 undefined 值)。

### 3.7 解构赋值

ES6 实现了一种复合声明与赋值语法,叫作**解构赋值**(destructuring assignment)。

在解构赋值中,等号右手端的值是数组或对象（“结构化”的值）左手端通过模拟数组或对象字面量语法指定一个或多个变量。在解构赋值发生时,会从右侧的值中提取(解构)出一个或多个值,并保存到左侧列出的变量中。

- 解构赋值可能最常用于在 `const`、`let` 或 `var`声明语句中初始化变量，但也可以在**常规赋值表达式**中使用(给已声明的变量赋值)。解构也可以在**定义函数参数**时使用。

  ```js
  let [x, y] = [1, 2]; // 相当于 let x=1, y=2
  [x, y] = [x + 1, y + 1]; // 相当于 x = x + 1, y = y + 1
  [x, y] = [y, x]; // 交换两个变量的值
  [x, y]; // [3,2]: 递增和交换后的值
  ```

- 解构赋值让**使用返回数组的函数变得异常便捷**

  ```js
  // 将 [x,y] 坐标转换为 [r, theta] 极坐标
  function toPoLar(x, y) {
    return [Math.sqrt(x*x+y*y), Math.atan2(y, x)];
  }

  // 将极坐标转换为笛卡儿坐标
  function toCartesian(r, theta) {
    return [r*Math.cos(theta), r*Math.sin(theta)];
  }

  let [r, theta] = toPolar(1.0, 1.0); // r == Math. sqrt(2); theta == Math PI/4
  let [x,y] = toCartesian(, theta); // [x, y] == [1.0,1,0]
  ```

- 可以在 JS 的各种 for 循环中声明变量和常量。同样也可以**在这个上下文中使用变量解构赋值**。下面这段代码循环遍历了一个对象所有属性的名/值，并使用解构赋值将两个元素的数组转换为单个变量:

  ```js
  let o = { x: 1, y: 2 }; // 要遍历的对象

  for (const [name, value] of object.entries(o)) {
    console.Log(name, value); // 打印"x 1"和"y 2"
  }
  ```

> 解构赋值左侧变量的个数不一定与右侧数组中元素的个数相同。左侧多余的变量会被设置为 undefined，而右侧多余的值会被忽略。

- **左侧的变量列表可以包含额外的逗号，以跳过右侧的某些值**:

  ```js
  let [x, y] = [1] // x == 1; y == undefined
  [x, y] = [1,2,3] // x == 1; y == 2
  [,x,y] = [1,2,3,4] // x == 2; y == 3
  ```

- 在解构赋值时,如果想把所有未使用或剩余的值收集到一个变量中，可以在左侧最后一个变量名前面加上 3 个点(...)

  ```js
  let [x, ...y] = [1, 2, 3, 4]; // y == [2,3,4]
  ```

- **解构赋值可用于嵌套数组**。此时,赋值的左侧看起来也应该像一个嵌套的数组字面量:

  ```js
  let [a, [b, c] = [1, [2, 2.5], 3]; // a == 1; b == 2; c == 2.5
  ```

  **数组解构的一个强大特性是它并不要求必须是数组**！实际上，赋值的右侧可以是任何可迭代对象(参见第 12 章<!--TODO-->)，任何可以在 fo/of 循环(参见 5.4.4 节<!--TODO-->)中使用的对象也可以被解构：

  ```js
  Let [first, ...rest] = "Hello"; // first == "H"; rest == ["e", "l", "l", "o"]

  ```

- 解构赋值在右侧是对象值的情况下也可以执行。此时，赋值的左侧看起来就像一个对象字面量，即一个包含在花括号内的逗号分隔的变量名列表

  ```js
  let transparent = { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }; //一个 RGBA 颜色对象
  let { r, g, b } = transparent; // r == 0.0; g == 0.0; b == 0.0
  ```

  下面这个例子展示了如何把 Math 对象的全局函数复制到变量中，这样可以简化需要大量三角计算的代码:

  ```js
  // 相当于 const sin = Math.sin, cos=Math.cos, tan=Math.tan
  const { sin, cos, tan } = Math;
  ```

  > 注意 : 代码中 Math 对象的属性远远不止解构赋值给个别变量的这 3 个。那些没有提到名字的属性都被忽略了。如果赋值的左侧包含一个不是 Math 属性的变量名,该变量将被赋值 undefined。

在上面每个对象解构的例子中，都选择了与要解构对象的属性一致的变量名。这可以保持语法简单且容易理解，但这并不是必需的。对象解构赋值左侧的每个标识符都可以是一个冒号分隔的标识符对，其中第一个标识符是要解构其值的属性名，第二个标识符是要把值赋给它的变量名：

```js
// 相当于 const cosine= Math.cos, tangent=Math.tan
const { cos: cosine, tan: tangent } = Math;
```

> **如果变量名和属性名不一样，对象解构语法会变得过于复杂，反而导致用处不大。建议不使用简写形式**。如果选择使用,要记住属性名一定是在冒号左侧，无论是在对象字面量中，还是在对象解构赋值的左侧。

在使用嵌套对象、对象的数组，或数组的对象时，解构赋值甚至会变得更复杂，但都是合法的:

```js
let points = [
  { x: 1, y: 2 },
  { x: 3, y: 4 }
]; // 两个坐标点对象的数组
let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = points; //解构到 4 个变量中
x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4; //=>true
```

如果不是解构对象的数组，也可以解构数组的对象：

```js
let points={p1: [1,2],p2: [3,4]}; // 有两个数组属性的对象
let {p1: [x1, y1], p2:[x2,y2]} = points; //解构到 4 个变量中
(×1 === 1 && y1 === 2 && x2 === 3 && y2 === 4) // true
```

类似这样的复杂解构语法既难写又难理解,甚至还不如使用类似 `let x1 = points.p1[0];` 这样的传统代码更简单易懂。

## 四. 表达式与操作符

### 4.1 表达式

[JavaScript#-表达式语句](../JavaScript.md#425-表达式语句)

### 4.2 操作符

下表总结了所有操作符,可以作为一个参考。

> 注意 : 多数操作符都以 `+` 和 `=` 这样的标点符号表示。不过,有一些也以 `delete` 和 `instanceof` 这样的关键字表示。关键字操作符也是常规操作符,与标点符号表示的操作符一样,只不过它们的语法没那么简短而已。

下表按操作符优先级组织。

- 表格前面的操作符比后面的操作符优先级更高。
- “结合性”中的“左”表示“从左到右执行”，“右”表示“从右到左执行”。
- “操作数”表示操作数的个数。
- “类型”表示操作数的类型，以及操作符的结果类型(`→` 后面)。

| 操作符                                                      | 操作                                           | 结合性 | 操作数 | 类型                 |
| ----------------------------------------------------------- | ---------------------------------------------- | ------ | ------ | -------------------- |
| ++                                                          | 先或后递增                                     | 右     | 1      | lval → num           |
| --                                                          | 先或后递减                                     | 右     | 1      | lval → num           |
| -                                                           | 负值                                           | 右     | 1      | num → num            |
| +                                                           | 转换为数值                                     | 右     | 1      | any → num            |
| ~                                                           | 反转二进制位                                   | 右     | 1      | int → int            |
| !                                                           | 反转布尔值                                     | 右     | 1      | bool → bool          |
| delete                                                      | 删除属性                                       | 右     | 1      | lval → bool          |
| typeof                                                      | 确定操作数类型                                 | 右     | 1      | any → str            |
| void                                                        | 返回 undefined                                 | 右     | 1      | any → undef          |
| \*\*                                                        | 幂                                             | 右     | 2      | num,num → num        |
| \*、/、%                                                    | 乘、除、取余                                   | 左     | 2      | num,num → num        |
| +、-                                                        | 加、减                                         | 左     | 2      | num,num → num        |
| +                                                           | 拼接字符串                                     | 左     | 2      | str, str → str       |
| <<                                                          | 左移位                                         | 左     | 2      | int,int → int        |
| >>                                                          | 右移位以符号填充                               | 左     | 2      | int,int → int        |
| >>>                                                         | 右移位以零填充                                 | 左     | 2      | int,int → int        |
| <、<=、>、>=                                                | 按数值顺序比较                                 | 左     | 2      | num,num → bool       |
| <、<=、>、>=                                                | 按字母表顺序比较                               | 左     | 2      | str,str → bool       |
| instanceof                                                  | 测试对象类                                     | 左     | 2      | obi,func → bool      |
| in                                                          | 测试属性是否存在                               | 左     | 2      | any,obj → bool       |
| ==                                                          | 非严格相等测试                                 | 左     | 2      | any,any → bool       |
| !=                                                          | 非严格不相等测试                               | 左     | 2      | any,any → bool       |
| ===                                                         | 严格相等测试                                   | 左     | 2      | any,any → bool       |
| !==                                                         | 严格不相等测试                                 | 左     | 2      | any,any → bool       |
| &                                                           | 计算按位与                                     | 左     | 2      | int,int → int        |
| ^                                                           | 计算按位异或                                   | 左     | 2      | int,int → int        |
| 竖杠                                                        | 计算按位或                                     | 左     | 2      | int,int → int        |
| &&                                                          | 计算逻辑与                                     | 左     | 2      | any,any → any        |
| 双竖杠                                                      | 计算逻辑或                                     | 左     | 2      | any,any → any        |
| ??                                                          | 选择第一个有定义的操作数，非 null 或 undefined | 左     | 2      | any, any → any       |
| ? :                                                         | 选择第二或第三个操作数                         | 右     | 3      | bool, any, any → any |
| =                                                           | 为变量或属性赋值                               | 右     | 2      | lval,any → any       |
| \*_=、_=、/=、%=、+=、-=、&=、^=、 竖杠等于、<<=、>>=、>>>= | 操作并赋值                                     | 右     | 2      | lval,any → any       |
| ,                                                           | 丢弃第一个操作数，返回第二个                   | 左     | 2      | any, any → any       |

> 注意 : 表中列出的赋值操作符和少数其他操作符期待操作数类型为 `lval`。`lval` 即 lvalue（左值），是一个历史悠久的术语，意思是“一个可以合法地出现在赋值表法式左侧的表达式”。在 JS 中，变量、对象属性和数组元素都是“左值”

#### 4.2.1 操作符优先级

**JS 新增的操作符并不总是符合上表这个优先级模式**。比如在表中 [`??` 操作符](#471-空值合并运算符) `||` 和 `&&` 优先级低，而实际上它相对于这两个操作符的优先级并没有定义。

ES2020 要求在混用 `??`和 `||` 或 `&&` 时使用必须使用圆括号。类似地，新的幂操作符 `**` 相对于一元负值操作符的优先级也没有明确定义，因此在同时求负值和求幂时也必须使用圆括号。

#### 4.2.2 求值顺序

操作符的优先级和结合性规定了复杂表达式中操作的执行顺序，但它们没有规定子表达式的求值顺序。**JS 始终严格按照从左到右的顺序对表达式求值**。

例如，在表达式 `w = x + y * z` 中，子表达式 w 首先被求值，再对 x、y 和 z 求值。然后将 y 和 z 相乘，加到 x 上，再把结果赋值给表达式 w 表示的变量或属性。在表达式中使用圆括号改变乘法、加法和赋值的相对顺序，但不会改变从左到右的求值顺序。

**求值顺序只在一种情况下会造成差异，即被求值的表达式具有副效应**，这会影响其他表达式的求值。比如，表达式 x 递增一个变量，而表达式 z 会使用这个变量，此时保证 x 先于 z 被求值就很重要了。

### 4.3 算术表达式

基本的算术操作符是 `**`(幂)、`*`(乘)、`/`(除)、`%`(模：除后的取余)、`+`(加) 和 `-`(减)。

#### 4.3.1 + 操作符

严格来讲，`+` 操作符的行为如下所示：

- 如果有一个**操作数是对象**，则 `+` 操作符使用[对象到原始值](#342-对象到原始值转换)的算法把该操作数转换为原始值。Date 对象用 `toString()` 方法来转换，其他所有对象通过 `valueOf()` 转换(如果这个方法返回原始值)。不过，多数对象并没有 `valueOf()` 方法，因此它们也会通过 `toString()` 方法转换。

- 完成对象到原始值的转换后，如果有操作数是字符串，另一个操作数也会被转换为字符串进行拼接。

- 否则，两个操作数都被转换为数值（或 NaN），计算加法。

#### 4.3.2 一元算术操作符

一元操作符有： `+`、`-`、`++`、`--`。在 JS 中，**一元操作符全部具有高优先级和右结合性**。

> 注意：`+` 和 `-`，既是一元操作符，也是二元操作符。

### 4.4 关系表达式

#### 4.4.1 严格相等

严格相等操作符 `===` 求值其操作数，然后按下列步骤比较两个值，不做类型转换。

- 如果两个值类型不同，则不相等。

- 如果两个值都是 null 或都是 undefined，则相等。

- 如果两个值都是布尔值 true 或都是布尔值 false，则相等。

- 如果一个或两个值是 NaN，则不相等(NaN 确实不等于任何值，也包括 NaN 自身！要检查某个值 ⅹ 是不是 NaN，使用 `x !== x` 或全局 `isNaN()` 函数)。

- 如果两个值都是数值且值相同，则相等。如果一个值是 0 而另一个是-0，则也相等。

- 如果两个值都是字符串且相同位置包含完全相同的 16 位值，则相等。
  如果两个字符串长度或内容不同，则不相等。两个字符串有可能看起来相同，也表示同样的意思，但底层编码却使用不同的 16 位值序列。 JS 不会执行 Unicode 归一化操作，像这样的两个字符串用 `===` 或 `==` 操作符都不会判定相等。

- 如果两个值引用同一个对象、数组或函数，则相等。如果它们引用不同的对象，即使两个对象有完全相同的属性，也不相等。

#### 4.4.2 比较操作符

比较和转换规则如下：

- 如果有操作数求值为对象，该对象会按照[对象到原始值转换](#342-对象到原始值转换)的算法被转换为原始值。即如果它的 `valueOf()` 方法返回原始值，就使用这个值，否则就使用它的 `toString()` 方法返回的值。

- 如果在完成对象到原始值的转换后两个操作数都是字符串，则使用字母表顺序比较这两个字符串，其中“字母表顺序”就是组成字符串的 16 位 Unicode 值的数值顺序。

- 如果在完成对象到原始值的转换后至少有一个操作数不是字符串，则两个操作数都会被转换为数值并按照数值顺序来比较。
  0 和 -0 被认为相等。Infinity 比它本身之外的任何数都大，-Infinity 比它本身之外的任何数都小。如果有一个操作数是(或转换后是)NaN，则这些比较操作符都返回 false。

  > 虽然算术操作符不允许 BigInt 值与常规数值混用，但比较操作符允许数值与 BigInt 进行比较。

JS 字符串是 16 位整数值的序列，而字符串比较就是比较两个字符串的数值序列。Unicode 定义的这个数值编码顺序不一定与特定语言或地区使用的传统校正顺序(collation order)匹配。

> 注意 : 字符串比较是区分大小写的，而**所有大写 ASCII 字母比所有小写 ASCII 字母都小**。如果不留意，这条规则很可能导致令人不解的结果。例如，根据 `<` 操作符，字符串 “Zoo” 会排在字符串 “aardvark” 前面。

如果需要**更可靠的字符串比较算法，可以用 `String.localeCompare()` 方法**，这个方法也会考虑特定地区的字母表顺序。

要执行不区分大小写的比较，可以使用 `String.toLowerCase()` 或 `String.toUpperCase()` 把字符串转换为全小写或全大写。

如果需要更通用和更好的本地化字符串比较工具，可以使用 11.7.3 节介绍的 `Intl.Collator`<!--TODO Intl.ColLator--> 类。

`+` **操作符和比较操作符同样都会对数值和字符串操作数区别对待**。

- `+` 偏向字符串，即只要有一个操作数是字符串，它就会执行拼接操作。

- 比较操作符偏向数值，只有两个操作数均为字符串时才按字符串处理。

> 注意：
> `<=`(小于或等于)和 `>=`(大于或等于)操作符不依赖相等或严格相等操作符确定两个值是否“相等”。
> 其中，小于或等于操作符只是简单地定义为“不大于”，而大于或等于操作符则定义为“不小于”。
> 还有例外情形，即只要有操作数是(或可以转换为) NaN，则全部 4 个比较操作符都返回 false。

#### 4.4.3 in 操作符

如果指定的属性在指定的对象或其原型链中，则 `in` 运算符返回 true。

`in` 操作符期待左侧操作数是字符串、符号或可以转换为字符串的值，期待右侧操作数是对象。

```js
let point = { x: 1, y: 1 };
'x' in point; // true：对象有名为 "x" 的属性
'z' in point; // false：对象没有名为 "z" 的属性
'toString' in point; // true：对象的继承了 toString 方法

let data = [8, 0, 1];
'0' in data; // true
1 in data; // true
5 in data; // false：没有元素 5
```

#### 4.4.4 instanceof 操作符

**`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上**。

`instanceof` 操作符期待左侧操作数是对象，右侧操作数是对象类的标识。这个操作符在左侧对象是右侧类的实例时求值为 true，否则求值为 false。

第 9 章<!--TODO 对象类-->解释了，在 JS 中，对象类是通过初始化它们的构造函数定义的。因而，`instanceof` 的右侧操作数应该是一个函数。

```js
let d = new Date(); // 通过 Date() 构造函数创建一个新对象
d instanceof Date; // true: d 是通过 Date() 创建的
d instanceof Object; // true: 所有对象都是 Object 的实例
d instanceof Number; // false: d 不是 Number 对象

let a = [1, 2, 3]; // 通过数组字面量语法创建一个数组
a instanceof Array; // true: a 是个数组
a instanceof Object; // true: 所有数组都是对象
a instanceof RegExp; // false: 数组不是正则表达式
```

> 注意：
> 所有对象都是 Object 的实例。`instanceof` 在确定对象是不是某个类的实例时会考虑“超类”。
> 如果 instanceof 的左侧操作数不是对象，它会返回 false。如果右侧操作数不是对象的类，它会抛出 TypeError。

要理解 instanceof 的工作原理，必须理解“原型链”。原型链是 JS 的继承机制，6.3.2 节<!--TODO 原型链-->有详细介绍。

为了对表达式 `o instanceof f` 求值，JS 会求值 `f.prototype`，然后在 `o` 的原型链上查找这个值。如果找到了，则 o 是 f(或 f 的子类)的实例，`instanceof` 返回 true。如果 `f.prototype` 不是 o 原型链上的一个值，则 o 不是 f 的实例，`instanceof` 返回 false。

### 4.5 逻辑表达式

#### 4.5.1 逻辑与 (&&)

`&&` 操作符首先对它左边的表达式求值，如果左边的值是假值，则整个表达式的值也一定是假值，因此 `&&` 返回它左侧的值，不再求值它右侧的表达式。

另一方面，如果 `&&` 左侧的值是真值，则整个表达式的值取决于右侧的值。如果右侧的值是真值，则整个表达式的值一定是真值;如果右侧的值是假值，则整个表达式的值一定是假值。因此，在左侧的值为真值时， `&&`操作符求值并返回它右侧的值:

```js
let o = { x: 1 };
let p = null;
o && o.x; // 1: o 是真值，因此返回 o.x 的值
p && p.x; // null: p是假值，因此返回它，不对p，x求值
```

#### 4.5.2 逻辑或 (||)

`||` 的习惯用法是在一系列备选项中选择第一个真值：

```js
let max = maxWidth || preferences.maxWidth || 500;
```

> 注意：如果 `0` 是 maxWidth 的有效值，则以上代码可能有问题，因为 0 是一个假值。此时可以使用 [`??` 操作符](#471-空值合并运算符)。

#### 4.5.3 逻辑非 (!)

作为医院操作符，`!` 操作符优先级较高。如果想反转表达式 p && q 的值，需要使用圆括号：`!(p && q)`。

可以通过如下 JS 语法来表达布尔代数的两个法则：

```js
// 德摩根定律
!(p && q) === (!p || !q); // true：p 和 q 可以是任何值
!(p || q) === (!p && !q); // true
```

### 4.6 赋值表达式

`=` 操作符期待其左侧操作数是一个左值，即变量或对象属性或数组元素。它期待右侧操作数是任意类型的任意值。赋值表达式的值是右侧操作数的值。

可以像下面这样在同一个表达式中赋值并测试这个值：

```js
(a = b) === 0;
```

> **注意** : **`=` 的优先级很低**，在较大的表达式中使用赋值的值通常需要使用圆括号。

赋值操作符**具有右结合性**，这意味着如果一个表达式中出现多个赋值操作符，它们会从右向左求值。因此，可以通过如下代码将一个值赋给多个变量:

```js
i = j = k = 0; // 把 3 个变量都初始化为 0
```

### 4.7 其他操作符

#### 4.7.1 空值合并运算符 (??)

`??` 求值其先定义的操作数，如果其左操作数不是 null 或 undefined，就返回该值。否则，它会返回右操作数的值。

与 `&&` 或 `||` 操作符类似，`??` 是短路的: 它只在第一个操作数求值为 null 或 undefined 时才会求值二个操作数。表达式 `a ?? b` 等价于:

```js
(a !== null) & (a !== undefined) ? a : b;
```

`??` 是对 `||` 的一个有用的替代，适合选择先定义的操作数，而不是第一个为真值的操作数。

`??` 操作符与 `&&` 和 `||` 操作符类似，但优先级并不比它们更高或更低。如果表达中混用了 `??` 和它们中的任何一个，必须使用圆括号说明先执行哪个操作。

#### 4.7.2 typeof 操作符

typeof 是个一元操作符，放在自己的操作数前面，这个操作数可以是任意类型。typeof 操作符的值是一个字符串，表明操作数的类型。

下表列出了所有 JS 值在应用 typeof 操作符后得到的值：

| x              | typeof x    |
| -------------- | ----------- |
| undefined      | "undefined" |
| null           | "object"    |
| true 或 false  | "boolean"   |
| 任意数值或 NaN | "number"    |
| 任意 BigInt    | "bigint"    |
| 任意字符串     | "string"    |
| 任意符号       | "symbol"    |
| 任意函数       | "function"  |
| 任意非函数对象 | "object"    |

可以像下面这样在表达式中使用 typeof 操作符:

```js
// 如果 value 是字符串，把它包含在引号中，否则把它转换为字符串
typeof value === 'string' ? "'" + value + "'" : value.toString();
```

> **注意**：
>
> 1. 如果操作数的值是 null， typeof 返回 “object”。如果想区分 null 和对象，必项显式测试这个特殊值。
> 2. 尽管 JS 函数是一种对象， typeof 操作符也认为函数不一样，因为它们有自己的返回值。
> 3. 因为对除函数之外的所有对象和数组值， typeof 都求值为 “object"，所以**可以只用它来区分对象和其他原始类型。而要区分不同对象的类，必须使用其他方法**，例如 [instanceof 操作符](#444-instanceof-操作符)、 class 特性(参见 <!--TODO 14.4.3 节)，或者 constructor 属性(参见 9.22 节和 14.3 节)-->。

#### 4.7.3 delete 操作符

delete 是一元操作符，尝试删除其操作数指定的对象属性或数组元素。

```js
let o = { x: 1, y: 2 }; //先定义一个对象
delete o.x; // 删除它的属性
"x" in o // false: 这个属性不存在了

let a = [1,2,3]; // 定义一个数组
delete a[2]: // 删除数组的最后一个元素
2 in a // false: 数组元素 2 不存在了
a.length // 5: 但要注意,数组长度没有变化
```

> 注意：被删除的属性或数组元素不仅会被设置为 undefined 值。当删除一个属性时，这个属性就不复存在了。尝试读取不存在的属性会返回 undefined，但可以通过 [`in` 操作符](#443-in-操作符)测试某个属性是否存在。删除某个数组元素会在数组中留下一个“坑”，并不改变数组的长度。结果数组是一个稀疏数组(参见 <!-- TODO 7.3 节 -->)。

delete 期待它的操作数是个左值。如果操作数不是左值， delete 什么也不做，且返回 true。否则，delete 尝试删除指定的左值。如果删除成功则返回 true。但是并非所有属性都是可以删除的: 不可配置属性(参见 <!--TODO 14.1 节-->)就无法删除。

在严格模式下， delete 的操作数如果是未限定标识符，比如变量、函数或函数参数，就会导致 Syntax Error.。此时，delete 操作符只能作用于属性访问表达式。

严格模式也会在 delete 尝试删除不可配置(即不可删除)属性时抛出 TypeError。但在严格模式之外，这两种情况都不会发生异常，delete 只是简单地返回 false，表示不能删除操作数。

下面是几个使用 delete 操作符的例子

```js
let o= {x:1,y:2}
delete o x; // 删除对象的一个属性: 返回 true
typeof o.x; // 属性不存在: 返回 "undefined"
delete o.x; // 删除不存在的属性: 返回 true
delete 1 // 这样做毫无意义,但会返回 true

// 不能删除变量，返回 false,或在严格模式下报 SyntaxError
delete o
// 不可删除的属性: 返回 false，或在严格模式下报 TypeError
delete Object. prototype
```

#### 4.7.4 await 操作符

`await` 是 ES2017 增加的，**用于让 JS 中的异步编程更自然**。

简单来说，`await` 期待一个 Promise 对象(表示异步计算)作为其唯一操作数，可以让代码看起来像是在等待异步计算完成(但实际上它不会阻塞主线程，不会妨碍其他异步操作进行)。

`await` 操作符的值是 Promise 对象的兑现值。关键在于，**`await` 只能出现在已经通过 `async` 关键字声明为异步的函数中**。要了解完整的细节，参见第 <!--TODO 13 --> 章。

## 五. 语句

[JavaScript#-表达式语句](../JavaScript.md#424-语句)

## 六. 对象

### 6.1 对象简介

对象是一种复合值，它汇聚多个值（原始值或其他对象）并允许按名字存储和获取这些值。对象是一个属性的无序集合，每个属性都有名字和值。属性名通常是字符串（也可以是符号，参见<!--TODO-->6.10.3 节），因此可以说对象把字符串映射为值。

这种字符串到值的映射曾经有很多种叫法，包括 “散列” “散列表” “字典” 或 “关联数组” 等熟悉的基本数据结构。不过，对象不仅仅是简单的字符串到值的映射。除了维持自己的属性之外， JS 对象也可以从其他对象继承属性，这个其他对象称为其“原型”。

**对象的方法通常是继承来的属性，而这种“原型式继承”也是 JS 的主要特性**。

JS 对象是动态的，即可以动态添加和删除属性。不过，可以用对象来模拟静态类型语言中的静态对象和“结构体”。对象也可以用于表示一组字符串（忽略字符串到值的映射中的值）。

> 在 JS 中，任何不是字符串、数值、符号或 true、 false、null、 undefined 的值都是对象。即使字符串、数值和布尔值不是对象，它们的行为也类似不可修改的对象。

对象是可修改的，是按引用操作而不是按值操作的。如果变量 x 指向一个对象，则代码 `let y = x;` 执行后，变量 y 保存的是同一个对象的引用，而不是该对象的副本。通过变量 y 对这个对象所做的任何修改，在变量 x 上都是可见的。

有时候，区分直接定义在对象上的属性和那些从原型对象上继承的属性很重要。JS 使用术语“自有属性”指代非继承属性。

除了名字和值之外，每个属性还有 3 个属性特性（property attribute）

- **writable**（可写）：指定是否可以设置属性的值。
- **enumerable**（可枚举）：指定是否可以在 for/in 循环中返回属性的名字。
- **configurable**（可配置）：指定是否可以删除属性，以及是否可修改其特性。

很多 JS 内置对象拥有只读、不可枚举或不可配置的属性。不过，默认情况下，所创建对象的所有属性都是可写、可枚举和可配置的。

### 6.2 创建对象

对象可以通过：

- 对象字面量
- `new` 关键字
- `Object.create()` 函数来创建

#### 6.2.1 对象字面量

创建对象最简单的方式是在 JS 代码中直接包含对象字面量。对象字面量的最简单形式是包含在一对花括号中的一组逗号分隔的 “名:值” 对。属性名是 JS 标识符或字符串字面量（**允许空字符串**）。属性值是任何 JS 表达式，这个表达式的值（可以是原始值或对象值）会变成属性的值。

```js
let empty = {}; // 没有属性的对象
let point = { x: 0, y: 0 }; // 包含两个数值属性
let p2 = { x: point.x, y: point.y + 1 }; // 值比较复杂
let book = {
  'main title': 'JavaScript', // 属性名包含空格
  'sub-title': 'The Definitive Guide', // 和连字符,因此使用字符串字面量对象
  for: 'all audiences', // for 是保留字，但没有引号
  // 这个属性的值本身是一个对象
  author: {
    firstname: 'David',
    surname: 'Flanagan'
  }
};
```

对象字面量是一个表达式，每次求值都会创建并初始化一个新的、不一样的对象。字面量每次被求值的时候，它的每个属性的值也会被求值。这意味着同一个对象字面量如果出现在循环体中，或出现在被重复调用的函数体丙，可以创建很多新对象，且这些对象属性的值可能不同。

#### 6.2.2 使用 new 创建对象

`new` 操作符用于创建和初始化一个新对象。**new 关键字后面必须跟一个函数调用。以这种方式使用的函数被称为构造函数**（constructor），目的是初始化新创建的对象。JS 为内置的类型提供了构造函数。例如:

```js
let o = new Object(); // 创建一个空对象，与 {} 相同
let a = new Array(); // 创建一个空数组，与 [] 相同
let d = new Date(); // 创建一个表示当前时间的日期对象
let r = new Map(); // 创建一个映射对象，用于存储键/值映射
```

除了内置的构造函数，实践中经常需要定义自己的构造函数来初始化新创建的对象。相关内容将在第 9 章<!--TODO-->介绍。

#### 6.2.3 原型

**在学习 `Object.create()` 函数前，必须先了解原型。几乎每个 JS 对象都有另一个与之关联的对象。这另一个对象被称为原型（prototype）**，第一个对象从这个原型继承属性。

通过对象字面量创建的所有对象都有相同的原型对象，在 JS 代码中可以通过 `Object.prototype` 引用这个原型对象。

`new` 关键字和构造函数调用创建的对象使用构造函数 `prototype` 属性的值作为它们的原型。换句话说，使用 `new Object()` 创建的对象继承自 `Object.prototype`，与通过 `{}` 创建的对象一样。

> 几乎所有对象都有原型,但只有少数对象有 `prototype` 属性。正是这些有 `prototype` 属性的对象为所有其他对象定义了原型。

`Object.prototype` 是为数不多的没有原型的对象，因为它不继承任何属性。其他原型对象都是常规对象，都有自己的原型。多数内置构造函数（和多数用户定义的构造函数）的原型都继承自 `Object.prototype`。

`Date.prototype` 从 `Object.prototype` 继承属性,因此通过 `new Date()` 创建的日期对象从 `Date.prototype` 和 `Object.prototype`继承属性。**这种原型对象链接起来的序列被称为原型链**。

6.3.2 节将介绍属性继承的原理。第 9 章会更详细地解释原型与构造函数之间的联系，将展示如何定义新的对象类，包括编写构造函数以及将其 `prototype` 属性设置为一个原型对象，让通过该构造函数创建的“实例”继承这个原型对象的属性。另外,14.3 节还将介绍如何查询(甚至修改)一个对象的原型。<!--TODO-->

#### 6.2.4 `Object.create()`

- `Object.create()` 用于创建一个新对象，使用其第一个参数作为新对象的原型:

  ```js
  let o1 = Object.create({ x: 1, y: 2 }); // o1 继承属性 x 和 y
  o1.x + o1.y; // 3
  ```

- 传入 `null` 可以创建一个没有原型的新对象。不过，这样创建的新对象不会继承任何东西，连 `toString()` 这种基本方法都没有（意味着不能对该对象应用 `+` 操作符）:

  ```js
  let o2 = Object.create(null); // 不继承任何属性或方法
  ```

- 如果想创建一个普通的空对象（类似或 `new Object()` 返回的对象）,传入 `Object.prototype`:

  ```js
  let o3 = Object.create(object.prototype); // o3 与 {} 或 new Object() 类似
  ```

- `Object.create()` 还可接收可选的第二个参数，用于描述新对象的属性。这个参数属于高级特性，将在 14.1 节介绍<!--TODO-->。

**防止意外修改**
`Object.create()` 的一个用途是防止对象被某个第三方库函数意外(但非恶意)修改。这种情况下，不要直接把对象传给库函数，而要传入一个继承自它的对象。如果函数读取这个对象的属性，可以读到继承的值。而如果它设置这对象的属性，则修改不会影响原始对象。

```js
let o = { x: 'todo list' };
library.function(Object.create(o)); // 防止意外修改
```

> 要理解其中的原理需要知道 JS 中属性查询和设置的过程。

### 6.3 查询和设置属性

要获得一个属性的值，可以使用 点（`.`）或方括号（`[]`）操作符。左边应该是一个表达式，其值为一个对象。

- 如果使用点操作符，右边必须是一个命名属性的简单标识符。

- 如果使用方括号，方括号中的值必须是一个表达式，其结果为包含目的属性名的字符串或一个可以转换为字符串或符号的值。

```js
let author = book.author;
let surname = book['surname'];
```

要创建或设置属性，与查询属性一样，可以使用点或方括号，只是要把它们放到赋值表达式的左边：

```js
book.edition = 7;
book['author'] = 'tom';
```

#### 6.3.1 作为关联数组的对象

下面两个 JS 表达式的值相同：

```js
object.property
object['property]
```

第一种语法使用点和标识符，与在 C 或 Java 中访问结构体或对象的静态字段的语法类似。

第二种语法使用方括号和字符串，看起来像访问数组，只不过是以字符串而非数值作为索引的数组。这种数组也被称为关联数组（或散列、映射、字典）。**JS 对象是关联数组**。

在使用点（`.`）操作符访问对象的属性时，属性名是通过标识符来表示的。标识符必须直接书写在 JS 程序中，它们不是一种数据类型，因此不能被程序操作。

在通过方括号（`[]`）这种数组表示法访问对象属性时，属性名是通过字符串来表示的。字符串是一种 JS 数据类型，因此可以在程序运行期间修改和创建，例如：

```js
let addr = '';
for (let i = 0; i < 4; i++) {
  addr += customer[`address${i}`] + '\n';
}
```

#### 6.3.2 继承

JS 对象有一组“自有属性”，同时也从它们的原型对象继承一组属性。要理解这一点，必须更详细地分析属性存取。

可以使用 `Object.create()` 函数以指定原型来创建对象。也可以通过 new 创建一个类的实例（第 九 章<!--TODO-->）,这两个都会创建从某个原型对象继承属性的对象。

假设要从对象 `o` 中查询属性 `x`。如果 `o` 没有 `x` 这个自有属性，则会从 `o` 的原型对象查询属性 `x`。如果原型对象也没有叫这个名字的自有属性，但它有自己的原型，则会继续查询这个原型的原型。这个过程一直持续，直至找到属性 `x` 或者查询到一个原型为 null 的对象。可见，对象通过其 `prototype` 属性创建了一个用于继承属性的链条或链表。

> 几乎所有对象都有原型，但大多数对象没有 `prototype` 属性。即便不能通过代码直接访对象的原型, JS 继承机制仍然照常运作。要了解背后的细节,可以参考 14.3 节<!--TODO-->。

```js
let o = {}; // o 从 Object.prototype 继承对象方法
o.x = 1; // 现在有自有属性 x

let p = Object.create(o); // p 从 o 和 Object.prototype 继承属性
p.y = 2; // 而且有一个自有属性 y

let q = Objet.create(p); // q 从 p、o 和 Object.prototype 继承属性
q.z = 3; // 且有一个自有属性 z

let f = q.toString(); // toString 继承自 Object.prototype
q.x + q.y; // 3: x 和 y 分别继承自 o 和 p
```

现在为对象 `o` 的 `y` 属性赋值。如果 `o` 有一个名为 `x` 的自有(非继承)属性，这次赋值就会修改已有 `x` 属性的值。否则，这次赋值会在对象 `o` 上创建一个名为 `x` 的新属性。

如果 `o` 之前继承了属性 `x`，那么现在这个**继承的属性会被新创建的同名属性隐藏**。

**属性赋值査询原型链只为确定是否允许赋值**。如果 `o` 继承了一个名为 `x` 的只读属性，则不允许赋值。不过，如果允许赋值则只会在原始对象上创建或设置属性，而**不会修改原型链中的对象**。

**查询属性时会用到原型链，而设置属性时不影响原型链是一个重要的 JS 特性**，利用这一点，可以选择性地覆盖继承的属性:

```js
let unitcircle = { r: 1 }; // c 继承的对象
let c = Object.create(unitcircle); // c 继承了属性
c.x = 1;
c.y = 1; // c 定义了两个自有属性

c.r = 2; // c 覆盖了它继承的属性

unitcircle.r; // 1: 原型不受影响
```

> **注意**：
>
> 属性赋值要么失败要么在原始对象上创建或设置属性的规则有一个**例外**:
> 如果 `o` 继承了属性 `x`，而该属性是一个通过设置方法定义的访问器属性(参见 6.10.6<!--TODO-->)，那么就会调用该设置方法而不会在 `o` 上创建新属性 `x`。
> 要注意，此时会在对象 `o` 上而不是在定义该属性的原型对象上调用设置方法。因此如果这个设置方法定义了别的属性，那也会在定义同样的属性，但仍然不会修改原型链。

#### 6.3.3 属性访问错误

属性访问表达式并不总是会返回或设置值。

査询不存在的属性不是错误。如果在 `o` 的自有属性和继承属性中都没找到属性 `x`，则属性访问表达式 `o.x` 的求值结果为 `undefined`。例如，book 对象有一个 "sub-title" 属性，没有 "subtitle" 属性：

```js
book.subtitle; // undefined: 属性不存在
```

然而，查询不存在对象的属性则是错误。因为 null 和 undefined 值没有属性，查询这两个值的属性是错误。继续前面的示例

```js
let len = book.subtitle.length; // TypeError: undefined 没有 length 属性
```

如果 `.` 的左边是 `null` 或 `undefined`，则属性访问表达式会失败。因此在写类似 `book.author.surname` 这样的表达式时，要确保 book 和 book.author 是有定义的。以下是两种防止这类问题的写法:

```js
// 简单但麻烦的技术
let surname = undefined;
if (book) {
  if (book.author) {
    surname = book.author.surname;
  }
}

// 取得 surname、null 或 undefined 的简洁的惯用技术
surname = book && book.author && book.author.surname;
```

ES2020 还可以通过 `?.` 支持条件式属性访问，用它可以把前面的赋值表达式改写成:

```js
let surname = book?.author?.surname;
```

尝试在 null 或 undefined 上设置属性也会导致 TypeError。而且，尝试在其他值上设置属性也不总是会成功，因为有些属性是只读的，不能设置，而有些对象不允许添加新属性。在严格模式下，只要尝试设置属性失败就会抛出 TypeError。在非严格模式下，这些失败通常是静默失败。

尝试在对象 `o` 上设置属性 p 在以下情况下会失败。

- `o` 有一个只读自有属性 p: **不可能设置只读属性**。
- `o` 有一个只读继承属性 p: **不可能用同名自有属性隐藏只读继承属性**。
- `o` 没有自有属性 `p`，`o` 没有继承通过设置方法定义的属性 `p`,`o` 的 `extensible` 特性(参见 14.2 节)是 false。因为 `p` 在 `o` 上并不存在，如果没有要调用的设置方法，那么 `p` 必须要添加到 `o` 上。但如果 `o` 不可扩展(`extensible` 为 false)，则不能在它上面定义新属性。

### 6.4 删除属性

delete 操作符用于从对象中移除属性。它唯一的操作数应该是属性访问表达式。**delete 并不操作属性的值，而是操作属性本身**:

```js
delete book.author; // book 对象现在没有 author 属性了
delete book['main title']; // book 对象也没有 "main title" 属性了
```

**delete 操作符只删除自有属性，不删除继承属性**（要删除继承属性，必须从定义属性的原型对象上删除。这样做会影响继承该原型的所有对象）。

如果 delete 操作成功或没有影响（如删除不存在的属性），则 delete 表达式求值为 true。对非属性访问表达式（无意义地）使用 delete，同样也会求值为 true：

```js
let o = { x: 1 }; // o 有自有属性 x 和继承属性 toString
delete o.x; // true: 删除属性 x
delete o.x; // true: 什么也不做(x 不存在)但仍然返回 true
delete o.toString; // true: 什么也不做（toString 不是自有属性）
delete 1; // true：无意义，但仍然返回 true
```

delete 不会删除 `configurable` 特性为 false 的属性。与通过变量声明或函数声明创建的全局对象的属性一样，某些内置对象的属性也是不可配置的。在严格模式下，尝试删除不可配置的属性会导致 TypeError。在非严格模式下, delete 直接求值为 false:

```js
// 在严格模式下，以下所有删除操作都会抛出 TypeError，而不是返回 false
delete Object.prototype; // false: 属性不可配置
var x = 1; // 声明一个全局变量
delete globalThis.x; // false: 不能删除这个属性
function f() {} // 声明一个全局函数
delete globalThis.f; // false: 不能删除这个属性
```

**删除全局对象可配置的属性**:

- 在非严格模式下，可以省略对全局对象的引用，只在 delete 操作符后面加上属性名:

  ```js
  globalThis.x = 1; // 创建可配置的全局属性(没有 let 或 var)
  delete x; // true: 这个属性可以删除
  ```

- 在严格模式下，如果操作数是一个像 x 这样的非限定标识符，delete 会抛出 Syntax Error，即必须写出完整的属性访问表达式:

  ```js
  delete x; //在严格模式下报 SyntaxError
  delete globalThis.x; //这样可以
  ```

### 6.5 测试属性

JS 对象可以被想象成一组属性，实际开发中经常需要测试这组属性的成员关系，即检查对象是否有一个给定名字的属性。为此，可以使用:

- `in` 操作符
- `hasOwnProperty()`
- `propertyIsEnumerable()`
- 或者直接查询相应属性

下面的示例都使用字符串作为属性名，但这些示例也适用于符号属性(参见 6.10.3 节<!--TODO-->)。

`in` 操作符要求左边是一个属性名，右边是一个对象。如果**对象有包含相应名字的自有属性或继承属性，将返回 true**:

```js
let o = { x: 1 };
'x' in o; // true: o 有自有属性 "x"
'y' in o; // false: o 没有属性"y"
'toString' in o; //=>true: o 继承了 toString 属性
```

对象的 `hasOwnProperty()` 方法**用于测试对象是否有给定名字的属性。对继承的属性，它返回 false**:

```js
let o = { x: 1 };
o.hasOwnProperty('x'); // true: o 有自有属性 X
o hasOwnProperty('y'); // false: o 没有属性 y
o.hasOwnProperty('toString'); // false: toString 是继承属性
```

`propertyIsEnumerable()` 方法细化了 `hasOwnProperty()` 测试。如果**传入的命名属性是自有属性且这个属性的 `enumerable` 特性为 true，这个方法会返回 true**。某些内置属性是不可枚举的。

> 使用常规 JS 代码创建的属性都是可枚举的，除非使用 14.1 节的技术将它们限制为不可枚举。<!--TODO-->

```js
let o = { x: 1 };
o.propertyIsEnumerable('x'); // true: o 有一个可枚举属性 x
o.propertyIsEnumerable('toString'); // false: toString不是自有属性
Object.prototype.propertyIsEnumerable('toString'); // false: toString 不可枚举
```

除了使用 `in` 操作符，通常简单的属性查询配合 `!==` 确保其不是未定义的就可以了：

```js
let o = { x: 1 };
o.x !== undefined; // true: o 有属性 x
o.y !== undefined; // false: o 没有属性 y
o.toString !== undefined; // true: o 继承了 tostring 属性
```

但有一件事 `in` 操作符可以做，而简单的属性访问技术做不到。**`in` 可以区分不存在的属性和存在但被设置为 undefined 的属性**。来看下面的代码:

```js
let o = { x: undefined }; // 把属性显式设置为 undefined
o.x !== undefined; // false: 属性 x 存在但值是 undefined
o.y !== undefined; // false: 属性 y 不存在
'x' in o; // true: 属性 x 存在
'y' in o; // false: 属性 y 不存在
delete o.x; // 删除属性 ⅹ
'x' in o; // false: 属性 x 不存在
```

### 6.6 枚举属性

除了测试属性是否存在，有时候也需要遍历或获取对象的所有属性。为此有几种不同的实现方式。

**`for/in` 循环对指定对象的每个可枚举（自有或继承）属性都会运行一次循环体，将属性的名字赋给循环变量**。对象继承的内置方法是不可枚举的，但 JS 代码添加给对象的属性默认是可枚举的。例如:

```js
let o = { x: 1, y: 2, z: 3 }; // 3 个可枚举自有属性
o.propertyIsEnumerable('toString'); // false: toString 不可枚举也不是自有属性
for (let p in o) {
  console.log(p); // 打印 x、y、z，但没有 toString
}
```

为防止通过 `for/in` 枚举继承的属性，可以在循环体内添加一个显式测试:

```js
for (let p in o) {
  if (!o.hasOwnProperty(p)) continue; // 跳过继承属性
}

for (let p in o) {
  if (typeof o[p] === 'function') continue; // 跳过所有方法
}
```

除了使用 `for/in` 循环，有时候可以先获取对象所有属性名的数组，然后再通过 `for/of` 循环遍历该数组。有 4 个函数可以用来取得属性名数组:

- `Object.keys()` 返回对象可枚举自有属性名的数组。不包含不可枚举属性、继承属性或名字属性(参见 6.10.3 节)。<!--TODO-->
- `Object.getOwnProperNames()` 与 `Object.keys()` 类似，但也会返回不可枚举自有属性名的数组，只要它们的名字是字符串。
- `Object.getOwnPropertySymbols()` 返回名字是符号的自有属性，无论是否可枚举。
- `Reflect.ownKeys()` 返回所有属性名，包括可枚举和不可枚举属性，以及字符串属性和符号属性(参见 14.6 节)<!--TODO-->。

#### 6.6.1 属性枚举顺序

ES6 正式定义了枚举对象自有属性的顺序。`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnProperSymbols()`、`Reflect.ownKeys()`及 `JS0N.stringify()` 等相关方法都按照下面的顺序列出属性，另外也受限于它们要列出不可枚举属性还是列出字符串属性或符号属性:

- 先列出名字为非负整数的字符串属性，按照数值顺序从最小到最大。这条规则意味着数组和类数组对象的属性会按照顺序被枚举。

- 在列出类数组索引的所有属性之后，再列出所有剩下的字符串名字（包括看起来像负数或浮点数的名字）的属性。这些属性按照它们添加到对象的先后顺序列出。对于在对象字面量中定义的属性，按照它们在字面量中出现的顺序列出。

- 最后，名字为符号对象的属性按照它们添加到对象的先后顺序列出。

`for/in` 循环的枚举顺序并不像上述枚举函数那么严格，但实现通常会按照上面描述的顺序枚举自有属性，然后再沿原型链上溯，以同样的顺序枚举每个原型对象的属性。

> **注意**: 如果已经有同名属性被枚举过了，甚至如果有一个同名属性是不可枚举的，那这个属性就不会枚举了

### 6.7 扩展对象

在 JS 程序中，把一个对象的属性复制到另一个对象上是很常见的。使用下面的代码很容易做到:

```js
let target = { x: 1 },
  source = { y: 2, z: 3 };
for (let key of Object.keys(source)) {
  target[key] = source[key];
}
```

因为这是个常见操作，各个 JS 框架为此定义了辅助函数，通常会命名为 `extend()`。最终，在 ES6 中，这个能力以 `Object.assign()` 的形式进入了核心 JS 语言。

**`Object.assign()` 接收两个或多个对象作为其参数。它会修改并返回第一个参数，第一个参数是目标对象，但不会修改第二个及后续参数，那些都是来源对象**。

对于每个来源对象，它会把该对象的可枚举自有属性（包括名字为符号的属性）复制到目标对象。它按照参数列表顺序逐个处理来源对象，第一个来源对象的属性会覆盖目标对象的同名属性，而第二个来源对象（如果有）的属性会覆盖第一个来源对象的同名属性。

`Object.assign()` 以普通的属性获取和设置方式复制属性，因此如果一个来源对象有获取方法或目标对象有设置方法，则它们会在复制期间被调用，但这些方法本身不会被复制。

将属性从一个对象分配到另一个对象的一个原因是，如果有一个默认对象为很多属性定义了默认值，并且如果该对象中不存在同名属性，可以将这些默认属性复制到另一个对象中。但是，像下面这样简单地使用 `Object.assign()` 不会达到目的:

```js
Object.assign(o, defaults); // 用 defaults 覆盖 o 的所有属性
```

此时，需要创建一个新对象，先把默认值复制到新对象中，然后再使用 `o` 的属性覆盖那些默认值

```js
o = Object.assign({}, defaults, o);
```

使用扩展操作符 `...` 也可以表达这种对象复制和覆盖操作:

```js
o = { ...defaults, ...o };
```

为了避免额外的对象创建和复制，也可以重写一版 `Object.assign()`，只复制那些不存在的属性:

```js
// 与 Object.assign() 类似，但不覆盖已经存在的属性
// （同时也不处理符号属性）
function merge(target, ...sources) {
  for (let source of sources) {
    for (let key of Object.keys(source)) {
      // 这里跟 Object.assign() 不同
      if (!(key in target)) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
Object.assign({ x: 1 }, { x: 2, y: 3 }, { y: 3, z: 4 }); // {x:2, y:3, z:4}
merge({ x: 1 }, { x: 2, y: 2 }, { y: 3, z: 4 }); // {x:1, y:2, z:4}
```

### 6.8 序列化对象

**对象序列化（serialization）是把对象的状态转换为字符串的过程，之后可以从中恢复对象的状态**。

函数 `JSON.stringify()` 和 `JSON.parse()` 用于序列化和恢复 JS 对象。这两个函数使用 JSON 数据交换格式。JSON 表示 JavaScript Object Notation（JavaScript 对象表示法），其语法与 JS 对象和数组字面量非常类似：

```js
let o = { x: 1, y: { z: [false, null, ''] } }; // 定义一个测试对象
let s = JSON.stringify(o); // s == '{"x":1,"y":{"z":[false,null,""]}}}'
let p = JSON.parse(s); // p == { x: 1, y: { z: [false, null, ''] } }
```

JSON 语法是 JavaScript 语法的子集，不能表示所有 JavaScript 的值。**可以序列化和恢复的值包括对象、数组、字符串、有限数值、true、 false 和 null**。

**JSON 无法序列化和恢复的值**：

- `NaN`、`Infinity` 和 `-Infinity` 会被序列化为 `null`。
- 日期对象会被序列化为 ISO 格式的日期字符串，但 `JSON.parse()` 会保持其字符串形式，不会恢复原始的日期对象。
- 函数、RegExp 和 Error 对象以及 undefined 值不能被序列化或恢复。
- **`JSON.stringify()` 只序列化对象的可枚举自有属性**。如果属性值无法序列化，则该属性会从输出的字符串中删除。

`JSON.stringify()` 和 `JSON.parse()` 都接收可选的第二个参数，用于自定义序列化及恢复操作。例如，可以通过这个参数指定要序列化哪些属性，或者在序列化或字符串化过程中如何转换某些值。11.6 节包含这两个函数的完整介绍。<!--TODO-->

### 6.9 对象方法

**所有 JavaScript 对象（除了那些显式创建为没有原型的）都从 `Object.prototype` 继承属性。这些继承的属性主要是方法**，因为它们几乎无处不在，所以对 JavaScript 程序而言特别重要。例如，`hasOwnProperty()` 和
`propertyIsEnumerable()` 方法。下面是几个 `Object.prototype` 上的通用方法，但这些方法很有可能被更特定的实现取代。

#### 6.9.1 toString() 方法

**`toString()` 方法不接收参数，返回表示调用它的对象的值的字符串**。每当需要把一个对象转换为字符串时，JS 就会调用该对象的这个方法。例如，在使用 `+` 操作符拼接一个字符串和一个对象时，或者把一个对象传入期望字符串参数的方法时。

默认的 `toString()` 方法并不能提供太多信息（但可以用于确定对象的类）。例如，下面这行代码只会得到字符串 "[object Object]":

```js
let s = { x: 1, y: 1 }.toString(); // s == "[object Object]
```

由于这个默认方法不会显示太有用的信息，很多类都会重新定义自己的 `toString()` 方法。例如，在把数组转换为字符串时，可以得到数组元素的一个列表，每个元素也都转换为字符串。而把函数转换为字符串时，可以得到函数的源代码。可以像下面这样定义自己的 `toString()` 方法:

```js
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  }
};
String(point); // "(1, 2)": toString() 用于转换为字符串
```

#### 6.9.2 toLocaleString() 方法

除了基本的 `toString()` 方法之外，对象也都有一个 **`toLocaleString()` 方法。这个方法的用途是返回对象的本地化字符串表示**。

- Object 定义的默认 `toLocaleString()` 方法本身没有实现任何本地化，而是简单地调用 `toString()` 并返回该值。
- Date 和 Number 定义了自己的 `toLocaleString()` 方法，尝试根据本地惯例格式化数值、日期和时闻。
- 数组也定义了一个与 `toString()` 类似的 `toLocaleString()` 方法，只不过它会调用每个数组元素的 `toLocaleString()` 方法，而不是调用它们的 `toString()` 方法。

对于前面的 point 对象，也可以如法炮制:

```js
let point = {
  X: 1000,
  y: 2000,
  toString: function () {
    return `(${this.x}, ${this.y})`;
  },
  toLocaleString: function () {
    return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`;
  }
};

point.toString(); // "(1000, 2000)"
point.toLocaleString(); // "(1,000, 2,000)": 千分位分隔符
```

#### 6.9.3 valueof() 方法

`valueof()` 方法与 `toString()` 方法很相似，但**会在 JS 需要把对象转换为某些非字符串原始值（通常是数值）时被调用**。如果在需要原始值的上下文中使用了对象，JS 会自动调用这个对象的 `valueof()` 方法。

默认的 `valueof()` 方法并没有做什么，因此一些内置类定义了自己的 `valueof()` 方法。Date 类定义的 `valueof()` 方法可以将日期转换为数值，这样就让日期对象可以通过 `<` 和 `>` 操作符来进行比较。类似地，对于 point 对象，也可以定义一个返回原点与当前点之间距离的 `valueof()`:

```js
let point = {
  x: 3,
  y: 4,
  valueof: function () {
    return Math.hypot(this.x, this.y);
  }
};

Number(point); // 5: valueof() 用于转换为数值
point > 4;
point > 5; // false
point < 6; // true
```

#### 6.9.4 toJSON() 方法

`Object.prototype` 实际上并未定义 `toJSON()` 方法，但 `JSON.stringify()` 方法会从要序列化的对象上寻找 `toJSON()` 方法。如果要序列化的对象上存在这个方法，就会调用它，然后序列化该方法的返回值，而不是原始对象。

Date 类(参见 11.4 <!--TODO-->节)定义了自己的 `toJSON()` 方法，返回一个表示日期的序列化字符串。同样，也可以给 point 对象定义这个方法:

```js
let point = {
  x: 1,
  y: 2,
  toString: function () {
    return `(${this.x}, ${this.y});`;
  },
  toJSON: function () {
    return this.toString();
  }
};

JSON.stringify([point]); // '["(1, 2)"]'
```

### 6.10 对象字面量扩展语法

最近的 JS 版本从几个方面扩展了对象字面量语法。下面将讲解这些扩展。
