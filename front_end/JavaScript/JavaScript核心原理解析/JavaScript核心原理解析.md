# JavaScript 核心原理解析

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [JavaScript 核心原理解析](#javascript-核心原理解析)
  - [一. JS 是如何构建起来的](#一-js-是如何构建起来的)
    - [1.1 delete](#11-delete)
      - [1.1.1 delete 删除的是表达式的引用类型的结果](#111-delete-删除的是表达式的引用类型的结果)
      - [1.1.2 规范中的引用](#112-规范中的引用)
      - [1.1.3 引用的作用](#113-引用的作用)
    - [1.2 声明语句与语法改变了 JS 语言核心性质](#12-声明语句与语法改变了-js-语言核心性质)
      - [1.2.1 声明](#121-声明)
      - [1.2.2 赋值](#122-赋值)
      - [1.2.3 变量泄露：向一个不存在的变量名赋值](#123-变量泄露向一个不存在的变量名赋值)

<!-- /code_chunk_output -->

**JS 是一门多范型语言，也称为混合范型语言**。JS 的简单来自于此，复杂也来自于此；生存能力来自于此，抨击诟病也来自于此。

JS 主要包括 5 个方面的语言特性：

- 结构化编程
- 面向对象编程
- 动态语言
- 函数式语言
- 并行语言

所谓的语言特性，其实是对语言的核心抽象概念的语法表现。

## 一. JS 是如何构建起来的

### 1.1 delete

早期的 JS 在推广时，仍然采用传统的数据类型的分类方法，也就是说，它宣称自己同时支持值类型和引用类型的数据，并且，所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。

JS 强行定义了 “Object 和 Function 就是引用类型”。对象和函数也就可以理解为：它们按引用来传递和使用。绝大多数情况下，这样解释起来是行得通的。但是到了 `delete` 运算这里，就不行。

因为这样一来，`delete 0` 就是删除一个值，而 `delete x` 就既可能是删除一个值，也可能是删除一个引用。然而，当时 JS 又同时约定：那些在 global 对象上声明的属性，就 “等同于” 全局变量。于是，这就带来了第三个问题：`delete x` 还可能是删除一个 global 对象上的属性。而它在执行这个操作的时候，看起来却像是一个全局变量。

`delete` 这个运算的表面意思，是该运算试图销毁某种东西。然而，`delete 0` 中的 0 是一个具体的、字面量表示的 “值”。一个字面量值 “0” 如何在现实世界中销毁呢？假定它销毁了，那是不是说，在这个语言当前的运行环境中，就不能使用 0 这个值了呢？显然，这不合理。所以，JS 认为 “**所有删除值的 delete 就直接返回 true**”，表明该行为过程中没有异常。

`delete` 出现的时代并没有结构化异常处理（即 try/catch 语句）。所以，通过函数调用中返回 true 来表明 “没有异常”，其实是很常规的做法。然而，返回值只表明执行过程中没有异常，但实际的执行行为是 “什么也没发生”。显然不可能真的将 “0” 从执行系统中清理出去。

那么接下来，就还剩下删除变量和删除属性。由于全局变量实际上是通过全局对象的属性来实现的，因此删除变量也就存在识别这两种行为的必要性。例如：

```js
delete x;
```

出于 JS 是动态语言这项特性，从根本上来说，是没有办法在语法分析期来判断 x 的性质的。所以现在，需要有一种方法在运行期来标识 x 的性质，以便进一步地处理它。这就导致了一种新的 “引用” 类型呼之欲出。

#### 1.1.1 delete 删除的是表达式的引用类型的结果

对于一门编译型语言来说，所谓 “0”，就是上面所述的一个值，它可以是基础值（Primitive values），也可以是数值类型。但如果将这个问题上升到编译之前的、所谓语法分析的阶段，那么 “0” 就会被称为一个记号（Tokens）。一个记号是没有语义的，记号既可以是语言能识别的，也可以是语言不能识别的。唯有把这二者同时纳入语言范畴，那么这个语言才能识别所谓的 “语法错误”。

`delete` 不仅仅是要操作 0 或 x 这样的单个记号或标识符（例如变量）。因为这个语法实际起作用的是一个对象的属性，也就是 “删除对象的成员”。那么它真正需要的语法其实是：

```js
delete obj.x;
```

只不过因为全局对象的成员可以用全局变量的形式来存取，所以它才能这样写：

```js
delete x;
```

所以，这正好将之前所认识的倒转过来，是删除 x 这个成员，而不是删除 x 这个值。不过有一点是没错的：既然没办法表达异常，而 delete 0 又不产生异常，那么它自然就该返回 true。

然而，如果理解了 `delete obj.x`，那么就一定会想到：`obj.x` 既不是引用类型，也不是值类型，它与 `typeof(x)` 识别的所有类型都无关。因为，它是一个表达式。所以，**delete 这个操作的正式语法设计并不是 “删除某个东西”，而是 “删除一个表达式的结果”**：

**表达式的结果**
**在 JS 中表达式是一个很独特的东西，所有一切表达式运算的终极目的都是为了得到一个值**。然后再用另外一些操作将这个值输出出来，例如变成网页中的一个元素（element）。这是 JS 语言创生的原力，也是它的基础设计。也只是因为有了这种设计，它才变得既像面向对象的，又像函数式语言的样子。

这个表达式得到的值，才是 delete 这个操作要删除的东西。在 JS 中，有两个东西可以被执行并存在执行结果：

- **语句**

  比如用 eval() 来执行一个字符串，那么实际上，执行的是一个语句，并返回了语句的值。

- **表达式**

  如果使用一对括号来强制一个表达式执行，那么这个括号运算得到的，就是这个表达式的值。表达式的值，在 ECMAScript 的规范中，称为 “引用”。这是一种称为 “规范类型” 的东西。

#### 1.1.2 规范中的引用

实际上这个概念出现得很早。从 JS 1.3 开始，ECMAScript 规范就在语言定义的层面，正式地将上述的天坑补起来，推出了 “（真正的）引用类型”。

但是，由于这个时候规范的影响力在开发人员中并不那么大，所以开发人员还是习惯性地将对象和函数称为引用，而其它类型就称为值，并且继续按照传统的理解来解释 JS 中对数据的处理。

这种情况下，一个引用只是在语法层面上表达 “它是对某种语法元素的引用”，而与在执行层面的值处理或引用处理没关系。所以，下面这行简短的语句：

```js
delete 0;
```

实际上是在说：JS 将 0 视为一个表达式，并尝试删除它的求值结果。所以，现在这里的 0，不是值类型的数据，而是一个表达式运算的结果。而在进一步的删除操作之前，JS 需要检测这个 Result 的类型：

- 如果它是值，则按照传统的 JS 的约定返回 true。
- 如果它是一个引用，那么对该引用进行分析，以决定如何操作。

ECMAScript 约定：任何表达式计算的结果要么是一个值，要么是一个引用。并且需要留意的是，在这个描述中，所谓对象，其实也是值。准确地说，是 “非引用类型”。例如：

```js
delete {};
```

那么显然，这里要删除的一对大括号是表示一个字面量的对象，当它被作为表达式执行的时候，结果也是一个值。这也是这类表达式被称为 “单值表达式” 的原因，这里并没有所谓的 “引用”。

可以这样，非常细致而准确地解释这一行代码：_单值表达式的运算结果返回那个 “对象字面量” 的单值。然后，delete 运算发现它的操作数是 “值/非引用类型”，就直接返回了 true。所以，什么也没有发生。_

在 JS 的内部，“引用” 是可以转换为 “值”，以便参与值运算的。因为表达式的本质是求值运算，所以引用是不能直接作为最终求值的操作数的。这依赖于一个非常核心的、称为 “GetValue()” 的**内部操作**。所谓内部操作，也称为内部抽象操作（internal abstract operations），是 ECMAScript 描述一个符合规范的引擎在具体实现时应当处理的那些行为。

**GetValue() 是从一个引用中取出值来的行为**。比如说下面这行代码：

```js
x = x;
```

上面的表达式其实是一个赋值表达式， “引用 x 赋值给引用 x” 其实这在语法层面来解释是非常直接的：

> 所有赋值操作的含义，是将右边的 “值”，赋给左边用于包含该值的 “引用”。

上面的 x=x，其实就是被翻译成：

```js
x = GetValue(x);
```

JS 识别两个 x 的不同的方法被称为**手性**，即是所谓 “左手端（lhs, left hand side）” 和 “右手端（rhs）”。它本来是用来描述自然语言的语法中，一个修饰词应该是放在它的主体的前面或是后面的。而在程序设计语言中，它用来说明一个记号（Token）是放在了赋值符号（例如 “=” 号）的左边或是右边。

> x 放在左边作为 lhs，它是引用。放在右边作为 rhs，就是值。

所以 x=x 的语义并不是 “x 赋给 x”，而是 “**把值 x 赋给引用 x**”。因此 “delete x” 归根到底，**是在删除一个表达式的、引用类型的结果**，而不是在删除 x 表达式，或者这个删除表达式的值。

在 JS 中的 delete 是一个很罕见的、能直接操作 “引用” 的语法元素。由于这里的 “引用” 是在 ECMAScript 规范层面的概念，因此在 JS 语言中能操作它的语法元素其实非常少。

#### 1.1.3 引用的作用

“属性存取运算符（.）” 返回一个关于 “x” 的引用，然后它可以作为下一个操作符（例如函数调用运算 “()”）的左手端来使用，这才有了著名的 “对象方法调用” 运算：

```js
obj.x();
```

因为在对象方法调用的时候，函数 x() 是来自于 obj.x 这个引用的，所以这个引用将 obj 这个对象传递给 x()，这才会让函数 x() 内部通过 this 来访问到 obj。

根本上来说，如果 obj.x 只是值，或者它作为右手端，那么它就不能 “携带” obj 这个对象，也就完成不了后续的方法调用操作。

> 对象存取 + 函数调用 = 方法调用

这是 JS 通过连续表达式运算来实现新的语义/语法的经典示例。而 “连续运算” 其实是函数式运算范式的基本原则。也就是说，obj.x() 是在 JS 中集合了 “引用规范类型操作” “函数式” “面向对象” 和 “动态语言” 等多种特性于一体的一个简单语法。

而它对语言的基础特性的依赖，就在于：

- delete 0 中的这个 0 是一个表达式求值
- delete x 中的 x 是一个引用
- delete obj.x 中 obj.x 是一组表达式连续运算的结果/引用

当 x 是全局对象 global 的属性时，所谓 delete x 其实只需要返回 global.x 这个引用就可以了。而当它不是全局对象 global 的属性时，那么就需要从当前环境中找到一个名为 x 的引用。找到这两种不同的引用的过程，称为 ResolveBinding；而这两种不同的 x，称为不同环境下绑定的标识符/名字。

### 1.2 声明语句与语法改变了 JS 语言核心性质

#### 1.2.1 声明

至今为止，除标签声明之外，JS 中一共只有六条声明用的语句。

> **注意**：所有真正被定义 “声明” 的语法结构都一定是 “语句”，并且都用于声明一个或多个标识符。这里的标识符包括变量、常量等。

严格意义上讲，JS 只有变量和常量两种标识符，六条声明语句中：

- `let x`：声明变量 x。不可在赋值之前读。
- `const x`：声明常量 x。不可写。
- `var x`：声明变量 x。在赋值之前可读取到 undefined 值。
- `function x`：声明变量 x。该变量指向一个函数。
- `class x`：声明变量 x。该变量指向一个类（该类的作用域内部是处理严格模式的）。
- `import x`：导入标识符并作为常量（有多种声明标识符的模式和方法）。

除了这六个语句之外，还有两个语句有潜在的声明标识符的能力，不过它们并不是严格意义上的声明语句（声明只是它们的语法效果）。这两个语句是指：

- `for (var|let|const x)`：for 语句有多种语法来声明一个或多个标识符，用作循环变量。
- `try … catch (x)`：catch 子句可以声明一个或多个标识符，用作异常对象变量。

声明是在语法分析阶段就处理的，并且因此它会使得当前代码上下文在正式执行之前就拥有了被声明的标识符，例如 x。

这其实非常有趣，因为这表明 **JS 虽然被称为是 “动态语言”，但确实是拥有静态语义的**。而在 JS 的早期，这个静态语义其实并没有处理得太好，一个典型的问题就是所谓的 “变量提升”。也就是可以在变量声明之前访问该变量。例如：

```js
console.log(x); // undefined
var x = 100;
console.log(x); // 100
```

由于标识符是在用户代码执行之前就已经由静态分析得到，并且创建在环境中，因此 let 声明的变量和 var 声明的变量在这一点上没有不同：它们都是在读取一个 “已经存在的” 标识符名。

在 ES6 之后出现的 let/const 变量在 “声明（和创建）一个标识符” 这件事上，与 var 并没有什么不同，只是 JS 拒绝访问还没有绑定值的 let/const 标识符而已。

ES6 之前：JS 是允许访问还没有绑定值的 var 所声明的标识符的。这种标识符后来统一约定称为 “**变量声明**（varDecls）”，而 “let/const” 则称为 “**词法声明**（lexicalDecls）”。JS 环境在创建一个 “变量名（varName in varDecls）” 后，会为它初始化绑定一个 undefined 值，而 “词法名字（lexicalNames）” 在创建之后就没有这项待遇，所以它们在缺省情况下就是 “还没有绑定值” 的标识符。

> 6 种声明语句中的函数是按变量声明的规则声明的；类的内部是处于严格模式中，它的名字是按 let 来处理的，而 import 导入的名字则是按 const 的规则来处理的。所以，**所有的声明本质上只有三种处理模式：var 变量声明、let 变量声明和 const 常量声明**。

#### 1.2.2 赋值

如果是在一门其它的（例如编译型的）语言中，“为变量 x 绑定一个初值” 就可能实现为 “在创建环境时将变量 x 指向一个特定的初始值”。这通常是静态语言的处理方法。JS 是门动态的语言，所以它的 “绑定初值” 的行为是通过动态的执行过程来实现的，也就是赋值操作。

在 JS 中，不是 `值 = 变量` 而是将右操作数（的值）赋给左操作数（的引用）：

```js
lRef = rValue;
```

它的严格语法表达是：

```txt
LeftHandSideExpression < = | AssignmentOperator >
AssignmentExpression
```

也就是说，在 JS 中，一个赋值表达式的左边和右边其实 “都是” 表达式。

#### 1.2.3 变量泄露：向一个不存在的变量名赋值

这是从 JS 1.0 开始就遗留下来的一个巨坑，也就是 “变量泄漏” 问题。这在早期的 JS 中的确是一个好用的特性：如果向一个不存在的变量名赋值，那么 JS 会在全局范围内创建它。

也就是说，代码中不需要显式地声明一个变量了，变量可以随用随声明，也不用像后来的 let 语句一样，还要考虑在声明语句之前能不能访问的问题了。这非常简单，在少量的代码中也相当易用。

但是，如果代码规模扩大，变成百千万行代码，那么 “一个全局变量是在哪里声明和创建的” 就变成一个非常要紧的问题。

如果随时都可能泄露一个代码给全局，或者随时都可能因为忘记本地的声明而读写了全局变量，那对调试除错将是一场灾难。另外，晚一些出现的运行期优化技术也不能很好地处理这种情况。所以从 ECMAScript5 开始的严格模式就禁止了这种特性，试图避免用户将变量泄露到全局环境。然而，即使在严格模式下这种漏露也未能避免，被称为 “**间接执行**”。

这种变量声明的发生是因为在早期设计中，JS 的全局环境是引擎使用一个称为 “**全局对象**” 东西管理起来的。

这个全局对象几乎类似或完全等同于一个普通对象。只不过，JS 引擎将全局的一些缺省对象、运行期环境的原生对象等东西都初始化在这个全局对象的属性中，并使用这个对象创建了一个称为 “**全局对象闭包**” 的东西，从而得到了 JS 的全局环境。

早期的 JS 的引擎实现非常简洁，许多基础的技术组件都是直接复用的，例如这里的所谓全局环境、全局闭包，或者全局对象的实现方法，就与 “with 语句” 的效果完全相同——他们是相互复用的。

当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此 JS 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了 “可以动态地向全局环境中添加一个变量”。并且，可以删除掉这个动态添加的 “变量”，因为本质上就是在删除全局对象的属性。

ES6 的全局环境为了兼容旧的 JS 语言设计，所以仍然是通过将全局对象初始化为这样的一个全局闭包来实现的。但是为了得到一个 “尽可能” 与其它变量环境相似的声明效果（varDecls），ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames），所有在静态语法分析期或在 eval() 中使用 var 声明的变量名就被放在这个列表中。然后约定，这个变量名列表中的变量是 “直接声明的变量”，不能使用 delete 删除。

于是，得到了这样的一种结果：

```js
// a 和 x 都是 global 的属性
var a = 100;
x = 200;

Object.getOwnPropertyDescriptor(global, 'a'); // { value: 100, writable: true, enumerable: true, configurable: false }
Object.getOwnPropertyDescriptor(global, 'x'); // { value: 200, writable: true, enumerable: true, configurable: true }

// a 不能删除，x 可以被删除
delete a; // false
delete x; // true

// 检查
console.log(a); // 100
console.log(x); // ReferenceError: x is not defined
```

所以，表面看起来 “泄漏到全局的变量” 与使用 var 声明的都是全局变量，并且都实现为 global 的属性，但事实上它们是不同的。并且当 var 声明发生在 eval() 中的时候，这一特性又还有所不同，例如：

```js
// 使用eval声明
eval('var b = 300');

// 它的性质是可删除的
Object.getOwnPropertyDescriptor(global, 'b').configurable; // true

// 检测与删除
b; // 300
delete b; // true
b; // ReferenceError: b is not defined
```

这种情况下使用 var 声明的变量名尽管也会添加到 varNames 列表，但它也可以从 varNames 中移除（这是唯一一种能从 varNames 中移除项的特例，而 lexicalNames 中的项是不可移除的）。

### 1.3 引用在表达式连续运算中传递计算过程的信息

JS 总是严格按照从左至右的顺序来计算表达式。

```js
w = x + y * z;
```

上面的代码中将首先计算子表达式 w，然后计算 x、y 和 z；然后，y 的值和 z 的值相乘，再加上 x 的值；最后将其赋值给表达式 w 所指代的变量或属性。

任何运算的操作数都是严格从左至右计算的，因此 x 先被处理，然后才会尝试对 y 和 z 求乘积。这里的 “x 先被处理” 是 JS 中的一个特异现象，即：**一切都是表达式，一切都是运算**。

这一现象在语言中是函数式的特性，类似 “一切被操作的对象都是函数求值的结果，一切操作都是函数”。

```js
var a = { n: 1 };
a.x = a = { n: 2 };
console.log(a.x); // undefined
```

上面代码中的第二行是两个连续赋值的表达式：

1. **a.x 总是最先被计算求值的**（从左至右）

   “a.x” 也是一个表达式，其结果是一个 “引用”。这个表达式 “a.x” 本身也要再计算它的左操作数，也就是 “a”。完整地讲，“a.x” 这个表达式的语义是：

   - 计算单值表达式 a，得到 a 的引用。
   - 将右侧的名字 x 理解为一个标识符，并作为 “.” 运算的右操作数。
   - 计算 “a.x” 表达式的结果。

   表达式 “a.x” 的计算结果是一个引用，因此通过这个引用保存了一些计算过程中的信息——例如它保存了 “a” 这个对象，以备后续操作中 “可能会” 作为 this 来使用。所以现在，在整行代码的表达式计算过程中，“a” 是作为一个**引用**被暂存下来了的。由第一行代码可知，这时保存在 “a.x” 这个引用中的 “a” 是当前的 “{n: 1}” 这个对象。

2. **再执行 `a =`**

   ```js
   var a = {n:1};
   a.x =     // <- `a` is {n:1}
         a = // <- `a` is {n:1}
   // ...
   ```

   这里的 “a = …” 中的 a 仍然是当前环境中的变量，与上一次暂存的值是相同的。

3. **第一次赋值**

   ```js
   // ...
   a.x = // <- `a` is {n:1}
     a =
       // <- `a` is {n:1}
       { n: 2 }; // 赋值，覆盖当前的左操作数（变量`a`）
   ```

   于是，左操作数 a 作为一个引用被覆盖了，这个引用仍然是当前上下文中的那个变量 a。因此，这里真实地发生了一次 `a = {n:2}`。

   但是，表达式最开始被保留在 “一个结果” 中的引用 a 不会更新。因为那是一个 “**运算结果**”，这个结果有且仅有引擎知道，它现在是一个引擎才理解的“**引用**（规范对象）”，对于它的可能操作只有：

   - 取值或置值（GetValue/PutValue）
   - 作为一个引用向别的地方传递等

4. **第二次赋值**

   现在，在整个语句行的最左侧 “空悬” 了一个已经求值过的 “a.x”。当它作为赋值表达式的左操作数时，它是一个被赋值的引用（这里是指将 a.x 的整体作为一个引用规范对象）。而它作为结果所保留的 “a”，可以从下面的代码看出来，是在被第一次赋值操作覆盖之前的、那个 “原始的变量 a”。

   ```js
   // 声明“原始的变量a”
   var a = { n: 1 };

   // 使它的属性表冻结（不能再添加属性）
   Object.freeze(a);

   try {
     a.x = a = { n: 2 };
   } catch (x) {
     // 异常发生，说明第二次赋值 “a.x = ...” 中操作的`a`正是原始的变量a
     console.log('第二次赋值导致异常.');
   }

   // 第一次赋值是成功的
   // a {n: 2}
   console.log(a.n); // 2
   ```

   而原始变量 a 在第一次赋值时被废弃了，所以第二次赋值是无意义的。最后 a 的值为 `{n: 2}`。

### 1.4 export
