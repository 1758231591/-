# 生态源码

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [生态源码](#生态源码)
  - [一. 响应式](#一-响应式)
  - [二. 运行时](#二-运行时)

<!-- /code_chunk_output -->

## 一. 响应式

Vue3 的组件之间是通过响应式机制来通知的，响应式机制可以自动收集系统中数据的依赖，并且在修改数据之后自动执行更新，极大提高开发的效率。

响应式机制的主要功能是，可以**把普通的 JS 对象封装成为响应式对象，拦截数据的获取和修改操作，实现依赖数据的自动化更新**。所以，一个最简单的响应式模型，可以通过 reactive 或者 ref 函数，把数据包裹成响应式对象，并且通过 effect 函数注册回调函数，然后在数据修改之后，响应式地通知 effect 去执行回调函数即可。

Vue3 的响应式是可以独立在其他平台使用的。比如可以新建 test.js，使用下面的代码在 node 环境中使用 Vue 响应。以 reactive 为例，使用 reactive 包裹 JS 对象之后，每一次对响应式对象 counter 的修改，都会执行 effect 内部注册的函数：

```js
const { watchEffect, reactive } = require('vue');

const counter = reactive({
  x: 1,
  y: 2
});

watchEffect(() => {
  const perimeter = (counter.x + counter.y) * 2;
  console.log(perimeter);
});

setTimeout(() => {
  counter.x += 1;
});
```

执行文件后，可以看到 watchEffect 内部的函数调用了两次。先来看一下响应式整体的流程图，上面的代码中使用 reactive 把普通的 JS 对象包裹成响应式数据了。

所以，在 effect 中获取 counter.num1 和 counter.num2 的时候，就会触发 counter 的 get 拦截函数；get 函数，会把当前的 effect 函数注册到一个全局的依赖地图中去。这样 counter.num1 在修改的时候，就会触发 set 拦截函数，去依赖地图中找到注册的 effect 函数，然后执行。

![响应式流程图](./image/响应式流程图.webp)

## 二. 运行时

前端框架需要处理的最核心的两个流程，就是首次渲染和数据更新后的渲染。先来看首次渲染的源码。

- **首次渲染**

  想要启动一个 Vue 项目，只需要从 Vue 中引入 createApp，传入 App 组件，并且调用 createApp 返回的 App 实例的 mount 方法，就实现了项目的启动。这个时候 Vue 也完成了首次渲染，代码逻辑如下：

  ![首次渲染代码逻辑](./image/首次渲染代码逻辑.webp)

  所以 createApp 就是项目的初始化渲染入口。可以在 Vue 中的 [runtime-dom](https://github.com/vuejs/core/blob/main/packages/runtime-dom/src/index.ts#L66) 中看到 createApp 的定义。

  首次查看源码的时候，可以先把一些无用的信息删除，方便梳理主体的逻辑。看 Vue 代码，和今天主题无关的无用信息有哪些，`__COMPAT__` 代码是用来兼容 Vue 2 的，`__DEV__` 代码是用来调试的，可以把这些代码删除之后，得到下面的简化版 createApp 源码：

  ```ts
  export const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    // 重写 mount
    app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;

      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = '';
      const proxy = mount(container, false, container instanceof SVGElement);
      if (container instanceof Element) {
        container.removeAttribute('v-cloak');
        container.setAttribute('data-v-app', '');
      }
      return proxy;
    };
    return app;
  };
  // 内部的 normalizeContainer 就是把传递的参数统一变为浏览器的 DOM 元素
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
    }
    return container;
  }
  ```

  再看思路就比较清晰了。使用 ensureRenderer 返回的对象去创建 app，并且重写了 app.mount 方法；在 mount 方法内部，查找 mount 传递的 DOM 元素，并且调用 ensureRenderer 返回的 mount 方法，进行初始化渲染。如下图所示：

  ![首次渲染图示](./image/首次渲染图示.webp)

  **这里 ensureRenderer 函数，内部通过 createRenderer 函数，创建了一个浏览器的渲染器，并且缓存了渲染器 renderer**，这种使用闭包做缓存的方式，在日常开发中也可以借鉴这种思路。

  createRenderer 函数传递的 rendererOptions 就是浏览器里面标签的增删改查 API：

  ```ts
  // 浏览器 dom 操作
  import { nodeOps } from './nodeOps';
  // 浏览器 dom 属性更新
  import { patchProp } from './patchProp';
  import { createRenderer } from '@vue/runtime-core';
  const rendererOptions = extend({ patchProp }, nodeOps);

  let renderer: Renderer<Element | ShadowRoot> | HydrationRenderer;

  function ensureRenderer() {
    return renderer || (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions));
  }
  ```

  可以看到，createRenderer 函数传递的参数是 nodeOps 和 patchProp 的合并对象。继续进入 nodeOps 和 pathProp 也可以看到下面的代码，写了很多方法。通过 ensureRenderer 存储这些操作方法后，createApp 内部就可以脱离具体的渲染平台了，这也是 Vue 3 实现跨端的核心逻辑：

  ```ts
  export const nodeOps: Omit<RendererOptions<Node, Element>, 'patchProp'> = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: child => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, isSVG, is, props): Element => {
      const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : undefined);

      if (tag === 'select' && props && props.multiple != null) {
        (el as HTMLSelectElement).setAttribute('multiple', props.multiple);
      }
      return el;
    },

    createText: text => doc.createTextNode(text),

    createComment: text => doc.createComment(text),

    setText: (node, text) => {
      node.nodeValue = text;
    },

    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: node => node.parentNode as Element | null,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector)
    // ...
  };
  ```

## 三. 虚拟 DOM

### 3.1 Vue 虚拟 DOM 执行流程

在 Vue 中，使用虚拟 DOM 来描述页面的组件，比如下面的 template 虽然格式和 HTML 很像，但是在 Vue 的内部会解析成 JS 函数，这个函数就是用来返回虚拟 DOM：

```xml
<div id="app">
  <p>hello world</p>
  <Rate :value="4"></Rate>
</div>
```

上面的 template 会解析成下面的函数，最终返回一个 JS 的对象能够描述这段 HTML：

```js
function render(){
  return h('div',{id:"app"},children:[
    h('p',{},'hello world'),
    h(Rate,{value:4}),
  ])
}
```

### 3.2 DOM 的创建

上面的 mount 函数中，使用 createVNode 函数创建项目的虚拟 DOM，可以看到 **Vue 内部的虚拟 DOM，也就是 vnode，就是一个对象，通过 type、props、children 等属性描述整个节点**：

```ts
const vnode = createVNode(
  rootComponent as ConcreteComponent,
  rootProps
)
function _createVNode() {

  // 处理属性和 class
  if (props) {
    ...
  }

  // 标记vnode信息
  const shapeFlag = isString(type)
    ? ShapeFlags.ELEMENT
    : __FEATURE_SUSPENSE__ && isSuspense(type)
    ? ShapeFlags.SUSPENSE
    : isTeleport(type)
    ? ShapeFlags.TELEPORT
    : isObject(type)
    ? ShapeFlags.STATEFUL_COMPONENT
    : isFunction(type)
    ? ShapeFlags.FUNCTIONAL_COMPONENT
    : 0

  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  )
}

function createBaseVNode(type,props,children,...){
    const vnode = {
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    children,
    shapeFlag,
    patchFlag,
    dynamicProps,
     ...
  } as VNode
  // 标准化子节点
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children)
  } else if (children) {
    vnode.shapeFlag |= isString(children)
      ? ShapeFlags.TEXT_CHILDREN
      : ShapeFlags.ARRAY_CHILDREN
  }
  return vnode
}componentUpdateFn
```

createVNode 负责创建 Vue 中的虚拟 DOM，而 mount 函数的核心逻辑就是使用 setupComponent 执行写的 `<script setup>`，使用 setupRenderEffect 监听组件的数据变化。所以会到 setupRenderEffect 函数中，去完整地剖析 Vue 中虚拟 DOM 的更新逻辑。

给组件注册了 update 方法，这个方法使用 effect 包裹后，当组件内的 ref、reactive 包裹的响应式数据变化的时候就会执行 update 方法，触发组件内部的更新机制。

看下面的代码，在 setupRenderEffect 内部的 componentUpdateFn 中，updateComponentPreRenderer 更新了属性和 slots，并且调用 renderComponentRoot 函数创建新的子树对象 nextTree，然后内部依然是调用 patch 函数。可以看到，**Vue 源码中的实现首次渲染和更新的逻辑都写在一起，在递归的时候如果对一个标签实现更新和渲染，就可以用一个函数实现**。

```ts
const componentUpdateFn = ()=>{
  if (!instance.isMounted) {
    // 首次渲染
    instance,
    parentSuspense,
    isSVG
    // ...
  }else{
    let { next, bu, u, parent, vnode } = instance
    if (next) {
      next.el = vnode.el
      updateComponentPreRender(instance, next, optimized)
    } else {
      next = vnode
    }
    const nextTree = renderComponentRoot(instance)
      patch(
        prevTree,
        nextTree,
        // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el!)!,
        // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree),
        instance,
        parentSuspense,
        isSVG
      )
    }
}

// 注册effect函数
const effect = new ReactiveEffect(
  componentUpdateFn,
  () => queueJob(instance.update),
  instance.scope // track it in component's effect scope
)
const update = (instance.update = effect.run.bind(effect) as S      chedulerJob)
update()

  const updateComponentPreRender = (
    instance: ComponentInternalInstance,
    nextVNode: VNode,
    optimized: boolean
  ) => {
    nextVNode.component = instance
    const prevProps = instance.vnode.props
    instance.vnode = nextVNode
    instance.next = null
    updateProps(instance, nextVNode.props, prevProps, optimized)
    updateSlots(instance, nextVNode.children, optimized)

    pauseTracking()
    // props update may have triggered pre-flush watchers.
    // flush them before the render update.
    flushPreFlushCbs(undefined, instance.update)
    resetTracking()
  }
```

比较关键的就是上面代码中的 **effect 函数，负责注册组件，这个函数也是 Vue 组件更新的入口函数**。

### 3.3 patch 函数

数据更新之后就会执行 patch 函数，下图就是 patch 函数执行的逻辑图：

![patch函数执行逻辑图](./image/patch%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%E5%9B%BE.webp)

在 patch 函数中，会针对不同的组件类型执行不同的函数，组件会执行 processComponent，HTML 标签会执行 processElement：

```ts
function path(n1, n2, container) {
  const { type, shapeFlag } = n2;
  switch (type) {
    case Text:
      processText(n1, n2, container);
      break;
    // 还有注释，fragment之类的可以处理，这里忽略
    default:
      // 通过shapeFlag判断类型
      if (shapeFlag & ShapeFlags.ELEMENT) {
        processElement(n1, n2, container, anchor);
      } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
        processComponent(n1, n2, container);
      }
  }
}

function processComponent(n1, n2, container) {
  // 老规矩，么有n1就是mount
  if (!n1) {
    // 初始化 component
    mountComponent(n2, container);
  } else {
    updateComponent(n1, n2, container);
  }
}
```

由于更新之后不是首次渲染了，patch 函数内部会执行 updateComponent，看下面的 updateComponent 函数内部，shouldUpdateComponent 会判断组件是否需要更新，实际执行的是 instance.update：

```ts
const instance = (n2.component = n1.component)!;
if (shouldUpdateComponent(n1, n2, optimized)) {
  // 正常更新
  instance.next = n2;
  // 如果子组件也已排队，请将其删除，以避免在同一刷新中重复更新同一子组件。
  invalidateJob(instance.update);
  // instance.update is the reactive effect.
  instance.update();
} else {
  // 无需更新。只需复制属性
  n2.component = n1.component;
  n2.el = n1.el;
  instance.vnode = n2;
}
```

组件的子元素是由 HTML 标签和组件构成，组件内部的递归处理最终也是对 HTML 标签的处理，所以，最后组件的更新都会进入到 processElement 内部的 patchElement 函数中。

### 3.4 patchElement 函数

在函数 patchElement 中主要就做两件事：

- **节点自身属性的更新**

  这里就能体现出 Vue 3 中性能优化的思想，通过 patchFlag 可以做到按需更新：

  - 如果标记了 FULL_PROPS，就直接调用 patchProps。
  - 如果标记了 CLASS，说明节点只有 class 属性是动态的，其他的 style 等属性都不需要进行判断和 DOM 操作。

  这样就极大的优化了属性操作的性能。

  内部执行 hostPatchProp 进行实际的 DOM 操作，Vue 3 的虚拟 DOM 真正做到了按需更新，这也是相比于 React 的一个优势。

  ```ts
  const patchElement = (
    n1: VNode,
    n2: VNode,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    slotScopeIds: string[] | null,
    optimized: boolean
  ) => {
    const el = (n2.el = n1.el!);
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS;

    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;

    // full diff
    patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);

    if (patchFlag > 0) {
      if (patchFlag & PatchFlags.FULL_PROPS) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        // class是动态的
        if (patchFlag & PatchFlags.CLASS) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, 'class', null, newProps.class, isSVG);
          }
        }

        // style样式是动态的
        if (patchFlag & PatchFlags.STYLE) {
          hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
        }

        // 属性需要diff
        if (patchFlag & PatchFlags.PROPS) {
          //
          const propsToUpdate = n2.dynamicProps!;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            // #1471 force patch value
            if (next !== prev || key === 'value') {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n1.children as VNode[],
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      //文本是动态的
      if (patchFlag & PatchFlags.TEXT) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children as string);
        }
      }
    }
  };
  ```

- **更新子元素**

  子元素的更新是 patchChildren 函数负责的，这个函数也是虚拟 DOM 中难度最高的一个函数，搞懂它还需要下一讲中的算法知识，先理解它主要的实现思路。<!-- TODO -->

  首先把子元素分成了文本、数组和空三个状态，新老子元素分别是这三种状态的一个，构成了不同的执行逻辑。这样 patchChildren 内部大致有五种情况需要处理：

  - 如果新的子元素是空，老的子元素不为空，直接卸载 unmount 即可。
  - 如果新的子元素不为空，老的子元素是空，直接创建加载即可。
  - 如果新的子元素是文本，老的子元素如果是数组就需要全部 unmount，是文本的话就需要执行 hostSetElementText。
  - 如果新的子元素是数组，比如是使用 v-for 渲染出来的列表，老的子元素如果是空或者文本，直接 unmount 后，渲染新的数组即可。

  - 最复杂的情况就是新的子元素和老的子元素都是数组。

    最朴实无华的思路就是把老的子元素全部 unmount，新的子元素全部 mount，这样虽然可以实现功能，但是没法复用已经存在的 DOM 元素。所以，需要判断出可以复用的 DOM 元素，如果一个虚拟 DOM 没有改动或者属性变了，不需要完全销毁重建，而是更新一下属性，最大化减少 DOM 的操作，这个任务就会交给 patchKeyedChildren 函数去完成。

    patchKeyedChildren 函数，做的事情就是尽可能高效地把老的子元素更新成新的子元素，如何高效复用老的子元素中的 DOM 元素是 patchKeyedChildren 函数的难点：

    ```ts
    const patchChildren: PatchChildrenFn = (
      n1,
      n2,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized = false
    ) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;

      const { patchFlag, shapeFlag } = n2;
      // 快速路径
      if (patchFlag > 0) {
        if (patchFlag & PatchFlags.KEYED_FRAGMENT) {
          // 这可以是完全键控的，也可以是混合键控的（有些键控了，有些没有）patchFlag的存在意味着子级保证是数组
          patchKeyedChildren(
            c1 as VNode[],
            c2 as VNodeArrayChildren,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) {
          // unkeyed
          patchUnkeyedChildren(
            c1 as VNode[],
            c2 as VNodeArrayChildren,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          return;
        }
      }

      // children 有 3 种可能：文本、数组或无子级。
      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
        // 文本子项快速路径
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          unmountChildren(c1 as VNode[], parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2 as string);
        }
      } else {
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          // prev children was array
          if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
            // 两个数组，不能假设任何内容，执行完全差异
            patchKeyedChildren(
              c1 as VNode[],
              c2 as VNodeArrayChildren,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            // 没有新的 children，就卸载旧的
            unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true);
          }
        } else {
          // 上一个子项为文本或空
          // 新的 children 为 array 或 null
          if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
            hostSetElementText(container, '');
          }
          // mount new if array
          if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
            mountChildren(
              c2 as VNodeArrayChildren,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    ```

    上面的代码执行逻辑如下图所示，根据 flags 判断子元素的类型后，执行不同的操作函数：

    ![patchChildren执行逻辑.webp](./image/patchChildren%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.webp)

### 3.5 patchChildren 的实现

patchChildren 是各类虚拟 DOM 框架中最难实现的函数，需要实现**一个高效的更新算法，能够使用尽可能少的更新次数，来实现从老的子元素到新的子元素的更新**。

类似体育课站队的时候，大家一开始站一排，但是顺序是乱的，需要尽快把队伍按照个头左低右高排列。

在 React 中，这种场景的处理逻辑是先进行循环，使用的是单侧插入的算法，在排队的时候挨个对比，如果你站我右边，并且个头比我高一点，说明咱俩的相对位置和最终队伍的位置是一致的，暂时不需要变化，如果你比我个头矮，就需要去我左边找到一个正确的位置插队进去。由于都只向单侧插入，最后就会把所有的节点移动到正确的位置之上，这就是 React15 框架内虚拟节点 diff 的逻辑，初步实现了 DOM 的复用；而 Vue 2 借鉴了 snabbdom 的算法，在此基础上做了第一层双端对比的优化。

首先 Web 场景之下对一个数组元素的操作，很少有直接全部替换的，比如操作一个表格，大概率是更关心表格某一行的一个字段、新增一行、删除一行，或者是对表格某个字段进行排序，所以可以从纯算法的场景之中加入实际应用的场景。

如果只是在表格里新增一行，那么可以不要一开始就开始循环，而是可以先进行节点的预判。比如，在下面的例子中，新的节点就是在老的节点中新增和删除了几个元素，在循环之前，先进行头部元素的判断。在这个例子里，可以预判出头部元素的 a、b、c、d 是一样的节点，说明节点不需要重新创建，只需要进行属性的更新，然后进行队尾元素的预判，可以判断出 g、h 元素也是一样的：

```txt
a b c d e f g h
a b c d i f j g h
```

这样虚拟 DOM diff 的逻辑就变成了下面的结构, 现在只需要比较 ef 和 ifg 的区别：

```txt
(a b c d) e f (g h)
(a b c) d) i f j (g h)
```

相比于之前的对比场景，需要遍历的运算量就大大减小了。而且，有很多场景比如新增一行或者删除一行的简单场景，预判完毕之后，新老元素有一个处于没有元素的状态，就可以直接执行 mount 或者 unmount 完成对比的全过程，不需要再进行复杂的遍历：

### 3.6 总结

现在 Vue 执行逻辑全景图变成了下面的样子，新增了组件更新的逻辑：

![Vue执行逻辑全景图.jpeg](./image/Vue%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%E5%85%A8%E6%99%AF%E5%9B%BE.jpeg)

Vue 响应式驱动了组件之间的数据通信机制，数据更新之后，组件会执行 instance.update 方法，update 方法内部执行 patch 方法进行新老子树的 diff 计算。

在更新函数中，主要做了两件事，pathProps 更新节点自身的属性，这里面使用了 pathFlags 做到了按需更新；patchChildren 执行子元素的更新。其中 patch 函数内部会只对节点内部的动态属性做更新，这种按需更新的机制是 Vue 性能优秀的一个原因。

函数内部针对新老子元素不同的状态，执行不同的逻辑。根据子元素是否为空或者数组，以及新元素是否为空或者数组，分别执行对应的删除或者 mount 逻辑，其中最复杂的就是新的子元素和老的子元素都是数组。

为了最大化减少 DOM 操作，patchKeyedChildren 使用了最长递增子序列来实现，并且相比于 React 的虚拟 DOM diff，新增了双端的预先判断 + 最长递增子序列算法来实现，这也是 Vue 性能比较优秀的另外一个原因。
