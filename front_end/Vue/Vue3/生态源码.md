# 生态源码

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [生态源码](#生态源码)
  - [一. 响应式](#一-响应式)
  - [二. 运行时](#二-运行时)
  - [三. 虚拟 DOM](#三-虚拟-dom)
    - [3.1 Vue 虚拟 DOM 执行流程](#31-vue-虚拟-dom-执行流程)
    - [3.2 DOM 的创建](#32-dom-的创建)
    - [3.3 patch 函数](#33-patch-函数)
    - [3.4 patchElement 函数](#34-patchelement-函数)
    - [3.5 patchChildren 的实现](#35-patchchildren-的实现)
    - [3.6 执行逻辑](#36-执行逻辑)
    - [3.7 位运算](#37-位运算)
      - [3.7.1 为什么位运算性能更好](#371-为什么位运算性能更好)
      - [3.7.2 如何运用位运算](#372-如何运用位运算)
    - [3.8 最长递增子序列](#38-最长递增子序列)
      - [3.8.1 贪心 + 二分](#381-贪心-二分)
  - [四. 编译原理](#四-编译原理)
    - [4.1 整体流程](#41-整体流程)
      - [4.1.1 tokenizer 的迷你实现](#411-tokenizer-的迷你实现)
      - [4.1.2 生成抽象语法树](#412-生成抽象语法树)
      - [4.1.3 语义分析和优化](#413-语义分析和优化)
    - [4.2 Vue Compiler 模块解析](#42-vue-compiler-模块解析)

<!-- /code_chunk_output -->

## 一. 响应式

Vue3 的组件之间是通过响应式机制来通知的，响应式机制可以自动收集系统中数据的依赖，并且在修改数据之后自动执行更新，极大提高开发的效率。

响应式机制的主要功能是，可以**把普通的 JS 对象封装成为响应式对象，拦截数据的获取和修改操作，实现依赖数据的自动化更新**。所以，一个最简单的响应式模型，可以通过 reactive 或者 ref 函数，把数据包裹成响应式对象，并且通过 effect 函数注册回调函数，然后在数据修改之后，响应式地通知 effect 去执行回调函数即可。

Vue3 的响应式是可以独立在其他平台使用的。比如可以新建 test.js，使用下面的代码在 node 环境中使用 Vue 响应。以 reactive 为例，使用 reactive 包裹 JS 对象之后，每一次对响应式对象 counter 的修改，都会执行 effect 内部注册的函数：

```js
const { watchEffect, reactive } = require('vue');

const counter = reactive({
  x: 1,
  y: 2
});

watchEffect(() => {
  const perimeter = (counter.x + counter.y) * 2;
  console.log(perimeter);
});

setTimeout(() => {
  counter.x += 1;
});
```

执行文件后，可以看到 watchEffect 内部的函数调用了两次。先来看一下响应式整体的流程图，上面的代码中使用 reactive 把普通的 JS 对象包裹成响应式数据了。

所以，在 effect 中获取 counter.num1 和 counter.num2 的时候，就会触发 counter 的 get 拦截函数；get 函数，会把当前的 effect 函数注册到一个全局的依赖地图中去。这样 counter.num1 在修改的时候，就会触发 set 拦截函数，去依赖地图中找到注册的 effect 函数，然后执行。

![响应式流程图](./image/响应式流程图.webp)

## 二. 运行时

前端框架需要处理的最核心的两个流程，就是首次渲染和数据更新后的渲染。先来看首次渲染的源码。

- **首次渲染**

  想要启动一个 Vue 项目，只需要从 Vue 中引入 createApp，传入 App 组件，并且调用 createApp 返回的 App 实例的 mount 方法，就实现了项目的启动。这个时候 Vue 也完成了首次渲染，代码逻辑如下：

  ![首次渲染代码逻辑](./image/首次渲染代码逻辑.webp)

  所以 createApp 就是项目的初始化渲染入口。可以在 Vue 中的 [runtime-dom](https://github.com/vuejs/core/blob/main/packages/runtime-dom/src/index.ts#L66) 中看到 createApp 的定义。

  首次查看源码的时候，可以先把一些无用的信息删除，方便梳理主体的逻辑。看 Vue 代码，和今天主题无关的无用信息有哪些，`__COMPAT__` 代码是用来兼容 Vue 2 的，`__DEV__` 代码是用来调试的，可以把这些代码删除之后，得到下面的简化版 createApp 源码：

  ```ts
  export const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    // 重写 mount
    app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;

      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = '';
      const proxy = mount(container, false, container instanceof SVGElement);
      if (container instanceof Element) {
        container.removeAttribute('v-cloak');
        container.setAttribute('data-v-app', '');
      }
      return proxy;
    };
    return app;
  };
  // 内部的 normalizeContainer 就是把传递的参数统一变为浏览器的 DOM 元素
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
    }
    return container;
  }
  ```

  再看思路就比较清晰了。使用 ensureRenderer 返回的对象去创建 app，并且重写了 app.mount 方法；在 mount 方法内部，查找 mount 传递的 DOM 元素，并且调用 ensureRenderer 返回的 mount 方法，进行初始化渲染。如下图所示：

  ![首次渲染图示](./image/首次渲染图示.webp)

  **这里 ensureRenderer 函数，内部通过 createRenderer 函数，创建了一个浏览器的渲染器，并且缓存了渲染器 renderer**，这种使用闭包做缓存的方式，在日常开发中也可以借鉴这种思路。

  createRenderer 函数传递的 rendererOptions 就是浏览器里面标签的增删改查 API：

  ```ts
  // 浏览器 dom 操作
  import { nodeOps } from './nodeOps';
  // 浏览器 dom 属性更新
  import { patchProp } from './patchProp';
  import { createRenderer } from '@vue/runtime-core';
  const rendererOptions = extend({ patchProp }, nodeOps);

  let renderer: Renderer<Element | ShadowRoot> | HydrationRenderer;

  function ensureRenderer() {
    return renderer || (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions));
  }
  ```

  可以看到，createRenderer 函数传递的参数是 nodeOps 和 patchProp 的合并对象。继续进入 nodeOps 和 pathProp 也可以看到下面的代码，写了很多方法。通过 ensureRenderer 存储这些操作方法后，createApp 内部就可以脱离具体的渲染平台了，这也是 Vue 3 实现跨端的核心逻辑：

  ```ts
  export const nodeOps: Omit<RendererOptions<Node, Element>, 'patchProp'> = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: child => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, isSVG, is, props): Element => {
      const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : undefined);

      if (tag === 'select' && props && props.multiple != null) {
        (el as HTMLSelectElement).setAttribute('multiple', props.multiple);
      }
      return el;
    },

    createText: text => doc.createTextNode(text),

    createComment: text => doc.createComment(text),

    setText: (node, text) => {
      node.nodeValue = text;
    },

    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: node => node.parentNode as Element | null,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector)
    // ...
  };
  ```

## 三. 虚拟 DOM

### 3.1 Vue 虚拟 DOM 执行流程

在 Vue 中，使用虚拟 DOM 来描述页面的组件，比如下面的 template 虽然格式和 HTML 很像，但是在 Vue 的内部会解析成 JS 函数，这个函数就是用来返回虚拟 DOM：

```xml
<div id="app">
  <p>hello world</p>
  <Rate :value="4"></Rate>
</div>
```

上面的 template 会解析成下面的函数，最终返回一个 JS 的对象能够描述这段 HTML：

```js
function render(){
  return h('div',{id:"app"},children:[
    h('p',{},'hello world'),
    h(Rate,{value:4}),
  ])
}
```

### 3.2 DOM 的创建

上面的 mount 函数中，使用 createVNode 函数创建项目的虚拟 DOM，可以看到 **Vue 内部的虚拟 DOM，也就是 vnode，就是一个对象，通过 type、props、children 等属性描述整个节点**：

```ts
const vnode = createVNode(
  rootComponent as ConcreteComponent,
  rootProps
)
function _createVNode() {

  // 处理属性和 class
  if (props) {
    ...
  }

  // 标记vnode信息
  const shapeFlag = isString(type)
    ? ShapeFlags.ELEMENT
    : __FEATURE_SUSPENSE__ && isSuspense(type)
    ? ShapeFlags.SUSPENSE
    : isTeleport(type)
    ? ShapeFlags.TELEPORT
    : isObject(type)
    ? ShapeFlags.STATEFUL_COMPONENT
    : isFunction(type)
    ? ShapeFlags.FUNCTIONAL_COMPONENT
    : 0

  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  )
}

function createBaseVNode(type,props,children,...){
    const vnode = {
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    children,
    shapeFlag,
    patchFlag,
    dynamicProps,
     ...
  } as VNode
  // 标准化子节点
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children)
  } else if (children) {
    vnode.shapeFlag |= isString(children)
      ? ShapeFlags.TEXT_CHILDREN
      : ShapeFlags.ARRAY_CHILDREN
  }
  return vnode
}componentUpdateFn
```

createVNode 负责创建 Vue 中的虚拟 DOM，而 mount 函数的核心逻辑就是使用 setupComponent 执行写的 `<script setup>`，使用 setupRenderEffect 监听组件的数据变化。所以会到 setupRenderEffect 函数中，去完整地剖析 Vue 中虚拟 DOM 的更新逻辑。

给组件注册了 update 方法，这个方法使用 effect 包裹后，当组件内的 ref、reactive 包裹的响应式数据变化的时候就会执行 update 方法，触发组件内部的更新机制。

看下面的代码，在 setupRenderEffect 内部的 componentUpdateFn 中，updateComponentPreRenderer 更新了属性和 slots，并且调用 renderComponentRoot 函数创建新的子树对象 nextTree，然后内部依然是调用 patch 函数。可以看到，**Vue 源码中的实现首次渲染和更新的逻辑都写在一起，在递归的时候如果对一个标签实现更新和渲染，就可以用一个函数实现**。

```ts
const componentUpdateFn = ()=>{
  if (!instance.isMounted) {
    // 首次渲染
    instance,
    parentSuspense,
    isSVG
    // ...
  }else{
    let { next, bu, u, parent, vnode } = instance
    if (next) {
      next.el = vnode.el
      updateComponentPreRender(instance, next, optimized)
    } else {
      next = vnode
    }
    const nextTree = renderComponentRoot(instance)
      patch(
        prevTree,
        nextTree,
        // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el!)!,
        // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree),
        instance,
        parentSuspense,
        isSVG
      )
    }
}

// 注册effect函数
const effect = new ReactiveEffect(
  componentUpdateFn,
  () => queueJob(instance.update),
  instance.scope // track it in component's effect scope
)
const update = (instance.update = effect.run.bind(effect) as S      chedulerJob)
update()

  const updateComponentPreRender = (
    instance: ComponentInternalInstance,
    nextVNode: VNode,
    optimized: boolean
  ) => {
    nextVNode.component = instance
    const prevProps = instance.vnode.props
    instance.vnode = nextVNode
    instance.next = null
    updateProps(instance, nextVNode.props, prevProps, optimized)
    updateSlots(instance, nextVNode.children, optimized)

    pauseTracking()
    // props update may have triggered pre-flush watchers.
    // flush them before the render update.
    flushPreFlushCbs(undefined, instance.update)
    resetTracking()
  }
```

比较关键的就是上面代码中的 **effect 函数，负责注册组件，这个函数也是 Vue 组件更新的入口函数**。

### 3.3 patch 函数

数据更新之后就会执行 patch 函数，下图就是 patch 函数执行的逻辑图：

![patch函数执行逻辑图](./image/patch%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%E5%9B%BE.webp)

在 patch 函数中，会针对不同的组件类型执行不同的函数，组件会执行 processComponent，HTML 标签会执行 processElement：

```ts
function path(n1, n2, container) {
  const { type, shapeFlag } = n2;
  switch (type) {
    case Text:
      processText(n1, n2, container);
      break;
    // 还有注释，fragment之类的可以处理，这里忽略
    default:
      // 通过shapeFlag判断类型
      if (shapeFlag & ShapeFlags.ELEMENT) {
        processElement(n1, n2, container, anchor);
      } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
        processComponent(n1, n2, container);
      }
  }
}

function processComponent(n1, n2, container) {
  // 老规矩，么有n1就是mount
  if (!n1) {
    // 初始化 component
    mountComponent(n2, container);
  } else {
    updateComponent(n1, n2, container);
  }
}
```

由于更新之后不是首次渲染了，patch 函数内部会执行 updateComponent，看下面的 updateComponent 函数内部，shouldUpdateComponent 会判断组件是否需要更新，实际执行的是 instance.update：

```ts
const instance = (n2.component = n1.component)!;
if (shouldUpdateComponent(n1, n2, optimized)) {
  // 正常更新
  instance.next = n2;
  // 如果子组件也已排队，请将其删除，以避免在同一刷新中重复更新同一子组件。
  invalidateJob(instance.update);
  // instance.update is the reactive effect.
  instance.update();
} else {
  // 无需更新。只需复制属性
  n2.component = n1.component;
  n2.el = n1.el;
  instance.vnode = n2;
}
```

组件的子元素是由 HTML 标签和组件构成，组件内部的递归处理最终也是对 HTML 标签的处理，所以，最后组件的更新都会进入到 processElement 内部的 patchElement 函数中。

### 3.4 patchElement 函数

在函数 patchElement 中主要就做两件事：

- **节点自身属性的更新**

  这里就能体现出 Vue 3 中性能优化的思想，通过 patchFlag 可以做到按需更新：

  - 如果标记了 FULL_PROPS，就直接调用 patchProps。
  - 如果标记了 CLASS，说明节点只有 class 属性是动态的，其他的 style 等属性都不需要进行判断和 DOM 操作。

  这样就极大的优化了属性操作的性能。

  内部执行 hostPatchProp 进行实际的 DOM 操作，Vue 3 的虚拟 DOM 真正做到了按需更新，这也是相比于 React 的一个优势。

  ```ts
  const patchElement = (
    n1: VNode,
    n2: VNode,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    slotScopeIds: string[] | null,
    optimized: boolean
  ) => {
    const el = (n2.el = n1.el!);
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS;

    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;

    // full diff
    patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);

    if (patchFlag > 0) {
      if (patchFlag & PatchFlags.FULL_PROPS) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        // class是动态的
        if (patchFlag & PatchFlags.CLASS) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, 'class', null, newProps.class, isSVG);
          }
        }

        // style样式是动态的
        if (patchFlag & PatchFlags.STYLE) {
          hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
        }

        // 属性需要diff
        if (patchFlag & PatchFlags.PROPS) {
          //
          const propsToUpdate = n2.dynamicProps!;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            // #1471 force patch value
            if (next !== prev || key === 'value') {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n1.children as VNode[],
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      //文本是动态的
      if (patchFlag & PatchFlags.TEXT) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children as string);
        }
      }
    }
  };
  ```

- **更新子元素**

  子元素的更新是 patchChildren 函数负责的，这个函数也是虚拟 DOM 中难度最高的一个函数，搞懂它还需要下一讲中的算法知识，先理解它主要的实现思路。<!-- TODO -->

  首先把子元素分成了文本、数组和空三个状态，新老子元素分别是这三种状态的一个，构成了不同的执行逻辑。这样 patchChildren 内部大致有五种情况需要处理：

  - 如果新的子元素是空，老的子元素不为空，直接卸载 unmount 即可。
  - 如果新的子元素不为空，老的子元素是空，直接创建加载即可。
  - 如果新的子元素是文本，老的子元素如果是数组就需要全部 unmount，是文本的话就需要执行 hostSetElementText。
  - 如果新的子元素是数组，比如是使用 v-for 渲染出来的列表，老的子元素如果是空或者文本，直接 unmount 后，渲染新的数组即可。

  - 最复杂的情况就是新的子元素和老的子元素都是数组。

    最朴实无华的思路就是把老的子元素全部 unmount，新的子元素全部 mount，这样虽然可以实现功能，但是没法复用已经存在的 DOM 元素。所以，需要判断出可以复用的 DOM 元素，如果一个虚拟 DOM 没有改动或者属性变了，不需要完全销毁重建，而是更新一下属性，最大化减少 DOM 的操作，这个任务就会交给 patchKeyedChildren 函数去完成。

    patchKeyedChildren 函数，做的事情就是尽可能高效地把老的子元素更新成新的子元素，如何高效复用老的子元素中的 DOM 元素是 patchKeyedChildren 函数的难点：

    ```ts
    const patchChildren: PatchChildrenFn = (
      n1,
      n2,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized = false
    ) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;

      const { patchFlag, shapeFlag } = n2;
      // 快速路径
      if (patchFlag > 0) {
        if (patchFlag & PatchFlags.KEYED_FRAGMENT) {
          // 这可以是完全键控的，也可以是混合键控的（有些键控了，有些没有）patchFlag的存在意味着子级保证是数组
          patchKeyedChildren(
            c1 as VNode[],
            c2 as VNodeArrayChildren,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) {
          // unkeyed
          patchUnkeyedChildren(
            c1 as VNode[],
            c2 as VNodeArrayChildren,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          return;
        }
      }

      // children 有 3 种可能：文本、数组或无子级。
      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
        // 文本子项快速路径
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          unmountChildren(c1 as VNode[], parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2 as string);
        }
      } else {
        if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          // prev children was array
          if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
            // 两个数组，不能假设任何内容，执行完全差异
            patchKeyedChildren(
              c1 as VNode[],
              c2 as VNodeArrayChildren,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            // 没有新的 children，就卸载旧的
            unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true);
          }
        } else {
          // 上一个子项为文本或空
          // 新的 children 为 array 或 null
          if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
            hostSetElementText(container, '');
          }
          // mount new if array
          if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
            mountChildren(
              c2 as VNodeArrayChildren,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    ```

    上面的代码执行逻辑如下图所示，根据 flags 判断子元素的类型后，执行不同的操作函数：

    ![patchChildren执行逻辑.webp](./image/patchChildren%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.webp)

### 3.5 patchChildren 的实现

patchChildren 是各类虚拟 DOM 框架中最难实现的函数，需要实现**一个高效的更新算法，能够使用尽可能少的更新次数，来实现从老的子元素到新的子元素的更新**。

类似体育课站队的时候，大家一开始站一排，但是顺序是乱的，需要尽快把队伍按照个头左低右高排列。

在 React 中，这种场景的处理逻辑是先进行循环，使用的是单侧插入的算法，在排队的时候挨个对比，如果你站我右边，并且个头比我高一点，说明咱俩的相对位置和最终队伍的位置是一致的，暂时不需要变化，如果你比我个头矮，就需要去我左边找到一个正确的位置插队进去。由于都只向单侧插入，最后就会把所有的节点移动到正确的位置之上，这就是 React15 框架内虚拟节点 diff 的逻辑，初步实现了 DOM 的复用；而 Vue 2 借鉴了 snabbdom 的算法，在此基础上做了第一层双端对比的优化。

首先 Web 场景之下对一个数组元素的操作，很少有直接全部替换的，比如操作一个表格，大概率是更关心表格某一行的一个字段、新增一行、删除一行，或者是对表格某个字段进行排序，所以可以从纯算法的场景之中加入实际应用的场景。

如果只是在表格里新增一行，那么可以不要一开始就开始循环，而是可以先进行节点的预判。比如，在下面的例子中，新的节点就是在老的节点中新增和删除了几个元素，在循环之前，先进行头部元素的判断。在这个例子里，可以预判出头部元素的 a、b、c、d 是一样的节点，说明节点不需要重新创建，只需要进行属性的更新，然后进行队尾元素的预判，可以判断出 g、h 元素也是一样的：

```txt
a b c d e f g h
a b c d i f j g h
```

这样虚拟 DOM diff 的逻辑就变成了下面的结构, 现在只需要比较 ef 和 ifg 的区别：

```txt
(a b c d) e f (g h)
(a b c) d) i f j (g h)
```

相比于之前的对比场景，需要遍历的运算量就大大减小了。而且，有很多场景比如新增一行或者删除一行的简单场景，预判完毕之后，新老元素有一个处于没有元素的状态，就可以直接执行 mount 或者 unmount 完成对比的全过程，不需要再进行复杂的遍历：

### 3.6 执行逻辑

现在 Vue 执行逻辑全景图变成了下面的样子，新增了组件更新的逻辑：

![Vue执行逻辑全景图.jpeg](./image/Vue%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%E5%85%A8%E6%99%AF%E5%9B%BE.jpeg)

Vue 响应式驱动了组件之间的数据通信机制，数据更新之后，组件会执行 instance.update 方法，update 方法内部执行 patch 方法进行新老子树的 diff 计算。

在更新函数中，主要做了两件事：

1. pathProps 更新节点自身的属性，这里面使用了 pathFlags 做到了按需更新
2. patchChildren 执行子元素的更新。其中 patch 函数内部会只对节点内部的动态属性做更新，这种按需更新的机制是 Vue 性能优秀的一个原因。

函数内部针对新老子元素不同的状态，执行不同的逻辑。根据子元素是否为空或者数组，以及新元素是否为空或者数组，分别执行对应的删除或者 mount 逻辑，其中最复杂的就是新的子元素和老的子元素都是数组。

为了最大化减少 DOM 操作，patchKeyedChildren 使用了[最长递增子序列](#38-最长递增子序列)来实现，并且相比于 React 的虚拟 DOM diff，新增了双端的预先判断 + 最长递增子序列算法来实现，这也是 Vue 性能比较优秀的另外一个原因。

### 3.7 位运算

在执行 diff 之前，要根据需要判断每个虚拟 DOM 节点有哪些属性需要计算，因为无论响应式数据怎么变化，静态的属性和节点都不会发生变化。

所以看每个节点 diff 的时候会做什么，在 renderer.ts 代码文件中就可以看到代码，主要就是**通过虚拟 DOM 节点的 patchFlag 树形判断是否需要更新节点**。

**方法就是使用 & 操作符来判断操作的类型**，比如 patchFlag & PatchFlags.CLASS 来判断当前元素的 class 是否需要计算 diff；shapeFlag & ShapeFlags.ELEMENT 来判断当前虚拟 DOM 是 HTML 元素还是 Component 组件。这个 `&` 其实就是位运算的按位与。

```ts
// class
// 当元素具有动态类绑定时，将匹配此标志。
if (patchFlag & PatchFlags.CLASS) {
  if (oldProps.class !== newProps.class) {
    hostPatchProp(el, 'class', null, newProps.class, isSVG);
  }
}

// style
// 当元素具有动态样式绑定时，匹配此标志
if (patchFlag & PatchFlags.STYLE) {
  hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
}
if (shapeFlag & ShapeFlags.ELEMENT) {
  processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
} else if (shapeFlag & ShapeFlags.COMPONENT) {
  processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
}
```

上面的代码中 & 就是按位与的操作符，这其实是二进制上的计算符号。

日常使用的数字都是十进制数字，比如数字 13 就是 `1*10+3` 的运算结果，每个位置都是代表 10 的 n 次方。13 也可以使用二进制表达，因为二进制每个位置只能是 0 和 1 两个数字，每个位置代表的是 2 的 n 次方，13 在二进制里是 1101，就是 `1*8+1*4+0*2+1*1`。

在 JS 中可以很方便地使用 toString(2) 的方式，把十进制数字转换成二进制。运算的概念很简单，就是在二进制上的“与”和“或”运算：

```js
(13).toString(2); // 1101

0 & 0; // 0
0 & 1; // 0
1 & 0; // 0
1 & 1; // 1

0 | 0; // 0
0 | 1; // 1
1 | 0; // 1
1 | 1; // 1

1 << 2; // 1左移动两位，就是100  就是1*2平方 = 4
```

二进制中，每个位置只能是 0 或者 1，& 和 | 的概念和 JS 中的 && 和 || 保持一致。两个二进制的 & 运算就是只有两个二进制位置都是 1 的时候，结果是 1，其余情况运算结果都是 0；| 是按位置进行 “或” 运算，只有两个二进制位置都是 0 的时候，结果是 0，其余情况运算结果都是 1；并且，还可以通过左移 << 和右移 >> 操作符，实现乘以 2 和除以 2 的效果。

由于**这些都是在二进制上的计算，运算的性能通常会比字符串和数字的计算性能要好**，这也是很多框架内部使用位运算的原因。

#### 3.7.1 为什么位运算性能更好

下面是 LeetCode231 题，判断数字 n 是不是 2 的幂次方，也就是说，判断数字 n 是不是 2 的整次方，比如 2、4、8。写出 JS 的解答，n 一直除以 2，如果有余数就是 false，否则就是 true：

```js
let isPowerOfTwo = function (n) {
  if (n === 1) return true;
  while (n > 2) {
    n = n / 2;
    if (n % 2 !== 0) return false;
  }
  return n === 2;
};
```

不过上面的解答可以用位运算来优化。先来分析一下 2 的幂次方的特点。2 的幂次方就是数字 1 左移动若干次，其余位置全部都是 0，所以 n-1 就是最高位变成 0，其余位置都变成 1，就像十进制里的 10000-1 = 9999。这样，n 和 n-1 每个二进制位的数字都不一样，可以用按位 “与” 来判断这个题的答案，如果 n&n-1 是 0 的话，数字 n 就符合 2 的整次幂的特点：

```js
// 16
// 10000
// 16-1 = 15
// 01111
// 16&15 = 0
let isPowerOfTwo = function (n) {
  return n > 0 && (n & (n - 1)) === 0;
};
```

#### 3.7.2 如何运用位运算

在 diff 判断，如何根据位运算的特点，设计出权限的组合认证方案。比如 Vue 中的动态属性，有文本、class、style、props 几个属性，可以使用二进制中的一个位置来表示权限，看下面的代码，使用左移的方式分别在四个二进制上标记了 1，代表四种不同的权限，使用按位或的方式去实现权限授予。

比如，一个节点如果 TEXT 和 STYLE 都需要修改，只需要使用 | 运算符就可以得到 flag1 的权限表示，这就是为什么 Vue 3 中针对虚拟 DOM 类型以及虚拟 DOM 需要动态计算 diff 的树形都做了标记，可以在 [Vue 3 的源码](https://github.com/vuejs/vue-next/blob/master/packages/shared/src/patchFlags.ts#L28)中看到下面的配置：

```ts
const PatchFlags = {
  TEXT: 1, // 0001
  CLASS: 1 << 1, // 0010
  STYLE: 1 << 2, // 0100
  PROPS: 1 << 3 // 1000
};

const flag1 = PatchFlags.TEXT | PatchFlags.STYLE; // 0101

// 权限校验

flag1 & PatchFlags.TEXT; // 有权限，结果大于1
flag1 & PatchFlags.CLASS; // 没有权限是 0
```

### 3.8 最长递增子序列

在虚拟 diff 计算中，如果新老子元素都是数组的时候，需要先做首尾的预判，如果新的子元素和老的子元素在预判完毕后，未处理的元素依然是数组，那么就需要对两个数组计算 diff，最终找到最短的操作路径，能够让老的子元素通过尽可能少的操作，更新成为新的子元素。

Vue 3 借鉴了 infero 的算法逻辑，就像操场上需要按照个头从低到高站好一样，采用的思路是先寻找一个现有队列中由低到高的队列，让这个队列尽可能的长，它们的相对位置不需要变化，而其他元素进行插入和移动位置，这样就可以做到尽可能少的操作 DOM。

看 [LeetCode 第 300 题](https://leetcode.cn/problems/longest-increasing-subsequence/)，题目描述如下, 需要在数组中找到最长底层的自序列长度：

```txt
给你一个整数数组 nums，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

=
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

首先可以使用动态规划的思路，通过每一步的递推，使用 dp 数组，记录出每一步操作的最优解，最后得到全局最优解。

在这个例子中，可以把 dp[i] 定义成 nums[0] 到 nums[i] 这个区间内，数组的最长递增子序列的长度，并且 dp 数组的初始值设为 1。

从左边向右递推，如果 nums[i+1]>nums[i]，dp[i+1]就等于 dp[i]+1；如果 nums[i+1] < nums[i]，就什么都不需要干，这样在遍历的过程中，就能根据数组当前位置之前的最长递增子序列长度推导出 i+1 位置的最长递增子序列长度。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
const lengthOfLIS = nums => {
  let n = nums.length;
  if (n === 0) return 0;

  let dp = new Array(n).fill(1);
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  return Math.max(...dp);
};
```

由于需要两层循环，所以这个解法的时间复杂度是 n 的平方，这个解法其实已经不错了，但是还有更优秀的解法，也就是 Vue 3 中用到的算法：贪心 + 二分。

#### 3.8.1 贪心 + 二分

贪心的思路就是在寻找最长递增的序列，所以，[1, 3] 要比 [1, 5] 好，也就是说，在这个上升的序列中，要让上升速度尽可能变得慢，这样才有可能让后面的元素尽可能也递增。

可以创建一个 arr 数组，用来保存这种策略下的最长递增子序列。如果当前遍历的 nums[i] 大于 arr 的最后一个元素，也就是大于 arr 的最大值时，把 nums[i] 追加到后面即可，否则就在 arr 中寻找一个第一个大于 num[i] 的数字并替换它。因为是 arr 是递增的数列，所以在寻找插入位置的时候，可以使用二分查找的方式，把整个算法的复杂度变成 O(nlgn)。

下面的代码就是贪心 + 二分的解法，可以得到正确的最长递增子序列的长度：

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
const lengthOfLIS = nums => {
  let len = nums.length;
  if (len <= 1) return len;

  let arr = [nums[0]];
  for (let i = 0; i < len; i++) {
    // nums[i] 大于 arr 尾元素时，直接追加到后面，递增序列长度+1
    if (nums[i] > arr[arr.length - 1]) {
      arr.push(nums[i]);
    } else {
      // 否则，查找递增子序列中第一个大于 nums[i] 的元素替换它
      // 递增序列，可以使用二分查找
      let left = 0;
      let right = arr.length - 1;
      while (left < right) {
        let mid = (left + right) >> 1;
        if (arr[mid] < nums[i]) {
          left = mid + 1;
        } else {
          right = mid;
        }
      }
      arr[left] = nums[i];
    }
  }
  return arr.length;
};
```

但是贪心 + 二分的这种解法，现在只能得到最长递增子序列的长度，但是最后得到的 arr 并不一定是最长递增子序列，因为移动的 num[i] 位置可能会不正确，只是得到的数组长度是正确的，所以需要对这个算法改造一下，把整个数组复制一份之后，最后也能得到正确的最长递增子序列。具体代码可以看 Vue 3 的 renderer.ts 文件中，函数 [getSequence](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/renderer.ts#L2409) 就是用来生成最长递增子序列，看下面的代码：

```ts
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr: number[]): number[] {
  const p = arr.slice(); // 赋值一份 arr
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j; // 存储在 result 最后一个索引的值
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      // 二分查找，查找比 arrI 小的节点，更新 result 的值
      while (u < v) {
        c = (u + v) >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  // 查找数组 p 找到最终的索引
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
```

这段代码就是 Vue 3 里的实现，result 存储的就是长度是 i 的递增子序列最小末位置的索引，最后计算出最长递增子序列。得到 increasingNewIndexSequence 队列后，再去遍历数组进行 patch 操作就可以实现完整的 diff 流程了：

```ts
for (i = toBePatched - 1; i >= 0; i--) {
  const nextIndex = s2 + i;
  const nextChild = c2[nextIndex] as VNode;
  const anchor = nextIndex + 1 < l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor;
  if (newIndexToOldIndexMap[i] === 0) {
    // mount new
    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
  } else if (moved) {
    // move if:
    // There is no stable subsequence (e.g. a reverse)
    // OR current node is not among the stable sequence
    if (j < 0 || i !== increasingNewIndexSequence[j]) {
      move(nextChild, container, anchor, MoveType.REORDER);
    } else {
      j--;
    }
  }
}
```

上面代码的思路，用下图演示。做完双端对比之后，a 和 g 已经计算出可以直接复用 DOM，剩下的队列中需要把 hbfdc 更新成 abdef。

1. 首先需要**使用 keyToNewIndexMap 存储新节点中每个 key 对应的索引**，比如下图中 key 是 c 的元素的索引就是 2
2. 然后**计算出 newIndexOldIndexMap 存储这个 key 在老的子元素中的位置**，可以根据 c 的索引是 2，在 newIndexOldIndexMap 中查询到在老的子元素的位置是 6

![Vue diff 流程](./image/Vue%20diff%20%E6%B5%81%E7%A8%8B.webp)

## 四. 编译原理

在 Vue 中，组件都是以虚拟 DOM 的形式存在，加载完毕之后注册 effect 函数。这样组件内部的数据变化之后，用 Vue 的响应式机制做到了通知组件更新，内部则使用 patch 函数实现了虚拟 DOM 的更新。那虚拟 DOM 是从哪来的？明明写的是 template 和 JSX，这就是 Vue 源码最后一个难点：Vue 中的 Compiler。下图就是 Vue 核心模块依赖关系图：

![Vue 核心模块依赖关系图](./image/Vue%20%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%9B%BE.webp)

编译原理也属于计算机中的一个重要学科，Vue 的 compiler 是在 Vue 场景下的实现，目的就是实现 template 到 render 函数的转变。Vue 官方提供了模板编译的[在线演示](https://vue-next-template-explorer.netlify.app/#eyJzcmMiOiI8ZGl2IGlkPVwiYXBwXCI+XG4gICAgPGRpdiBAY2xpY2s9XCIoKT0+Y29uc29sZS5sb2coeHgpXCIgOmlkPVwibmFtZVwiPnt7bmFtZX19PC9kaXY+XG4gICAgPGgxIDpuYW1lPVwidGl0bGVcIj7njqnovax2dWUzPC9oMT5cbiAgICA8cCA+57yW6K+R5Y6f55CGPC9wPlxuPC9kaXY+XG4iLCJzc3IiOmZhbHNlLCJvcHRpb25zIjp7ImhvaXN0U3RhdGljIjp0cnVlLCJjYWNoZUhhbmRsZXJzIjp0cnVlLCJvcHRpbWl6ZUJpbmRpbmdzIjpmYWxzZX19)。

### 4.1 整体流程

转化的过程可以分为下面的示意图几步来实现：

首先，代码会被解析成一个对象，这个对象有点像虚拟 DOM 的概念，用来描述 template 的代码关系，这个对象就是抽象语法树（AST）。然后通过 transform 模块对代码进行优化，比如识别 Vue 中的语法，静态标记、最后通过 generate 模块生成最终的 render 函数。

![Vue 编译整体流程](./image/Vue%20%E7%BC%96%E8%AF%91%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.webp)

用下面的代码就能实现上述的流程图里的内容。其中 parse 函数负责生成抽象语法树 AST，transform 函数负责语义转换，generate 函数负责最终的代码生成：

```js
function compiler(template) {
  const ast = parse(template);
  transform(ast);
  const code = generate(ast);
  return code;
}

let template = `<div id="app">
  <div @click="()=>console.log(xx)" :id="name">{{name}}</div>
  <h1 :name="title">玩转vue3</h1>
  <p>编译原理</p>
</div>
`;

const renderFunction = compiler(template);
console.log(renderFunction);
```

#### 4.1.1 tokenizer 的迷你实现

parse 函数首先，要对 template 进行词法分析，把模板中的 `<div>`, @click, {{}} 等语法识别出来，转换成一个个的 token。可以理解为把 template 的语法进行了分类，这一步叫 tokenizer。

下面的代码就是 tokenizer 的迷你实现。使用 tokens 数组存储解析的结果，然后对模板字符串进行循环，在 template 中，< > / 和空格都是关键的分隔符，如果碰见 < 字符，需要判断下一个字符的状态。如果是字符串就标记 tagstart；如果是 / 就知道是结束标签，标记为 tagend，最终通过 push 方法把分割之后的 token 存储在数组 tokens 中返回。

```ts
function tokenizer(input) {
  let tokens = [];
  let type = '';
  let val = '';
  // 粗暴循环
  for (let i = 0; i < input.length; i++) {
    let ch = input[i];
    if (ch === '<') {
      push();
      if (input[i + 1] === '/') {
        type = 'tagend';
      } else {
        type = 'tagstart';
      }
    }
    if (ch === '>') {
      if (input[i - 1] == '=') {
        //箭头函数
      } else {
        push();
        type = 'text';
        continue;
      }
    } else if (/[\s]/.test(ch)) {
      // 碰见空格截断一下
      push();
      type = 'props';
      continue;
    }
    val += ch;
  }
  return tokens;

  function push() {
    if (val) {
      if (type === 'tagstart') val = val.slice(1); // <div => div
      if (type === 'tagend') val = val.slice(2); //  </div  => div
      tokens.push({
        type,
        val
      });
      val = '';
    }
  }
}
```

#### 4.1.2 生成抽象语法树

下面的数组中，分别用 tagstart、props tagend 和 text 标记，用它们标记了全部内容。然后下一步需要把这个数组按照标签的嵌套关系转换成树形结构，这样才能完整地描述 template 标签的关系。

```ts
[
  { type: 'tagstart', val: 'div' },
  { type: 'props', val: 'id="app"' },
  { type: 'tagstart', val: 'div' },
  { type: 'props', val: '@click="()=console.log(xx)"' },
  { type: 'props', val: ':id="name"' },
  { type: 'text', val: '{{name}}' },
  { type: 'tagend', val: 'div' },
  { type: 'tagstart', val: 'h1' },
  { type: 'props', val: ':name="title"' },
  { type: 'text', val: '玩转vue3' },
  { type: 'tagend', val: 'h1' },
  { type: 'tagstart', val: 'p' },
  { type: 'text', val: '编译原理' },
  { type: 'tagend', val: 'p' },
  { type: 'tagend', val: 'div' }
];
```

然后分析 token 数组，看看它是如何转化成一个体现语法规则的树形结构的。就像用虚拟 DOM 描述页面 DOM 结构一样，使用树形结构描述 template 的语法，这个树称之为抽象语法树，简称 AST。

下面的代码中用 parse 函数实现 AST 的解析。过程是这样的，首先使用一个 AST 对象作为根节点。然后通过 walk 函数遍历整个 tokens 数组，根据 token 的类型不同，生成不同的 node 对象。最后根据 tagend 的状态来决定 walk 的递归逻辑，最终实现了整棵树的构建：

```ts
function parse(template) {
  const tokens = tokenizer(template);
  let cur = 0;
  let ast = {
    type: 'root',
    props: [],
    children: []
  };
  while (cur < tokens.length) {
    ast.children.push(walk());
  }
  return ast;

  function walk() {
    let token = tokens[cur];
    if (token.type == 'tagstart') {
      let node = {
        type: 'element',
        tag: token.val,
        props: [],
        children: []
      };
      token = tokens[++cur];
      while (token.type !== 'tagend') {
        if (token.type == 'props') {
          node.props.push(walk());
        } else {
          node.children.push(walk());
        }
        token = tokens[cur];
      }
      cur++;
      return node;
    }
    if (token.type === 'tagend') {
      cur++;
      // return token
    }
    if (token.type == 'text') {
      cur++;
      return token;
    }
    if (token.type === 'props') {
      cur++;
      const [key, val] = token.val.replace('=', '~').split('~');
      return {
        key,
        val
      };
    }
  }
}
```

上面的代码会生成抽象语法树 AST，这个树的结构如下面代码所示，通过 type 和 children 描述整个 template 的结构：

```json
{
  "type": "root",
  "props": [],
  "children": [
    {
      "type": "element",
      "tag": "div",
      "props": [
        {
          "key": "id",
          "val": "\"app\""
        }
      ],
      "children": [
        {
          "type": "element",
          "tag": "div",
          "props": [
            {
              "key": "@click",
              "val": "\"()"
            },
            {
              "key": ":id",
              "val": "\"name\""
            }
          ],
          "children": [
            {
              "type": "text",
              "val": "{{name}}"
            }
          ]
        },
        {
          "type": "element",
          "tag": "h1",
          "props": [
            {
              "key": ":name",
              "val": "\"title\""
            }
          ],
          "children": [
            {
              "type": "text",
              "val": "玩转vue3"
            }
          ]
        },
        {
          "type": "element",
          "tag": "p",
          "props": [],
          "children": [
            {
              "type": "text",
              "val": "编译原理"
            }
          ]
        }
      ]
    }
  ]
}
```

#### 4.1.3 语义分析和优化

有了抽象语法树之后，还要进行语义的分析和优化，也就是说，要在这个阶段理解语句要做的事。

1. 在 template 这个场景下，两个大括号包裹的字符串就是变量，@click 就是事件监听。下面的代码中使用 transform 函数实现这个功能，这一步主要是理解 template 中 Vue 的语法，并且为最后生成的代码做准备。使用 context 对象存储 AST 所需要的上下文，如果用到了变量 {{}}，就需要引入 toDisplayString 函数，上下文中的 helpers 存储的就是用到的工具函数。

   ```ts
   function transform(ast) {
     // 优化一下ast
     let context = {
       // import { toDisplayString , createVNode , openBlock , createBlock } from "vue"
       helpers: new Set(['openBlock', 'createVnode']) // 用到的工具函数
     };
     traverse(ast, context);
     ast.helpers = context.helpers;
   }
   ```

2. 然后使用 traverse 函数递归整个 AST，去优化 AST 的结构，并且在这一步实现简单的静态标记。当节点标记为 element 的时候，递归调用整个 AST，内部挨个遍历 AST 所有的属性，默认使用 ast.flag 标记节点的动态状态：

   - 如果属性是 @ 开头的，就认为它是 Vue 中的事件绑定，使用 arg.flag|= PatchFlags.EVENT 标记当前节点的事件是动态的，需要计算 diff。
   - 冒号开头的就是动态的属性传递，并且把 class 和 style 标记了不同的 flag。
   - 如果都没有命中的话，就使用 static:true，标记当前节点位是静态节点。

   ```ts
   function traverse(ast, context) {
     switch (ast.type) {
       case 'root':
         context.helpers.add('createBlock');
       // log(ast)
       case 'element':
         ast.children.forEach(node => {
           traverse(node, context);
         });
         ast.flag = 0;
         ast.props = ast.props.map(prop => {
           const { key, val } = prop;
           if (key[0] == '@') {
             ast.flag |= PatchFlags.EVENT; // 标记event需要更新
             return {
               key: 'on' + key[1].toUpperCase() + key.slice(2),
               val
             };
           }
           if (key[0] == ':') {
             const k = key.slice(1);
             if (k == 'class') {
               ast.flag |= PatchFlags.CLASS; // 标记class需要更新
             } else if (k == 'style') {
               ast.flag |= PatchFlags.STYLE; // 标记style需要更新
             } else {
               ast.flag |= PatchFlags.PROPS; // 标记props需要更新
             }
             return {
               key: key.slice(1),
               val
             };
           }
           if (key.startsWith('v-')) {
             // pass such as v-model
           }
           // 标记 static 是 true 静态节点
           return { ...prop, static: true };
         });
         break;
       case 'text':
         // transformText
         let re = /\{\{(.*)\}\}/g;
         if (re.test(ast.val)) {
           // 有 {{
           ast.flag |= PatchFlags.TEXT; // 标记 props 需要更新
           context.helpers.add('toDisplayString');
           ast.val = ast.val.replace(/\{\{(.*)\}\}/g, function (s0, s1) {
             return s1;
           });
         } else {
           ast.static = true;
         }
     }
   }
   ```

3. 经过上面的代码标记优化之后，项目在数据更新之后，浏览器计算虚拟 dom diff 运算的时候，就会执行类似下面的代码逻辑。

   **通过在 compiler 阶段的标记，让 template 产出的虚拟 DOM 有了更精确的状态，可以越过大部分的虚拟 DOM 的 diff 计算，极大提高 Vue 的运行时效率，这个思想日常开发中也可以借鉴学习**。

   ```js
   if (vnode.static) {
     return;
   }
   if (vnode.flag & patchFlag.CLASS) {
     // 遍历 class 计算 diff
   } else if (vnode.flag & patchFlag.STYLE) {
     // 计算 style 的 diff
   } else if (vnode.flag & patchFlag.TEXT) {
     // 计算文本的 diff
   }
   ```

4. 接下来，基于优化之后的 AST 生成目标代码，也就是 generate 函数要做的事：遍历整个 AST，拼接成最后要执行的函数字符串。

   下面的代码中，首先把 helpers 拼接成 import 语句，并且使用 walk 函数遍历整个 AST，在遍历的过程中收集 helper 集合的依赖。最后，在 createVnode 的最后一个参数带上 ast.flag 进行状态的标记：

   ```ts
   function generate(ast) {
     const { helpers } = ast;

     let code = `
   import {${[...helpers].map(v => v + ' as _' + v).join(',')}} from 'vue'\n
   export function render(_ctx, _cache, $props){
     return(_openBlock(), ${ast.children.map(node => walk(node))})}`;

     function walk(node) {
       switch (node.type) {
         case 'element':
           let { flag } = node; // 编译的标记
           let props =
             '{' +
             node.props
               .reduce((ret, p) => {
                 if (flag.props) {
                   //动态属性
                   ret.push(p.key + ':_ctx.' + p.val.replace(/['"]/g, ''));
                 } else {
                   ret.push(p.key + ':' + p.val);
                 }

                 return ret;
               }, [])
               .join(',') +
             '}';
           return `_createVnode("${node.tag}",${props}),[
             ${node.children.map(n => walk(n))}
           ],${JSON.stringify(flag)}`;
           break;
         case 'text':
           if (node.static) {
             return '"' + node.val + '"';
           } else {
             return `_toDisplayString(_ctx.${node.val})`;
           }
           break;
       }
     }
     return code;
   }
   ```

5. 最后执行一下代码，看下效果输出的代码。可以看到，它已经和 Vue 输出的代码很接近了，这个产出的 render 函数最终会和组件的 setup 函数一起组成运行时的组件对象。

   ```ts
   function compiler(template) {
     const ast = parse(template);
     transform(ast);

     const code = generate(ast);
     return code;
   }

   let template = `<div id="app">
      <div @click="()=>console.log(xx)" :id="name">{{name}}</div>
      <h1 :name="title">玩转vue3</h1>
      <p >编译原理</p>
    </div>
    `;

   const renderFunction = compiler(template);
   console.log(renderFunction);

   // 下面是输出结果
   import {
     openBlock as _openBlock,
     createVnode as _createVnode,
     createBlock as _createBlock,
     toDisplayString as _toDisplayString
   } from 'vue';

   export function render(_ctx, _cache, $props) {
     return (
       _openBlock(),
       _createVnode('div', { id: 'app' }),
       [
         _createVnode('div', { onClick: '()=>console.log(xx)', id: 'name' }),
         [_toDisplayString(_ctx.name)],
         24,
         _createVnode('h1', { name: 'title' }),
         ['玩转vue3'],
         8,
         _createVnode('p', {}),
         ['编译原理'],
         0
       ],
       0
     );
   }
   ```

### 4.2 Vue Compiler 模块解析

#### 4.2.1 入口分析

Vue 3 内部有 4 个和 compiler 相关的包。compiler-dom 和 compiler-core 负责实现浏览器端的编译，compiler-ssr 负责服务器端渲染，compiler-sfc 是编译 .vue 单文件组件的。

在 [vue-next/packages/compiler-dom/index.ts](https://github.com/vuejs/core/blob/main/packages/compiler-dom/src/index.ts#L40) 文件下，可以找到下面这段代码。

```ts
/**
 * @param {String} template 项目中的模板字符串
 * @param {Object} options 编译的配置
 * 内部调用了 baseCompile 函数，可以看到，这里的调用关系和 runtime-dom、runtime-core 的关系类似，compiler-dom 负责传入浏览器 Dom 相关的 API，实际编译的 baseCompile 是由 compiler-core 提供的。
 */
export function compile(template: string, options: CompilerOptions = {}): CodegenResult {
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...(options.nodeTransforms || [])
      ],
      directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
      transformHoist: __BROWSER__ ? null : stringifyStatic
    })
  );
}
```

先来看看 compiler-dom 做了哪些额外的配置。首先，parserOption 传入了 parse 的配置，通过 parserOptions 传递的 isNativeTag 来区分 element 和 component。这里的实现也非常简单，把所有 html 的标签名存储在一个对象中，然后就可以很轻松地判断出 div 是浏览器自带的 element。baseCompile 传递的其他参数 nodeTransforms 和 directiveTransforms，它们做的也是和上面代码类似的事。

```ts
export const parserOptions: ParserOptions = {
  isVoidTag,
  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
  isPreTag: tag => tag === 'pre',
  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,

  isBuiltInComponent: (tag: string): symbol | undefined => {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION;
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP;
    }
  }
  // ...
};
const HTML_TAGS =
  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
  'option,output,progress,select,textarea,details,dialog,menu,' +
  'summary,template,blockquote,iframe,tfoot';
export const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
```

#### 4.2.2 Vue 浏览器端编译的核心流程

baseCompile 函数就是 Vue 浏览器端编译的核心流程。

1. 先通过 baseParse 把传递的 template 解析成 AST。
2. 然后通过 transform 函数对 AST 进行语义化分析。
3. 最后通过 generate 函数生成代码。

这个主要逻辑和 compiler 基本一致。

```ts
export function baseCompile(template: string | RootNode, options: CompilerOptions = {}): CodegenResult {
  const ast = isString(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);

  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []) // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {} // user transforms
      )
    })
  );
  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers
    })
  );
}
```

Vue 的[在线模板编译环境](https://vue-next-template-explorer.netlify.app/#eyJzcmMiOiI8ZGl2IGlkPVwiYXBwXCI+XG4gICAgPGRpdiBAY2xpY2s9XCIoKT0+Y29uc29sZS5sb2coeHgpXCIgOmlkPVwibmFtZVwiPnt7bmFtZX19PC9kaXY+XG4gICAgPGgxIDpuYW1lPVwidGl0bGVcIj7njqnovax2dWUzPC9oMT5cbiAgICA8cCA+57yW6K+R5Y6f55CGPC9wPlxuPC9kaXY+XG4iLCJzc3IiOmZhbHNlLCJvcHRpb25zIjp7ImhvaXN0U3RhdGljIjp0cnVlLCJjYWNoZUhhbmRsZXJzIjp0cnVlLCJvcHRpbWl6ZUJpbmRpbmdzIjpmYWxzZX19)，可以在 console 中看到 Vue 解析得到的 AST。如下图所示，可以看到这个 AST 比迷你版多了很多额外的属性。**loc 用来描述节点对应代码的信息，component 和 directive 用来记录代码中出现的组件和指令等等**。

![Vue 编译的AST](./image/Vue%20%E7%BC%96%E8%AF%91%E7%9A%84AST.webp)
