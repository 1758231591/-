# 生态源码

## 一. 响应式

Vue3 的组件之间是通过响应式机制来通知的，响应式机制可以自动收集系统中数据的依赖，并且在修改数据之后自动执行更新，极大提高开发的效率。

响应式机制的主要功能是，可以**把普通的 JS 对象封装成为响应式对象，拦截数据的获取和修改操作，实现依赖数据的自动化更新**。所以，一个最简单的响应式模型，可以通过 reactive 或者 ref 函数，把数据包裹成响应式对象，并且通过 effect 函数注册回调函数，然后在数据修改之后，响应式地通知 effect 去执行回调函数即可。

Vue3 的响应式是可以独立在其他平台使用的。比如可以新建 test.js，使用下面的代码在 node 环境中使用 Vue 响应。以 reactive 为例，使用 reactive 包裹 JS 对象之后，每一次对响应式对象 counter 的修改，都会执行 effect 内部注册的函数：

```js
const { watchEffect, reactive } = require('vue');

const counter = reactive({
  x: 1,
  y: 2
});

watchEffect(() => {
  const perimeter = (counter.x + counter.y) * 2;
  console.log(perimeter);
});

setTimeout(() => {
  counter.x += 1;
});
```

执行文件后，可以看到 watchEffect 内部的函数调用了两次。先来看一下响应式整体的流程图，上面的代码中使用 reactive 把普通的 JS 对象包裹成响应式数据了。

所以，在 effect 中获取 counter.num1 和 counter.num2 的时候，就会触发 counter 的 get 拦截函数；get 函数，会把当前的 effect 函数注册到一个全局的依赖地图中去。这样 counter.num1 在修改的时候，就会触发 set 拦截函数，去依赖地图中找到注册的 effect 函数，然后执行。

![响应式流程图](./image/响应式流程图.webp)

## 二. 运行时

前端框架需要处理的最核心的两个流程，就是首次渲染和数据更新后的渲染。先来看首次渲染的源码。

- **首次渲染**

  想要启动一个 Vue 项目，只需要从 Vue 中引入 createApp，传入 App 组件，并且调用 createApp 返回的 App 实例的 mount 方法，就实现了项目的启动。这个时候 Vue 也完成了首次渲染，代码逻辑如下：

  ![首次渲染代码逻辑](./image/首次渲染代码逻辑.webp)

  所以 createApp 就是项目的初始化渲染入口。可以在 Vue 中的 [runtime-dom](https://github.com/vuejs/core/blob/main/packages/runtime-dom/src/index.ts#L66) 中看到 createApp 的定义。

  首次查看源码的时候，可以先把一些无用的信息删除，方便梳理主体的逻辑。看 Vue 代码，和今天主题无关的无用信息有哪些，`__COMPAT__` 代码是用来兼容 Vue 2 的，`__DEV__` 代码是用来调试的，可以把这些代码删除之后，得到下面的简化版 createApp 源码：

  ```ts
  export const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    // 重写 mount
    app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;

      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = '';
      const proxy = mount(container, false, container instanceof SVGElement);
      if (container instanceof Element) {
        container.removeAttribute('v-cloak');
        container.setAttribute('data-v-app', '');
      }
      return proxy;
    };
    return app;
  };
  // 内部的 normalizeContainer 就是把传递的参数统一变为浏览器的 DOM 元素
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
    }
    return container;
  }
  ```

  再看思路就比较清晰了。使用 ensureRenderer 返回的对象去创建 app，并且重写了 app.mount 方法；在 mount 方法内部，查找 mount 传递的 DOM 元素，并且调用 ensureRenderer 返回的 mount 方法，进行初始化渲染。如下图所示：

  ![首次渲染图示](./image/首次渲染图示.webp)

  **这里 ensureRenderer 函数，内部通过 createRenderer 函数，创建了一个浏览器的渲染器，并且缓存了渲染器 renderer**，这种使用闭包做缓存的方式，在日常开发中也可以借鉴这种思路。

  createRenderer 函数传递的 rendererOptions 就是浏览器里面标签的增删改查 API：

  ```ts
  // 浏览器 dom 操作
  import { nodeOps } from './nodeOps';
  // 浏览器 dom 属性更新
  import { patchProp } from './patchProp';
  import { createRenderer } from '@vue/runtime-core';
  const rendererOptions = extend({ patchProp }, nodeOps);

  let renderer: Renderer<Element | ShadowRoot> | HydrationRenderer;

  function ensureRenderer() {
    return renderer || (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions));
  }
  ```

  可以看到，createRenderer 函数传递的参数是 nodeOps 和 patchProp 的合并对象。继续进入 nodeOps 和 pathProp 也可以看到下面的代码，写了很多方法。通过 ensureRenderer 存储这些操作方法后，createApp 内部就可以脱离具体的渲染平台了，这也是 Vue 3 实现跨端的核心逻辑：

  ```ts
  export const nodeOps: Omit<RendererOptions<Node, Element>, 'patchProp'> = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: child => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, isSVG, is, props): Element => {
      const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : undefined);

      if (tag === 'select' && props && props.multiple != null) {
        (el as HTMLSelectElement).setAttribute('multiple', props.multiple);
      }
      return el;
    },

    createText: text => doc.createTextNode(text),

    createComment: text => doc.createComment(text),

    setText: (node, text) => {
      node.nodeValue = text;
    },

    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: node => node.parentNode as Element | null,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector)
    // ...
  };
  ```
