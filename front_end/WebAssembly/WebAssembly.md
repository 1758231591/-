# WebAssembly

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [WebAssembly](#webassembly)
  - [一. 基础](#一-基础)
  - [二. 核心原理](#二-核心原理)
    - [2.1 堆栈机模型、寄存器机与累加器机](#21-堆栈机模型-寄存器机与累加器机)
      - [2.1.1 堆栈机模型](#211-堆栈机模型)
      - [2.1.2 累加器机](#212-累加器机)
      - [2.1.3 寄存器机](#213-寄存器机)
      - [2.1.4 三种计算模型对比](#214-三种计算模型对比)
    - [2.2 ISA 与 V-ISA](#22-isa-与-v-isa)
    - [2.3 Section 概览](#23-section-概览)
      - [2.3.1 通用头部结构字段](#231-通用头部结构字段)
      - [2.3.2 单体 Section](#232-单体-section)
      - [2.3.3 互补 Section](#233-互补-section)
      - [2.3.4 魔数和版本号](#234-魔数和版本号)

<!-- /code_chunk_output -->

## 一. 基础

**WebAssembly 是基于栈式虚拟机的虚拟二进制指令集（V-ISA），它被设计为高级编程语言的可移植编译目标，并且可以通过将其部署在 Web 平台上，以便为客户端及服务端应用程序提供服务**。

Web 前端正变得越来越开放。如今，不仅能够直接使用 HTML、JS 来编写各类跨端应用程序，Wasm 的出现更能够直接在 Web 平台上，使用那些业界已存在许久的众多优秀的 C/C++ 代码库。除此之外，Wasm 还能让 Web 应用具有更高的性能，甚至让 Web 应用能够与原生应用展开竞争。不仅如此，走出 Web，WASI 的出现更是为 Wasm 提供了更大的舞台。

自 2015 年 Wasm 一路走来，这期间经历的重要的发展节点：

- 2015 年 4 月，WebAssembly Community Group 成立。
- 2015 年 6 月，WebAssembly 第一次以 WCG 的官方名义向外界公布。
- 2016 年 8 月，WebAssembly 开始进入了漫长的 “Browser Preview” 阶段。
- 2017 年 2 月，WebAssembly 官方 LOGO 在 Github 上的众多讨论中被最终确定。
- 同年同月，一个历史性的阶段，四大浏览器（FireFox、Chrome、Edge、WebKit）在 WebAssembly 的 MVP（最小可用版本）标准实现上达成共识，这意味着 WebAssembly 在其 MVP 标准上的 “Browser Preview” 阶段已经结束。
- 2017 年 8 月，W3C WebAssembly Working Group 成立，意味着 WebAssembly 正式成为 W3C 众多技术标准中的一员。
- 2019 年 12 月，W3C 正式宣布，Wasm 将成为除现有的 HTML、CSS 以及 JS 之外的第四种，W3C 官方推荐在 Web 平台上使用的 “语言”。

![Wasm生态](./image/Wasm生态.webp)

实际上在 Wasm 真正出现之前，人们就已经开始尝试探索各类新型技术以赋予 Web 应用更高的运行效率。从 NaCl、PNaCl 到 ASM.js，它们主要有三点共同特征：

1. 源码中都使用了类型明确的变量。
2. 应用都拥有独立的运行时环境，并且与原有的 JS 运行时环境分离。
3. 支持将原有的 C/C++ 应用通过某种方式转换到基于这些技术的实现，并可以直接运行在 Web 浏览器中。

## 二. 核心原理

### 2.1 堆栈机模型、寄存器机与累加器机

#### 2.1.1 堆栈机模型

堆栈机，全称为 “堆栈结构机器（Stack Machine）”。堆栈机本身是一种常见的计算模型。基于堆栈机模型实现的计算机，无论是虚拟机还是实体计算机，都会使用 “栈” 这种结构来实现数据的存储和交换过程。栈是一种 “后进先出（LIFO）” 的数据结构，即最后被放入栈容器中的数据可以被最先取出。

大多数指令在执行时，都会从堆栈机的栈容器中取出若干个所需的操作数，然后根据指令所对应的功能，堆栈机会对取出的操作数进行一定的运算和处理。当这个过程结束后，若指令有需要返回的计算结果，这个值会被重新压入到栈容器中。

假设需要计算表达式 “1 + 2” 的值，编译器在实际进行编译时，假设在没有使用任何优化策略的情况下，通常会生成类似如下的这样几条指令：

![堆栈机生成指令](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E7%94%9F%E6%88%90%E6%8C%87%E4%BB%A4.webp)

如上图所示，这里将编译器生成的指令集合，按照指令从上到下的执行顺序放在左侧。堆栈机中栈容器的当前状态放置在右侧。可以看到，此时的栈容器为空，内部没有任何数据。下面，堆栈机开始执行第一条指令 “push 1”。push 指令会将紧随其后出现的操作数直接压入栈中。当该指令执行完毕后，此时栈容器的状态如下图所示：

![堆栈机指令执行第一步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

将已经执行完毕的指令用红色进行标记。此时，栈容器的栈底存放着通过第一条 push 指令压入的操作数 “1”。以同样的方式，堆栈机继续执行第二条指令 “push 2”。该条指令执行完毕后，栈容器的状态如下图所示：

![堆栈机指令执行第二步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

可以看到，目前栈容器中存放有通过前两条 push 指令压入的操作数 “1” 和 “2”。接下来，堆栈机继续执行第三条 “add” 指令。

执行这条指令需要两个操作数，因此在执行指令时，堆栈机会首先检查当前的栈容器，看其中存放的元素数量是否满足 “大于或等于 2 个”。如果这个条件成立，堆栈机会直接从栈容器的顶部取出两个操作数，然后将它们直接相加，所得到的结果会被再次压入到栈容器中。当最后一条 add 指令执行完毕后，此时栈容器的状态如下图所示：

![堆栈机指令执行第三步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%89%E6%AD%A5.webp)

当全部指令执行完毕后，在栈容器中，会存放有表达式 “1 + 2” 在经过堆栈机求值后的结果值。

#### 2.1.2 累加器机

顾名思义，累加器机是使用 “累加器”，来作为指令操作数的交换场所。累加器机实际上是一种较为古老的计算模型，它仅能够使用可存放单一值的累加器寄存器单元，来作为指令操作数的暂存场所。因此，基于累加器机模型设计的指令一般都仅支持一个操作数。

不仅如此，由于累加器的存储容量有限，因此对于一些需要进行暂存的中间数据，通常都只能够被存放到机器的线性内存中。又由于访问线性内存的速度，一般远远低于访问寄存器的速度，因此从某种程度上来讲，累加器机的指令整体执行效率会相对较低。

比如，对同样的表达式 “1 + 2” 进行求值，在累加器机中，对应的指令和执行情况，可以大致用如下图示来进行概括：

![累加器机指令执行第一步](./image/%E7%B4%AF%E5%8A%A0%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

初始状态时，累加器中没有任何数据。接下来，指令按照类似从上到下的顺序开始执行。第一条指令 “load” 会将其后面跟随的立即数（根据指令设计不同，后面也可能会跟随一个线性内存的地址）放到累加器中。当该条指令执行完毕后，累加器机的整体状态如下图所示：

![累加器机指令执行第二步](./image/%E7%B4%AF%E5%8A%A0%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

以上，便是累加器机模型下的指令设计特征，以及机器的整体运作模式。

#### 2.1.3 寄存器机

另一种常用的计算模型被称为 “寄存器机”。顾名思义，基于这种计算模型的机器，将使用特定的 CPU 寄存器组，来作为指令执行过程中数据的存储和交换容器。在寄存器机中，由于每一条参与到数据交换和处理的指令，都需要显式地标记操作数所在的寄存器（比如通过别名的方式），因此相较于堆栈机和累加器机，寄存器机模型下的指令相对更长。但相对地，数据的交换过程也变得更加灵活。

还是拿对表达式 “1 + 2” 进行求值这个例子，来看一看寄存器机在执行这句表达式时的具体流程。如下图所示，假设在这个机器的 CPU 中，有 “r0” 与 “r1” 两个通用寄存器。在初始情况下，这两个寄存器中没有存放任何内容：

![寄存器机生成指令](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E7%94%9F%E6%88%90%E6%8C%87%E4%BB%A4.webp)

第一条指令 “load r0, 1”。load 指令将接受两个操作数。第一个为目标寄存器的别名，第二个为一个立即数。当指令执行时，作为第二个操作数的立即数，将会被存放到由第一个操作数指定的寄存器中。该指令执行完毕时，对应的寄存器机整体状态如下图所示。此时，寄存器 r0 中存放有数值 1，而寄存器 r1 中没有存放任何内容。

![寄存器机指令执行第一步](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

第二条指令与第一条指令类似，这条 “add” 指令会将作为第二个操作数的立即数累加到，由第一个操作数所指定的寄存器中。当指令全部执行完毕后，对应的寄存器机终态将如下图所示。此时，寄存器 r0 中存放有表达式 “1 + 2” 的计算终值 “3”，而寄存器 r1 中仍然没有存放任何内容：

![寄存器机指令执行第二步](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

在上述整个指令的执行流程中，全程都没有使用到寄存器 r1，这也是寄存器机的一个优点。对于某些复杂的计算流程，寄存器机可以对执行流程进行优化。而优化策略的实施便得益于其拥有的众多数据暂存容器，也就是寄存器。

#### 2.1.4 三种计算模型对比

总的来看，包括 “堆栈机”、“累加器机” 以及 “寄存器机” 在内的三种计算模型，都有着不同的基本结构。比如指令可以接受的操作数个数、可操作数据所存放的位置，以及指令与指令之间交互方式的细微差别等等。它们都拥有其各自的特点与使用场景：

- 堆栈机使用栈结构作为数据的存储与交换容器，由于其 “后进先出” 的特性，使得无法直接对位于栈底的数据进行操作。因此在某些情况下，机器会使用额外的指令来进行栈数据的交换过程，从而损失了一定的执行效率。但另一方面，堆栈机模型最为简单且易于实现，对应生成的指令代码长短大小适中。

- 累加器机由于其内部只有一个累加器寄存器可用于暂存数据，因此在指令的执行过程中，可能会频繁请求机器的线性内存，从而导致一定的性能损耗。但另一方面，由于累加器模型下的指令最多只能有一个操作数，因此对应的指令较为精简。

- 寄存器机内大多数与数据操作相关的指令，都需要在执行时指定目标寄存器，这无疑增加了指令的长度。过于灵活的数据操作，也意味着寄存器的分配和使用规则变得复杂。但相对的，众多的数据暂存容器，给予了寄存器机更大的优化空间。因此，通常对于同样的一段计算逻辑，基于寄存器机模型，可以生成更为高效的指令执行结构。

### 2.2 ISA 与 V-ISA

通常来说，对于可以应用在诸如 i386、X86-64 等实际存在的物理系统架构上的指令集，一般称之为 ISA（Instruction Set Architecture，指令集架构）。而对另外一种使用在虚拟架构体系中的指令集，通常称之为 V-ISA，也就是 Virtual（虚拟）的 ISA。对这些 V-ISA 的设计，大多都是基于堆栈机模型进行的。而 Wasm 就是这样的一种 V-ISA。

Wasm 之所以会选择堆栈机模型来进行指令的设计，其主要原因是由于堆栈机本身的设计与实现较为简单。快速的原型实现可以为 Wasm 的未来发展预先试错。

另一个重要原因是，借助于堆栈机模型的栈容器特征，可以使得 Wasm 模块的指令代码验证过程变得更加简单。简单的实现易于 Wasm 引擎与浏览器的集成。基于堆栈机的结构化控制流，通过对 Wasm 指令进行 SSA（Static Single Assignment Form，静态单赋值形式）变换，可以保证即使是在堆栈机模型下，Wasm 代码也能够有着较好的执行性能。而堆栈机模型本身长短适中的指令长度，确保了 Wasm 二进制模块能够在相同体积下，拥有着更高密度的指令代码。

如下所示，是一段标准的 [Wasm 指令](https://webassembly.github.io/spec/core/appendix/index-instructions.html)：

```wasm
i32.const 1
i32.const 2
i32.add
```

前两条指令使用了 “i32.const”，这个指令会将紧随其后的立即数作为一个 i32 类型，也就是 32 位整数类型的值，压入到堆栈机的栈容器中。

最后一条指令 “i32.add”，会取出位于栈容器顶部的两个 i32 类型的值，并相加，然后再将计算结果重新放回到栈容器中。同样的，堆栈机在实际执行这条指令前，也会首先检查当前的栈容器顶部是否含有至少两个 i32 类型的值。可以看到，这段 Wasm 指令的执行方式，与堆栈机模型中的指令执行流程完全一样。

类比汇编语言与机器码。这里看到的诸如 “i32.const” 与 “i32.add” ，其实都是 Wasm 这个 V-ISA 指令集中，各个指令所对应的文本助记符（mnemonic）。实际当这些助记符被编译到 Wasm 二进制模块中时，会使用助记符所对应的二进制字节码（一般被称为 OpCode，可以简单地将其理解为一些二进制数字），并配合一些编码算法来压缩整个二进制模块文件的体积。

> Wasm 虽然有着类似汇编语言的这种 “助记符” 形式，但在大多数情况下，它仅被作为诸如 C/C++ 等高级编程语言的最终编译目标。编译器会自动处理从这些高级语言源代码到 Wasm 二进制指令的转换过程。

### 2.3 Section 概览

从整体上来看，同 ELF 二进制文件类似，Wasm 模块的二进制数据也是以 Section 的形式被安排和存放的。对于 Section，可以直接把它想象成，一个个具有特定功能的一簇二进制数据。

通常，为了能够更好地组织模块内的二进制数据，需要把具有相同功能，或者相关联的那部分二进制数据摆放到一起。而这些被摆放在一起，具有一定相关性的数据，便组成了一个个 Section。

换句话说，每一个不同的 Section 都描述了关于这个 Wasm 模块的一部分信息。而模块内的所有 Section 放在一起，便描述了整个模块在二进制层面的组成结构。在一个标准的 Wasm 模块内，以现阶段的 MVP 标准为参考，可用的 Section 有如下几种。

![WASM 的 MVP 标准下可用的 Section](./image/WASM%20%E7%9A%84%20MVP%20%E6%A0%87%E5%87%86%E4%B8%8B%E5%8F%AF%E7%94%A8%E7%9A%84%20Section.webp)

> **注意**：除了其中名为 “Custom Section”，也就是 “自定义段” 这个 Section 之外，其他的 Section 均需要按照每个 Section 所专有的 Section ID 按从小到大的顺序，在模块的低地址位到高地址位方向依次进行 “摆放”。

#### 2.3.1 通用头部结构字段

从整体上来看，每一个 Section 都由有着相同结构的 “头部” 作为起始，在这部分结构中描述了这个 Section 的一些属性字段，比如不同类型 Section 所专有的 ID、Section 的有效载荷长度。除此之外还有一些可选字段，比如当前 Section 的名称与长度信息等等。可以参考下面这张表：

![Section 通用头部结构字段](./image/Section%20%E9%80%9A%E7%94%A8%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E5%AD%97%E6%AE%B5.webp)

表中第二列给出的一些类型，目前只需要将它们理解为一种特定的编码方式就可以了，关于这些编码方式和数据类型的具体信息，会在下一节课中进行讲解。<!-- TODO -->

“字段” 这一列中的 “name_len” 与 “name” 两个字段主要用于 Custom Section，用来存放这个 Section 名字的长度，以及名字所对应的字符串数据。

#### 2.3.2 单体 Section

这一类 Section 一般可以独自描述整个模块的一部分特征（或者说是功能），同时也可以与其他 Section 一起配合起来使用。

1. **Type Section**

   ![Type Section](./image/Type%20Section.webp)

   首先，第一个出现在模块中的 Section 是 “Type Section”。顾名思义，这个 Section **用来存放与 “类型” 相关的东西**。而这里的类型，主要是指 “函数类型”。

   与大部分编程语言类似，函数类型一般由函数的**参数**和**返回值**两部分组成。而只要知道了这两部分，就能够确定在函数调用前后，栈上数据的变化情况。因此，对于 “函数类型”，也可以将其直接理解为更加常见的一个概念 —— “函数签名”。

   接下来，来看这个 Section 在二进制层面的具体组成方式。可以将 Type Section 的组成内容分为如下两个部分，分别是：所有 Section 都具有的[通用头部结构](#231-通用头部结构字段)，以及各个 Section 所专有的、不同的有效载荷部分。

   对于 Type Section 来说，它的专有 ID 是 1。紧接着排在 “头部” 后面的便是这个 Section 相关的有效载荷信息（payload_data）。每个不同类型的 Section 其有效载荷的结构都不相同。比如，Type Section 的有效载荷部分组成如下表所示：

   ![Type Section 的有效载荷部分组成](./image/Type%20Section%20%E7%9A%84%E6%9C%89%E6%95%88%E8%BD%BD%E8%8D%B7%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.webp)

   可以看到，Type Section 的有效载荷部分是由一个 count 字段和多个 entries 字段数据组合而成的。其中要注意的是 entries 字段对应的 func_type 类型，该类型是一个复合类型，其具体的二进制组成结构又通过另外的一些字段来描述，具体可以参考下面这张表：

   ![Type Section的 entries 字段的具体组成](./image/Type%20Section%E7%9A%84%20entries%20%E5%AD%97%E6%AE%B5%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%84%E6%88%90.webp)

2. **Start Section**

   ![Start Section](./image/Start%20Section.webp)

   Start Section 的 ID 为 8。通过这个 Section，**可以为模块指定在其初始化过程完成后，需要首先被宿主环境执行的函数**。

   所谓的 “初始化完成后” 是指：模块实例内部的线性内存和 Table，已经通过相应的 Data Section 和 Element Section 填充好相应的数据，但导出函数还无法被宿主环境调用的这个时刻。关于 Data Section 和 Element Section <!-- TODO -->

   > **注意**：一个 Wasm 模块只能拥有一个 Start Section，也就是说只能调用一个函数。并且调用的函数也不能拥有任何参数，同时也不能有任何的返回值。

3. **Global Section**

   ![GlobalSection](./image/GlobalSection.webp)

   Global Section 的 ID 为 6。这个 Section 中**主要存放了整个模块中使用到的全局数据（变量）信息**。这些全局变量信息可以用来控制整个模块的状态。在这个 Section 中，对于每一个全局数据，都需要标记出它的值类型、可变性以及值对应的初始化表达式。

4. **Custom Section**

   Custom Section 的 ID 为 0。这个 Section **主要用来存放一些与模块本身主体结构无关的数据**，比如调试信息、source-map 信息等等。VM（Virtual Machine，虚拟机）在实例化并执行一个 Wasm 二进制模块中的指令时，对于可以识别的 Custom Section，将会以特定的方式为其提供相应的功能。而 VM 对于无法识别的 Custom Section 则会选择直接忽略。

   VM 对于 Custom Section 的识别，主要是通过它 “头部” 信息中的 “name” 字段来进行。在目前的 MVP 标准中，有且仅有一个标准中明确定义的 Custom Section，也就是 “Name Section”。这个 Section 对应的头部信息中，“name” 字段的值即为字符串 “name”。在这个 Section 中存放了有关模块定义中 “可打印名称” 的一些信息。

#### 2.3.3 互补 Section

下面每一组的两个 Section 共同协作，一同描述了整个 Wasm 模块的某方面特征。

1. **Import Section 和 Export Section**

   ![Import Section 和 Export Section](./image/Import%20Section%20%E5%92%8C%20Export%20Section.webp)

   首先是 Import Section，它的 ID 为 2。Import Section **主要用于作为 Wasm 模块的 “输入接口”**。在这个 Section 中，定义了所有从外界宿主环境导入到模块对象中的资源，这些资源将会在模块的内部被使用。

   允许被导入到 Wasm 模块中的资源包括：函数（Function）、全局数据（Global）、线性内存对象（Memory）以及 Table 对象（Table）。

   Export Section 的 ID 为 7，通过它，可以**将一些资源导出到虚拟机所在的宿主环境中**。允许被导出的资源类型同 Import Section 的可导入资源一致。而导出的资源应该如何被表达及处理，则需要由宿主环境运行时的具体实现来决定。

2. **Function Section 和 Code Section**

   ![Function Section 和 Code Section](./image/Function%20Section%20%E5%92%8C%20Code%20Section.webp)

   Function Section 的 ID 为 3，**其中存放了这个模块中所有函数对应的函数类型信息**。在 Wasm 标准中，所有模块内使用到的函数都会通过整型的 indicies 来进行索引并调用。可以想象这样一个数组，在这个数组中的每一个单元格内都存放有一个函数指针，当需要调用某个函数时，通过 “指定数组下标” 的方式来进行索引就可以了。

   而 Function Section 便描述了在这个数组中，从索引 0 开始，一直到数组末尾所有单元格内函数，所分别对应的函数类型信息。这些类型信息是由 [Type Section](#232-单体-section) 来描述的。

   Type Section 存放了 Wasm 模块使用到的所有函数类型（签名）；Function Section 存放了模块内每个函数对应的函数类型，即具体的函数与类型对应关系；而在 Code Section 中存放的则是每个函数的具体定义，也就是实现部分。

   Code Section 的 ID 为 10，它的组织结构从宏观上来看，同样可以将它理解成一个数组结构，这个数组中的每个单元格都**存放着某个函数的具体定义**，也就是函数体对应的一簇 Wasm 指令集合。每个 Code Section 中的单元格都对应着 Function Section 这个 “数组” 结构在相同索引位置的单元格。也就是说，Code Section 的 0 号单元格中存放着 Function Section 的 0 号单元格中所描述函数类型对应的具体实现。

   > 当然，上述提到的各种 “数组” 结构，其实并不一定真的是由编程语言中的数组来实现的。只是从各个 Section 概念上的协作和数据引用方式来看，可以通过数组来模拟这样的交互流程。具体实现需要依以各个 VM 为准。

3. **Table Section 和 Element Section**

   ![Table Section 和 Element Section](./image/Table%20Section%20%E5%92%8C%20Element%20Section.webp)

   Table Section 的 ID 为 4。在 MVP 标准中，它的作用并不大，只需要知道可以在其对应的 Table 结构中存放类型为 “anyFunc” 的函数指针，并且还可以通过指令 “call_indirect” 来调用这些函数指针所指向的函数。Table Section 的结构与 Function Section 类似，也都是由 “一个个小格子” 按顺序排列而成的，可以用数组的结构来类比着进行理解。

   在实际的 VM 实现中，虚拟机会将模块的 Table 结构，初始化在独立于模块线性内存的区域中，这个区域无法被模块本身直接访问。因此 Table 中这些 “小格子” 内具体存放的值，对于 Wasm 模块本身来说是不可见的。

   所以在使用 call_indirect 指令时，只能通过 indicies，也就是 “索引” 的方式，来指定和访问这些 “小格子” 中的内容。这在某种程度上，保证了 Table 中数据的安全性。在默认情况下，Table Section 是没有与任何内容相关联的，也就是说从二进制角度来看，在 Table Section 中，只存放了用于描述某个 Table 属性的一些元信息。比如：Table 中可以存放哪种类型的数据？Table 的大小信息等等。

   那为了给 Table Section 所描述的 Table 对象填充实际的数据，还需要使用名为 Element Section 的 Section 结构。Element Section 的 ID 为 9，通过这个 Section，便可以为 Table 内部填充实际的数据。

4. **Memory Section 和 Data Section**

   ![Memory Section 和 Data Section](./image/Memory%20Section%20%E5%92%8C%20Data%20Section.webp)

   Memory Section 的 ID 为 5。同 Table Section 的结构类似，借助 Memory Section，可以**描述一个 Wasm 模块内所使用的线性内存段的基本情况**，比如这段内存的初始大小、以及最大可用大小等等。

   **Wasm 模块内的线性内存结构，主要用来以二进制字节的形式，存放各类模块可能使用到的数据**，比如一段字符串、一些数字值等等。

   通过浏览器等宿主环境提供的比如 WebAssembly.Memory 对象，可以直接将一个 Wasm 模块内部使用的线性内存结构，以 “对象” 的形式从模块实例中导出。而被导出的内存对象，可以根据宿主环境的要求，做任何形式的变换和处理，或者也可以直接通过 Import Section，再次导入给其他的 Wasm 模块来进行使用。

   同样地，在 Memory Section 中，也只是存放了描述模块线性内存属性的一些元信息，如果要为线性内存段填充实际的二进制数据，还需要使用另外的 Data Section。Data Section 的 ID 为 11。

#### 2.3.4 魔数和版本号

Section 信息固然十分重要，但另一个更重要的问题是：如何识别一个二进制文件是不是一个合法有效的 Wasm 模块文件呢？其实同 ELF 二进制文件一样，Wasm 也同样使用 “魔数” 来标记其二进制文件类型。所谓**魔数，可以简单地将它理解为具有特定含义/功能的一串数字**。

一个标准 Wasm 二进制模块文件的头部数据是由具有特殊含义的字节组成的。其中开头的前四个字节分别为 “（高地址）0x6d 0x73 0x61 0x0（低地址）”，这四个字节对应的 ASCII 可见字符为 “asm”（第一个为空字符，不可见）。

接下来的四个字节，用来表示当前 Wasm 二进制文件所使用的 Wasm 标准版本号。就目前来说，所有 Wasm 模块该四个字节的值均为 “（高地址）0x0 0x0 0x0 0x1（低地址）”，即表示版本 1。在实际解析执行 Wasm 模块文件时，VM 也会通过这几个字节来判断，当前正在解析的二进制文件是否是一个合法的 Wasm 二进制模块文件。
