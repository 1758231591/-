# WebAssembly

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [WebAssembly](#webassembly)
  - [一. 基础](#一-基础)
  - [二. 核心原理](#二-核心原理)
    - [2.1 堆栈机模型、寄存器机与累加器机](#21-堆栈机模型-寄存器机与累加器机)
      - [2.1.1 堆栈机模型](#211-堆栈机模型)
      - [2.1.2 累加器机](#212-累加器机)
      - [2.1.3 寄存器机](#213-寄存器机)

<!-- /code_chunk_output -->

## 一. 基础

**WebAssembly 是基于栈式虚拟机的虚拟二进制指令集（V-ISA），它被设计为高级编程语言的可移植编译目标，并且可以通过将其部署在 Web 平台上，以便为客户端及服务端应用程序提供服务**。

Web 前端正变得越来越开放。如今，不仅能够直接使用 HTML、JS 来编写各类跨端应用程序，Wasm 的出现更能够直接在 Web 平台上，使用那些业界已存在许久的众多优秀的 C/C++ 代码库。除此之外，Wasm 还能让 Web 应用具有更高的性能，甚至让 Web 应用能够与原生应用展开竞争。不仅如此，走出 Web，WASI 的出现更是为 Wasm 提供了更大的舞台。

自 2015 年 Wasm 一路走来，这期间经历的重要的发展节点：

- 2015 年 4 月，WebAssembly Community Group 成立。
- 2015 年 6 月，WebAssembly 第一次以 WCG 的官方名义向外界公布。
- 2016 年 8 月，WebAssembly 开始进入了漫长的 “Browser Preview” 阶段。
- 2017 年 2 月，WebAssembly 官方 LOGO 在 Github 上的众多讨论中被最终确定。
- 同年同月，一个历史性的阶段，四大浏览器（FireFox、Chrome、Edge、WebKit）在 WebAssembly 的 MVP（最小可用版本）标准实现上达成共识，这意味着 WebAssembly 在其 MVP 标准上的 “Browser Preview” 阶段已经结束。
- 2017 年 8 月，W3C WebAssembly Working Group 成立，意味着 WebAssembly 正式成为 W3C 众多技术标准中的一员。
- 2019 年 12 月，W3C 正式宣布，Wasm 将成为除现有的 HTML、CSS 以及 JS 之外的第四种，W3C 官方推荐在 Web 平台上使用的 “语言”。

![Wasm生态](./image/Wasm生态.webp)

实际上在 Wasm 真正出现之前，人们就已经开始尝试探索各类新型技术以赋予 Web 应用更高的运行效率。从 NaCl、PNaCl 到 ASM.js，它们主要有三点共同特征：

1. 源码中都使用了类型明确的变量。
2. 应用都拥有独立的运行时环境，并且与原有的 JS 运行时环境分离。
3. 支持将原有的 C/C++ 应用通过某种方式转换到基于这些技术的实现，并可以直接运行在 Web 浏览器中。

## 二. 核心原理

### 2.1 堆栈机模型、寄存器机与累加器机

#### 2.1.1 堆栈机模型

堆栈机，全称为 “堆栈结构机器（Stack Machine）”。堆栈机本身是一种常见的计算模型。基于堆栈机模型实现的计算机，无论是虚拟机还是实体计算机，都会使用 “栈” 这种结构来实现数据的存储和交换过程。栈是一种 “后进先出（LIFO）” 的数据结构，即最后被放入栈容器中的数据可以被最先取出。

大多数指令在执行时，都会从堆栈机的栈容器中取出若干个所需的操作数，然后根据指令所对应的功能，堆栈机会对取出的操作数进行一定的运算和处理。当这个过程结束后，若指令有需要返回的计算结果，这个值会被重新压入到栈容器中。

假设需要计算表达式 “1 + 2” 的值，编译器在实际进行编译时，假设在没有使用任何优化策略的情况下，通常会生成类似如下的这样几条指令：

![堆栈机生成指令](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E7%94%9F%E6%88%90%E6%8C%87%E4%BB%A4.webp)

如上图所示，这里将编译器生成的指令集合，按照指令从上到下的执行顺序放在左侧。堆栈机中栈容器的当前状态放置在右侧。可以看到，此时的栈容器为空，内部没有任何数据。下面，堆栈机开始执行第一条指令 “push 1”。push 指令会将紧随其后出现的操作数直接压入栈中。当该指令执行完毕后，此时栈容器的状态如下图所示：

![堆栈机指令执行第一步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

将已经执行完毕的指令用红色进行标记。此时，栈容器的栈底存放着通过第一条 push 指令压入的操作数 “1”。以同样的方式，堆栈机继续执行第二条指令 “push 2”。该条指令执行完毕后，栈容器的状态如下图所示：

![堆栈机指令执行第二步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

可以看到，目前栈容器中存放有通过前两条 push 指令压入的操作数 “1” 和 “2”。接下来，堆栈机继续执行第三条 “add” 指令。

执行这条指令需要两个操作数，因此在执行指令时，堆栈机会首先检查当前的栈容器，看其中存放的元素数量是否满足 “大于或等于 2 个”。如果这个条件成立，堆栈机会直接从栈容器的顶部取出两个操作数，然后将它们直接相加，所得到的结果会被再次压入到栈容器中。当最后一条 add 指令执行完毕后，此时栈容器的状态如下图所示：

![堆栈机指令执行第三步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%89%E6%AD%A5.webp)

当全部指令执行完毕后，在栈容器中，会存放有表达式 “1 + 2” 在经过堆栈机求值后的结果值。

#### 2.1.2 累加器机

顾名思义，累加器机是使用 “累加器”，来作为指令操作数的交换场所。累加器机实际上是一种较为古老的计算模型，它仅能够使用可存放单一值的累加器寄存器单元，来作为指令操作数的暂存场所。因此，基于累加器机模型设计的指令一般都仅支持一个操作数。

不仅如此，由于累加器的存储容量有限，因此对于一些需要进行暂存的中间数据，通常都只能够被存放到机器的线性内存中。又由于访问线性内存的速度，一般远远低于访问寄存器的速度，因此从某种程度上来讲，累加器机的指令整体执行效率会相对较低。

比如，对同样的表达式 “1 + 2” 进行求值，在累加器机中，对应的指令和执行情况，可以大致用如下图示来进行概括：

![累加器机指令执行第一步](./image/%E7%B4%AF%E5%8A%A0%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

初始状态时，累加器中没有任何数据。接下来，指令按照类似从上到下的顺序开始执行。第一条指令 “load” 会将其后面跟随的立即数（根据指令设计不同，后面也可能会跟随一个线性内存的地址）放到累加器中。当该条指令执行完毕后，累加器机的整体状态如下图所示：

![累加器机指令执行第二步](./image/%E7%B4%AF%E5%8A%A0%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

以上，便是累加器机模型下的指令设计特征，以及机器的整体运作模式。

#### 2.1.3 寄存器机

另一种常用的计算模型被称为 “寄存器机”。顾名思义，基于这种计算模型的机器，将使用特定的 CPU 寄存器组，来作为指令执行过程中数据的存储和交换容器。在寄存器机中，由于每一条参与到数据交换和处理的指令，都需要显式地标记操作数所在的寄存器（比如通过别名的方式），因此相较于堆栈机和累加器机，寄存器机模型下的指令相对更长。但相对地，数据的交换过程也变得更加灵活。

还是拿对表达式 “1 + 2” 进行求值这个例子，来看一看寄存器机在执行这句表达式时的具体流程。如下图所示，假设在这个机器的 CPU 中，有 “r0” 与 “r1” 两个通用寄存器。在初始情况下，这两个寄存器中没有存放任何内容：

![寄存器机生成指令](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E7%94%9F%E6%88%90%E6%8C%87%E4%BB%A4.webp)

第一条指令 “load r0, 1”。load 指令将接受两个操作数。第一个为目标寄存器的别名，第二个为一个立即数。当指令执行时，作为第二个操作数的立即数，将会被存放到由第一个操作数指定的寄存器中。该指令执行完毕时，对应的寄存器机整体状态如下图所示。此时，寄存器 r0 中存放有数值 1，而寄存器 r1 中没有存放任何内容。

![寄存器机指令执行第一步](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

第二条指令与第一条指令类似，这条 “add” 指令会将作为第二个操作数的立即数累加到，由第一个操作数所指定的寄存器中。当指令全部执行完毕后，对应的寄存器机终态将如下图所示。此时，寄存器 r0 中存放有表达式 “1 + 2” 的计算终值 “3”，而寄存器 r1 中仍然没有存放任何内容：

![寄存器机指令执行第二步](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

在上述整个指令的执行流程中，全程都没有使用到寄存器 r1，这也是寄存器机的一个优点。对于某些复杂的计算流程，寄存器机可以对执行流程进行优化。而优化策略的实施便得益于其拥有的众多数据暂存容器，也就是寄存器。

#### 2.1.4 三种计算模型对比

总的来看，包括 “堆栈机”、“累加器机” 以及 “寄存器机” 在内的三种计算模型，都有着不同的基本结构。比如指令可以接受的操作数个数、可操作数据所存放的位置，以及指令与指令之间交互方式的细微差别等等。它们都拥有其各自的特点与使用场景：

- 堆栈机使用栈结构作为数据的存储与交换容器，由于其 “后进先出” 的特性，使得无法直接对位于栈底的数据进行操作。因此在某些情况下，机器会使用额外的指令来进行栈数据的交换过程，从而损失了一定的执行效率。但另一方面，堆栈机模型最为简单且易于实现，对应生成的指令代码长短大小适中。

- 累加器机由于其内部只有一个累加器寄存器可用于暂存数据，因此在指令的执行过程中，可能会频繁请求机器的线性内存，从而导致一定的性能损耗。但另一方面，由于累加器模型下的指令最多只能有一个操作数，因此对应的指令较为精简。

- 寄存器机内大多数与数据操作相关的指令，都需要在执行时指定目标寄存器，这无疑增加了指令的长度。过于灵活的数据操作，也意味着寄存器的分配和使用规则变得复杂。但相对的，众多的数据暂存容器，给予了寄存器机更大的优化空间。因此，通常对于同样的一段计算逻辑，基于寄存器机模型，可以生成更为高效的指令执行结构。

### 2.2 ISA 与 V-ISA

通常来说，对于可以应用在诸如 i386、X86-64 等实际存在的物理系统架构上的指令集，一般称之为 ISA（Instruction Set Architecture，指令集架构）。而对另外一种使用在虚拟架构体系中的指令集，通常称之为 V-ISA，也就是 Virtual（虚拟）的 ISA。对这些 V-ISA 的设计，大多都是基于堆栈机模型进行的。而 Wasm 就是这样的一种 V-ISA。

Wasm 之所以会选择堆栈机模型来进行指令的设计，其主要原因是由于堆栈机本身的设计与实现较为简单。快速的原型实现可以为 Wasm 的未来发展预先试错。

另一个重要原因是，借助于堆栈机模型的栈容器特征，可以使得 Wasm 模块的指令代码验证过程变得更加简单。简单的实现易于 Wasm 引擎与浏览器的集成。基于堆栈机的结构化控制流，通过对 Wasm 指令进行 SSA（Static Single Assignment Form，静态单赋值形式）变换，可以保证即使是在堆栈机模型下，Wasm 代码也能够有着较好的执行性能。而堆栈机模型本身长短适中的指令长度，确保了 Wasm 二进制模块能够在相同体积下，拥有着更高密度的指令代码。

如下所示，是一段标准的 [Wasm 指令](https://webassembly.github.io/spec/core/appendix/index-instructions.html)：

```wasm
i32.const 1
i32.const 2
i32.add
```

前两条指令使用了 “i32.const”，这个指令会将紧随其后的立即数作为一个 i32 类型，也就是 32 位整数类型的值，压入到堆栈机的栈容器中。

最后一条指令 “i32.add”，会取出位于栈容器顶部的两个 i32 类型的值，并相加，然后再将计算结果重新放回到栈容器中。同样的，堆栈机在实际执行这条指令前，也会首先检查当前的栈容器顶部是否含有至少两个 i32 类型的值。可以看到，这段 Wasm 指令的执行方式，与堆栈机模型中的指令执行流程完全一样。

类比汇编语言与机器码。这里看到的诸如 “i32.const” 与 “i32.add” ，其实都是 Wasm 这个 V-ISA 指令集中，各个指令所对应的文本助记符（mnemonic）。实际当这些助记符被编译到 Wasm 二进制模块中时，会使用助记符所对应的二进制字节码（一般被称为 OpCode，可以简单地将其理解为一些二进制数字），并配合一些编码算法来压缩整个二进制模块文件的体积。

> Wasm 虽然有着类似汇编语言的这种 “助记符” 形式，但在大多数情况下，它仅被作为诸如 C/C++ 等高级编程语言的最终编译目标。编译器会自动处理从这些高级语言源代码到 Wasm 二进制指令的转换过程。

### 2.3 Section 概览

从整体上来看，同 ELF 二进制文件类似，Wasm 模块的二进制数据也是以 Section 的形式被安排和存放的。对于 Section，可以直接把它想象成，一个个具有特定功能的一簇二进制数据。

通常，为了能够更好地组织模块内的二进制数据，需要把具有相同功能，或者相关联的那部分二进制数据摆放到一起。而这些被摆放在一起，具有一定相关性的数据，便组成了一个个 Section。

换句话说，每一个不同的 Section 都描述了关于这个 Wasm 模块的一部分信息。而模块内的所有 Section 放在一起，便描述了整个模块在二进制层面的组成结构。在一个标准的 Wasm 模块内，以现阶段的 MVP 标准为参考，可用的 Section 有如下几种。

![WASM 的 MVP 标准下可用的 Section](./image/WASM%20%E7%9A%84%20MVP%20%E6%A0%87%E5%87%86%E4%B8%8B%E5%8F%AF%E7%94%A8%E7%9A%84%20Section.webp)

> **注意**：除了其中名为 “Custom Section”，也就是 “自定义段” 这个 Section 之外，其他的 Section 均需要按照每个 Section 所专有的 Section ID 按从小到大的顺序，在模块的低地址位到高地址位方向依次进行 “摆放”。

#### 2.3.1 单体 Section

这一类 Section 一般可以独自描述整个模块的一部分特征（或者说是功能），同时也可以与其他 Section 一起配合起来使用。

1. Type Section

   ![Type Section](./image/Type%20Section.webp)

   首先，第一个出现在模块中的 Section 是 “Type Section”。顾名思义，这个 Section 用来存放与“类型”相关的东西。而这里的类型，主要是指“函数类型”。

   与大部分编程语言类似，函数类型一般由函数的参数和返回值两部分组成。而只要知道了这两部分，就能够确定在函数调用前后，栈上数据的变化情况。因此，对于 “函数类型”，也可以将其直接理解为更加常见的一个概念 —— “函数签名”。

   接下来更进一步，来看看这个 Section 在二进制层面的具体组成方式。可以将 Type Section 的组成内容分为如下两个部分，分别是：所有 Section 都具有的通用 “头部” 结构，以及各个 Section 所专有的、不同的有效载荷部分。

   从整体上来看，每一个 Section 都由有着相同结构的 “头部” 作为起始，在这部分结构中描述了这个 Section 的一些属性字段，比如不同类型 Section 所专有的 ID、Section 的有效载荷长度。除此之外还有一些可选字段，比如当前 Section 的名称与长度信息等等。可以参考下面这张表。

   ![Section 通用头部结构字段](./image/Section%20%E9%80%9A%E7%94%A8%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E5%AD%97%E6%AE%B5.webp)
