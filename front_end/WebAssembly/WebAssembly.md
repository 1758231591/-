# WebAssembly

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [WebAssembly](#webassembly)
  - [一. 基础](#一-基础)
  - [二. 核心原理](#二-核心原理)
    - [2.1 堆栈机模型、寄存器机与累加器机](#21-堆栈机模型-寄存器机与累加器机)
      - [2.1.1 堆栈机模型](#211-堆栈机模型)
      - [2.1.2 累加器机](#212-累加器机)
      - [2.1.3 寄存器机](#213-寄存器机)
      - [2.1.4 三种计算模型对比](#214-三种计算模型对比)
    - [2.2 ISA 与 V-ISA](#22-isa-与-v-isa)
    - [2.3 Section 概览](#23-section-概览)
      - [2.3.1 通用头部结构字段](#231-通用头部结构字段)
      - [2.3.2 单体 Section](#232-单体-section)
      - [2.3.3 互补 Section](#233-互补-section)
      - [2.3.4 魔数和版本号](#234-魔数和版本号)
    - [2.4 Wasm 使用的数据编码方式](#24-wasm-使用的数据编码方式)
      - [2.4.1 字节序](#241-字节序)
      - [2.4.2 LEB-128 整数编码](#242-leb-128-整数编码)
        - [2.4.2.1 Unsigned LEB-128](#2421-unsigned-leb-128)
        - [2.4.2.2 Signed LEB-128](#2422-signed-leb-128)
      - [2.4.3 IEEE-754 浮点数编码](#243-ieee-754-浮点数编码)
      - [2.4.4 UTF-8 字符串编码](#244-utf-8-字符串编码)
      - [2.4.5 Wasm 数字类型](#245-wasm-数字类型)
    - [2.5 WAT（WebAssembly Text Format）](#25-watwebassembly-text-format)
      - [2.5.1 S- 表达式（S-Expression）](#251-s-表达式s-expression)
      - [2.5.2 源码、字节码与 Flat-WAT](#252-源码-字节码与-flat-wat)
      - [2.5.3 模块结构与 WAT](#253-模块结构与-wat)
      - [2.5.4 WAT 与 WAST](#254-wat-与-wast)
    - [2.6 WASI](#26-wasi)
      - [2.6.1 Capability-based Security](#261-capability-based-security)
      - [2.6.2 系统调用（System Call）](#262-系统调用system-call)
      - [2.6.3 WebAssembly 操作系统接口（WASI）](#263-webassembly-操作系统接口wasi)

<!-- /code_chunk_output -->

## 一. 基础

**WebAssembly 是基于栈式虚拟机的虚拟二进制指令集（V-ISA），它被设计为高级编程语言的可移植编译目标，并且可以通过将其部署在 Web 平台上，以便为客户端及服务端应用程序提供服务**。

Web 前端正变得越来越开放。如今，不仅能够直接使用 HTML、JS 来编写各类跨端应用程序，Wasm 的出现更能够直接在 Web 平台上，使用那些业界已存在许久的众多优秀的 C/C++ 代码库。除此之外，Wasm 还能让 Web 应用具有更高的性能，甚至让 Web 应用能够与原生应用展开竞争。不仅如此，走出 Web，WASI 的出现更是为 Wasm 提供了更大的舞台。

自 2015 年 Wasm 一路走来，这期间经历的重要的发展节点：

- 2015 年 4 月，WebAssembly Community Group 成立。
- 2015 年 6 月，WebAssembly 第一次以 WCG 的官方名义向外界公布。
- 2016 年 8 月，WebAssembly 开始进入了漫长的 “Browser Preview” 阶段。
- 2017 年 2 月，WebAssembly 官方 LOGO 在 Github 上的众多讨论中被最终确定。
- 同年同月，一个历史性的阶段，四大浏览器（FireFox、Chrome、Edge、WebKit）在 WebAssembly 的 MVP（最小可用版本）标准实现上达成共识，这意味着 WebAssembly 在其 MVP 标准上的 “Browser Preview” 阶段已经结束。
- 2017 年 8 月，W3C WebAssembly Working Group 成立，意味着 WebAssembly 正式成为 W3C 众多技术标准中的一员。
- 2019 年 12 月，W3C 正式宣布，Wasm 将成为除现有的 HTML、CSS 以及 JS 之外的第四种，W3C 官方推荐在 Web 平台上使用的 “语言”。

![Wasm生态](./image/Wasm生态.webp)

实际上在 Wasm 真正出现之前，人们就已经开始尝试探索各类新型技术以赋予 Web 应用更高的运行效率。从 NaCl、PNaCl 到 ASM.js，它们主要有三点共同特征：

1. 源码中都使用了类型明确的变量。
2. 应用都拥有独立的运行时环境，并且与原有的 JS 运行时环境分离。
3. 支持将原有的 C/C++ 应用通过某种方式转换到基于这些技术的实现，并可以直接运行在 Web 浏览器中。

## 二. 核心原理

### 2.1 堆栈机模型、寄存器机与累加器机

#### 2.1.1 堆栈机模型

堆栈机，全称为 “堆栈结构机器（Stack Machine）”。堆栈机本身是一种常见的计算模型。基于堆栈机模型实现的计算机，无论是虚拟机还是实体计算机，都会使用 “栈” 这种结构来实现数据的存储和交换过程。栈是一种 “后进先出（LIFO）” 的数据结构，即最后被放入栈容器中的数据可以被最先取出。

大多数指令在执行时，都会从堆栈机的栈容器中取出若干个所需的操作数，然后根据指令所对应的功能，堆栈机会对取出的操作数进行一定的运算和处理。当这个过程结束后，若指令有需要返回的计算结果，这个值会被重新压入到栈容器中。

假设需要计算表达式 “1 + 2” 的值，编译器在实际进行编译时，假设在没有使用任何优化策略的情况下，通常会生成类似如下的这样几条指令：

![堆栈机生成指令](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E7%94%9F%E6%88%90%E6%8C%87%E4%BB%A4.webp)

如上图所示，这里将编译器生成的指令集合，按照指令从上到下的执行顺序放在左侧。堆栈机中栈容器的当前状态放置在右侧。可以看到，此时的栈容器为空，内部没有任何数据。下面，堆栈机开始执行第一条指令 “push 1”。push 指令会将紧随其后出现的操作数直接压入栈中。当该指令执行完毕后，此时栈容器的状态如下图所示：

![堆栈机指令执行第一步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

将已经执行完毕的指令用红色进行标记。此时，栈容器的栈底存放着通过第一条 push 指令压入的操作数 “1”。以同样的方式，堆栈机继续执行第二条指令 “push 2”。该条指令执行完毕后，栈容器的状态如下图所示：

![堆栈机指令执行第二步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

可以看到，目前栈容器中存放有通过前两条 push 指令压入的操作数 “1” 和 “2”。接下来，堆栈机继续执行第三条 “add” 指令。

执行这条指令需要两个操作数，因此在执行指令时，堆栈机会首先检查当前的栈容器，看其中存放的元素数量是否满足 “大于或等于 2 个”。如果这个条件成立，堆栈机会直接从栈容器的顶部取出两个操作数，然后将它们直接相加，所得到的结果会被再次压入到栈容器中。当最后一条 add 指令执行完毕后，此时栈容器的状态如下图所示：

![堆栈机指令执行第三步](./image/%E5%A0%86%E6%A0%88%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%89%E6%AD%A5.webp)

当全部指令执行完毕后，在栈容器中，会存放有表达式 “1 + 2” 在经过堆栈机求值后的结果值。

#### 2.1.2 累加器机

顾名思义，累加器机是使用 “累加器”，来作为指令操作数的交换场所。累加器机实际上是一种较为古老的计算模型，它仅能够使用可存放单一值的累加器寄存器单元，来作为指令操作数的暂存场所。因此，基于累加器机模型设计的指令一般都仅支持一个操作数。

不仅如此，由于累加器的存储容量有限，因此对于一些需要进行暂存的中间数据，通常都只能够被存放到机器的线性内存中。又由于访问线性内存的速度，一般远远低于访问寄存器的速度，因此从某种程度上来讲，累加器机的指令整体执行效率会相对较低。

比如，对同样的表达式 “1 + 2” 进行求值，在累加器机中，对应的指令和执行情况，可以大致用如下图示来进行概括：

![累加器机指令执行第一步](./image/%E7%B4%AF%E5%8A%A0%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

初始状态时，累加器中没有任何数据。接下来，指令按照类似从上到下的顺序开始执行。第一条指令 “load” 会将其后面跟随的立即数（根据指令设计不同，后面也可能会跟随一个线性内存的地址）放到累加器中。当该条指令执行完毕后，累加器机的整体状态如下图所示：

![累加器机指令执行第二步](./image/%E7%B4%AF%E5%8A%A0%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

以上，便是累加器机模型下的指令设计特征，以及机器的整体运作模式。

#### 2.1.3 寄存器机

另一种常用的计算模型被称为 “寄存器机”。顾名思义，基于这种计算模型的机器，将使用特定的 CPU 寄存器组，来作为指令执行过程中数据的存储和交换容器。在寄存器机中，由于每一条参与到数据交换和处理的指令，都需要显式地标记操作数所在的寄存器（比如通过别名的方式），因此相较于堆栈机和累加器机，寄存器机模型下的指令相对更长。但相对地，数据的交换过程也变得更加灵活。

还是拿对表达式 “1 + 2” 进行求值这个例子，来看一看寄存器机在执行这句表达式时的具体流程。如下图所示，假设在这个机器的 CPU 中，有 “r0” 与 “r1” 两个通用寄存器。在初始情况下，这两个寄存器中没有存放任何内容：

![寄存器机生成指令](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E7%94%9F%E6%88%90%E6%8C%87%E4%BB%A4.webp)

第一条指令 “load r0, 1”。load 指令将接受两个操作数。第一个为目标寄存器的别名，第二个为一个立即数。当指令执行时，作为第二个操作数的立即数，将会被存放到由第一个操作数指定的寄存器中。该指令执行完毕时，对应的寄存器机整体状态如下图所示。此时，寄存器 r0 中存放有数值 1，而寄存器 r1 中没有存放任何内容。

![寄存器机指令执行第一步](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E6%AD%A5.webp)

第二条指令与第一条指令类似，这条 “add” 指令会将作为第二个操作数的立即数累加到，由第一个操作数所指定的寄存器中。当指令全部执行完毕后，对应的寄存器机终态将如下图所示。此时，寄存器 r0 中存放有表达式 “1 + 2” 的计算终值 “3”，而寄存器 r1 中仍然没有存放任何内容：

![寄存器机指令执行第二步](./image/%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AD%A5.webp)

在上述整个指令的执行流程中，全程都没有使用到寄存器 r1，这也是寄存器机的一个优点。对于某些复杂的计算流程，寄存器机可以对执行流程进行优化。而优化策略的实施便得益于其拥有的众多数据暂存容器，也就是寄存器。

#### 2.1.4 三种计算模型对比

总的来看，包括 “堆栈机”、“累加器机” 以及 “寄存器机” 在内的三种计算模型，都有着不同的基本结构。比如指令可以接受的操作数个数、可操作数据所存放的位置，以及指令与指令之间交互方式的细微差别等等。它们都拥有其各自的特点与使用场景：

- 堆栈机使用栈结构作为数据的存储与交换容器，由于其 “后进先出” 的特性，使得无法直接对位于栈底的数据进行操作。因此在某些情况下，机器会使用额外的指令来进行栈数据的交换过程，从而损失了一定的执行效率。但另一方面，堆栈机模型最为简单且易于实现，对应生成的指令代码长短大小适中。

- 累加器机由于其内部只有一个累加器寄存器可用于暂存数据，因此在指令的执行过程中，可能会频繁请求机器的线性内存，从而导致一定的性能损耗。但另一方面，由于累加器模型下的指令最多只能有一个操作数，因此对应的指令较为精简。

- 寄存器机内大多数与数据操作相关的指令，都需要在执行时指定目标寄存器，这无疑增加了指令的长度。过于灵活的数据操作，也意味着寄存器的分配和使用规则变得复杂。但相对的，众多的数据暂存容器，给予了寄存器机更大的优化空间。因此，通常对于同样的一段计算逻辑，基于寄存器机模型，可以生成更为高效的指令执行结构。

### 2.2 ISA 与 V-ISA

通常来说，对于可以应用在诸如 i386、X86-64 等实际存在的物理系统架构上的指令集，一般称之为 ISA（Instruction Set Architecture，指令集架构）。而对另外一种使用在虚拟架构体系中的指令集，通常称之为 V-ISA，也就是 Virtual（虚拟）的 ISA。对这些 V-ISA 的设计，大多都是基于堆栈机模型进行的。而 Wasm 就是这样的一种 V-ISA。

Wasm 之所以会选择堆栈机模型来进行指令的设计，其主要原因是由于堆栈机本身的设计与实现较为简单。快速的原型实现可以为 Wasm 的未来发展预先试错。

另一个重要原因是，借助于堆栈机模型的栈容器特征，可以使得 Wasm 模块的指令代码验证过程变得更加简单。简单的实现易于 Wasm 引擎与浏览器的集成。基于堆栈机的结构化控制流，通过对 Wasm 指令进行 SSA（Static Single Assignment Form，静态单赋值形式）变换，可以保证即使是在堆栈机模型下，Wasm 代码也能够有着较好的执行性能。而堆栈机模型本身长短适中的指令长度，确保了 Wasm 二进制模块能够在相同体积下，拥有着更高密度的指令代码。

如下所示，是一段标准的 [Wasm 指令](https://webassembly.github.io/spec/core/appendix/index-instructions.html)：

```wasm
i32.const 1
i32.const 2
i32.add
```

前两条指令使用了 “i32.const”，这个指令会将紧随其后的立即数作为一个 i32 类型，也就是 32 位整数类型的值，压入到堆栈机的栈容器中。

最后一条指令 “i32.add”，会取出位于栈容器顶部的两个 i32 类型的值，并相加，然后再将计算结果重新放回到栈容器中。同样的，堆栈机在实际执行这条指令前，也会首先检查当前的栈容器顶部是否含有至少两个 i32 类型的值。可以看到，这段 Wasm 指令的执行方式，与堆栈机模型中的指令执行流程完全一样。

类比汇编语言与机器码。这里看到的诸如 “i32.const” 与 “i32.add” ，其实都是 Wasm 这个 V-ISA 指令集中，各个指令所对应的文本助记符（mnemonic）。实际当这些助记符被编译到 Wasm 二进制模块中时，会使用助记符所对应的二进制字节码（一般被称为 OpCode，可以简单地将其理解为一些二进制数字），并配合一些编码算法来压缩整个二进制模块文件的体积。

> Wasm 虽然有着类似汇编语言的这种 “助记符” 形式，但在大多数情况下，它仅被作为诸如 C/C++ 等高级编程语言的最终编译目标。编译器会自动处理从这些高级语言源代码到 Wasm 二进制指令的转换过程。

### 2.3 Section 概览

从整体上来看，同 ELF 二进制文件类似，Wasm 模块的二进制数据也是以 Section 的形式被安排和存放的。对于 Section，可以直接把它想象成，一个个具有特定功能的一簇二进制数据。

通常，为了能够更好地组织模块内的二进制数据，需要把具有相同功能，或者相关联的那部分二进制数据摆放到一起。而这些被摆放在一起，具有一定相关性的数据，便组成了一个个 Section。

换句话说，每一个不同的 Section 都描述了关于这个 Wasm 模块的一部分信息。而模块内的所有 Section 放在一起，便描述了整个模块在二进制层面的组成结构。在一个标准的 Wasm 模块内，以现阶段的 MVP 标准为参考，可用的 Section 有如下几种。

![WASM 的 MVP 标准下可用的 Section](./image/WASM%20%E7%9A%84%20MVP%20%E6%A0%87%E5%87%86%E4%B8%8B%E5%8F%AF%E7%94%A8%E7%9A%84%20Section.webp)

> **注意**：除了其中名为 “Custom Section”，也就是 “自定义段” 这个 Section 之外，其他的 Section 均需要按照每个 Section 所专有的 Section ID 按从小到大的顺序，在模块的低地址位到高地址位方向依次进行 “摆放”。

#### 2.3.1 通用头部结构字段

从整体上来看，每一个 Section 都由有着相同结构的 “头部” 作为起始，在这部分结构中描述了这个 Section 的一些属性字段，比如不同类型 Section 所专有的 ID、Section 的有效载荷长度。除此之外还有一些可选字段，比如当前 Section 的名称与长度信息等等。可以参考下面这张表：

![Section 通用头部结构字段](./image/Section%20%E9%80%9A%E7%94%A8%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%E5%AD%97%E6%AE%B5.webp)

表中第二列给出的一些类型，目前只需要将它们理解为一种特定的编码方式就可以了，关于这些编码方式和数据类型的具体信息，会在下一节课中进行讲解。<!-- TODO -->

“字段” 这一列中的 “name_len” 与 “name” 两个字段主要用于 Custom Section，用来存放这个 Section 名字的长度，以及名字所对应的字符串数据。

#### 2.3.2 单体 Section

这一类 Section 一般可以独自描述整个模块的一部分特征（或者说是功能），同时也可以与其他 Section 一起配合起来使用。

1. **Type Section**

   ![Type Section](./image/Type%20Section.webp)

   首先，第一个出现在模块中的 Section 是 “Type Section”。顾名思义，这个 Section **用来存放与 “类型” 相关的东西**。而这里的类型，主要是指 “函数类型”。

   与大部分编程语言类似，函数类型一般由函数的**参数**和**返回值**两部分组成。而只要知道了这两部分，就能够确定在函数调用前后，栈上数据的变化情况。因此，对于 “函数类型”，也可以将其直接理解为更加常见的一个概念 —— “函数签名”。

   接下来，来看这个 Section 在二进制层面的具体组成方式。可以将 Type Section 的组成内容分为如下两个部分，分别是：所有 Section 都具有的[通用头部结构](#231-通用头部结构字段)，以及各个 Section 所专有的、不同的有效载荷部分。

   对于 Type Section 来说，它的专有 ID 是 1。紧接着排在 “头部” 后面的便是这个 Section 相关的有效载荷信息（payload_data）。每个不同类型的 Section 其有效载荷的结构都不相同。比如，Type Section 的有效载荷部分组成如下表所示：

   ![Type Section 的有效载荷部分组成](./image/Type%20Section%20%E7%9A%84%E6%9C%89%E6%95%88%E8%BD%BD%E8%8D%B7%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.webp)

   可以看到，Type Section 的有效载荷部分是由一个 count 字段和多个 entries 字段数据组合而成的。其中要注意的是 entries 字段对应的 func_type 类型，该类型是一个复合类型，其具体的二进制组成结构又通过另外的一些字段来描述，具体可以参考下面这张表：

   ![Type Section的 entries 字段的具体组成](./image/Type%20Section%E7%9A%84%20entries%20%E5%AD%97%E6%AE%B5%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%84%E6%88%90.webp)

2. **Start Section**

   ![Start Section](./image/Start%20Section.webp)

   Start Section 的 ID 为 8。通过这个 Section，**可以为模块指定在其初始化过程完成后，需要首先被宿主环境执行的函数**。

   所谓的 “初始化完成后” 是指：模块实例内部的线性内存和 Table，已经通过相应的 Data Section 和 Element Section 填充好相应的数据，但导出函数还无法被宿主环境调用的这个时刻。关于 Data Section 和 Element Section <!-- TODO -->

   > **注意**：一个 Wasm 模块只能拥有一个 Start Section，也就是说只能调用一个函数。并且调用的函数也不能拥有任何参数，同时也不能有任何的返回值。

3. **Global Section**

   ![GlobalSection](./image/GlobalSection.webp)

   Global Section 的 ID 为 6。这个 Section 中**主要存放了整个模块中使用到的全局数据（变量）信息**。这些全局变量信息可以用来控制整个模块的状态。在这个 Section 中，对于每一个全局数据，都需要标记出它的值类型、可变性以及值对应的初始化表达式。

4. **Custom Section**

   Custom Section 的 ID 为 0。这个 Section **主要用来存放一些与模块本身主体结构无关的数据**，比如调试信息、source-map 信息等等。VM（Virtual Machine，虚拟机）在实例化并执行一个 Wasm 二进制模块中的指令时，对于可以识别的 Custom Section，将会以特定的方式为其提供相应的功能。而 VM 对于无法识别的 Custom Section 则会选择直接忽略。

   VM 对于 Custom Section 的识别，主要是通过它 “头部” 信息中的 “name” 字段来进行。在目前的 MVP 标准中，有且仅有一个标准中明确定义的 Custom Section，也就是 “Name Section”。这个 Section 对应的头部信息中，“name” 字段的值即为字符串 “name”。在这个 Section 中存放了有关模块定义中 “可打印名称” 的一些信息。

#### 2.3.3 互补 Section

下面每一组的两个 Section 共同协作，一同描述了整个 Wasm 模块的某方面特征。

1. **Import Section 和 Export Section**

   ![Import Section 和 Export Section](./image/Import%20Section%20%E5%92%8C%20Export%20Section.webp)

   首先是 Import Section，它的 ID 为 2。Import Section **主要用于作为 Wasm 模块的 “输入接口”**。在这个 Section 中，定义了所有从外界宿主环境导入到模块对象中的资源，这些资源将会在模块的内部被使用。

   允许被导入到 Wasm 模块中的资源包括：函数（Function）、全局数据（Global）、线性内存对象（Memory）以及 Table 对象（Table）。

   Export Section 的 ID 为 7，通过它，可以**将一些资源导出到虚拟机所在的宿主环境中**。允许被导出的资源类型同 Import Section 的可导入资源一致。而导出的资源应该如何被表达及处理，则需要由宿主环境运行时的具体实现来决定。

2. **Function Section 和 Code Section**

   ![Function Section 和 Code Section](./image/Function%20Section%20%E5%92%8C%20Code%20Section.webp)

   Function Section 的 ID 为 3，**其中存放了这个模块中所有函数对应的函数类型信息**。在 Wasm 标准中，所有模块内使用到的函数都会通过整型的 indicies 来进行索引并调用。可以想象这样一个数组，在这个数组中的每一个单元格内都存放有一个函数指针，当需要调用某个函数时，通过 “指定数组下标” 的方式来进行索引就可以了。

   而 Function Section 便描述了在这个数组中，从索引 0 开始，一直到数组末尾所有单元格内函数，所分别对应的函数类型信息。这些类型信息是由 [Type Section](#232-单体-section) 来描述的。

   Type Section 存放了 Wasm 模块使用到的所有函数类型（签名）；Function Section 存放了模块内每个函数对应的函数类型，即具体的函数与类型对应关系；而在 Code Section 中存放的则是每个函数的具体定义，也就是实现部分。

   Code Section 的 ID 为 10，它的组织结构从宏观上来看，同样可以将它理解成一个数组结构，这个数组中的每个单元格都**存放着某个函数的具体定义**，也就是函数体对应的一簇 Wasm 指令集合。每个 Code Section 中的单元格都对应着 Function Section 这个 “数组” 结构在相同索引位置的单元格。也就是说，Code Section 的 0 号单元格中存放着 Function Section 的 0 号单元格中所描述函数类型对应的具体实现。

   > 当然，上述提到的各种 “数组” 结构，其实并不一定真的是由编程语言中的数组来实现的。只是从各个 Section 概念上的协作和数据引用方式来看，可以通过数组来模拟这样的交互流程。具体实现需要依以各个 VM 为准。

3. **Table Section 和 Element Section**

   ![Table Section 和 Element Section](./image/Table%20Section%20%E5%92%8C%20Element%20Section.webp)

   Table Section 的 ID 为 4。在 MVP 标准中，它的作用并不大，只需要知道可以在其对应的 Table 结构中存放类型为 “anyfunc” 的函数指针，并且还可以通过指令 “call_indirect” 来调用这些函数指针所指向的函数。Table Section 的结构与 Function Section 类似，也都是由 “一个个小格子” 按顺序排列而成的，可以用数组的结构来类比着进行理解。

   在实际的 VM 实现中，虚拟机会将模块的 Table 结构，初始化在独立于模块线性内存的区域中，这个区域无法被模块本身直接访问。因此 Table 中这些 “小格子” 内具体存放的值，对于 Wasm 模块本身来说是不可见的。

   所以在使用 call_indirect 指令时，只能通过 indicies，也就是 “索引” 的方式，来指定和访问这些 “小格子” 中的内容。这在某种程度上，保证了 Table 中数据的安全性。在默认情况下，Table Section 是没有与任何内容相关联的，也就是说从二进制角度来看，在 Table Section 中，只存放了用于描述某个 Table 属性的一些元信息。比如：Table 中可以存放哪种类型的数据？Table 的大小信息等等。

   那为了给 Table Section 所描述的 Table 对象填充实际的数据，还需要使用名为 Element Section 的 Section 结构。Element Section 的 ID 为 9，通过这个 Section，便可以为 Table 内部填充实际的数据。

4. **Memory Section 和 Data Section**

   ![Memory Section 和 Data Section](./image/Memory%20Section%20%E5%92%8C%20Data%20Section.webp)

   Memory Section 的 ID 为 5。同 Table Section 的结构类似，借助 Memory Section，可以**描述一个 Wasm 模块内所使用的线性内存段的基本情况**，比如这段内存的初始大小、以及最大可用大小等等。

   **Wasm 模块内的线性内存结构，主要用来以二进制字节的形式，存放各类模块可能使用到的数据**，比如一段字符串、一些数字值等等。

   通过浏览器等宿主环境提供的比如 WebAssembly.Memory 对象，可以直接将一个 Wasm 模块内部使用的线性内存结构，以 “对象” 的形式从模块实例中导出。而被导出的内存对象，可以根据宿主环境的要求，做任何形式的变换和处理，或者也可以直接通过 Import Section，再次导入给其他的 Wasm 模块来进行使用。

   同样地，在 Memory Section 中，也只是存放了描述模块线性内存属性的一些元信息，如果要为线性内存段填充实际的二进制数据，还需要使用另外的 Data Section。Data Section 的 ID 为 11。

#### 2.3.4 魔数和版本号

Section 信息固然十分重要，但另一个更重要的问题是：如何识别一个二进制文件是不是一个合法有效的 Wasm 模块文件呢？其实同 ELF 二进制文件一样，Wasm 也同样使用 “魔数” 来标记其二进制文件类型。所谓**魔数，可以简单地将它理解为具有特定含义/功能的一串数字**。

一个标准 Wasm 二进制模块文件的头部数据是由具有特殊含义的字节组成的。其中开头的前四个字节分别为 “（高地址）0x6d 0x73 0x61 0x0（低地址）”，这四个字节对应的 ASCII 可见字符为 “asm”（第一个为空字符，不可见）。

接下来的四个字节，用来表示当前 Wasm 二进制文件所使用的 Wasm 标准版本号。就目前来说，所有 Wasm 模块该四个字节的值均为 “（高地址）0x0 0x0 0x0 0x1（低地址）”，即表示版本 1。在实际解析执行 Wasm 模块文件时，VM 也会通过这几个字节来判断，当前正在解析的二进制文件是否是一个合法的 Wasm 二进制模块文件。

```c
int add (int a, int b) {
  return a + b;
}
```

在这段代码中，定义了一个简单的函数 “add”。这个函数接收两个 int 类型的参数，并返回这两个参数的和。使用 [WasmFiddle](https://wasdk.github.io/WasmFiddle/) 在线 Wasm 编译工具，将上述代码编译成对应的 Wasm 二进制文件，并将它下载到本地。然后，可以使用 VSCode 的 Hex Editor 插件来查看这个二进制文件的字节码内容。可以参考下面的这张图：

![wasm文件的字节码内容](./image/wasm%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E5%86%85%E5%AE%B9.webp)

可以看到，最开始红色方框内的前八个字节 “0x0 0x61 0x73 0x6d 0x1 0x0 0x0 0x0” 便是 Wasm 模块文件开头的 “魔数” 和版本号。

接下来的 “0x1” 是 Section 头部结构中的 “id” 字段，这里的值为 “0x1”，表明接下来的数据属于模块的 Type Section。紧接着绿色方框内的五个十六进制数字 “0x87 0x80 0x80 0x80 0x0” 是由 varuint32 编码的 “payload_len” 字段信息，经过解码，它的值为 “0x7”，表明这个 Section 的有效载荷长度为 7 个字节。

Type Section 的有效载荷是由一个 “count” 字段和多个 “entries” 类型数据组成的。因此可以进一步推断出，接下来的字节 “0x1” 便代表着，当前 Section 中接下来存在的 “entries” 类型实体的个数为 1 个。

根据同样的分析过程，可以知道，紧接着紫色方框内的六个十六进制数字序列 “0x60 0x2 0x7f 0x7f 0x1 0x7f” 便代表着 “一个接受两个 i32 类型参数，并返回一个 i32 类型值的函数类型”。

### 2.4 Wasm 使用的数据编码方式

在上面的例子的几十个十六进制数字中，看到了组成 Wasm 模块所不可或缺的 “魔数” 与 “版本号” 编码，以及组成了各个 Section 结构的专有编码。在这些字节码中，Wasm 会使用不同的编码方案来处理不同的字段数据。比如对于 Section 的通用头部结构来说，Wasm 会用名为 “varuint7” 的编码方式，来编码各个 Section 的专有 ID。

除此之外，对于字符串以及浮点数，Wasm 也会分别通过 UTF-8 以及 IEEE-754 编码来将这些字面量值转换为对应的二进制编码，并存储到最终的 Wasm 二进制模块文件中。

#### 2.4.1 字节序

字节序也就是指 “字节的排列顺序”。在计算机中，数据是以最原始的二进制 0 和 1 的方式被存储的。在大多数现代计算机体系架构中，计算机的最小可寻址数据为 8 位（bit)，即 1 个字节（byte）。

因此，通常将 1 字节定义为一个存储单元的大小。对于连续占用了多个存储单元的数据，通常称之为 “多字节数据”，组成这段数据的每个字节都会地址连续地进行存放。

比如，在 C/C++ 中，一个 short 类型的变量便是一个多字节数据。假设有一个该类型的变量，其值为 1000。如下图所示，将该值在内存中的实际二进制存放形式展示如下。

![C语言中值为1000的short类型变量在内存中的实际存放形式](./image/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%80%BC%E4%B8%BA1000%E7%9A%84short%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E5%AD%98%E6%94%BE%E5%BD%A2%E5%BC%8F.webp)

对于一个多字节数据，会将其在二进制形式下，用于组成该数字值的最低有效数字位与最高有效数字位，分别称为这个数据的 “最低有效位（LSB，Least Significant Bit）” 和 “最高有效位（MSB，Most Significant Bit）”。如上图所标记出的那样。

而当计算机将这个多字节数据存放到物理内存中时，一个对于存储方式的不同抉择便出现了。是应该选择将多字节数据的 LSB 位，存放到物理内存的低地址段（也就是相应地把 MSB 位存放到高地址段）；还是相反地，应该将多字节数据的 LSB 位，存放到物理内存的高地址段（即将 MSB 位相应地存放到低地址段）呢？实际上这两种方式均有被业界所使用，它们分别被称为 “小端模式” 与 “大端模式”。

- **小端模式（Little-Endian）**

  小端模式即 “将多字节数据的 LSB 位存放到内存的低地址位，相应地将 MSB 位存放到内存的高地址位”。下面的这张图是之前那个存储着值 1000 的 short 类型变量，在以 “小端模式” 进行存放时的内存结构图：

  ![小端模式内存结构图](./image/%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.webp)

  可以看到，这个 short 类型变量值的 LSB 位所对应的低 8 位数据（0xe8），被存放到了内存的低地址位单元（a+1）中。 MSB 位对应的高 8 位数据（0x3）则被存放到了内存的高地址单元（a+2）中。而这便是 “小端模式” 所独有的特征。

- **大端模式（Big-Endian）**

  与小端模式相反，在大端模式下，多字节数据的 LSB 位所对应部分会被存放到内存的高地址位，而 MSB 对应的部分则会被存放到内存的低地址位。也就是说，将上图内存中两个存储单元所存放的数据 0x3 与 0xe8 的位置相互调换后，便是大端模式下的数据存储方式。

实际上，大端模式与小端模式两者并没有优劣之分，这两种模式均被广泛地应用在基于不同处理器架构的计算机和一些特殊的应用场景中。

#### 2.4.2 LEB-128 整数编码

LEB-128 的全称为 “Little Endian Base 128”，是一种用于整数的、基于小端模式的可变长编码。所谓 “可变长编码”，是指源数据在经过编码后，所得到的目标编码结果长度并不固定，依据不同的输入数据会得到不同长度的编码结果。

LEB-128 编码通常可以被分为两种更为具体的形式，即 “Unsigned LEB-128” 与 “Signed LEB-128”。其中前者仅用于编码无符号整数，后者主要用于编码有符号整数。

在无符号整数中，没有符号位，也就是说在该类型所对应大小范围内的所有比特位，都可以用来保存整数值的一部分。相反，在有符号整数中，类型首位会被用作符号位。

##### 2.4.2.1 Unsigned LEB-128

假设这里使用 Unsigned LEB-128 来编码一个正整数 123456。编码的具体步骤如下所示：

1. 首先将该十进制数转换为对应原码（与补码相同）的二进制表示方式。

   ```txt
   11110001001000000
   ```

2. 将该二进制数用额外的 “0” 位进行填充，直至其总位数达到最近的一个 7 的倍数。

   > **注意**：这里只能够在该数字最高位的左侧进行填充，这样才不会影响数字原本的值。这种为无符号数进行位数扩展的方式一般称之为 “**零扩展**”。

   ```txt
   000011110001001000000
   ```

3. 将该二进制数以每 7 个二进制位为一组进行分组，每组之间以空格进行区分。

   ```txt
   0000111 1000100 1000000
   ```

4. 在最高有效位所在分组的左侧填充一个值为 “0” 的二进制位。而在其他分组的最高位左侧填充一个值为 “1” 的二进制位。

   ```txt
   00000111 11000100 11000000
   ```

5. 将上述二进制位分组以每组为单位，转换成对应的十六进制值，即为编码所得结果。

   ```txt
   0x7 0xc4 0xc0
   ```

到这里，一次对无符号（Unsigned）整数进行的 LEB-128 编码过程便完成了。对于 Unsigned LEB-128 编码的解码过程，实质上与编码过程完全相反。

##### 2.4.2.2 Signed LEB-128

Signed LEB-128 的编码过程，实质上与 Unsigned LEB-128 十分类似。假设用它来编码一个有符号的负整数 -123456。编码的具体流程如下所示：

1. 首先，将该数字转换为对应的二进制表示形式。

   > **注意**：由于 -123456 为一个有符号数，因此在编码时需要使用它的补码形式。在下面这段二进制编码中，第一位是符号位，这里的 “1” 表示该二进制序列所对应的十进制数是一个负数。

   ```txt
   100001110111000000
   ```

2. 对这个有符号数进行 “符号扩展” 操作。

   所谓 “符号扩展” 是指对二进制数的最高位，也就是符号位，其左侧填充指定的二进制位来增加整个有符号数的总位数，并同时保证该二进制数本身的值不会被改变。因此，对于负整数来说，需要为其填充 “1”，而正整数则填充 “0”。与 Unsigned LEB-128 类似，这里对其进行符号扩展，直到这个二进制数的总位数达到最近的一个 7 的倍数。

   ```txt
   111100001110111000000
   ```

3. 将这个二进制数以每 7 个二进制位为一组进行分组，每组之间以空格进行区分。

   ```txt
   1111000 0111011 1000000
   ```

4. 在最高有效位所在分组的左侧填充一个值为 “0” 的二进制位。而在其他分组的最高位左侧填充一个值为 “1” 的二进制位。

   ```txt
   01111000 10111011 11000000
   ```

5. 将上述二进制分组以每组为单位，转换成对应的十六进制值，即为编码所得结果。

   ```txt
   0x78 0xbb 0xc0
   ```

可以看到，Signed LEB-128 与 Unsigned LEB-128 在编码规则上的不同，仅体现在整个编码流程的前两步。这两步的不同主要是由于无符号数与有符号数在计算机内的实际存储方式不同。

> **注意**：经过编码计算所得的结果，需要按照 “小端模式” 的方式存放在内存中，这也是 LEB-128 编码的一个重要特征。不仅如此，当在实际应用 LEB-128 编码时，有时由于所编码数字有着固定的大小（比如 64 位），因此会导致实际的编码结果中可能会含有特殊的 “填充字节”，比如 “0x80” 与 “0xff”。

#### 2.4.3 IEEE-754 浮点数编码

IEEE-754 是一种用于进行浮点数编码的行业标准。几乎可以在任何与浮点数编码有关的应用场景中看到它的存在。在 IEEE-754 标准中规定，一个浮点数由三个不同的部分组成，即 “符号位”、“指数位” 与 “小数位”。这里以 32 位浮点数 “1234.567” 为例，来看它在 IEEE-754 下的实际编码结构：

首先，32 位的最高位，也就是其 MSB 位会被**符号位**占用，以标记该浮点数的正负性。同整数一样，该位为 “0” 表示正数，为 “1” 则表示负数。因此对于 “1234.567” 来说，该位的值为 0。

紧接着符号位的是长度为 8 位的 “**指数位**”。该位用来记录的是，当以 “科学计数法” 形式表示一个浮点数时，其中**底数所对应的幂次值**。这里需要将小数编码成对应的二进制形式，因此所使用科学计数法的底数为 “2”。指数位采用了一种名为 “移码” 的值存储方法，以便能支持负数次幂。当计算该位的实际值时，会将从上一步中得到的幂次值与 127 相加，以得到该位的最终结果。对于 “1234.567”，可以按照如下步骤来计算对应的指数位值。

1. 将浮点数按照整数位和小数位，分别转换成对应的二进制表示形式（对于小数部分，采用 “循环乘 2” 的方式，来将其展开成二进制形式）。

   ```txt
   10011010010.10010001001001...
   ```

2. 将从上一步得到的二进制小数，以“科学计数法”的形式进行表示。

   ```txt
   1.001101001010010001001001... * 2^10
   ```

3. 计算指数位对应的十进制数值。即将上述 2 的幂次值 10，再加上 127，得到 137。换算成二进制序列即 “10001001”。

紧接着指数位的是剩下 23 位的 “**小数位**”，该位**主要用于存放浮点数在二进制科学计数法形式下，对应的小数部分序列**。

> **注意**：这部分只有 23 位大小，对于溢出的部分将会被直接截断。

最后，可以得到浮点数 1234.567 在 IEEE-754 编码下的完整组成形式：

![浮点数在IEEE-754编码下的完整组成形式](./image/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8IEEE-754%E7%BC%96%E7%A0%81%E4%B8%8B%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%84%E6%88%90%E5%BD%A2%E5%BC%8F.webp)

实际上，在 Wasm 模块中，所有以字面量形式出现的浮点数值，都会通过 IEEE-754 进行编码。而经过编码生成的二进制序列，也将成为 Wasm 二进制模块组成的一部分。

#### 2.4.4 UTF-8 字符串编码

与 LEB-128 类似，UTF-8 也是一种可变长编码，即随着被编码内容的不同，实际产生的编码结果其长度也各不相同。如下图所示，UTF-8 的编码结果值可能会有着从最少 1 个字节到最多 4 个字节不等的长度。

![UTF-8 字符串编码](./image/UTF-8%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81.webp)

UTF-8 的编码过程是基于 Unicode 字符集进行的。在 Unicode 字符集中，每一个字符都有其对应的码位值。比如对于汉字 “极”，它在 Unicode 字符集中的码位值为 “26497”，换算为十六进制即 “0x6781”。

Unicode 虽然规定了各个字符对应的码位值，但却没有规定这些值应该以怎样的格式被计算机存储。UTF-8 作为众多 Unicode 编码方式中的常用一种，通过上面这种方式巧妙地解决了这个问题。下面仍以汉字 “极” 为例，来介绍 UTF-8 编码的具体过程：

1. 先将该汉字对应的码位值展开成二进制序列的形式。

   ```txt
   01100111 10000001
   ```

2. 根据上图中第三行对应的规则（码位值位于 [U+0800, U+FFFF] 之间），替换出 UTF-8 编码对应的三个字节。在替换时，需要将从上一步获得的二进制序列中的各个二进制位，按照从左到右的顺序依次替换掉 UTF-8 编码中用于占位的 “x”。

   ```txt
   11100110 10011110 10000001
   ```

3. 将替换结果转换为对应的十六进制形式，即为 UTF-8 编码的最终结果。

   ```txt
   0xe6 0x9e 0x81
   ```

#### 2.4.5 Wasm 数字类型

上面是 Wasm 二进制模块中，可能会使用到的所有二进制编码方案。对于整数的编码，Wasm 并没有 “直接使用” LEB-128，而是在其基础之上又做了进一步的约束。

Wasm 将其模块内部所使用到的数字值分为以下三种类型：

- **uintN**（N = 8 / 16 / 32）

  该类型表示了一个占用 N 个 bit 的无符号整数。该整数由 N/8 个字节组成，并以小端模式进行存储。N 的可取值为 8、16 或 32。

- **varuintN**（N = 1 / 7 / 32）

  该类型表示一个使用 Unsigned LEB-128 编码，具有 N 个 bit 长度的可变长无符号整数。N 的可取值为 1、7 或 32，对应各类型的可取值范围为 [0, 2^N-1]。需要注意的是，当使用较大数据类型（比如 N 取 32）来存放较小的值，比如 12 时，在经过 Unsigned LEB-128 编码后的二进制序列中，可能会存在用于占位的字节 “0x80”。

- **varintN**（N = 7 / 32 / 64）

  该类型与上述的 varuintN 类似，只不过表示的是使用 Signed LEB-128 编码，具有 N 个 bit 长度的可变长有符号整数。N 的可取值为 7、32 或 64，对应各类型的取值范围为 [-2^(N-1), +2^(N-1)-1]。同样地，当在使用一个较大类型（比如 N 取 64）保存较小的整数值时，经过 Signed LEB-128 编码后的二进制序列中，可能会存在用于占位的字节 “0x80” 或 “0xff”。

### 2.5 WAT（WebAssembly Text Format）

假设有如下这样一段 C/C++ 源代码，在这段代码中，定义了一个函数 factorial，该函数接受一个 int 类型的整数 n，然后返回该整数所对应的阶乘。将它编译成对应的 WAT 代码：

```c++
int factorial(int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
```

经过编译和转换后，该函数对应的 WAT 文本代码如下所示：

```wat
(func $factorial (; 0 ;) (param $0 i32) (result i32)
 (local $1 i32)
 (local $2 i32)
 (block $label$0
  (br_if $label$0
   (i32.eqz
    (get_local $0)
   )
  )
  (set_local $2
   (i32.const 1)
  )
  (loop $label$1
   (set_local $2
    (i32.mul
     (get_local $0)
     (get_local $2)
    )
   )
   (set_local $0
    (tee_local $1
     (i32.add
      (get_local $0)
      (i32.const -1)
     )
    )
   )
   (br_if $label$1
    (get_local $1)
   )
  )
  (return
   (get_local $2)
  )
 )
 (i32.const 1)
)
```

WAT 的全称 “WebAssembly Text Format”，一般称其为 “WebAssembly 可读文本格式”。它是一种与 Wasm 字节码格式完全等价，可用于编码 Wasm 模块及其相关定义的文本格式。

这种格式使用 “S- 表达式” 的形式来表达 Wasm 模块及其定义，将组成模块各部分的字节码用一种更加线性的、可读的方式进行表达。

这种文本格式可以被 Wasm 相关的编译工具直接使用，比如 WAVM 虚拟机、Binaryen 调试工具等。不仅如此，Web 浏览器还会在 Wasm 模块没有与之对应的 source-map 数据时（即无法显示模块对应的源语言代码，比如 C/C++ 代码），使用对应的 WAT 可读文本格式代码来作为代替，以方便开发者进行调试。

#### 2.5.1 S- 表达式（S-Expression）

“S- 表达式”，又被称为 “S-Expression”，或者简写为 “sexpr”，它是一种用于表达树形结构化数据的记号方式。最初，S- 表达式被用于 Lisp 语言，表达其源代码以及所使用到的字面量数据。比如，在 Common Lisp 这个 Lisp 方言中，有如下形式的一段代码：

```lisp
(print
 (* 2 (+ 3 4))
)
```

这段 Lisp 代码与之前生成的函数 factorial 所对应 WAT 可读文本代码，在结构上有着些许的相似。在这段代码中，调用了名为 print 的方法，将一个简单数学表达式 “2 \* (3 + 4)” 的计算结果值，打印到了系统的标准输出流（stdout）中。

在 “S- 表达式” 中，使用一对小括号 “()” 来定义每一个表达式的结构。而表达式之间的相互嵌套关系则表达了一定的语义规则。比如在上面的 Lisp 代码中，子表达式 “(\* 2 (+ 3 4))” 的值直接作为了 print 函数的输入参数。而对于这个子表达式本身，也通过内部嵌套的括号表达式及运算符，规定了求值的具体顺序和规则。

不仅如此，每一个表达式在求值时，都会将该表达式将要执行的 “操作”，作为括号结构的第一个元素，而对应该操作的具体操作 “内容” 则紧跟其后。

这里将 “操作” 和 “内容” 都加上了引号，因为 “S- 表达式” 可以被应用于多种不同的场景中，所以这里的操作可能是指一个函数、一个 V-ISA 中的指令，甚至是标识一个结构的标识符。而所对应的 “内容” 也可以是不同类型的元素或结构。

对一个 “S- 表达式” 的求值会从最内层的括号表达式开始。比如对于上述的 Lisp 代码，首先计算其最内层表达式 “(+ 3 4)” 的值。计算完毕后，该括号表达式的位置会由该表达式的计算结果进行替换。以此类推，从内到外，最后计算出整个表达式的值。当然，除了求值，对于诸如 print 函数来说，也会产生一些如 “与操作系统 IO 进行交互” 之类的副作用（Side Effect）。

可以参考下面这张图来理解 “S- 表达式” 的组成结构与求值方式（以上述 Lisp 代码为例）：

![S-Expression求值方式](./image/S-Expression%E6%B1%82%E5%80%BC%E6%96%B9%E5%BC%8F.webp)

#### 2.5.2 源码、字节码与 Flat-WAT

为了能够更加直观地看清楚从源代码、Wasm 字节码再到 WAT 三者之间的对应关系，首先要做的第一件事就是将对应的 WAT 代码 “拍平（flatten）”，将其变成 “Flat-WAT”。这里还是以 “factorial” 函数对应生成的 WAT 可读文本代码为例。

“拍平” 的过程十分简单。正常在通过 “S- 表达式” 形式表达的 WAT 代码中，通过 “嵌套” 与 “小括号” 的方式指定了各个表达式的求值顺序。而 “拍平” 的过程就是将这些嵌套以及括号结构去掉，以 “从上到下” 的先后顺序，来表达整个程序的执行流程。

上述 WAT 代码在被 “拍平” 之后，可以得到如下所示的 Flat-WAT 代码：

```flat-wat
(func $factorial (param $0 i32) (result i32)
 block $label$0
  local.get $0
  i32.eqz
  br_if $label$0
  local.get $0
  i32.const 255
  i32.add
  i32.const 255
  i32.and
  call $factorial
  local.get $0
  i32.mul
  i32.const 255
  i32.and
  return
 end
 i32.const 1)
```

然后再将对应 “factorial” 函数的 C/C++ 源代码、Wasm 字节码以及上述 WAT 经过转换生成的 Flat-WAT 代码放到一起：

![源码、字节码与 Flat-WAT](./image/%E6%BA%90%E7%A0%81%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%20Flat-WAT.webp)

#### 2.5.3 模块结构与 WAT

WAT 除了可以通过 “S- 表达式” 的形式，来描述一个定义在 Wasm 模块内的函数定义以外，WAT 还可以描述与 Wasm 模块定义相关的其他部分，比如模块中各个 Section 的具体结构。如下所示，这是用于构成一个完整 Wasm 模块定义的其他字节码组成部分，所对应的 WAT 可读文本代码：

```txt
(module
 (table 0 anyfunc)
 (memory $0 1)
 (export "memory" (memory $0))
 (export "factorial" (func $factorial))
 ...
)
```

在这里，仍然使用 “S- 表达式” 的形式，通过为子表达式指定不同的 “操作” 关键字，进而赋予每个表达式不同的含义。比如带有 “table” 关键字的子表达式，定义了 Table Section 的结构。其中的 “0” 表示该 Section 的初始大小为 0，随后紧跟的 “anyfunc” 表示该 Section 可以容纳的元素类型为函数指针类型。其他的诸如 “memory” 表达式定义了 Memory Section，“export” 表达式定义了 Export Section，以此类推。

#### 2.5.4 WAT 与 WAST

在 Wasm 的发展初期，曾出现过一种以 “.wast” 为后缀的文本文件格式，这种文本文件经常被用来存放类似 WAT 的代码内容。

但实际上，以 “.wast” 为后缀的文本文件通常表示着 “.wat” 的一个超集。也就是说，在该文件中可能会包含有一些，基于 WAT 可读文本格式代码标准扩展而来的其他语法结构。比如一些与 “断言” 和 “测试” 有关的代码，而这部分语法结构并不属于 Wasm 标准的一部分。

相反的，以 “.wat” 为后缀结尾的文本文件，通常只能够包含有 Wasm 标准语法所对应的 WAT 可读文本代码。并且在一个文本文件中，也只能够定义单一的 Wasm 模块结构。

因此，在日常的 Wasm 学习、开发和调试过程中，更推荐使用 “.wat” 这个后缀，来作为包含有 WAT 代码的文本文件扩展名。这样可以保障该文件能够具有足够高的兼容性，能够适配大多数的编译工具，甚至是浏览器来进行识别和解析。

**WAT 相关工具**
需要安装名为 [WABT](https://github.com/WebAssembly/wabt#building-using-cmake-directly-linux-and-macos)（The WebAssembly Binary Toolkit）的 Wasm 工具集。

- **wasm2wat**：该工具主要用于将指定文件内的 Wasm 二进制代码转译为对应的 WAT 可读文本代码。
- **wat2wasm**：该工具的作用恰好与 wasm2wat 相反。它可以将输入文件内的 WAT 可读文本代码转译为对应的 Wasm 二进制代码。
- **wat-desugar**：该工具主要用于将输入文件内的，基于 “S- 表达式” 形式表达的 WAT 可读文本代码 “拍平” 成对应的 Flat-WAT 代码。

默认情况下，转译生成的目标代码将被输出到操作系统的标准输出流中。也可以通过 “-o” 参数来指定输出结果的保存文件。

### 2.6 WASI

WebAssembly 这个单词实际上是由两部分组成，也就是 “Web” 和 “Assembly”。“Web” 表明了 Wasm 的出身，也就是说它发明并最早应用于 Web 浏览器中， “Assembly” 则表明了 Wasm 的本质，这个词翻译过来的意思是 “汇编”，也就是指代它的 V-ISA 属性。

鉴于 Wasm 所拥有 “可移植”、“安全” 及 “高效” 等特性，Wasm 也被逐渐应用在 Web 领域之外的一些其他场景中。也就是可以用于将 Wasm 应用到 out-of-web 环境中的一项新的标准 —— WASI（WebAssembly System Interface，Wasm 操作系统接口）。通过这项标准，Wasm 将可以直接与操作系统打交道。

#### 2.6.1 Capability-based Security

“Capability-based Security” 是一个在 “计算机安全” 领域中十分重要的概念，翻译过来为 “基于能力的安全”。

Capability-based Security 是一种已知的、常用的安全模型。通常来讲，在计算机领域中，所提及的 capability 可以指代如 Token、令牌等概念。capability 是一种用于表示某种权限的标记，它可以在用户之间进行传递且无法被伪造。

在一个使用了 Capability-based Security 安全模型的操作系统中，任何用户对计算机资源的访问，都需要通过一个具体的 capability 来进行。

Capability-based Security 同时也指代了一种规范用户程序的原则。比如这些用户程序可以根据 “最小特权原则”（该原则要求计算环境中的各个模块仅能够访问当下所必需的信息或资源）来彼此直接共享 capability，这样可以使得操作系统仅分配用户程序需要使用的权限，并且可以做到 “一次分配，多次使用”。

Capability-based Security 这个安全模型，通常会跟另外的一种基于 “分级保护域” 方式实现的安全模型形成对比。

基于 “分级保护域” 实现的安全模型，被广泛应用于类 Unix 的各类操作系统中，比如下图所示的操作系统 Ring0 层和 Ring3 层（Ring1 / Ring2 一般不会被使用）便是 “分级保护域” 的一种具体实现形式：

![基于“分级保护域”实现的安全模型](./image/%E5%9F%BA%E4%BA%8E%E2%80%9C%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F%E2%80%9D%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.webp)

在传统意义上，Ring0 层拥有着最高权限，一般用于内核模式；而 Ring3 层的权限则会被稍加限制，一般用于运行用户程序。当一个运行在 Ring3 层的用户程序，试图去调用只有 Ring0 层进程才有权限使用的指令时，操作系统会阻止调用。这就是“分级保护域”的大致概念。

反观 Capability-based Security，capability 通过替换在分级保护域中使用的 “引用”，来达到提升系统安全性的目的。这里的 “引用” 是指用于访问资源的一类 “定位符”，比如用于访问某个文件资源的 “文件路径字符串” 便是一个引用。

引用本身并没有指定实际对应资源的权限信息，以及哪些用户程序可以拥有这个引用。因此，每一次尝试通过该引用来访问实际资源的操作，都会经由操作系统来进行基于 “分级保护域” 的权限验证。比如验证发起访问的用户是否有权限持有该资源，这种方式便十分适合早期计算机系统的 “多用户” 特征（每个用户有不同的权限）。

在具有 capability 概念的操作系统中，只要用户程序拥有了这个 capability，那它就拥有足够的权限去访问对应的资源。从理论上来讲，基于 Capability-based Security 的操作系统，甚至不需要如 “权限控制列表（ACL）” 这类的传统权限控制机制。

当然，为了实现上述提到的 capability 的能力，每一个 capability 不再是单一的由 “字符串” 组成的简单数据结构。并且还需要保障，capability 的内部结构不会被用户程序直接访问和修改，以防止 capability 本身被伪造。

相对应的，用户程序只能够通过 capability 暴露出的特定 “入口”，来访问对应的系统资源。可以用操作系统中常见的一个概念 —— “文件描述符（File Descriptor）” 来类比 capability 的概念：

![文件描述符](./image/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.webp)

可以将文件描述符类比为 capability。举个例子，当应用程序在通过 C 标准库中的 “fopen” 函数去打开一个文件时，函数会返回一个非负整数，来表示一个特定文件资源对应的文件描述符。

在拥有了这个描述符后，应用程序便可以按照在调用 “fopen” 函数时所指定的操作（比如 “w”），来相应地对这个文件资源进行处理。当函数返回负整数时，则表示无法获得该资源。在这些返回的错误代码中，就包含有与 “权限不足” 相关的调用错误信息。

最为重要的一点是，拥有某个 capability 的用户程序，可以 “任意地” 处理这个 capability。比如，可以访问其对应的系统资源、可以将其传递给其他的应用程序来进行使用，或者也可以选择直接将这个 capability 删除。操作系统有义务确保某个特定的 capability 只能够对应系统中的某个特定的资源或操作，以保证安全策略的完备性。

#### 2.6.2 系统调用（System Call）

“使用 C 标准库中的 fopen 函数，来打开一个计算机本地文件”。当在调用这个 fopen 函数打开某个文件时，实际上发生了什么？fopen 函数是如何访问操作系统的文件资源的呢？

fopen 函数是 C 标准库中定义的一个函数，那么就从某个特定的 C 标准库实现所对应的源代码入手，来看看 fopen 函数的具体实现细节。这里以 musl 这个 libc 的实现为例。在它的源代码中，可以找到如下这段对 fopen 函数的定义代码（这里只列出了关键的部分）：

```C
FILE *fopen(const char *restrict filename, const char *restrict mode) {
  // ...
  /* Compute the flags to pass to open() */
  flags = __fmodeflags(mode);

  fd = sys_open(filename, flags, 0666);
  if (fd < 0) return 0;
  // ...
}
```

代码的具体实现流程和细节不做深究，唯一需要注意的，就是这句函数调用语句 `fd = sys_open(filename, flags, 0666);`。在这行语句中，musl 调用了一个名为 “sys_open” 的函数，而在这个函数的背后，就是 “系统调用”。

实际上，任何其他需要与操作系统资源打交道的 C ，甚至是 C++ 标准库函数（包括 fopen 函数在内），都需要通过 “系统调用” 来间接访问和使用这些系统资源。sys_open 函数其实是对系统调用进行了封装，在函数内部会使用内联的汇编代码，去实际调用某个具体的 “系统调用”。这里 sys_open 对应的，便是指 “用于打开本地文件资源” 的那个系统调用。

每一个系统调用，都对应着需要与操作系统打交道的某个特定功能，并且有着唯一的 “系统调用 ID” 与之相对应。在不同的操作系统中，对应同一系统调用的系统调用 ID 可能会发生变化。

而 C/C++ 标准库的作用，便是提供了一个统一、稳定的编程接口。让程序可以做到 “一次编写，到处编译”。从某种程度上来讲，标准库的出现为应用程序源代码提供了 “可移植性”。比如不再需要随着操作系统类型的变化，而硬编码不同的系统调用 ID。

除此之外，标准库还会帮助处理系统调用前后需要做的一些事情，比如简化函数参数的传递、对各种异常情况进行处理，以及 “关闭文件” 之类的 “善后” 工作。关于用户应用程序与操作系统调用之间的关系，可以参考下图：

![用户应用程序与操作系统调用之间的关系](./image/%E7%94%A8%E6%88%B7%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.webp)

#### 2.6.3 WebAssembly 操作系统接口（WASI）

Wasm 是一套新的 V-ISA（虚拟指令集架构），其中的这些虚拟指令便无法被真实的物理 CPU 硬件直接执行。所以如果想要在浏览器之外使用 Wasm，就需要提供一种基础设施，来解释并执行这些被存放在 Wasm 二进制模块中的虚拟指令。对于这样的基础设施，通常称之为 “虚拟机（Virtual Machine）”，或者是 “运行时引擎（Runtime Engine）”。

假设此时已经有了这样的一个虚拟机，可以用于执行 Wasm 的虚拟字节码指令。然后希望将一段 C/C++ 代码经过编译后，以 Wasm 的形式在这个虚拟机中运行。在这段 C/C++ 代码中，使用到了之前提到的 fopen 函数。

但是问题来了。在如 musl 这类 C 标准库的实现中，类似 fopen 这样的函数，最后会被编译为对某个特定平台（IA32、X86-64 等）系统调用的调用过程。这对于 Wasm 来说，会使自己丧失 “天生自带” 的可移植性。单纯对于某一个 Wasm 模块来讲，由于并不知道这个模块将会被运行在什么类型的操作系统上，因此无法将平台相关的具体信息放到 Wasm 模块中。那如何解决这个问题呢？WASI 给了答案。

WASI 在 Wasm 字节码与虚拟机之间，增加了一层 “系统调用抽象层”。比如对于在 C/C++ 源码中使用的 fopen 函数，当将这部分源代码与专为 WASI 实现的 C 标准库 “wasi-libc” 进行编译时，源码中对 fopen 的函数调用过程，其内部会间接通过调用名为 `__wasi_path_open` 的函数来实现。这个 `__wasi_path_open` 函数，便是对实际系统调用的一个抽象。

`__wasi_path_open` 函数的具体实现细节会交由各个虚拟机自行处理。也就是说，虚拟机需要在其 Runtime 运行时环境中提供，对 Wasm 模块字节码所使用到的 __wasi_path_open 函数的解析和执行能力的支持。而虚拟机在实际实现这些系统调用抽象层接口时，也需要通过实际的系统调用来进行。只不过这些细节上的处理，对于 Wasm 二进制模块来讲，是完全透明的。

可以将上述提到的 wasi-libc、Wasm 二进制模块、WASI 系统调用抽象层，以及虚拟机基础设施之间的关系，通过下图来直观地展示：

![WASI与虚拟机关系图](./image/WASI%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B3%E7%B3%BB%E5%9B%BE.webp)

实际上，类似 __wasi_path_open 的这类以 `__wasi` 开头的，用于抽象实际系统调用的函数，便是 WASI 的核心组成部分。WASI 根据不同系统调用所提供的不同功能，将这些系统调用对应的 WASI 抽象函数接口，分别划分到了不同的子集合中。

比如一个名为 “wasi-core” 的 WASI 标准子集合，包含有对应于 “文件操作” 与 “网络操作” 等相关系统调用的 WASI 抽象函数接口。其他如 “crypto”、“multimedia” 等子集合，甚至可以包含与实际系统调用无关的一系列 WASI 抽象系统调用接口。可以理解为 WASI 所描述的抽象系统调用，是针对 Wasm V-ISA 描述的抽象机器而言。针对这部分抽象系统的具体实现，则会依赖一部分实际的系统调用。

WASI 在设计和实现时，需要遵守 Wasm 的两个基本原则：

- **可移植性（Portability）**

  WASI 通过在 Wasm 二进制字节码与虚拟机基础设施之间，提供统一的 “系统调用抽象层” 来保证 Wasm 模块的可移植性。这样一来，上层的 Wasm 模块可以不用考虑平台相关的调用细节，统一将对实际系统调用的调用过程，转换为对 “抽象系统调用” 的调用过程。

  而 “抽象系统调用” 的实现细节，则由下层的相关基础设施来负责处理。基础设施会根据其所在操作系统类型的不同，将对应的抽象系统调用映射到真实的系统调用上。当然，并不是所有的抽象系统调用都需要被映射到真实的系统调用上，因为对于某些抽象系统调用而言，基础设施只是负责提供相应的实现即可。

  这样，一个经过编译生成的 Wasm 二进制模块便可以在浏览器之外也同样保证其可移植性。真正做到 “一次编译，到处运行”，“**抽象**” 便是解决这个问题的关键。

- **安全性（Security）**

  实际上，基础设施在真正实现 WASI 标准时，便会采用 “Capability-based Security” 的方式来控制每一个 Wasm 模块实例所拥有的 capability。

  举个例子，假设一个 Wasm 模块想要打开一个计算机本地文件，而且这个模块还是由使用了 fopen 函数的 C/C++ 源代码编译而来，那对应的虚拟机在实例化该 Wasm 模块时，便会将 fopen 对应的 WASI 系统调用抽象函数 “__wasi_path_open” 以某种方式（比如通过包装后的函数指针），当做一个 capability 从模块的 Import Section 传递给该模块进行使用。

  通过这种方式，基础设施掌握了主动权。它可以决定是否要将某个 capability 提供给 Wasm 模块进行使用。若某个 Wasm 模块偷偷使用了一些不为开发者知情的系统调用，那么当该模块在虚拟机中进行实例化时，便会露出马脚。掌握这样的主动权，正适合如今基于众多不知来源的第三方库进行代码开发的现状。

  对于没有经过基础设施授权的 capability 调用过程，将会被基础设施拦截。通过相应的日志系统进行收集，这些 “隐藏的小伎俩” 便会在第一时间被开发者/用户感知，并进行相应的处理。

### 2.7 API

在目前与 Wasm 相关的一系列标准中，可以将这些标准主要分为两个部分：

- **Wasm 核心标准**（Core Interfaces）：主要定义了与 “Wasm 字节码”、“Wasm 模块结构”、“WAT 可读文本格式” 以及模块验证与指令执行细节等相关的内容。

- **嵌入接口标准**（Embedding interfaces）：定义了有关 Wasm 在 Web 平台上，在与浏览器进行交互时所需要使用的相关 Web 接口以及 JS 接口。

#### 2.7.1 Wasm 浏览器加载流程

![Wasm 浏览器加载流程](./image/Wasm%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.webp)
