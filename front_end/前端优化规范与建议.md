---
title: 前端优化与建议
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [前端优化与建议](#前端优化与建议)
  - [一. 浏览器加载过程与问题](#一-浏览器加载过程与问题)
    - [1.1 加载过程](#11-加载过程)
    - [1.2 问题](#12-问题)
  - [二. 优化建议](#二-优化建议)
    - [2.1 HTML](#21-html)
      - [2.1.1 避免空的 src 和 href](#211-避免空的src和href)
      - [2.1.2 减少 DOM 元素数量](#212-减少dom元素数量)
      - [2.1.3 减少 iframe 数量](#213-减少iframe数量)
      - [2.1.4 减少 DOM 访问](#214-减少dom访问)
      - [2.1.5 打包组建成复合文档](#215-打包组建成复合文档)
      - [2.1.6 HTML 文档结构层次尽量少，最好不深于六层](#216-html文档结构层次尽量少最好不深于六层)
    - [2.2 CSS](#22-css)
      - [2.2.1 将 CSS 放在页面最上面](#221-将css放在页面最上面)
      - [2.2.2 避免在 CSS 中使用 Expressions](#222-避免在css中使用expressions)
      - [2.2.3 优化 CSS Sprite](#223-优化css-sprite)
    - [2.3 JS](#23-js)
      - [2.3.1 将 JavaScript 放在页面的最下面](#231-将javascript放在页面的最下面)
      - [2.3.2 将 JavaScript 和 CSS 放到外部文件](#232-将javascript和css放到外部文件)
      - [2.3.3 JavaScript 和 CSS 压缩和模块打包](#233-javascript和css压缩和模块打包)
      - [2.3.4 移除重复的脚本](#234-移除重复的脚本)
      - [2.3.5 在脚本中尽量减少 DOM 操作，尽量缓存访问 DOM 的样式信息，避免过度触发回流](#235-在脚本中尽量减少dom操作尽量缓存访问dom的样式信息避免过度触发回流)
    - [2.4 网络](#24-网络)
      - [2.4.1 尽量的减少 HTTP 的请求数](#241-尽量的减少http的请求数)
      - [2.4.2 使用 CDN(内容分发网络)](#242-使用cdn内容分发网络)
      - [2.4.3 添加 Expire/Cache-Control 头](#243-添加expirecache-control头)
      - [2.4.4 减少 DNS 查询](#244-减少dns查询)
      - [2.4.5 使用 AJAX 缓存](#245-使用ajax缓存)
      - [2.4.6 配置实体标签(ETag)](#246-配置实体标签etag)
      - [2.4.7 避免 404](#247-避免404)
    - [2.5 其他](#25-其他)
      - [2.5.1 启用 Gzip 压缩](#251-启用gzip压缩)
      - [2.5.2 根据域名划分内容](#252-根据域名划分内容)
      - [2.5.3 减少 Cookie 大小](#253-减少cookie大小)
      - [2.5.4 优化图像](#254-优化图像)
      - [2.5.5 使用小且可缓存的 favicon.ico](#255-使用小且可缓存的faviconico)
      - [2.5.6 移动客户端图片保持单个内容小于 25KB](#256-移动客户端图片保持单个内容小于25kb)
      - [2.5.7 按需加载资源](#257-按需加载资源)
      - [2.5.8 使用预加载](#258-使用预加载)

<!-- /code_chunk_output -->

# 前端优化与建议

## 一. 浏览器加载过程与问题

### 1.1 加载过程

1. 解析 HTML 生成 DOM 树
   当浏览器接收到服务器响应来的 HTML 文档后，会遍历文档节点，生成 DOM 树。

   > 注意:DOM 树的生成过程中可能会被 CSS 和 JS 的加载执行阻塞

2. 解析 CSS 生成 CSSOM 规则树
   浏览器解析 CSS 文件并生成 CSS 规则树，每个 CSS 文件都被分析成一个 StyleSheet 对象，每个对象都包含 CSS 规则。CSS 规则对象包含对应于 CSS 语法的选择器和声明对象以及其他对象。

3. 将 DOM 树与 CSSOM 规则树合并在一起生成渲染树
   通过 DOM 树和 CSS 规则树便可以构建渲染树。浏览器会先从 DOM 树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的 CSS 样式规则并应用。

4. 遍历渲染树开始布局，计算每个节点的位置大小信息
   从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

5. 将渲染树每个节点绘制到屏幕 将渲染树每个节点绘制到屏幕
   遍历渲染树，调用渲染器的 `paint()` 方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的 UI 后端组件完成的。

### 1.2 问题

渲染阻塞
: 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建 DOM。每次去执行 JavaScript 脚本都会严重地阻塞 DOM 树的构建，如果 JavaScript 脚本还操作了 CSSOM，而正好这个 CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM 的下载和构建。

根据渲染树布局，计算 CSS 样式，即每个节点在页面中的大小和位置等几何信息。HTML 默认是流式布局的，CSS 和 js 会打破这种布局，改变 DOM 的外观样式以及大小和位置。这时就要提到两个重要概念： **repaint** 和 **reflow**。

- repaint：屏幕的一部分重画，不影响整体布局，比如某个 CSS 的背景色变了，但元素的几何尺寸和位置不变。
- reflow ：意味着元件的几何尺寸变了，需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是 Reflow，或是 Layout。

## 二. 优化建议

### 2.1 HTML

#### 2.1.1 避免空的 src 和 href

#### 2.1.2 减少 DOM 元素数量

网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500 个元素和 5000 个元素在加载速度上会有很大差别。

> `document.getElementsByTagName("*").length` 获取页面中有多少的元素

#### 2.1.3 减少 iframe 数量

使用 iframe 要注意理解 iframe 的优缺点

优点:

1. 可以用来加载速度较慢的内容，例如广告。
2. 安全沙箱保护。浏览器会对 iframe 中的内容进行安全控制。
3. 脚本可以并行下载
4. 相同的网页内容可避免代码重复

缺点:

1. 即使 iframe 内容为空也消耗加载时间
2. 会阻止页面加载
3. 没有语义

#### 2.1.4 减少 DOM 访问

通过 Javascript 访问 DOM 元素没有想象中快，元素多的网页尤其慢，对于 Javascript 对 DOM 的访问要注意:

1. 缓存已经访问过的元素
2. Offline 更新节点然后再加回 DOM Tree
3. 避免通过 Javascript 修改 layout

#### 2.1.5 打包组建成复合文档

把页面内容打包成复合文本就如同带有多附件的 Email，它能够使你在一个 HTTP 请求中取得多个组件。当你使用这条规则时，首先要确定用户代理是否支持（iPhone 不支持）。

#### 2.1.6 HTML 文档结构层次尽量少，最好不深于六层

### 2.2 CSS

#### 2.2.1 将 CSS 放在页面最上面

提高浏览器的渲染性能,避免浏览器出现空白和闪烁的问题

#### 2.2.2 避免在 CSS 中使用 Expressions

在页面显示和缩放,页面滚动,移动鼠标时,CSS 中的 Expressions 都会重新计算

#### 2.2.3 优化 CSS Sprite

1. Sprite 图中水平排列图片，垂直排列会增加文件大小
2. Sprite 图中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以便适用 PNG8 格式
3. 不要在 Sprite 的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。

### 2.3 JS

#### 2.3.1 将 JavaScript 放在页面的最下面

避免 js 出错后页面不显示,加载效率高

#### 2.3.2 将 JavaScript 和 CSS 放到外部文件

#### 2.3.3 JavaScript 和 CSS 压缩和模块打包

使用打包工具压缩，打包

1. 去除不必要的空白符,格式符,注释符
2. 简写方法名，参数名，压缩 JS 脚本

#### 2.3.4 移除重复的脚本

#### 2.3.5 在脚本中尽量减少 DOM 操作，尽量缓存访问 DOM 的样式信息，避免过度触发回流

1. 减少通过 JavaScript 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画
2. 动画尽量使用在绝对定位或固定定位的元素上
3. 隐藏在屏幕外，或在页面滚动时，尽量停止动画

### 2.4 网络

#### 2.4.1 尽量的减少 HTTP 的请求数

从客户端到服务器端的请求消息。包括消息首行中，对资源的请求方法，资源的标识符以及使用的协议

> 方法: 压缩,打包

#### 2.4.2 使用 CDN(内容分发网络)

内容分发网络，尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快,更稳定

#### 2.4.3 添加 Expire/Cache-Control 头

expire 的头内容是一个时间值,值就是资源在本地的过期时间,存在本地,在本地缓存阶段,找到一个本地的资源值,当前时间还没超过资源的过期时间,就直接使用这一个资源,不会发送 http 请求

Cache-Control 是 HTTP 协议中常用的头部之一,顾名思义,它是负责控制页面的缓存机制,如果该头部指示缓存,缓存的内容也会存在本地.操作流程和 expire 相似,但也有不同的地方,Cache-Control 有更多的选项和处理方式

#### 2.4.4 减少 DNS 查询

> 方法:缓存
> 时间长时: 减少 DNS 的重复查找，节省时间
> 时间短时: 及时的检测网站服务器的变化，保证正确性

#### 2.4.5 使用 AJAX 缓存

#### 2.4.6 配置实体标签(ETag)

Entity Tag(实体标签) 属于 HTTP 协议,受 WEB 服务支持

优点:

1. 使用特殊的字符串,来标识某个请求资源版本
2. 如果客户端接收到的 ETag 与服务器的 ETag 一致,那么服务器会返回 304
3. 帮服务器减轻负担

缺点:

1. ETags 的版本信息即使主流服务器也未能很好地支持跨服务器的判断，比如你从一个服务器集群中一台到 ETags，然后发送到了另一台那么校验很有可能会失败。

#### 2.4.7 避免 404

404 代表服务器没有找到资源，要特别要注意 404 的情况

1. 客户端发送一个请求但是服务器却返回一个无用的结果，时间浪费。
2. 网页中需要加载一个外部脚本，结果返回一个 404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成 Javascript 去解析。

### 2.5 其他

#### 2.5.1 启用 Gzip 压缩

在服务器端用 Gzip 压缩,客户端再次用 Gzip 压缩至缓存

> 注意 : pdf 文件可以从需要被压缩的类型中剔除，因为 pdf 文件本身已经压缩，gzip 对其效果不大

#### 2.5.2 根据域名划分内容

浏览器一般对同一个域的下载连接数有所限制，按照域名划分下载内容可以使浏览器增大并行下载连接，但是注意控制域名使用在 2-4 个之间，不然 dns 查询也是个问题。

一般网站规划会将静态资源放在类似于 static.example.com，动态内容放在www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。

#### 2.5.3 减少 Cookie 大小

Cookie 被用来做认证或个性化设置，其信息被包含在 http 报文头中，对于 cookie 要注意以下几点，来提高请求的响应速度

1. 去除没有必要的 cookie，如果网页不需要 cookie 就完全禁掉
2. 将 cookie 的大小减到最小
3. 注意 cookie 设置的 domain 级别，没有必要情况下不要影响到 sub-domain
4. 设置合适的过期时间，比较长的过期时间可以提高响应速度。

#### 2.5.4 优化图像

在上传图片之前对其做以下优化

1. 检查 GIF 图片中图像颜色的数量是否和调色板规格一致。如果发现图片中只用到了 4 种颜色，而在调色板的中显示的 256 色的颜色槽，那么这张图片就还有压缩的空间。
2. 尝试把 GIF 格式转换成 PNG 格式
3. 在所有的 PNG 图片上运行 pngcrush(或者其它 PNG 优化工具)
4. 在所有的 JPEG 图片上运行 jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息

#### 2.5.5 使用小且可缓存的 favicon.ico

1. 网站图标文件 favicon.ico，不管服务器有还是没有，浏览器都会去尝试请求这个图标。所以要确保这个图标
   1. 存在
   2. 文件尽量小，最好小于 1k
   3. 设置一个长的过期时间

#### 2.5.6 移动客户端图片保持单个内容小于 25KB

这限制是因为 iPhone，他只能缓存小于 25K，注意这是解压后的大小。所以单纯 gzip 不一定够用，精简文件工具要用

#### 2.5.7 按需加载资源

资源（特别是图片）的按需加载或者说惰性加载，可以有助于 Web 应用在整体上获得更好的性能。对于使用大量图片的页面来说惰性加载有着显著的三个好处：

1. 减少向服务器发出的并发请求数量（这就使得页面的其他部分获得更快的加载时间）
2. 减少浏览器的内存使用率（更少的图片，更少的内存）
3. 减少服务器端的负载

#### 2.5.8 使用预加载

预加载可以，在真正需要之前，通过取得必需的资源和相关数据来改善访问用户的浏览体验，主要有 3 类预先获取:

1. 链接预先获取
2. DNS 预先获取
3. 预先渲染
   在离开当前 web 页面之前，使用预先获取方式，对应每个链接的 URL 地址，CSS，图片和脚本都会被预先获取。这保证了访问者能在最短时间内使用链接在画面间切换。只需在网站 HTML 中的链接属性上增加 `rel="prefetch"`、`rel="dns-prefetch"` 或者 `rel="prerender"` 标记。
