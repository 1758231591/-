---
title: 前端性能优化
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [前端性能优化](#前端性能优化)
  - [一. 浏览器](#一-浏览器)
    - [1.1 加载过程](#11-加载过程)
      - [1.1.1 浏览器加载过程中的渲染阻塞](#111-浏览器加载过程中的渲染阻塞)
    - [1.2 缓存机制介绍与缓存策略剖析](#12-缓存机制介绍与缓存策略剖析)
      - [1.2.1 HTTP 缓存机制](#121-http-缓存机制)
        - [1.2.1.1 强缓存](#1211-强缓存)
        - [1.2.1.2 协商缓存](#1212-协商缓存)
        - [1.2.1.3 HTTP 缓存决策指南](#1213-http-缓存决策指南)
      - [1.2.2 Memory Cache](#122-memory-cache)
      - [1.2.3 Service Worker Cache](#123-service-worker-cache)
      - [1.2.4 Push Cache](#124-push-cache)
    - [1.3 本地存储](#13-本地存储)
      - [1.3.1 Cookie](#131-cookie)
      - [1.3.2 Web Storage](#132-web-storage)
      - [1.3.3 IndexedDB](#133-indexeddb)
  - [二. HTML](#二-html)
    - [2.1 避免空的 src 和 href](#21-避免空的-src-和-href)
    - [2.2 减少 DOM 元素数量](#22-减少-dom-元素数量)
    - [2.3 减少 iframe 数量](#23-减少-iframe-数量)
    - [2.4 减少 DOM 访问](#24-减少-dom-访问)
    - [2.5 打包组建成复合文档](#25-打包组建成复合文档)
    - [2.6 HTML 文档结构层次尽量少，最好不深于六层](#26-html-文档结构层次尽量少最好不深于六层)
    - [2.7 减少 Cookie 大小](#27-减少-cookie-大小)
    - [2.8 按需加载资源](#28-按需加载资源)
    - [2.9 使用预加载](#29-使用预加载)
  - [三. CSS](#三-css)
    - [3.1 将 CSS 放在页面最上面](#31-将-css-放在页面最上面)
    - [3.2 避免在 CSS 中使用 Expressions](#32-避免在-css-中使用-expressions)
    - [3.3 优化 CSS Sprite](#33-优化-css-sprite)
  - [四. JS](#四-js)
    - [4.1 将 JavaScript 放在页面的最下面](#41-将-javascript-放在页面的最下面)
    - [4.2 将 JavaScript 和 CSS 放到外部文件](#42-将-javascript-和-css-放到外部文件)
    - [4.3 JavaScript 和 CSS 压缩和模块打包](#43-javascript-和-css-压缩和模块打包)
    - [4.4 移除重复的脚本](#44-移除重复的脚本)
    - [4.5 在脚本中尽量减少 DOM 操作，尽量缓存访问 DOM 的样式信息，避免过度触发回流](#45-在脚本中尽量减少-dom-操作尽量缓存访问-dom-的样式信息避免过度触发回流)
  - [五. 网络](#五-网络)
    - [5.1 尽量的减少 HTTP 的请求数](#51-尽量的减少-http-的请求数)
    - [5.2 使用 CDN(内容分发网络)](#52-使用-cdn内容分发网络)
    - [5.3 添加 Expire/Cache-Control 头](#53-添加-expirecache-control-头)
    - [5.4 减少 DNS 查询](#54-减少-dns-查询)
    - [5.5 使用 AJAX 缓存](#55-使用-ajax-缓存)
    - [5.6 避免 404](#56-避免-404)
    - [5.7 根据域名划分内容](#57-根据域名划分内容)
  - [六. 其他](#六-其他)
    - [6.1 启用 Gzip 压缩](#61-启用-gzip-压缩)
    - [6.2 图片优化](#62-图片优化)
      - [6.2.1 JPEG/JPG](#621-jpegjpg)
      - [6.2.2 PNG-8 与 PNG-24](#622-png-8-与-png-24)
      - [6.2.3 SVG](#623-svg)
      - [6.2.4 Base64](#624-base64)
      - [6.2.5 WebP](#625-webp)
    - [6.3 使用小且可缓存的 favicon.ico](#63-使用小且可缓存的-faviconico)
    - [6.4 移动客户端图片保持单个内容小于 25KB](#64-移动客户端图片保持单个内容小于-25kb)
    - [6.5 webPack 优化](#65-webpack-优化)

<!-- /code_chunk_output -->

# 前端性能优化

## 一. 浏览器

### 1.1 加载过程

1. DNS 解析
2. TCP 连接
3. HTTP 请求抛出
4. 服务端处理请求，HTTP 响应返回
5. 解析响应内容

   1. 解析 HTML 生成 DOM 树
      当浏览器接收到服务器响应来的 HTML 文档后，会遍历文档节点，生成 DOM 树。

      > 注意:DOM 树的生成过程中可能会被 CSS 和 JS 的加载执行阻塞

   2. 解析 CSS 生成 CSSOM 规则树
      浏览器解析 CSS 文件并生成 CSS 规则树，每个 CSS 文件都被分析成一个 StyleSheet 对象，每个对象都包含 CSS 规则。CSS 规则对象包含对应于 CSS 语法的选择器和声明对象以及其他对象。

   3. 将 DOM 树与 CSSOM 规则树合并在一起生成渲染树
      通过 DOM 树和 CSS 规则树便可以构建渲染树。浏览器会先从 DOM 树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的 CSS 样式规则并应用。

   4. 遍历渲染树开始布局，计算每个节点的位置大小信息
      从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

   5. 将渲染树每个节点绘制到屏幕 将渲染树每个节点绘制到屏幕
      遍历渲染树，调用渲染器的 `paint()` 方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的 UI 后端组件完成的。

#### 1.1.1 浏览器加载过程中的渲染阻塞

当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建 DOM。每次去执行 JS 脚本都会严重地阻塞 DOM 树的构建，如果 JS 脚本还操作了 CSSOM，而正好这个 CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM 的下载和构建。

根据渲染树布局，计算 CSS 样式，即每个节点在页面中的大小和位置等几何信息。HTML 默认是流式布局的，CSS 和 JS 会打破这种布局，改变 DOM 的外观样式以及大小和位置。这时就要提到两个重要概念： **repaint** 和 **reflow**。

- repaint : 屏幕的一部分重画，不影响整体布局，比如某个 CSS 的背景色变了，但元素的几何尺寸和位置不变。
- reflow : 意味着元件的几何尺寸变了，需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是 Reflow，或是 Layout。

### 1.2 缓存机制介绍与缓存策略剖析

缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段。

> 通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。

浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：

- [Memory Cache](#MemoryCache)
- Service Worker Cache
- HTTP Cache
- Push Cache

Network 面板 size 列截图

![浏览器缓存](./image/浏览器缓存.png)

图中，形如"（from xxx）"这样的描述——对应的资源，这些资源就是通过缓存获取到的。其中，"from memory cache" 对标到 Memory Cache 类型，"from ServiceWorker" 对标到 Service Worker Cache 类型。至于 "Push Cache"，这个比较特殊，是 HTTP2 的新特性。

#### 1.2.1 HTTP 缓存机制

HTTP 缓存是日常开发中最为熟悉的一种缓存机制。它又分为**强缓存**和**协商缓存**。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。

##### 1.2.1.1 强缓存

**强缓存的特征**
强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，**不会再与服务端发生通信**。

> 命中强缓存的情况下，返回的 HTTP 状态码为 200

**强缓存的实现**：从 expires 到 cache-control

```txt
expires: Wed, 11 Sep 2019 16:12:18 GMT
```

可以看到，expires 是一个时间戳，接下来如果试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。由于时间戳是服务器来定义的，而本地时间的取值却来自客户端，因此 expires 的工作机制对客户端时间与服务器时间之间的一致性提出了极高的要求，若服务器与客户端存在时差，将带来意料之外的结果。

```txt
cache-control: max-age=31536000
```

在 `Cache-Control` 中，通过 `max-age` 来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度(单位: 秒)。在 HTTP1.1 标准试图将缓存相关配置收敛进 Cache-Control 这样的大背景下， `max-age` 可以视作是对 expires 能力的补位/替换。在当下的前端实践里，普遍会倾向于使用 `max-age`。

> 注意:
> max-age 是一个相对时间，这就意味着它有能力规避掉 expires 可能会带来的时差问题：max-age 机制下，资源的过期判定不再受服务器时间戳的限制。客户端会记录请求到资源的时间点，以此作为相对时间的起点，从而确保参与计算的两个时间节点（起始时间和当前时间）都来源于客户端，由此便能够实现更加精准的判断。
> Cache-Control 的 max-age 配置项相对于 expires 的优先级更高。当 Cache-Control 与 expires 同时出现时，以 Cache-Control 为准

**Cache-Control 应用分析**
Cache-Control 不止于 max-age。如下的用法也非常常见：

```txt
cache-control: max-age=3600, s-maxage=31536000
```

**s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。**

在项目不是特别大的场景下，max-age 足够用了。但在依赖各种代理的大型架构中，不得不考虑代理服务器的缓存问题。s-maxage 就是用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。

> s-maxage 仅在代理服务器中生效，客户端中只考虑 max-age。

**public 与 private**
public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。

如果为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果设置了 private，则该资源只能被浏览器缓存。private 为默认值。但多数情况下，public 并不需要手动设置。

> 明确的缓存信息（例如“max-age”）已表示响应是可以缓存的。

**no-store 与 no-cache**
no-cache
: 为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走协商缓存的路线）。

no-store
: 不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许直接向服务端发送请求、并下载完整的响应。

##### 1.2.1.2 协商缓存

协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。

如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。

**协商缓存的实现**：从 Last-Modified 到 Etag

Last-Modified 是一个时间戳，如果启用了协商缓存，它会在首次请求时随着 Response Headers 返回：

```txt
Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
```

随后每次请求时，会带上一个叫 `If-Modified-Since` 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：

服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回 304 响应，Response Headers 不会再添加 Last-Modified 字段。

使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：

- 编辑了文件，但文件的内容没有改变。服务端并不清楚是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。
- 当修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。

> 这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。

**Etag**
Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。

Etag 和 Last-Modified 类似，当首次请求时，会在响应头里获取到一个最初的标识符字符串，它可以是这样的：

```txt
ETag: W/"2a3b-1602480f459"
```

那么下一次请求时，请求头里就会带上一个值相同的、名为 `if-None-Match` 的字符串供服务端比对了：

```txt
If-None-Match: W/"2a3b-1602480f459"
```

如果客户端接收到的 ETag 与服务器的 ETag 一致,那么服务器会返回 304

**缺点**:

- Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能。因此启用 Etag 需要审时度势。
- ETags 的版本信息即使主流服务器也未能很好地支持跨服务器的判断，比如你从一个服务器集群中一台到 ETags，然后发送到了另一台那么校验很有可能会失败。

> Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。

##### 1.2.1.3 HTTP 缓存决策指南

![http缓存决策](./image/http缓存决策.png)

1. 当资源内容不可复用时，直接为 `Cache-Control` 设置 `no-store`，拒绝一切形式的缓存
2. 否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 `Cache-Control` 的值为 `no-cache`
3. 否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 `private` 还是 `public`
4. 然后考虑该资源的过期时间，设置对应的 `max-age` 和 `s-maxage` 值
5. 最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。

**它的可行度非常高。**

#### 1.2.2 Memory Cache

MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。

内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。

内存是有限的，很多时候需要先考虑即时呈现的内存余量，再根据具体的情况决定分配给内存和磁盘的资源量的比重——资源存放的位置具有一定的随机性。

内存缓存划分规则可以总结出这样的规律：

- 资源存不存内存，浏览器秉承的是“节约原则”。Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”。
- 体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件，它们往往被直接甩进磁盘。

#### 1.2.3 Service Worker Cache

Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的 “个人行为” 无法干扰页面的性能，这个 “幕后工作者” 可以实现离线缓存、消息推送和网络代理等功能。借助 Service worker 实现的离线缓存就称为 Service Worker Cache。

Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非主动终止它。这是它可以用来实现离线存储的重要先决条件。

**Service Worker 如何实现离线缓存**:

1. 首先在入口文件中插入这样一段 JS 代码，用以判断和引入 Service Worker：

   ```js
   window.navigator.serviceWorker
     .register("/test.js")
     .then(() => {
       console.log("注册成功");
     })
     .catch((err) => {
       console.error("注册失败");
     });
   ```

   在 test.js 中，进行缓存的处理。假设需要缓存的文件分别是 test.html, test.css 和 test.js：

   ```js
   // Service Worker会监听 install事件，在其对应的回调里可以实现初始化的逻辑
   self.addEventListener("install", (event) => {
     event.waitUntil(
       // 考虑到缓存也需要更新，open内传入的参数为缓存的版本号
       caches.open("test-v1").then((cache) => {
         return cache.addAll([
           // 此处传入指定的需缓存的文件名
           "/test.html",
           "/test.css",
           "/test.js",
         ]);
       })
     );
   });

   // Service Worker 会监听所有的网络请求，网络请求的产生触发的是 fetch 事件，可以在其对应的监听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，实现从 Service Worker 中取到缓存的目的
   self.addEventListener("fetch", (event) => {
     event.respondWith(
       // 尝试匹配该请求对应的缓存值
       caches.match(event.request).then((res) => {
         // 如果匹配到了，调用Server Worker缓存
         if (res) {
           return res;
         }
         // 如果没匹配到，向服务端发起这个资源请求
         return fetch(event.request).then((response) => {
           if (!response || response.status !== 200) {
             return response;
           }
           // 请求成功的话，将请求缓存起来。
           caches.open("test-v1").then(function (cache) {
             cache.put(event.request, response);
           });
           return response.clone();
         });
       })
     );
   });
   ```

   > https 协议才能使用 Server Worker。

#### 1.2.4 Push Cache

Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。HTTP2 是趋势、是未来，需要对 Push Cache 的关键特性有所了解。

- Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。
- Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
- 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。

### 1.3 本地存储

#### 1.3.1 Cookie

Cookie 的本职工作并非本地存储，而是“维持状态”。

在 Web 开发的早期，人们亟需解决的一个问题就是状态管理的问题：HTTP 协议是一个无状态协议，服务器接收客户端的请求，返回一个响应，故事到此就结束了，服务器并没有记录下关于客户端的任何信息。那么下次请求的时候，如何让服务器知道“我是我”呢？

在这样的背景下，Cookie 应运而生。

Cookie 其实就是一个存储在浏览器里的小文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。

关于 Cookie 的详细内容，可以在 Chrome 的 `Application` 面板中查看到，**Cookie 以键值对的形式存在**。

**缺点**:

- Cookie 不够大
  Cookie 最大只能有 4KB。当 Cookie 超过 4KB 时，它将被裁切。

- 过量的 Cookie 会带来巨大的性能浪费
  **Cookie 是紧跟域名的**。通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，也可以手动设置 domain 的值：

  ```txt
  Set-Cookie: name=student; domain=student.me
  ```

  **同一个域名下的所有请求，都会携带 Cookie**。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。

#### 1.3.2 Web Storage

为了弥补 Cookie 的局限性，出现了 Web Storage，Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 `Local Storage` 与 `Session Storage`，这两组概念非常相近。

**Local Storage 与 Session Storage 的区别**
两者的区别在于生命周期与作用域的不同。

- **生命周期**

  - Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除
  - Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。

- **作用域**
  - Local Storage、Session Storage 和 Cookie 都遵循同源策略。
  - Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。

**Web Storage 的特性**:

- 存储容量大 : Web Storage 根据浏览器的不同，存储容量可以达到 5-10M 之间。
- 仅位于浏览器端，不与服务端发生通信。

**Web Storage 核心 API 使用示例**
Web Storage 保存的数据内容和 Cookie 一样，是文本内容，以键值对的形式存在。Local Storage 与 Session Storage 在 API 方面无异，这里以 localStorage 为例：

- 存储数据：setItem()

  ```js
  localStorage.setItem("user_name", "dsy");
  ```

- 读取数据：getItem()

  ```js
  localStorage.getItem("user_name");
  ```

- 删除某一键名对应的数据：removeItem()

  ```js
  localStorage.removeItem("user_name");
  ```

- 清空数据记录：clear()

  ```js
  localStorage.clear();
  ```

**应用场景**:

- Local Storage
  Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。
  考虑到 Local Storage 的特点之一是**持久**，有时更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串，有的网站还会用它存储一些不经常更新的 CSS、JS 等静态资源。

- Session Storage
  Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当开启新的会话时，它也需要相应的更新或释放。比如微博的 Session Storage 就主要是存储本次会话的浏览足迹。
  Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，还需要先对字符串进行一轮解析。

> Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。

#### 1.3.3 IndexedDB

IndexedDB 是一个运行在浏览器上的非关系型数据库。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。

接下来，遵循 MDN 推荐的操作模式，通过一个基本的 IndexedDB 使用流程，旨在对 IndexedDB 形成一个感性的认知：

1. 打开/创建一个 IndexedDB 数据库（当该数据库不存在时，open 方法会直接创建一个名为 mainDB 新数据库）。

   ```js
   // 后面的回调中，可以通过 event.target.result 拿到数据库实例
   let db;
   // 参数1位数据库名，参数2为版本号
   const request = window.indexedDB.open("mainDB", 1);
   // 使用IndexedDB失败时的监听函数
   request.onerror = function (event) {
     console.log("无法使用IndexedDB");
   };
   // 成功
   request.onsuccess = function (event) {
     // 此处就可以获取到db实例
     db = event.target.result;
     console.log("你打开了IndexedDB");
   };
   ```

2. 创建一个 object store（object store 对标到数据库中的“表”单位）。

   ```js
   // onupgradeneeded 事件会在初始化数据库/版本发生更新时被调用，在它的监听函数中创建 object store
   request.onupgradeneeded = function (event) {
     let objectStore;
     // 如果同名表未被创建过，则新建test表
     if (!db.objectStoreNames.contains("test")) {
       objectStore = db.createObjectStore("test", { keyPath: "id" });
     }
   };
   ```

3. 构建一个事务来执行一些数据库操作，像增加或提取数据等。

   ```js
   // 创建事务，指定表格名称和读写权限
   const transaction = db.transaction(["test"], "readWrite");
   // 拿到 Object Store 对象
   const objectStore = transaction.objectStore("test");
   // 向表格写入数据
   objectStore.add({ id: 1, name: "xiuyan" });
   ```

4. 通过监听正确类型的事件以等待操作完成。

   ```js
   // 操作成功时的监听函数
   transaction.oncomplete = function (event) {
     console.log("操作成功");
   };
   // 操作失败时的监听函数
   transaction.onerror = function (event) {
     console.log("这里有一个Error");
   };
   ```

**IndexedDB 的应用场景**
在 IndexedDB 中，可以创建多个数据库，一个数据库中创建多张表，一张表中存储多条数据——这足以 hold 住复杂的结构性数据。
IndexedDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，就可以使用 IndexedDB 来帮忙。

## 二. HTML

### 2.1 避免空的 src 和 href

### 2.2 减少 DOM 元素数量

网页中元素过多对网页的加载和脚本的执行都是沉重的负担，500 个元素和 5000 个元素在加载速度上会有很大差别。

> `document.getElementsByTagName("*").length` 获取页面中有多少的元素

### 2.3 减少 iframe 数量

使用 iframe 要注意理解 iframe 的优缺点

优点:

1. 可以用来加载速度较慢的内容，例如广告。
2. 安全沙箱保护。浏览器会对 iframe 中的内容进行安全控制。
3. 脚本可以并行下载
4. 相同的网页内容可避免代码重复

缺点:

1. 即使 iframe 内容为空也消耗加载时间
2. 会阻止页面加载
3. 没有语义

### 2.4 减少 DOM 访问

通过 Javascript 访问 DOM 元素没有想象中快，元素多的网页尤其慢，对于 Javascript 对 DOM 的访问要注意:

1. 缓存已经访问过的元素
2. Offline 更新节点然后再加回 DOM Tree
3. 避免通过 Javascript 修改 layout

### 2.5 打包组建成复合文档

把页面内容打包成复合文本就如同带有多附件的 Email，它能够使你在一个 HTTP 请求中取得多个组件。当你使用这条规则时，首先要确定用户代理是否支持（iPhone 不支持）。

### 2.6 HTML 文档结构层次尽量少，最好不深于六层

### 2.7 减少 Cookie 大小

Cookie 被用来做认证或个性化设置，其信息被包含在 http 报文头中，对于 cookie 要注意以下几点，来提高请求的响应速度

1. 去除没有必要的 cookie，如果网页不需要 cookie 就完全禁掉
2. 将 cookie 的大小减到最小
3. 注意 cookie 设置的 domain 级别，没有必要情况下不要影响到 sub-domain
4. 设置合适的过期时间，比较长的过期时间可以提高响应速度。

### 2.8 按需加载资源

资源（特别是图片）的按需加载或者说惰性加载，可以有助于 Web 应用在整体上获得更好的性能。对于使用大量图片的页面来说惰性加载有着显著的三个好处：

1. 减少向服务器发出的并发请求数量（这就使得页面的其他部分获得更快的加载时间）
2. 减少浏览器的内存使用率（更少的图片，更少的内存）
3. 减少服务器端的负载

### 2.9 使用预加载

预加载可以在真正需要之前，通过取得必需的资源和相关数据来改善访问用户的浏览体验，主要有 3 类预加载:

1. 链接预先获取
2. DNS 预先获取
3. 预先渲染
   在离开当前 web 页面之前，使用预先获取方式，对应每个链接的 URL 地址，CSS，图片和脚本都会被预先获取。这保证了访问者能在最短时间内使用链接在画面间切换。只需在网站 HTML 中的链接属性上增加 `rel="prefetch"`、`rel="dns-prefetch"` 或者 `rel="prerender"` 标记。

## 三. CSS

### 3.1 将 CSS 放在页面最上面

提高浏览器的渲染性能,避免浏览器出现空白和闪烁的问题

### 3.2 避免在 CSS 中使用 Expressions

在页面显示和缩放,页面滚动,移动鼠标时,CSS 中的 Expressions 都会重新计算

### 3.3 优化 CSS Sprite

1. Sprite 图中水平排列图片，垂直排列会增加文件大小
2. Sprite 图中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以便适用 PNG8 格式
3. 不要在 Sprite 的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。

## 四. JS

### 4.1 将 JavaScript 放在页面的最下面

避免 js 出错后页面不显示,加载效率高

### 4.2 将 JavaScript 和 CSS 放到外部文件

### 4.3 JavaScript 和 CSS 压缩和模块打包

使用打包工具压缩，打包

1. 去除不必要的空白符,格式符,注释符
2. 简写方法名，参数名，压缩 JS 脚本

### 4.4 移除重复的脚本

### 4.5 在脚本中尽量减少 DOM 操作，尽量缓存访问 DOM 的样式信息，避免过度触发回流

1. 减少通过 JavaScript 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画
2. 动画尽量使用在绝对定位或固定定位的元素上
3. 隐藏在屏幕外，或在页面滚动时，尽量停止动画

## 五. 网络

### 5.1 尽量的减少 HTTP 的请求数

从客户端到服务器端的请求消息。包括消息首行中，对资源的请求方法，资源的标识符以及使用的协议

> 方法: 压缩,打包

### 5.2 使用 CDN(内容分发网络)

CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。

**CDN 的核心功能**:

- 缓存 : 把资源 copy 一份到 CDN 服务器上这个过程
- 回源 : CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程

**CDN 与前端性能优化**
CDN 往往被用来存放静态资源。“根服务器”本质上是业务服务器，它的核心任务在于生成动态页面或返回非纯静态页面，这两种过程都是需要计算的。业务服务器仿佛一个车间，车间产出所需的资源，相比之下，CDN 服务器则像一个仓库，它只充当资源的“栖息地”和“搬运工”。

所谓“静态资源”，就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。而“动态资源”，顾名思义是需要后端实时动态生成的资源，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。

什么是“非纯静态资源”呢？它是指需要服务器在页面之外作额外计算的 HTML 页面。具体来说，当打开某一网站之前，该网站需要通过权限认证等一系列手段确认身份、进而决定是否要把 HTML 页面呈现出来。这种情况下 HTML 确实是静态的，但它和业务服务器的操作耦合，把它丢到 CDN 上显然是不合适的。

**CDN 的实际应用**
静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段。

**CDN 优化细节**
如何让 CDN 的效用最大化？这是需要前后端程序员一起思考的庞大命题。它涉及到 CDN 服务器本身的性能优化、CDN 节点的地址选取等。

- CDN 的域名选取不一样的
  同一个域名下的请求都会地携带 Cookie，而静态资源往往并不需要 Cookie 携带信息。把静态资源和主页面置于不同的域名下，可以避免了不必要的 Cookie 的出现。

### 5.3 添加 Expire/Cache-Control 头

expire 的头内容是一个时间值,值就是资源在本地的过期时间,存在本地,在本地缓存阶段,找到一个本地的资源值,当前时间还没超过资源的过期时间,就直接使用这一个资源,不会发送 http 请求

Cache-Control 是 HTTP 协议中常用的头部之一,顾名思义,它是负责控制页面的缓存机制,如果该头部指示缓存,缓存的内容也会存在本地.操作流程和 expire 相似,但也有不同的地方,Cache-Control 有更多的选项和处理方式

### 5.4 减少 DNS 查询

> 方法:缓存
> 时间长时: 减少 DNS 的重复查找，节省时间
> 时间短时: 及时的检测网站服务器的变化，保证正确性

### 5.5 使用 AJAX 缓存

### 5.6 避免 404

404 代表服务器没有找到资源，要特别要注意 404 的情况

1. 客户端发送一个请求但是服务器却返回一个无用的结果，时间浪费。
2. 网页中需要加载一个外部脚本，结果返回一个 404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成 Javascript 去解析。

### 5.7 根据域名划分内容

浏览器一般对同一个域的下载连接数有所限制，按照域名划分下载内容可以使浏览器增大并行下载连接，但是注意控制域名使用在 2-4 个之间，不然 dns 查询也是个问题。

一般网站规划会将静态资源放在类似于 static.example.com，动态内容放在www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。

## 六. 其他

### 6.1 启用 Gzip 压缩

在服务器端用 Gzip 压缩,客户端再次用 Gzip 压缩至缓存

> 注意 : pdf 文件可以从需要被压缩的类型中剔除，因为 pdf 文件本身已经压缩，gzip 对其效果不大

### 6.2 图片优化

在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。

一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n^ 种颜色。

#### 6.2.1 JPEG/JPG

有损压缩、体积小、加载快、不支持透明

**使用场景**
JPG 适用于呈现色彩丰富的图片，在日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。使用 JPG 呈现大图，既可以保住图片的质量，又不会带来令人头疼的图片体积。

**优点**:

- JPG 最大的特点是**有损压缩**。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为"有损"压缩，JPG 的压缩方式仍然是一种高质量的压缩方式：当把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。
- JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被人类的肉眼所察觉——前提是你用对了业务场景。

**缺点**:

- 当它处理 **矢量图形** 和 **Logo** 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。
- JPEG 图像**不支持透明度处理**，透明图片需要召唤 PNG 来呈现。

#### 6.2.2 PNG-8 与 PNG-24

无损压缩、质量高、体积大、支持透明

**使用场景**
考虑到 PNG 在处理线条和颜色对比度方面的优势，主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等。

**优缺点**:

- PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。8 和 24，都是二进制数的位数。8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。
- PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了 JPG 的局限性，**唯一的缺点就是体积太大**。

1. 检查 GIF 图片中图像颜色的数量是否和调色板规格一致。如果发现图片中只用到了 4 种颜色，而在调色板的中显示的 256 色的颜色槽，那么这张图片就还有压缩的空间。
2. 尝试把 GIF 格式转换成 PNG 格式
3. 在所有的 PNG 图片上运行 pngcrush(或者其它 PNG 优化工具)
4. 在所有的 JPEG 图片上运行 jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息

**PNG-8 与 PNG-24 的选择**:

理论上来说，当追求最佳的显示效果、并且不在意文件体积大小时，是推荐使用 PNG-24 的。

但实践当中，为了规避体积的问题，一般不用 PNG 去处理较复杂的图像。当遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8。

> 如何确定一张图片是该用 PNG-8 还是 PNG-24 去呈现呢？好的做法是把图片先按照这两种格式分别输出，看 PNG-8 输出的结果是否会带来肉眼可见的质量损耗，并且确认这种损耗是否在可接受的范围内，基于对比的结果去做判断。

#### 6.2.3 SVG

特点: 文本文件、体积小、不失真、兼容性好

SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。

**优点**:

- 和性能关系最密切的一点就是：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。
- 图片可无限放大而不失真。这使得 SVG 即使是被放到视网膜屏幕上，也可以一如既往地展现出较好的成像品质——1 张 SVG 足以适配 n 种分辨率。
- SVG 是文本文件。既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 `.svg` 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。这使得 SVG 文件可以被非常多的工具读取和修改，具有较强的灵活性。

**缺点**:

- 渲染成本比较高，这点对性能来说是很不利的。
- SVG 存在着其它图片格式所没有的学习成本（它是可编程的）。

**使用方式**:

- 将 SVG 写入 HTML

  ```html
  <svg xmlns="http://www.w3.org/2000/svg" width="200" height="200">
    <circle cx="50" cy="50" r="50" />
  </svg>
  ```

- 将 SVG 写入独立文件后引入 HTML

  ```html
  <img src="文件名.svg" alt="" />
  ```

#### 6.2.4 Base64

文本文件、依赖编码、小图标解决方案

Base64 并非一种图片格式，而是一种编码方式。**Base64 是作为 CSS Sprites 的补充而存在的。**

Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。

**使用场景**
非常小的 Logo。

在一张图片满足以下条件时会对它应用 Base64 编码：

- 图片的实际尺寸很小（不超过 2kb）
- 图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）
- 图片的更新频率非常低

#### 6.2.5 WebP

年轻的全能型选手

WebP 于 2010 年被提出，是 Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。

**优点**:

- WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。
- 与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。
- 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。

**缺点**:

- 兼容性差
- WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。

### 6.3 使用小且可缓存的 favicon.ico

1. 网站图标文件 favicon.ico，不管服务器有还是没有，浏览器都会去尝试请求这个图标。所以要确保这个图标
   1. 存在
   2. 文件尽量小，最好小于 1k
   3. 设置一个长的过期时间

### 6.4 移动客户端图片保持单个内容小于 25KB

这限制是因为 iPhone，他只能缓存小于 25K，注意这是解压后的大小。所以单纯 gzip 不一定够用，精简文件工具要用

### 6.5 webPack 优化
