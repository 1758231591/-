---
title : 微信小程序
author: dsy
keyword: "wxml wxss wxs 小程序框架"
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [微信小程序](#微信小程序)
  - [一. 基础](#一-基础)
    - [1.1 申请账号并预览小程序](#11-申请账号并预览小程序)
    - [1.2 小程序代码构成](#12-小程序代码构成)
      - [1.2.1 JSON 配置](#121-json-配置)
        - [1.2.1.1 全局配置 app.js](#1211-全局配置-appjs)
        - [1.2.1.2 工具配置 project.config.json](#1212-工具配置-projectconfigjson)
        - [1.2.1.3 页面配置 page.json](#1213-页面配置-pagejson)
        - [1.2.1.4 网站地图配置 sitemap.json](#1214-网站地图配置-sitemapjson)
        - [1.2.1.5 JSON 语法注意事项](#1215-json-语法注意事项)
      - [1.2.2 WXML 模板](#122-wxml-模板)
      - [1.2.3 WXSS 样式](#123-wxss-样式)
      - [1.2.4 JS 逻辑交互](#124-js-逻辑交互)
    - [1.3 小程序宿主环境](#13-小程序宿主环境)
      - [1.3.1 渲染层和逻辑层](#131-渲染层和逻辑层)
      - [1.3.2 程序与页面](#132-程序与页面)
      - [1.3.3 组件](#133-组件)
      - [1.3.4 API](#134-api)
    - [1.4 小程序协同工作与发布](#14-小程序协同工作与发布)
      - [1.4.1 小程序的版本](#141-小程序的版本)
      - [1.4.2 发布上线](#142-发布上线)
      - [1.4.3 运营数据](#143-运营数据)
    - [1.5 目录结构](#15-目录结构)
  - [二. 小程序框架](#二-小程序框架)
    - [2.1 场景值](#21-场景值)
    - [2.2 逻辑层](#22-逻辑层)
      - [2.2.1 注册小程序实例](#221-注册小程序实例)
      - [2.2.2 注册页面](#222-注册页面)
        - [2.2.2.1 使用 Page 构造器注册页面](#2221-使用-page-构造器注册页面)
        - [2.2.2.2 在页面中使用 behaviors](#2222-在页面中使用-behaviors)
        - [2.2.2.3 使用 Component 构造器构造页面](#2223-使用-component-构造器构造页面)
      - [2.2.3 页面生命周期](#223-页面生命周期)
      - [2.2.4 页面路由](#224-页面路由)
      - [2.2.5 模块化](#225-模块化)
      - [2.2.6 API](#226-api)
    - [2.3 视图层](#23-视图层)
      - [2.3.1 WXML](#231-wxml)
        - [2.3.1.1 数据绑定](#2311-数据绑定)
        - [2.3.1.2 列表渲染](#2312-列表渲染)
        - [2.3.1.3 条件渲染](#2313-条件渲染)
        - [2.3.1.4 模板](#2314-模板)
        - [2.3.1.5 引用](#2315-引用)
      - [2.3.2 WXSS](#232-wxss)
      - [2.3.3 WXS 语法参考](#233-wxs-语法参考)
        - [2.3.3.1 模块](#2331-模块)
        - [2.3.3.2 变量](#2332-变量)
        - [2.3.3.3 注释](#2333-注释)
        - [2.3.3.4 运算符](#2334-运算符)
        - [2.3.3.5 数据类型](#2335-数据类型)
        - [2.3.3.6 基础类库](#2336-基础类库)
      - [2.3.4 事件系统](#234-事件系统)
        - [2.3.4.1 事件的使用方式](#2341-事件的使用方式)
        - [2.3.4.2 事件详解](#2342-事件详解)
        - [2.3.4.3 事件对象](#2343-事件对象)
        - [2.3.4.4 使用WXS函数响应事件](#2344-使用wxs函数响应事件)
      - [2.3.5 简易双向绑定](#235-简易双向绑定)
      - [2.3.6 基础组件](#236-基础组件)
      - [2.3.7 获取界面上的信息节点](#237-获取界面上的信息节点)
      - [2.3.8 响应显示区域的变化](#238-响应显示区域的变化)
      - [2.3.9 动画](#239-动画)
      - [2.3.10 初始渲染缓存](#2310-初始渲染缓存)
  - [三. 小程序运行时](#三-小程序运行时)
    - [3.1 运行环境](#31-运行环境)
    - [3.2 JavaScript 支持情况](#32-javascript-支持情况)
    - [3.3 运行机制](#33-运行机制)
    - [3.4 更新机制](#34-更新机制)
  - [四. 自定义组件](#四-自定义组件)
    - [4.1 组件模板与样式](#41-组件模板与样式)
    - [4.2 Component 构造器](#42-component-构造器)
    - [4.3 组件间通信与事件](#43-组件间通信与事件)
    - [4.4 组件生命周期](#44-组件生命周期)
    - [4.5 behaviors](#45-behaviors)
      - [4.5.1 参数与含义](#451-参数与含义)
      - [4.5.2 内置 behaviors](#452-内置-behaviors)
    - [4.6 组件间关系](#46-组件间关系)
      - [4.6.1 定义和使用组件间关系](#461-定义和使用组件间关系)
      - [4.6.2 关联一类组件](#462-关联一类组件)
      - [4.6.3 relations 定义段](#463-relations-定义段)
    - [4.7 数据监听器](#47-数据监听器)
    - [4.8 纯数据字段](#48-纯数据字段)
    - [4.9 抽象节点](#49-抽象节点)
    - [4.10 自定义组件扩展](#410-自定义组件扩展)
    - [4.11 单元测试](#411-单元测试)
    - [4.12 获取更新性能统计信息](#412-获取更新性能统计信息)
  - [五. 基础能力](#五-基础能力)
    - [5.1 网络](#51-网络)
      - [5.1.1 使用说明](#511-使用说明)
      - [5.1.2 局域网通信](#512-局域网通信)
    - [5.2 存储](#52-存储)
    - [5.3 文件系统](#53-文件系统)
    - [5.4 画布](#54-画布)
      - [5.4.1 坐标系](#541-坐标系)
      - [5.4.2 渐变](#542-渐变)
    - [5.5 分包加载](#55-分包加载)
      - [5.5.1 使用分包](#551-使用分包)
      - [5.5.2 独立分包](#552-独立分包)
      - [5.5.3 分包预下载](#553-分包预下载)
    - [5.6 多线程Worker](#56-多线程worker)
    - [5.7 服务端能力](#57-服务端能力)
      - [5.7.1 服务端API](#571-服务端api)
      - [5.7.2 消息推送](#572-消息推送)
        - [5.7.2.1 开发者服务器接收消息推送](#5721-开发者服务器接收消息推送)
        - [5.7.2.2 云函数接收消息推送](#5722-云函数接收消息推送)
    - [5.8 自定义 tabBar](#58-自定义-tabbar)
    - [5.9 周期性更新](#59-周期性更新)
    - [5.10 数据预拉取](#510-数据预拉取)
    - [5.11 DarkModel 适配指南](#511-darkmodel-适配指南)
    - [5.12 大屏适配指南](#512-大屏适配指南)
  - [六. 硬件能力](#六-硬件能力)
    - [6.1 蓝牙](#61-蓝牙)
    - [6.2 NFC](#62-nfc)
    - [6.3 WI-FI](#63-wi-fi)
  - [七. 开放能力](#七-开放能力)
    - [7.1 用户信息](#71-用户信息)
      - [7.1.1 小程序登录](#711-小程序登录)
      - [7.1.2 UnionID 机制说明](#712-unionid-机制说明)
      - [7.1.3 授权](#713-授权)
      - [7.1.4 开放数据校验与解密](#714-开放数据校验与解密)
        - [7.1.4.1 开发者后台校验与解密开放数据](#7141-开发者后台校验与解密开放数据)
        - [7.1.4.2 云调用直接获取开放数据](#7142-云调用直接获取开放数据)

<!-- /code_chunk_output -->

[compatibility]: https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html
[api]: https://developers.weixin.qq.com/miniprogram/dev/api/
[组件]: https://developers.weixin.qq.com/miniprogram/dev/component/
[服务端]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/
[消息加解密说明]: https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/Message_Encryption/Message_encryption_and_decryption.html
[云开发]: https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html
[grid]: https://developers.weixin.qq.com/miniprogram/dev/extended/component-plus/grid.html
[camera]: https://developers.weixin.qq.com/miniprogram/dev/component/camera.html

[canvas]: https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html
[CanvasContext]: https://developers.weixin.qq.com/miniprogram/dev/api/canvas/CanvasContext.html
[CanvasContext.createCircularGradient]: https://developers.weixin.qq.com/miniprogram/dev/api/canvas/CanvasContext.createCircularGradient.html
[CanvasContext.createLinearGradient]: https://developers.weixin.qq.com/miniprogram/dev/api/canvas/CanvasContext.createLinearGradient.html
[CanvasGradient.addColorStop]: https://developers.weixin.qq.com/miniprogram/dev/api/canvas/CanvasGradient.addColorStop.html

[Worker.postMessage]: https://developers.weixin.qq.com/miniprogram/dev/api/worker/Worker.postMessage.html
[Worker.onMessage]: https://developers.weixin.qq.com/miniprogram/dev/api/worker/Worker.onMessage.html

[wx.login]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html
[wx.request]: https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html
[wx.uploadFile]: https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/wx.uploadFile.html
[wx.downloadFile]: https://developers.weixin.qq.com/miniprogram/dev/api/network/download/wx.downloadFile.html
[wx.connectSocket]: https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.connectSocket.html
[wx.createUDPSocket]: https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/wx.createUDPSocket.html
[wx.startLocalServiceDiscovery]: https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.startLocalServiceDiscovery.html
[wx.setStorage]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorage.html
[wx.setStorageSync]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html
[wx.getStorage]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.getStorage.html
[wx.getStorageSync]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.getStorageSync.html
[wx.clearStorage]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.clearStorage.html
[wx.clearStorageSync]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.clearStorageSync.html
[wx.removeStorage]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.removeStorage.html
[wx.removeStorageSync]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.removeStorageSync.html
[wx.getFileSystemManager]: https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.getFileSystemManager.html
[wx.setBackgroundFetchToken]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.setBackgroundFetchToken.html
[wx.getBackgroundFetchData]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.getBackgroundFetchData.html
[wx.getUserInfo]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html
[wx.getSetting]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.getSetting.html
[wx.openSetting]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.openSetting.html
[wx.authorize]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorize.html
[wx.getLocation]: https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html
[wx.chooseLocation]: https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.chooseLocation.html
[wx.startLocationUpdateBackground]: https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.startLocationUpdateBackground.html
[wx.chooseAddress]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/address/wx.chooseAddress.html
[wx.chooseInvoiceTitle]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/invoice/wx.chooseInvoiceTitle.html
[wx.chooseInvoice]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/invoice/wx.chooseInvoice.html
[wx.getWeRunData]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/werun/wx.getWeRunData.html
[wx.startRecord]: https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/wx.startRecord.html
[wx.saveImageToPhotosAlbum]: https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.saveImageToPhotosAlbum.html
[wx.saveVideoToPhotosAlbum]: https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.saveVideoToPhotosAlbum.html
[wx.checkSession]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.checkSession.html
[wx.checkIsSupportSoterAuthentication]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/soter/wx.checkIsSupportSoterAuthentication.html
[wx.startSoterAuthentication]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/soter/wx.startSoterAuthentication.html
[wx.showShareMenu]: https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.showShareMenu.html
[wx.getShareInfo]: https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.getShareInfo.html
[wx.updateShareMenu]: https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.updateShareMenu.html

[wx.openBluetoothAdapter]: https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.openBluetoothAdapter.html
[wx.closeBluetoothAdapter]: https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.closeBluetoothAdapter.html
[wx.getBLEDeviceServices]: https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.getBLEDeviceServices.html
[wx.getBLEDeviceCharacteristics]: https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.getBLEDeviceCharacteristics.html

[wx.offThemeChange]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offThemeChange.html
[wx.onThemeChange]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onThemeChange.html
[wx.onAppShow]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppShow.html
[wx.onAppHide]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppHide.html
[wx.onError]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onError.html
[wx.onPageNotFound]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html

[FileSystemManager]: https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.html
[FileSystemManager.saveFile]: https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.saveFile.html
[FileSystemManager.copyFile]: https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.copyFile.html

[cloud.getWXContext]:https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-server-api/utils/getWXContext.html
[auth.code2Session]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html
[updatableMessage.createActivityId]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/updatable-message/updatableMessage.createActivityId.html

# 微信小程序

---

## 一. 基础

**小程序与普通网页开发的区别**:

1. ​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。
2. 网页开发可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。
3. JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。
4. 小程序开发过程中需要面对的是两大操作系统 **iOS** 和 **Android** 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的

运行环境 | 逻辑层 | 渲染层
--------|-------|-------
iOS  | JavaScriptCore | WKWebView
安卓 | V8 | 定制内核
小程序开发工具 | NWJS | Chrome WebView

### 1.1 申请账号并预览小程序

进入 [小程序注册页](https://mp.weixin.qq.com/wxopen/waregister?action=step1) 根据指引填写信息和提交相应的资料，申请账号

在小程序管理平台，可以管理小程序的权限，查看数据报表，发布小程序等操作。

登录 [微信公众平台](https://mp.weixin.qq.com/) ，可以在菜单 "开发"-"开发设置"-"开发设置" 中看到小程序的 **AppID** 。

小程序的 AppID 相当于小程序平台的一个身份证，后续会在很多地方要用到 AppID （注意这里要区别于服务号或订阅号的 AppID）。

新建项目选择小程序项目，选择代码存放的硬盘路径，填入小程序的 AppID，给项目起名字，勾选 "不使用云服务"，点击新建，点击顶部菜单编译就可以在微信开发者工具中预览小程序。

### 1.2 小程序代码构成

#### 1.2.1 JSON 配置

JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的是静态配置的角色。
在项目的根目录有一个 *app.json*、*sitemap.json* 和 *project.config.json*，此外在 *pages/logs* 目录下还有一个 *logs.json*

##### 1.2.1.1 全局配置 app.js

app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。完整配置项说明参考 [小程序全局配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

以下是一个包含了部分常用配置选项的 app.json ：

```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/index"
  ],
  "window": {
    "navigationBarTitleText": "Demo"
  },
  "tabBar": {
    "list": [{
      "pagePath": "pages/index/index",
      "text": "首页"
    }, {
      "pagePath": "pages/logs/index",
      "text": "日志"
    }]
  },
  "networkTimeout": {
    "request": 10000,
    "downloadFile": 10000
  },
  "debug": true
}
```

##### 1.2.1.2 工具配置 project.config.json

在工具上做的任何配置都会写入到 project.config.json，当重新安装工具或者换电脑工作时，只要载入同一个项目的代码包，开发者工具就自动会恢复到开发项目时的个性化配置。其他配置项细节可以参考文档 [开发者工具配置](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)

##### 1.2.1.3 页面配置 page.json

这里的 page.json 是用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。每一个小程序页面也可以使用同名 .json 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。例如: 顶部颜色、是否允许下拉刷新等等。完整配置项说明可以参考文档 [小程序页面配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)

```json
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

##### 1.2.1.4 网站地图配置 sitemap.json

微信现已开放小程序内搜索，可以通过 **sitemap.json** 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的**搜索词条触发**该索引时，小程序的页面将可能展示在搜索结果中。
爬虫访问小程序内页面时，会携带特定的 user-agent：mpcrawler 及 [场景值](#21-场景值)：1129。

当在小程序项目中设置了 sitemap 的配置文件（默认为 sitemap.json）时，便可在开发者工具控制台上显示当前页面是否被索引的调试信息
完整配置项说明参考 [小程序 sitemap 配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html)

所有页面都会被微信索引（默认情况）

```json
{
  "rules" : {
    "action" : "allow",
    "page" : "*"
  }
}
```

> 注意:
>
> 1. 若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。
> 2. 没有 sitemap.json 则默认所有页面都能被索引
> 3. {"action": "allow", "page": "*"} 是优先级最低的默认规则，未显式指明 "disallow" 的都默认被索引
> 4. sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false
> 5. sitemap 文件内容最大为 5120 个 UTF8 字符

##### 1.2.1.5 JSON 语法注意事项

1. JSON文件都是被包裹在一个大括号中 {}，通过key-value的方式来表达数据。
2. JSON的Key必须包裹在一个双引号中
3. JSON的值只能是以下几种数据格式，其他任何格式都会触发报错
    - 数字，包含浮点数和整数
    - 字符串，需要包裹在双引号中
    - boolean值，true 或者 false
    - 数组，需要包裹在方括号中 []
    - 对象，需要包裹在大括号中 {}
    - Null
4. JSON 文件中无法使用注释，试图添加注释将会引发报错。

#### 1.2.2 WXML 模板

在小程序中 WXML 充当的是类似 HTML 的角色。和 HTML 非常相似，WXML 由标签、属性等等构成。但是也有很多不一样的地方:

1. 小程序的 WXML 用的标签是 view, button, text 等等，这些标签是小程序包装好的基本能力，还提供了地图、视频、音频等等组件能力。
2. 多了一些 **wx:if** 这样的属性以及 **{{ }}** 这样的表达式
  现在提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理**状态**，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路。

WXML这样写

```wxml
<text>{{msg}}</text>
```

JS只需要管理状态即可

```js
this.setData({
  msg : "This is a cat"
})
```

通过 {{ }} 的语法把一个变量绑定到界面上，称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for 等控制能力，在小程序里边，这些控制能力都用 `wx:` 开头的属性来表达。详细的文档可以参考 [WXML](#231-wxml)

#### 1.2.3 WXSS 样式

WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。更详细的文档可以参考 [WXSS](#232-wxss)

1. WXSS 在底层支持新的尺寸单位 `rpx` ，可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。
2. 提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，可以写一个 **app.wxss** 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 **page.wxss** 仅对当前页面生效。
3. WXSS 仅支持部分 CSS 选择器

#### 1.2.4 JS 逻辑交互

一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，可以通过编写 **JS** 脚本文件来处理用户的操作。更详细的事件可以参考文档 [WXML事件](#234-事件系统)

```wxml
<view>{{msg}}</view>
<button bindtap="clickMe">点击</button>
```

点击 button 按钮的时候，希望把界面上 msg 显示成 "this is a cat"，于是在 button 上声明一个属性: **bindtap** ，在 JS 文件里边声明了 **clickMe** 方法来响应这次点击操作

```js
page({
  clickMe : function () {
    this.setData({msg: "this is a cat"});
  }
})
```

此外还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。更多 API 可以参考文档 [小程序的API][api] 。

### 1.3 小程序宿主环境

微信客户端给小程序所提供的环境叫宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。

#### 1.3.1 渲染层和逻辑层

小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了 **WebView** 进行渲染；逻辑层采用 **JsCore** 线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由微信客户端转发，小程序的通信模型如下图所示。

![微信小程序通信模型](./image/微信小程序通信模型.png)

有关渲染层和逻辑层的详细文档参考 [小程序框架](#二-小程序框架)

#### 1.3.2 程序与页面

微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。紧接着通过 app.json 的 **pages** 字段知道当前小程序的所有页面路径。

如果没有定义 `entryPagePath` 属性，默认 pages 列表的第一项为小程序的默认启动路径（首页）。不支持带页面路径参数。

然后，微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，渲染出首页。

小程序启动之后，在 app.js 定义的 App 实例的 `onLaunch` 回调会被执行。整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 [注册程序 App](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html) 。

**pages/logs/logs** 下包括了4种文件，微信客户端会先根据 logs.json 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 WXML 结构和 WXSS 样式。最后客户端会装载 logs.js，logs.js 的大体内容就是:

```js
// 代码示例
Page({
  data: { // 参与页面渲染的数据
    logs: []
  },
  onLoad: function () {
    // 页面渲染后 执行
  }
})
```

`Page` 是一个页面构造器，这个构造器生成了一个页面。在生成页面的时候，小程序框架会把 data 数据和 logs.wxml 一起渲染出最终的结构。在渲染完界面之后，页面实例就会收到一个 `onLoad` 的回调，可以在这个回调处理需要的逻辑。Page 构造器详细文档参考 [注册页面 Page](#222-注册页面)

#### 1.3.3 组件

小程序提供了丰富的基础组件，可以像搭积木一样，组合各种组件拼合成小程序。

在小程序里边，只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，在界面显示地图：

```wxml
<map></map>
```

使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，希望地图一开始的中心的经纬度是北京，那么需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:

```wxml
<map longitude="116.397128" latitude="39.916527" ></map>
```

组件的内部行为也会通过事件的形式感知，例如用户点击了地图上的某个标记，可以在 js 编写 markertap 函数来处理：

```wxml
<map bind:markertap="markertap" longitude="116.397128" latitude="39.916527"></map>
```

也可以通过 style 或者 class 来控制组件的外层样式，以便适应界面宽度高度等等。更多的组件可以参考 [小程序组件][组件] 。

#### 1.3.4 API

为了很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 。更多的 API 可以参考文档 [小程序的API][api]。

要获取用户的地理位置时，只需要：

```js
wx.getLocation({
  type: 'wgs84',
  success: (res) => {
    var latitude = res.latitude // 纬度
    var longitude = res.longitude // 经度
  }
})
```

> 注意：多数 API 的回调都是 **异步**，需要处理好代码逻辑的异步问题。

### 1.4 小程序协同工作与发布

#### 1.4.1 小程序的版本

一般的软件开发流程，编写代码自测开发版程序，直到程序达到一个稳定可体验的状态时，然后把这个体验版本给到产品经理和测试人员进行体验测试，最后修复完程序的Bug后发布供外部用户正式使用。小程序的版本根据这个流程设计了小程序版本的概念。

版本 | 说明
----|------
开发版本 | 使用开发者工具，可将代码上传到开发版本中。开发版本只保留每人最新的一份上传的代码。点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码
体验版本 | 可以选择某个开发版本作为体验版，并且选取一份体验版。
审核中版本 | 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。
线上版本 | 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。

考虑到项目是协同开发的模式，一个小程序可能同时由多个开发者进行开发，往往开发者在小程序开发者工具上编写完代码后需要到手机进行真机体验，所以每个开发者拥有自己对应的一个开发版本。因为处于开发中的版本是不稳定的，开发者随时会修改代码覆盖开发版，为了让测试和产品经理有一个完整稳定的版本可以体验测试，小程序平台允许把其中一个开发版本设置成体验版，因此建议在项目开发阶段特殊分配一个开发角色，用于上传稳定可供体验测试的代码，并把他上传的开发版本设置成体验版。

#### 1.4.2 发布上线

一个小程序从开发完到上线一般要经过 预览-> 上传代码 -> 提交审核 -> 发布等步骤。

**预览**
使用开发者工具可以预览小程序，帮助开发者检查小程序在移动客户端上的真实表现。

点击开发者工具顶部操作栏的预览按钮，开发者工具会自动打包当前项目，并上传小程序代码至微信的服务器，成功之后会在界面上显示一个二维码。使用当前小程序开发者的微信扫码即可看到小程序在手机客户端上的真实表现。

**上传代码**
同预览不同，上传代码是用于提交体验或者审核使用的。

点击开发者工具顶部操作栏的上传按钮，填写版本号以及项目备注，需要注意的是，这里版本号以及项目备注是为了方便管理员检查版本使用的，开发者可以根据自己的实际要求来填写这两个字段。

上传成功之后，登录小程序管理后台 - 开发管理 - 开发版本 就可以找到刚提交上传的版本了。

可以将这个版本设置 体验版 或者是 提交审核

**提交审核**
为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过审核的。

在开发者工具中上传了小程序代码之后，登录 小程序管理后台 - 开发管理 - 开发版本 找到提交上传的版本。

在开发版本的列表中，点击 提交审核 按照页面提示，填写相关的信息，即可以将小程序提交审核。

> 注意: 严格测试了版本之后，再提交审核，过多的审核不通过，可能会影响后续的时间。

**发布**
审核通过之后，管理员的微信中会收到小程序通过审核的通知，此时登录 小程序管理后台 - 开发管理 - 审核版本中可以看到通过审核的版本。

点击发布后，即可发布小程序。小程序提供了两种发布模式：**全量发布** 和 **分阶段发布**。全量发布是指当点击发布之后，所有用户访问小程序时都会使用当前最新的发布版本。分阶段发布是指分不同时间段来控制部分用户使用最新的发布版本，分阶段发布我们也称为灰度发布。一般来说，普通小程序发布时采用全量发布即可，当小程序承载的功能越来越多，使用的用户数越来越多时，采用分阶段发布是一个非常好的控制风险的办法。

#### 1.4.3 运营数据

有两种方式可以方便的看到小程序的 [运营数据](https://developers.weixin.qq.com/miniprogram/analysis/)

1. 登录 [小程序管理后台](https://mp.weixin.qq.com/) - 数据分析，点击相应的 tab 可以看到相关的数据。

2. 使用小程序数据助手，在微信中方便的查看运营数据

### 1.5 目录结构

小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。

一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

文件 | 必需 | 作用
-----|------|----
app.js | 是 | 小程序逻辑
app.json | 是 | 小程序公共配置
app.wxss | 否 | 小程序公共样式表

一个小程序页面由四个文件组成，分别是：

文件类型 | 必需 | 作用
--------|------|----
js | 是 | 页面逻辑
wxml | 是 | 页面结构
json | 否 | 页面配置
wxss | 否 | 页面样式表

> **注意**：为了减少配置项，描述页面的四个文件必须具有相同的路径与文件名。

**允许上传的文件**
在项目目录中，以下文件会经过编译，因此上传之后无法直接访问到：.js、app.json、.wxml、*.wxss（其中 wxml 和 wxss 文件仅针对在 app.json 中配置了的页面）。除此之外，只有后缀名在白名单内的文件可以被上传，不在白名单列表内文件在开发工具能被访问到，但无法被上传。具体白名单列表如下：

1. wxs
2. png
3. jpg
4. jpeg
5. gif
6. svg
7. json
8. cer
9. mp3
10. aac
11. m4a
12. mp4
13. wav
14. ogg
15. silk

## 二. 小程序框架

### 2.1 场景值

场景值用来描述用户进入小程序的路径。部分场景值下还可以获取来源应用、公众号或小程序的appId。完整场景值的含义可查看 [场景值列表](https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html)。

**获取场景值** :

- 对于小程序，可以在 App 的 **onLaunch** 和 **onShow**，或 **wx.getLaunchOptionsSync** 中获取场景值。
- 对于小游戏，可以在 **wx.getLaunchOptionsSync** 和 **wx.onShow** 中获取场景值

> 注 : 由于Android系统限制，目前还无法获取到按 Home 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值。

### 2.2 逻辑层

小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供 JavaScript 代码的运行环境以及微信小程序的特有功能。

逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。

写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。

小程序在 JavaScript 的基础上，增加了一些其他功能:

- 增加 App 和 Page 方法，进行程序注册和页面注册。
- 增加 `getApp` 和 `getCurrentPages` 方法，分别用来获取 App 实例和当前页面栈。
- 提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。
- 提供模块化能力，每个页面有独立的作用域。

> 注 : 小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 浏览器 中一些能力都无法使用，如 window，document 等。

#### 2.2.1 注册小程序实例

每个小程序都需要在 **app.js** 中调用 **App** 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。
详细的参数含义和使用 [App 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html) 。

整个小程序只有一个 App 实例，是全部页面共享的。可以通过 `getApp` 方法获取到全局唯一的 App 实例，获取App上的数据或调用注册在 App 上的函数。
**例** : [app.js](./test/app.js)

> 注 : 调用 **App** 方法注册小程序实例，必须调用且只能调用一次。不然会出现无法预期的后果。

#### 2.2.2 注册页面

对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。

##### 2.2.2.1 使用 Page 构造器注册页面

简单的页面可以使用 Page() 进行构造。详细的参数含义和使用参考 [Page 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html) 。

**例** : [index.js](./test/pages/index/index.js)

##### 2.2.2.2 在页面中使用 behaviors

> 基础库 2.9.2 开始支持，低版本需做 [兼容处理][compatibility]。

页面可以引用 `behaviors` 。 behaviors 可以用来让多个页面有相同的数据字段和方法。具体用法参见 [behaviors](#45-behaviors)

##### 2.2.2.3 使用 Component 构造器构造页面

> 基础库 1.6.3 开始支持，低版本需做 [兼容处理][compatibility]。

Page 构造器适用于简单的页面。但对于复杂的页面， Page 构造器可能并不好用。

此时，可以使用 `Component` 构造器来构造页面。 `Component` 构造器的主要区别是：方法需要放在 `methods: { }` 里面。
这种创建方式非常类似于 *自定义组件* ，可以像自定义组件一样使用 `behaviors` 等高级特性。具体细节阅读 [Component 构造器](#42-component-构造器) 。

#### 2.2.3 页面生命周期

![小程序页面Page实例的生命周期](./image/小程序页面Page实例的生命周期.png)

#### 2.2.4 页面路由

在小程序中所有页面的路由全部由框架进行管理。

**页面栈**
框架以栈的形式维护了当前的所有页面。可以使用 `getCurrentPages()` 函数获取当前页面栈。当发生路由切换的时候，页面栈的表现如下：

路由方式 | 页面栈表现
--------|------------
初始化 | 新页面入栈
打开新页面 | 新页面入栈
页面重定向 | 当前页面出栈，新页面入栈
页面返回 | 页面不断出栈，直到目标返回页
Tab 切换 | 页面全部出栈，只留下新的 Tab 页面
重加载 | 页面全部出栈，只留下新的页面

**路由方式**
对于路由的触发方式以及页面生命周期函数如下：

路由方式 | 触发时机 | 路由前页面 | 路由后页面
--------|----------|-----------|----------
初始化 | 小程序打开的第一个页面 | - | onLoad, onShow
打开新页面 | 调用 API `wx.navigateTo`；使用组件 `<navigator open-type="navigateTo"/>` | onHide | onLoad, onShow
页面重定向 | 调用 API `wx.redirectTo`；使用组件 `<navigator open-type="redirectTo"/>` | onUnload | onLoad, onShow
页面返回 | 调用 API `wx.navigateBack`；使用组件`<navigator open-type="navigateBack">`；用户按左上角返回按钮 | onUnload | onShow
Tab 切换 | 调用 API `wx.switchTab`；使用组件 `<navigator open-type="switchTab"/>`；用户切换 Tab | - | 各种情况请参考下表
重启动 | 调用 API `wx.reLaunch`；使用组件 `<navigator open-type="reLaunch"/>` | onUnload | onLoad, onShow

Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：

当前页面 | 路由后页面 | 触发的生命周期（按顺序）
--------|------------|--------------------
A | A | Nothing happen
A | B | A.onHide(), B.onLoad(), B.onShow()
A | B（再次打开） | A.onHide(), B.onShow()
C | A | C.onUnload(), A.onShow()
C | B | C.onUnload(), B.onLoad(), B.onShow()
D | B | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()
D（从转发进入） | A | D.onUnload(), A.onLoad(), A.onShow()
D（从转发进入） | B | D.onUnload(), B.onLoad(), B.onShow()

**Tips**:

- `navigateTo`, `redirectTo` 只能打开非 tabBar 页面。
- `switchTab` 只能打开 tabBar 页面。
- `reLaunch` 可以打开任意页面。
- 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
- 调用页面路由带的参数可以在目标页面的 `onLoad` 中获取。

#### 2.2.5 模块化

可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 `module.exports` 才能暴露。
​在需要使用这些模块的文件中，使用 `require` 将公共代码引入

> **注意** : 小程序目前不支持直接引入 node_modules , 需要使用到 node_modules 时候需要拷贝出相关的代码到小程序的目录中，或者使用小程序支持的 npm 功能。

**文件作用域**
在 JS 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。

通过全局函数 `getApp` 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置。

#### 2.2.6 API

小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍参考 [API 文档][api]。

常用的小程序API有以下几种:

**事件监听API**
小程序约定，以 `on` 开头的 API 用来监听某个事件是否触发，如：`wx.onSocketOpen`，`wx.onCompassChange` 等

这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

```js
// 代码示例
wx.onCompassChange(function (res) {
  console.log(res.direction)
})
```

**同步API**
小程序约定，以 **Sync** 结尾的 API 都是同步 API， 如 `wx.setStorageSync`，`wx.getSystemInfoSync` 等。此外，也有一些其他的同步 API，如 `wx.createWorker`，`wx.getBackgroundAudioManager` 等

同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。

```js
// 代码示例
try {
  wx.getStorageSync('key', 'value')
} catch (e) {
  console.log(e)
}
```

**异步API**
大多数 API 都是异步 API，如 `wx.request`，`wx.login` 等。这类 API 接口通常都接受一个 `Object` 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：

Object 参数说明

参数名 | 类型 | 必填 | 说明
-------|-----|------|------
success | function | 否 | 接口调用成功的回调函数
fail | function | 否 | 接口调用失败的回调函数
complete | function | 否 | 接口调用结束的回调函数（调用成功、失败都会执行）
其他 | Any | - | 接口定义的其他参数

回调函数的参数

success，fail，complete 函数调用时会传入一个 Object 类型参数，包含以下字段:

属性 | 类型 | 说明
----|-------|-----
errMsg | string | 错误信息，如果调用成功返回 `${apiName}:ok`
errCode | number | 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 0。
其他 | Any | 接口返回的其他数据

异步 API 的执行结果需要通过 `Object` 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能，如 `wx.request`，`wx.connectSocket` 等。

```js
// 代码示例
wx.login({
  success(res) {
    if(res.code) {
      // 发起网络请求
      wx.request({
        url: 'https://test.com/onLogin',
        data: {
          code : res.code
        }
      })
    } else {
      console.log('登录失败' + res.message);
    }
  }
})
```

**异步 API 返回 Promise**
基础库 2.10.2 版本起，异步 API 支持 **callback & promise** 两种调用方式。当接口参数 Object 对象中不包含 success/fail/complete 时将默认返回 promise，否则仍按回调方式执行，无返回值。

> 注意:
>
> 1. 部分接口如 `downloadFile`, `request`, `uploadFile`, `connectSocket`, `createCamera`（小游戏）本身就有返回值， 它们的 promisify 需要自行封装。
> 2. 当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 Uncaught (in promise)，可通过 catch 来进行捕获。
> 3. `wx.onUnhandledRejection` 可以监听未处理的 Promise 拒绝事件。

```js
// 代码示例
// callback 形式调用
wx.chooseImage({
  count: 1,
  sizeType:['original', 'compressed'],
  success(res) {
    console.log('res:')
  }
})
```

**云开发API**
需要开通并使用 [小程序云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)，即可使用云开发API，在小程序端直接调用服务端的 [云函数](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html#%E4%BA%91%E5%87%BD%E6%95%B0)。

```js
// 代码示例
wx.cloud.callFunction({
  // 云函数名称
  name: 'cloudFunc',
  // 传给云函数的参数
  data: {
    a: 1,
    b: 2,
  },
  success: function(res) {
    console.log(res.result) // 示例
  },
  fail: console.error
})

// 此外，云函数同样支持promise形式调用
```

### 2.3 视图层

框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。

将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。

WXML(WeiXin Markup language) 用于描述页面的结构。

WXS(WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。

WXSS(WeiXin Style Sheet) 用于描述页面的样式。

组件(Component)是视图的基本组成单元。

#### 2.3.1 WXML

WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合 [基础组件][组件]、[事件系统][#234-事件系统]，可以构建出页面的结构。

##### 2.3.1.1 数据绑定

WXML 中的动态数据均来自对应 Page 的 data。

**简单绑定**
数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于:

- 内容

```wxml
<view>{{message}}</view>
```

```js
Page({
  data: {
    message: 'This is a cat.'
  }
})
```

- 组件属性(需要在双引号以内)

```wxml
<view id="item-{{id}}"></view>
```

```js
Page({
  data: {
    id: 0
  }
})
```

- 控制属性(需要在双引号以内)

```wxml
<view wx:if="{{condition}}"></view>
```

```js
Page({
  data:{
    condition: true
  }
})
```

- 关键字(需要在双引号以内)

**true**
: boolean 类型的 true，代表真值。

**false**
: boolean 类型的 false，代表假值。

```wxml
<view checked="{{false}}"></view>
```

> 特别注意：不要直接写 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值

**运算**
可以在 `{{}}` 内进行简单的运算，支持的有如下几种方式：

- 三元运算

```wxml
<view hidden="{{flag != 0 ? true : true}}">{{flag}}</view>
```

- 算术运算

```wxml
<view>{{a + b}} + {{c}} + d</view> // 3 + 3 + d
```

```js
Page({
  data: {
    a: 1,
    b: 2,
    c: 3
  }
})
```

- 逻辑判断

```wxml
<view wx:if="{{length > 5}}"> </view>
```

- 字符串运算

```wxml
<view>{{"hello" + name}}</view>
```

```js
Page({
  data: {
    name: 'Tom'
  }
})
```

- 数据路径运算

```wxml
<view>{{object.key}} {{array[0]}}</view>
```

```js
Page({
  data: {
    object: {
      key: "hello"
    },
    array: ['Tom']
  }
})
```

**组合**
也可以在 Mustache 内直接进行组合，构成新的对象或者数组。

- 数组

```wxml
<view wx:for="{{[zero, 1, 2, 3, 4]}}">{{item}}</view> // 最终组合成数组[0, 1, 2, 3, 4]
```

```js
Page({
  data: {
    zero: 0
  }
})
```

- 对象

```wxml
<template is="objectCombine" data="{{for: a, bar: b}}"></template> // 最终组合成的对象是 {for: 1, bar: 2}
```

```js
Page({
  data: {
    a: 1,
    b: 2
  }
})
```

也可以用扩展运算符 `...` 来将一个对象展开

```wxml
<template is="objectCombine" data="{{...obj, ...obj2, e: 5}}"></template> // 最终组合成的对象是 {a: 1, b: 2, c: 3, d: 4, e: 5}
```

```js
Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      c: 3,
      d: 4
    }
  }
})
```

如果对象的 key 和 value 相同，也可以间接地表达。

```wxml
<template is="objectCombine" data="{{foo, bar}}"></template> // 最终组合成的对象是 {foo: 'my-foo', bar:'my-bar'}
```

```js
Page({
  data: {
    foo: 'my-foo',
    bar: 'my-bar'
  }
})
```

> **注意** : 上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如：

```wxml
<template is="objectCombine" data="{{...obj1, ...obj2, a, c: 6}}"></template> // 最终组合成的对象是 {a: 5, b: 3, c: 6}
```

```js
Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      c: 1,
      d: 2
    }
  },
  a: 5
})
```

> **注意** : 花括号与引号之间如果有空格，将最终被解析成为字符串

```wxml
<view wx:for="{{[1, 2, 3]}} ">
  {{item}}
</view>
```

等同于

```wxml
<view wx:for="{{[1, 2, 3] + ' '}}">
  {{item}}
</view>
```

##### 2.3.1.2 列表渲染

**wx:for**
在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item` 。

```wxml
<view wx:for="{{array}}">
  {{index}} : {{item.message}}
</view>
```

```js
Page({
  data: {
    array: [{
      message: 'foo'
    }, {
      message: 'bar'
    }]
  }
})
```

使用 `wx:for-item` 可以指定数组当前元素的变量名，使用 `wx:for-index` 可以指定数组当前下标的变量名：

```wxml
<view wx:for="{{array}}" wx:for-index="i" wx:for-item="li">
  {{i}} : {{li.message}}
</view>
```

`wx:for` 也可以嵌套，下边是一个九九乘法表:

```wxml
<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
  <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    <view wx:if="{{i <= j}}">
      {{i}} * {{j}} = {{i * j}}
    </view>
  </view>
</view>
```

**block wx:for**
类似 **block wx:if**，也可以将 `wx:for` 用在 `<block/>` 标签上，以渲染一个包含多节点的结构块。例如：

```wxml
<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: </view>
  <view> {{item}} </view>
</block>
```

**wx:key**
如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

wx:key 的值以两种形式提供:

1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2. 保留关键字 `*this` 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。

当数据改变触发渲染层重新渲染的时候，会校正带有 `key` 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

> 如不提供 `wx:key`，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。

[示例代码](https://developers.weixin.qq.com/s/tpg5tKmv6kZt)

> 注意:
> 当 `wx:for` 的值为字符串时，会将字符串解析成字符串数组
> 花括号和引号之间如果有空格，将最终被解析成为字符串

##### 2.3.1.3 条件渲染

**wx:if**
在框架中，使用 `wx:if=""` 来判断是否需要渲染该代码块：

```wxml
<view wx:if="{{condition}}"> True </view>
```

也可以用 `wx:elif` 和 `wx:else` 来添加一个 else 块：

```wxml
<view wx:if="{{length > 9}}">1</view>
<view wx:elif="{{length > 6}}">2</view>
<view wx:else>3</view>
```

**block wx:if**
因为 `wx:if` 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```wxml
<block wx:if="{{condition}}">
  <view>1</view>
  <view>2</view>
</block>
```

> 注意： `<block/>` 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。

**wx:if 与 hidden 的区别**
因为 `wx:if` 之中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。

同时 `wx:if` 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。

##### 2.3.1.4 模板

WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。

**定义模板**
使用 `name` 属性，作为模板的名字。然后在 `<template/>` 内定义代码片段，如：

```wxml
<!--
  index: int
  msg: string
  time: string
-->
<template name="msgItem">
  <view>
    <text>{{index}} : {{msg}}</text>
    <text>{{time}}</text>
  </view>
</template>
```

**使用模板**
使用 `is` 属性，声明需要的使用的模板，然后将模板所需要的 `data` 传入，如：

```wxml
<template is="msgItem" data="{{...item}}" />
```

```js
Page({
  data: {
    item: {
      index: 0,
      msg: 'this is a template',
      time: '2020-12-24'
    }
  }
})
```

`is` 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板：

```js
<template name="odd">
  <view> odd </view>
</template>
<template name="even">
  <view> even </view>
</template>

<block wx:for="{{[1, 2, 3, 4]}}">
  <template is="{{item % 2 == 0 ? 'even' : 'odd'}}" />
</block>
```

**模板的作用域**
模板拥有自己的作用域，只能使用 `data` 传入的数据以及模板定义文件中定义的 `<wxs />` 模块。

##### 2.3.1.5 引用

WXML 提供两种文件引用方式 `import` 和 `include`。

**import**
`import` 可以在该文件中使用目标文件定义的 `template` ，如：

在 item.wxml 中定义了一个叫 item 的 template：

```wxml
<!-- item.wxml -->
<template name="item">
  <text>{{text}}</text>
</template>
```

在 index.wxml 中引用了 item.wxml，就可以使用item模板：

```wxml
<import src="item.wxml">
<template is="item" data="{{text: 'footer'}}">
```

**import 的作用域**
import 有作用域的概念，即只会 `import` 目标文件中定义的 template，而不会 import 目标文件 import 的 template。

> 例 : C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。

**include**
include 可以将目标文件除了 `<template/>` `<wxs/>` 外的整个代码引入，相当于是拷贝到 `include` 位置，如：

```wxml
<!-- index.wxml -->
<include src="header.wxml"/>
<view> body </view>
<include src="footer.wxml"/>
```

```wxml
<!-- header.wxml -->
<view> header </view>
```

```wxml
<!-- footer.wxml -->
<view> footer </view>
```

#### 2.3.2 WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。

WXSS 用来决定 WXML 的组件应该怎么显示。WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。

与 CSS 相比，WXSS 扩展的特性有：

- **尺寸单位**
  `rpx`（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。

  设备 | rpx换算px (屏幕宽度/750) | px换算rpx (750/屏幕宽度)
  -----|-------------------------|------------------------
  iPhone5 | 1rpx = 0.42px | 1px = 2.34rpx
  iPhone6 | 1rpx = 0.5px | 1px = 2rpx
  iPhone6 Plus | 1rpx = 0.552px | 1px = 1.81rpx

- **样式导入**
  使用 `@import` 语句可以导入外联样式表，`@import` 后跟需要导入的外联样式表的相对路径，用 **;** 表示语句结束。

**内联样式**
框架组件上支持使用 style、class 属性来控制组件的样式。

- **style** : 静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，尽量避免将静态的样式写进 style 中，以免影响渲染速度。

```wxss
<view style="color:{{color}}"></view>
```

- **class** : 用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上 *.* ，样式类名之间用 空格 分隔。

```wxss
<view class="normal_view left_view"></view>
```

**选择器**
目前支持的选择器有:

选择器 | 样例 | 样例描述
-------|-----|---------
.class | .intro | 选择所有拥有 class="intro" 的组件
**#id** | #first_name | 选择拥有 id="first_name" 的组件
element | view | 选择所有 view 组件
element, element | view, checkbox | 选择所有文档的 view 组件和所有的 checkbox 组件
::after | view::after | 在 view 组件后边插入内容
::before | view::before | 在 view 组件前边插入内容

**全局样式与局部样式**
定义在 **app.wxss** 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 **app.wxss** 中相同的选择器。

#### 2.3.3 WXS 语法参考

WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。WXS 与 JS 是不同的语言，有自己的语法，并不和 JS 一致。

> 注意:
>
> 1. WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
> 2. WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。
> 3. WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。
> 4. WXS 函数不能作为组件的事件回调。
> 5. 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。
> 6. const、let 不能使用，只能使用 var
> 7. WXS 里数据类型与基础类库中的属性 除 constructor 外的具体含义参考 ES5 标准。
> 8. WXS 里的方法具体使用参考 ES5 标准。

##### 2.3.3.1 模块

WXS 代码可以编写在 **wxml** 文件中的 `<wxs>` 标签内，或以 `.wxs` 为后缀名的文件内。

**模块**
: 每一个 **.wxs** 文件和 **<wxs>** 标签都是一个单独的模块。每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。一个模块要想对外暴露其内部的私有变量与函数，只能通过 **module.exports** 实现。

**.wxs 文件**
: 在微信开发者工具里面，右键可以直接创建 .wxs 文件，在其中直接编写 WXS 脚本。`.wxs` 文件可以被其他的 `.wxs` 文件 或 WXML 中的 `<wxs>` 标签引用。

**module 对象**
每个 **wxs** 模块均有一个内置的 **module** 对象。

**属性**:

- **exports** : 通过该属性，可以对外共享本模块的私有变量与函数。

> 例 : [test.wxs](./test/pages/tests/test.wxs)

**require函数**
在 .wxs 模块中引用其他 wxs 文件模块，可以使用 `require` 函数。

引用的时候，要注意如下几点：

- 只能引用 .wxs 文件模块，且必须使用相对路径。
- wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
- 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

**<wxs> 标签**

属性名 | 类型 | 说明
-------|-----|-----
module | String | 当前 `<wxs>` 标签的模块名。必填字段。
src | String | 引用 .wxs 文件的相对路径。仅当本标签为单闭合标签或标签的内容为空时有效

- module属性
  module 属性是当前 `<wxs>` 标签的模块名。在单个 wxml 文件内，建议其值唯一。有重复模块名则按照先后顺序覆盖（后者覆盖前者）。不同文件之间的 wxs 模块名不会相互覆盖。
  module 属性值的命名必须符合下面两个规则：
  - 首字符必须是：字母（a-zA-Z），下划线（_）
  - 剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）

- src属性
  src 属性可以用来引用其他的 wxs 文件模块。
  引用的时候，要注意如下几点：
  - 只能引用 .wxs 文件模块，且必须使用相对路径。
  - wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
  - 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

> 注意:
> 1.`<wxs>` 模块只能在定义模块的 WXML 文件中被访问到。使用 `<include>` 或 `<import>` 时，`<wxs>` 模块不会被引入到对应的 WXML 文件中。
> 2.`<template>` 标签中，只能使用定义该 `<template>` 的 WXML 文件中定义的 `<wxs>` 模块。

##### 2.3.3.2 变量

**概念**:

- WXS 中的变量均为值的引用。
- 没有声明的变量直接赋值使用，会被定义为全局变量。
- 如果只声明变量而不赋值，则默认值为 undefined。
- var表现与javascript一致，会有变量提升。

**变量名**
变量命名必须符合下面两个规则：

- 首字符必须是：字母（a-zA-Z），下划线（_）
- 剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）

**保留标识符**
以下标识符不能作为变量名：

```js
delete void typeof

null undefined NaN Infinity var

if else

true false

require

this function arguments return

for while do break continue switch case default
```

##### 2.3.3.3 注释

WXS 主要有 3 种注释的方法。

```wxml
<!-- 示例代码 -->

// 方法一：单行注释

/**
* 方法二：多行注释
*/

/*
方法三：结尾注释。即从 /* 开始往后的所有 WXS 代码均被注释
```

##### 2.3.3.4 运算符

**一元运算符**:

```js
var a = 10, b = 20;

// 自增运算
console.log(10 === a++);
console.log(12 === ++a);
// 自减运算
console.log(12 === a--);
console.log(10 === --a);
// 正值运算
console.log(10 === +a);
// 负值运算
console.log(0-10 === -a);
// 否运算
console.log(-11 === ~a);
// 取反运算
console.log(false === !a);
// delete 运算
console.log(true === delete a.fake);
// void 运算
console.log(undefined === void a);
// typeof 运算
console.log("number" === typeof a);
```

**位运算符**:

```js
var a = 10, b = 20;

// 左移运算
console.log(80 === (a << 3));
// 无符号右移运算
console.log(2 === (a >> 2));
// 带符号右移运算
console.log(2 === (a >>> 2));
// 与运算
console.log(2 === (a & 3));
// 异或运算
console.log(9 === (a ^ 3));
// 或运算
console.log(11 === (a | 3));
```

**运算符优先级**:

优先级 | 运算符 | 说明 | 结合性
-------|-------|------|------
20 | ( ... ) | 括号 | n/a
19 | ... . ... | 成员访问 | 从左到右
-| ... [ ... ] | 成员访问 | 从左到右
-| ... ( ... ) | 函数调用 | 从左到右
17 | ... ++ | 后置递增 | n/a
-| ... -- | 后置递减 | n/a
16 | ! ... | 逻辑非 | 从右到左
-| ~ ... | 按位非 | 从右到左
-| **+ ...** | 一元加法 | 从右到左
-| **- ...** | 一元减法 | 从右到左
-| ++ ... | 前置递增 | 从右到左
-| -- ... | 前置递减 | 从右到左
-| typeof ... | typeof | 从右到左
-| void ... | void | 从右到左
-| delete ... | delete | 从右到左
14 | ... * ... | 乘法 | 从左到右
-| ... / ... | 除法 | 从左到右
-| ... % ... | 取模 | 从左到右
13 | ... + ... | 加法 | 从左到右
-| ... - ... | 减法 | 从左到右
12 | ... << ... | 按位左移 | 从左到右
-| ... >> ... | 按位右移 | 从左到右
-| ... >>> ... | 无符号右移 | 从左到右
11 | ... < ... | 小于 | 从左到右
-| ... <= ... | 小于等于 | 从左到右
-| ... > ... | 大于 | 从左到右
-| ... >= ... | 大于等于 | 从左到右
10 | ... == ... | 等号 | 从左到右
-| ... != ... | 非等号 | 从左到右
-| ... === ... | 全等号 | 从左到右
-| ... !== ... | 非全等号 | 从左到右
9 | ... & ... | 按位与 | 从左到右
8 | ... ^ ... | 按位异或 | 从左到右
7 | ... ｜ ... | 按位或 | 从左到右
6 | ... && ... | 逻辑与 | 从左到右
5 | ... ｜｜ ... | 逻辑或 | 从左到右
4 | ... ? ... : ... | 条件运算符 | 从右到左
3 | ... = ... | 赋值 | 从右到左
-| ... += ... | 赋值 | 从右到左
-| ... -= ... | 赋值 | 从右到左
-| ... *= ... | 赋值 | 从右到左
-| ... /= ... | 赋值 | 从右到左
-| ... %= ... | 赋值 | 从右到左
-| ... <<= ... | 赋值 | 从右到左
-| ... >>= ... | 赋值 | 从右到左
-| ... >>>= ... | 赋值 | 从右到左
-| ... &= ... | 赋值 | 从右到左
-| ... ^= ... | 赋值 | 从右到左
-| ... ｜= ... | 赋值 | 从右到左
0 | ... , ... | 逗号 | 从左到右

##### 2.3.3.5 数据类型

WXS 语言目前共有以下几种数据类型：

1. number ： 数值
2. string ：字符串
3. boolean：布尔值
4. object：对象
5. function：函数
6. array : 数组
7. date：日期
8. regexp：正则

- **number**
  - 语法 : number 包括两种数值：整数，小数。
  - 属性
    - constructor: 返回字符串 "Number"
  - 方法
    - toString
    - toLocaleString
    - valueOf
    - toFixed
    - toExponential
    - toPrecision

- **string**
  - 语法 : 单引号 和 双引号 都可以
  - 属性
    - constructor : 返回字符串 "String"
    - length
  - 方法
    - toString
      valueOf
    - charAt
    - charCodeAt
    - concat
    - indexOf
    - lastIndexOf
    - localeCompare
    - match
    - replace
    - search
    - slice
    - split
    - substring
    - toLowerCase
    - toLocaleLowerCase
    - toUpperCase
    - toLocaleUpperCase
    - trim

- **boolean**
  - 语法 : 只有两个特定的值：true 和 false
  - 属性
    - constructor : 返回字符串 "Boolean"
  - 方法
    - toString
    - valueOf

- **object**
  - 语法 : object 是一种无序的键值对
  - 属性
    - constructor : 返回字符串"Object"
  - 方法
    - toString : 返回字符串 "[Object Object]"

- **function**
  - 语法 : 支持常用的两种定义，以及 匿名函数，闭包等
  - arguments : function 里面可以使用 arguments 关键词。该关键词目前只支持以下的属性
    - length : 传递给函数的参数个数。
    - [index]: 通过 *index* 下标可以遍历传递给函数的每个参数。
  - 属性
    - constructor : 返回字符串 "Function"
    - length : 返回函数的形参个数
  - 方法
    - toString : 返回字符串"[Function Function]"

- **Array**
  - 语法 : 支持 `var a = []` 和 `var b = [1,"2",{},function(){}]`
  - 属性
    - constructor : 返回字符串 "Array"
    - length
  - 方法
    - toString
    - concat
    - join
    - pop
    - push
    - reverse
    - shift
    - slice
    - sort
    - splice
    - unshift
    - indexOf
    - lastIndexOf
    - every
    - some
    - forEach
    - map
    - filter
    - reduce
    - reduceRight

- **date**
  - 语法 : 生成 date 对象需要使用 `getDate()` 函数, 返回一个当前时间的对象。

    ```wxs
    // 格式
    getDate()
    getDate(milliseconds)
    getDate(dateString)
    getDate(year, month[, date[, hours[, minutes[, seconds[, milliseconds]]]]])
    ```

  - 参数
    - milliseconds : 从1970年1月1日00:00:00 UTC开始计算的毫秒数
    - dateString : 日期字符串，其格式为："month day, year hours:minutes:seconds"

    ```wxs
    // 示例
    var date = getDate(); //返回当前时间对象

    date = getDate(1500000000000);
    // Fri Jul 14 2017 10:40:00 GMT+0800 (中国标准时间)
    date = getDate('2017-7-14');
    // Fri Jul 14 2017 00:00:00 GMT+0800 (中国标准时间)
    date = getDate(2017, 6, 14, 10, 40, 0, 0);
    // Fri Jul 14 2017 10:40:00 GMT+0800 (中国标准时间)
    ```

  - 属性
    - constructor : 返回字符串 "Date"
  - 方法
    - toString
    - toDateString
    - toTimeString
    - toLocaleString
    - toLocaleDateString
    - toLocaleTimeString
    - valueOf
    - getTime
    - getFullYear
    - getUTCFullYear
    - getMonth
    - getUTCMonth
    - getDate
    - getUTCDate
    - getDay
    - getUTCDay
    - getHours
    - getUTCHours
    - getMinutes
    - getUTCMinutes
    - getSeconds
    - getUTCSeconds
    - getMilliseconds
    - getUTCMilliseconds
    - getTimezoneOffset
    - setTime
    - setMilliseconds
    - setUTCMilliseconds
    - setSeconds
    - setUTCSeconds
    - setMinutes
    - setUTCMinutes
    - setHours
    - setUTCHours
    - setDate
    - setUTCDate
    - setMonth
    - setUTCMonth
    - setFullYear
    - setUTCFullYear
    - toUTCString
    - toISOString
    - toJSON

- **regexp**
  - 语法 : 生成 regexp 对象需要使用 getRegExp() 函数。

    ```wxs
      getRegExp(pattern[, flags])
    ``

  - 参数
    - pattern : 正则表达式的内容
    - flags : 修饰符，该字段只能包含以下内容 `g`、`i`、`m`
  - 属性
    - constructor : 返回字符串 "RegExp"
    - source
    - global
    - ignoreCase
    - multiline
    - lastIndex
  - 方法
    - exec
    - test
    - toString

- **数据类型判断**
  - constructor : 数据类型的判断可以使用 constructor 属性。
  - typeof : 使用 typeof 也可以区分部分数据类型。

##### 2.3.3.6 基础类库

- **console**
  - console.log 方法用于在 console 窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。

- **Math**
  - 属性
    - E
    - LN10
    - LN2
    - LOG2E
    - LOG10E
    - PI
    - SQRT1_2
    - SQRT2
  - 方法
    - abs
    - acos
    - asin
    - atan
    - atan2
    - ceil
    - cos
    - exp
    - floor
    - log
    - max
    - min
    - pow
    - random
    - round
    - sin
    - sqrt
    - tan

- **JSON**
  - 方法
    - stringify(object) : 将 object 对象转换为 JSON 字符串，并返回该字符串。
    - parse(string) : 将 JSON 字符串转化成对象，并返回该对象。

- **Number**
  - 属性
    - MAX_VALUE
    - MIN_VALUE
    - NEGATIVE_INFINITY
    - POSITIVE_INFINITY

- **Date**
  - 属性
    - parse
    - UTC
    - now

- **Global**
  - 属性
    - NaN
    - Infinity
    - undefined
  - 方法
    - parseInt
    - parseFloat
    - isNaN
    - isFinite
    - decodeURI
    - decodeURIComponent
    - encodeURI
    - encodeURIComponent

#### 2.3.4 事件系统

**什么是事件**:

- 事件是视图层到逻辑层的通讯方式
- 事件可以将用户的行为反馈到逻辑层进行处理
- 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数
- 事件对象可以携带额外信息，如 id，dataset，touches

##### 2.3.4.1 事件的使用方式

- **在组件中绑定一个事件处理函数**
  - 如 `bindtap`，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。

  ```wxml
  <view id="tapTest" data-hi="WeiXin" bindtap="topName"> Click Me! </view>
  ```

  - 在相应的Page定义中写上相应的事件处理函数，参数是event。

  ```js
  Page({
    tapName: function(event) {
      console.log(event);
    }
  })
  ```

##### 2.3.4.2 事件详解

- **事件分类**
  事件分为 冒泡事件 和 非冒泡事件：

  WXML的冒泡事件列表:

  类型 | 触发条件
  -----|--------
  touchstart | 手指触摸动作开始
  touchmove | 手指触摸后移动
  touchcancel | 手指触摸动作被打断，如来电提醒，弹窗
  touchend | 手指触摸动作结束
  tap | 手指触摸后马上离开
  longpress | 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发，最低版本 1.5.0
  longtap | 手指触摸后，超过350ms再离开（推荐使用longpress事件代替）
  transitionend | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发
  animationstart | 会在一个 WXSS animation 动画开始时触发
  animationiteration | 会在一个 WXSS animation 一次迭代结束时触发
  animationend | 会在一个 WXSS animation 动画完成时触发
  touchforcechange | 在支持 3D Touch 的 iPhone 设备，重按时会触发，最低版本 1.9.9

  > 注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的submit事件，input 的input事件，scroll-view 的scroll事件，(详见各个 [组件][组件] )

- **普通事件绑定**
  事件绑定的写法类似于组件的属性，如：

  ```wxml
  <view bindtap="handleTap"> Click Me! </view>
  ```

  如果用户点击这个 view ，则页面的 handleTap 会被调用。
  事件绑定函数可以是一个数据绑定，如：

  ```wxml
  <view bindtap="{{handleName}}"> Click Me! </view>
  ```

  此时，页面的 `this.data.handlerName` 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。
  > 自基础库版本 1.5.0 起，在大多数组件和自定义组件中， bind 后可以紧跟一个冒号，其含义不变，如 `bind:tap` 。基础库版本 2.8.1 起，在所有组件中开始提供这个支持。

- **绑定并阻止事件冒泡**
  除 `bind` 外，也可以用 `catch` 来绑定事件。与 `bind` 不同，`catch` 会阻止事件向上冒泡。

  例如：在下边这个例子中，点击 inner view 会先后调用 handleTap3 和 handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outer view 会触发 handleTap1。

  ```wxml
  <view id="outer" bindtap="handleTap1">
    <view id="middle" catch:tap="handleTap2">
      <view id="inner" bindtap="handleTap3">
    </view>
  </view>
  ```

- **互斥事件绑定**
  自基础库版本 2.8.2 起，除 bind 和 catch 外，还可以使用 `mut-bind` 来绑定事件。一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。

- **事件的捕获阶段**
  自基础库版本 1.5.0 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用 `capture-bind`、`capture-catch` 关键字，后者将中断捕获阶段和取消冒泡阶段。

  在下面的代码中，点击 inner view 会先后调用handleTap2、handleTap4、handleTap3、handleTap1。

  ```wxml
  <view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">
    <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4"></view>
  </view>
  ```

  如果将上面代码中的第一个 `capture-bind` 改为 `capture-catch`，将只触发 handleTap2。

##### 2.3.4.3 事件对象

如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

- **BaseEvent 基础事件对象属性列表**:

  属性 | 类型 | 说明
  -----|------|-----
  type | String | 事件类型
  timeStamp | Integer | 事件生成的时间戳
  [target](#target) | Object | 触发事件的组合的一些属性值集合
  [currentTarget](#currentTarget) | Object | 当前组件的一些属性值集合
  [mark](#mark) | Object | 事件标记数据，基础库版本 2.7.1

- **CustomEvent 自定义事件对象属性列表** (继承BaseEvent)

  属性 | 类型 | 说明
  -----|------|-------
  [detail](#detail) | Object | 说明

- **TouchEvent 触摸事件对象属性列表** (继承BaseEvent)

  属性 | 类型 | 说明
  ----|------|------
  [touches](#touches) | Array | 触摸事件，当前停留在屏幕中的触摸点信息的数组
  [changedTouches](#changedTouches) | Array | 触摸事件，当前变化的触摸点信息的数组

  > 特殊事件：canvas 中的触摸事件不可冒泡，所以没有 currentTarget

- <span id="target">**target**</span>
  触发事件的源组件

  属性 | 类型 | 说明
  ----|------|-----
  id | String | 事件源组件的id
  [dataset](#dateset) | Object | 事件源组件上由 `data-` 开头的自定义属性组合的集合

- <span id="currentTarget">**currentTarget**</span>
  事件绑定的当前组件

  属性 | 类型 | 说明
  -----|-----|-----
  id | String | 当前组件的id
  [dataset](#dateset) | Object | 当前组件上由 `data-` 开头的自定义属性组合的集合

- <span id="dataset">dataset</span>
  在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。
  在 WXML 中，这些自定义数据以 data- 开头，多个单词由连字符 - 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：
  - data-element-type ，最终会呈现为 event.currentTarget.dataset.elementType ；
  - data-elementType ，最终会呈现为 event.currentTarget.dataset.elementtype 。

- <span id="mark">mark</span>
  在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点。此外， mark 还可以用于承载一些自定义数据（类似于 dataset ）。
  当事件触发时，事件冒泡路径上所有的 mark 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 mark 。）

  ```wxml
  <view mark:myMark="last" bindtap="bindViewTap">
    <button mark:anotherMark="leaf" bindtap="bindButtonTap">按钮</button>
  </view>
  ```

  在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。

  ```js
  Page({
    bindViewTap: function (e) {
      e.mark.myMark === "last"; // true
      e.mark.anotherMark === "leaf"; // true
    }
  })
  ```

  mark 和 dataset 很相似，主要区别在于： mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值；而 dataset 仅包含一个节点的 data- 属性值。
  细节注意事项：

  - 如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。
  - 在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark 。
  - 不同于 dataset ，节点的 mark 不会做连字符和大小写转换

- <span id="touches">touches</span>
  touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。
  - Touch对象

    属性 | 类型 | 说明
    ----|------|-----
    identifier | Number | 触摸点的标识符
    pageX, pageY | Number | 距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴
    clientX, clientY | Number | 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴

  - CanvasTouch 数组

    属性 | 类型 | 说明
    ----|------|-----
    identifier | Number | 触摸点的标识符
    x，y | Number | 距离 Canvas 左上角的距离，Canvas 的左上角为原点，横向为X轴，纵向为Y轴

- <span id="changedTouches">changedTouches</span>
  changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。

- <span id="detail">detail</span>
  自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义。
  点击事件的detail 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。

##### 2.3.4.4 使用WXS函数响应事件

> 基础库 2.4.4 开始支持，低版本需做 [兼容处理][compatibility]。

从基础库版本2.4.4开始，支持使用WXS函数绑定事件，WXS函数接受2个参数，第一个是event，在原有的event的基础上加了 **event.instance** 对象，第二个参数是 **ownerInstance**，和 event.instance 一样是一个**ComponentDescriptor** 对象。具体使用如下：

- **组件中绑定和注册事件处理的WXS函数**

  ```wxml
  <wxs module="wxs" src="./test.wxs"></wxs>
  <!-- 注：绑定的WXS函数必须用 {{}} 括起来 -->
  <view id="tapTest" data-hi="WeiXin" bindtap="{{wxs.tapName}}"> Click Me! </view>
  ```

- **test.wxs文件实现tapName函数**

  ```wxs
  function tapName(event, ownerInstance) {
    console.log('top WeiXin', JSON.stringify(event));
  }
  module.exports = {
    tapName : tapName
  }
  ```

ownerInstance包含了一些方法，可以设置组件的 样式 和 class，具体包含的方法以及为什么要用 WXS函数响应事件，[点击查看详情](https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html)。

#### 2.3.5 简易双向绑定

> 基础库 2.9.3 开始支持，低版本需做 [兼容处理][compatibility]。

**双向绑定语法**
在 WXML 中，普通的属性的绑定是单向的。如果使用 `this.setData({ value: 'leaf' })` 来更新 value ，`this.data.value` 和输入框的中显示的值都会被更新为 `leaf` ；但如果用户修改了输入框里的值，却不会同时改变 `this.data.value` 。

如果需要在用户输入的同时改变 `this.data.value` ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 `model:` 前缀：

```wxml
<input model:value="{{value}}">
```

这样，如果输入框的值被改变了，`this.data.value` 也会同时改变。同时，WXML 中所有绑定了 value 的位置也会被一同更新， 数据监听器 也会被正常触发。

用于双向绑定的表达式有如下限制：

- 只能是一个单一字段的绑定，不能是

  ```wxml
  <input model:value="值为 {{value}}" />
  <input model:value="{{ a + b }}" />
  ```

- 不能 data 路径，如

  ```wxml
  <input model:value="{{a.b}}" />
  ```

**在自定义组件中传递双向绑定**
双向绑定同样可以使用在自定义组件上。如下的自定义组件：

```js
// custom-component.js
Component({
  properties : {
    myValue: String
  }
})
```

```wxml
<!-- custom-component.wxml -->
<input model:input="{{myValue}}">
```

这个自定义组件将自身的 myValue 属性双向绑定到了组件内输入框的 value 属性上。这样，如果页面这样使用这个组件:

```wxml
<custom-component model:my-value="{{pageValue}}" />
```

当输入框的值变更时，自定义组件的 myValue 属性会同时变更，这样，页面的 `this.data.pageValue` 也会同时变更，页面 WXML 中所有绑定了 pageValue 的位置也会被一同更新。

**在自定义组件中触发双向绑定更新**
自定义组件还可以自己触发双向绑定更新，做法就是：使用 `setData` 设置自身的属性。例如：

```js
// custom-component.js
Component({
  properties: {
    myValue: String
  },
  methods: {
    update: function() {
      // 更新 myValue
      this.setData({
        myValue : "leaf"
      })
    }
  }
})
```

如果页面这样使用这个组件：

```wxml
<custom-component model:my-value="{{pageValue}}" />
```

当组件使用 `setData` 更新 **myValue** 时，页面的 `this.data.pageValue` 也会同时变更，页面 WXML 中所有绑定了 **pageValue** 的位置也会被一同更新。

#### 2.3.6 基础组件

框架提供了一系列基础组件，可以通过组合这些基础组件进行快速开发。详细介绍参考 [组件文档][组件]

什么是组件：

- 组件是视图层的基本组成单元。
- 组件自带一些功能与微信风格一致的样式。
- 一个组件通常包括 **开始标签** 和 **结束标签**，**属性** 用来修饰这个组件，**内容** 在两个标签之内。

> 注意：所有组件与属性都是小写，以连字符-连接

**属性类型**:

类型 | 描述 | 注解
-----|------|-----
Boolean | 布尔值 | 组件写上该属性，不管是什么值都被当作 true；只有组件上没有该属性时，属性值才为false。如果属性值为变量，变量的值会被转换为Boolean类型
Number | 数字 | 1, 2.5
String | 字符串 | "string"
Array | 数组 | [ 1, "string" ]
Object | 对象 | { key: value }
EventHandler | 事件处理函数名 | "handlerName" 是 Page 中定义的事件处理函数名
Any | 任意属性

**公共属性**
所有组件都有以下属性：

属性名 | 类型 | 描述 | 注解
-------|-----|------|-----
id | String | 组件的唯一标示 | 保持整个页面唯一
class | String | 组件的样式类 | 在对应的 WXSS 中定义的样式类
style | String | 组件的内联样式 | 可以动态设置的内联样式
hidden | Boolean | 组件是否显示 | 所有组件默认显示
data-* | Any | 自定义属性 | 组件上触发的事件时，会发送给事件处理函数
`bind*` / `catch*` | EventHandler | 组件的事件 | 详见[事件系统](#234-事件系统)

**特殊属性**
几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，参考各个 [组件][组件] 的定义。

#### 2.3.7 获取界面上的信息节点

**WXML信息节点**
`wx.createSelectorQuery()` 可以用于获取节点属性、样式、在界面上的位置等信息。
最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

```js
const query = wx.createSelectorQuery();
query.select("#the-id").boundingClientRect(function(res) {
  res.top; // #the-id 节点的上边界坐标（相对于显示区域）
})
query.selectViewport().scrollOffSet(function(res) {
  res.scrollTop; // 显示区域的竖直滚动位置
})
// 执行所有的请求。请求结果按请求次序构成数组，在callback的第一个参数中返回
query.exec((e) => {
  console.log(e);
});
```

上述示例中，`#the-id` 是一个节点选择器，与 CSS 的选择器相近但略有区别，参见 [SelectorQuery.select](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.select.html) 的相关说明。

> 在 **自定义组件** 或包含 **自定义组件的页面** 中，推荐使用 `this.createSelectorQuery` 来代替 `wx.createSelectorQuery` ，这样可以确保在正确的范围内选择节点。

**WXML节点布局相交状态**
`wx.createIntersectionObserver(Object component, Object options)` API， 可用于监听两个或多个组件节点在布局位置上的相交状态。这一组API常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。

这一组API涉及的主要概念如下:

- 参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的 交集 作为参照区域。页面显示区域也可作为参照区域之一。
- 目标节点：监听的目标，默认只能是一个节点（使用 `selectAll` 选项时，可以同时监听多个节点）。
- 相交区域：目标节点的布局区域与参照区域的相交区域。
- 相交比例：相交区域占参照区域的比例。
- 阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。

以下示例代码可以在目标节点（用选择器 `.target-class` 指定）每次进入或离开页面显示区域时，触发回调函数。

```js
Page({
  onLoad: function(){
    wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
      res.id // 目标节点 id
      res.dataset // 目标节点 dataset
      res.intersectionRatio // 相交区域占目标节点的布局区域的比例
      res.intersectionRect // 相交区域
      res.intersectionRect.left // 相交区域的左边界坐标
      res.intersectionRect.top // 相交区域的上边界坐标
      res.intersectionRect.width // 相交区域的宽度
      res.intersectionRect.height // 相交区域的高度
    })
  }
})
```

以下示例代码可以在目标节点（用选择器 .target-class 指定）与参照节点（用选择器 .relative-class 指定）在页面显示区域内相交或相离，且相交或相离程度达到目标节点布局区域的20%和50%时，触发回调函数。

```js
Page({
  onLoad: function(){
    wx.createIntersectionObserver(this, {
      thresholds: [0.2, 0.5]
    }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
      res.intersectionRatio // 相交区域占目标节点的布局区域的比例
      res.intersectionRect // 相交区域
      res.intersectionRect.left // 相交区域的左边界坐标
      res.intersectionRect.top // 相交区域的上边界坐标
      res.intersectionRect.width // 相交区域的宽度
      res.intersectionRect.height // 相交区域的高度
    })
  }
})
```

> 注意：
> 与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是 "布局区域"，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中 overflow 样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。
> 在 **自定义组件或包含自定义组件的页面中**，推荐使用 `this.createIntersectionObserver` 来代替 `wx.createIntersectionObserver` ，这样可以确保在正确的范围内选择节点。

#### 2.3.8 响应显示区域的变化

**显示区域尺寸**
显示区域指小程序界面中可以自由布局展示的区域。在默认情况下，小程序显示区域的尺寸自页面初始化起就不会发生变化。但以下两种方式都可以改变这一默认行为。

- **在手机上启用屏幕旋转支持**
  从小程序基础库版本 2.4.0 开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持屏幕旋转的方法是：在 **app.json** 的 **window** 段中设置 `"pageOrientation": "auto"` ，或在页面 json 文件中配置 `"pageOrientation": "auto"` 。

  如果页面添加声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。

  从小程序基础库版本 2.5.0 开始， `pageOrientation` 还可以被设置为 `landscape` ，表示固定为横屏显示。

- **在 iPad 上启用屏幕旋转支持**
从小程序基础库版本 2.3.0 开始，在 iPad 上运行的小程序可以支持屏幕旋转。使小程序支持 iPad 屏幕旋转的方法是：在 **app.json** 中添加 `"resizable": true` 。

> 注意：
> 如果小程序添加了声明，则在屏幕旋转时，小程序将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。
> 在 iPad 上不能单独配置某个页面是否支持屏幕旋转。

**Media Query**
有时，对于不同尺寸的显示区域，页面的布局会有所差异。此时可以使用 `media query` 来解决大多数问题。

```wxss
.my-class {
  width: 400px;
}
@media (max-width:480px) {
  /* 仅在 480px 或更窄的屏幕上生效的样式规则 */
  .my-class {
    width: 200px;
  }
}
```

在 WXML 中，可以使用 [match-media](https://developers.weixin.qq.com/miniprogram/dev/component/match-media.html) 组件来根据 media query 匹配状态展示、隐藏节点。

此外，可以在页面或者自定义组件 JS 中使用 `this.createMediaQueryObserver()` 方法来创建一个 `MediaQueryObserver` 对象，用于监听指定的 media query 的匹配状态。

**屏幕旋转事件**
有时，仅仅使用 media query 无法控制一些精细的布局变化。此时可以使用 js 作为辅助。

在 js 中读取页面的显示区域尺寸，可以使用 `selectorQuery.selectViewport` 。

页面尺寸发生改变的事件，可以使用页面的 `onResize` 来监听。对于自定义组件，可以使用 `resize` 生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库版本 2.4.0 开始支持。）

```js
Page({
  onResize: function(res) {
    res.size.windowWidth // 新的显示区域宽度
    res.size.windowHeight // 新的显示区域高度
  }
})
```

```js
Component({
  pageLifetimes: {
    resize(res) {
      res.size.windowWidth // 新的显示区域宽度
      res.size.windowHeight // 新的显示区域高度
    }
  }
})
```

#### 2.3.9 动画

**界面动画的常见方式**
在小程序中，通常可以使用 CSS 渐变 和 CSS 动画 来创建简易的界面动画。

动画过程中，可以使用 `bindtransitionend` `bindanimationstart` `bindanimationiteration` `bindanimationend` 来监听动画事件。

事件名 | 含义
------|------
transitionend | CSS 渐变结束或 wx.createAnimation 结束一个阶段
animationstart | CSS动画开始
animationiteration | CSS 动画结束一个阶段
animationend | CSS动画结束

> 注意：
> 这几个事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。
> 同时，还可以使用 `wx.createAnimation` 接口来动态创建简易的动画效果。（新版小程序基础库中推荐使用下面的关键帧动画接口代替。）

**关键帧动画**:

> 基础库 2.9.0 开始支持，低版本需做 [兼容处理][compatibility]。

从小程序基础库 2.9.0 开始支持一种更友好的动画创建方式，用于代替旧的 `wx.createAnimation` 。它具有更好的性能和更可控的接口。
在页面或自定义组件中，当需要进行关键帧动画时，可以使用 `this.animate` 接口：

```js
this.animate(selector, keyframes, duration, callback)
```

参数说明

属性 | 类型 | 必填 | 说明
-----|-----|------|-----
selector | String | 是 | 选择器（同 SelectorQuery.select 的选择器格式）
keyframes | Array | 是 | 关键帧信息
duration | Number | 是 | 动画持续时长(单位：毫秒)
callback | function | 是 | 动画完成后的回调函数

keyframes 中对象的结构

属性 | 类型 | 默认值 | 必填 | 说明
-----|-----|--------|------|-----
offset | Number | - | 否 | 关键帧的偏移，范围[0-1]
ease | String | linear | 否 | 动画缓动函数
transformOrigin | String | - | 否 | 基点位置，即 CSS transform-origin
backgroundColor | String | - | 否 | 背景颜色，即 CSS background-color
bottom | Number/String | - | 否 | 底边位置，即 CSS bottom
height | Number/String | - | 否 | 高度，即 CSS height
left | Number/String | - | 否 | 左边位置，即 CSS left
width | Number/String | - | 否 | 宽度，即 CSS width
opacity | Number | - | 否 | 不透明度，即 CSS opacity
right | Number | - | 否 | 右边位置，即 CSS right
top | Number/String | - | 否 | 顶边位置，即 CSS top
matrix | Array | - | 否 | 变换矩阵，即 CSS transform matrix
matrix3d | Array | - | 否 | 三维变换矩阵，即 CSS transform matrix3d
rotate | Number | - | 否 | 旋转，即 CSS transform rotate
rotate3d | Array | - | 否 | 三维旋转，即 CSS transform rotate3d
rotateX | Number | - | 否 | X 方向旋转，即 CSS transform rotateX
rotateY | Number | - | 否 | Y 方向旋转，即 CSS transform rotateY
rotateZ | Number | - | 否 | Z 方向旋转，即 CSS transform rotateZ
scale | Array | - | 否 | 缩放，即 CSS transform scale
scale3d | Array | - | 否 | 三维缩放，即 CSS transform scale3d
scaleX | Number | - | 否 | X 方向缩放，即 CSS transform scaleX
scaleY | Number | - | 否 | Y 方向缩放，即 CSS transform scaleY
scaleZ | Number | - | 否 | Z 方向缩放，即 CSS transform scaleZ
skew | Array | - | 否 | 倾斜，即 CSS transform skew
skewX | Number | - | 否 | X 方向倾斜，即 CSS transform skewX
skewY | Number | - | 否 | Y 方向倾斜，即 CSS transform skewY
translate | Array | - | 否 | 位移，即 CSS transform translate
translate3d | Array | - | 否 | 三维位移，即 CSS transform translate3d
translateX | Number | - | 否 | X 方向位移，即 CSS transform translateX
translateY | Number | - | 否 | Y 方向位移，即 CSS transform translateY
translateZ | Number | - | 否 | Z 方向位移，即 CSS transform translateZ

```js
this.animate('#container', [
  { opacity: 1.0, rotate: 0, backgroundColor: '#FF0000' },
  { opacity: 0.5, rotate: 45, backgroundColor: '#00FF00'},
  { opacity: 0.0, rotate: 90, backgroundColor: '#FF0000' },
  ], 5000, function () {
    this.clearAnimation('#container', { opacity: true, rotate: true }, function () {
      console.log("清除了#container上的opacity和rotate属性")
    })
}.bind(this))

this.animate('.block', [
  { scale: [1, 1], rotate: 0, ease: 'ease-out'  },
  { scale: [1.5, 1.5], rotate: 45, ease: 'ease-in', offset: 0.9},
  { scale: [2, 2], rotate: 90 },
], 5000, function () {
  this.clearAnimation('.block', function () {
    console.log("清除了.block上的所有动画属性")
  })
}.bind(this))
```

调用 animate API 后会在节点上新增一些样式属性覆盖掉原有的对应样式。如果需要清除这些样式，可在该节点上的动画全部执行完毕后使用 `this.clearAnimation` 清除这些属性。

```js
this.clearAnimation(selector, options, callback)
```

参数说明

属性 | 类型 | 必填 | 说明
-----|-----|------|-----
selector| String | 是 | 选择器（同 SelectorQuery.select 的选择器格式）
options | Object | 否 | 需要清除的属性，不填写则全部清除
callback | Function | 否 | 清除完成后的回调函数

**滚动驱动的动画**
根据滚动位置而不断改变动画的进度是一种比较常见的场景，这类动画可以让人感觉到界面交互很连贯自然，体验更好。因此，从小程序基础库 2.9.0 开始支持一种由滚动驱动的动画机制。

基于上面关键帧动画接口，新增一个 `ScrollTimeline` 的参数，用来绑定滚动元素（目前只支持 `scroll-view`）。接口定义如下：

```js
this.animate(selector, keyframes, duration, ScrollTimeline)
```

ScrollTimeline 中对象的结构

属性 | 类型 | 默认值 | 必填 | 说明
-----|-----|--------|------|-----
scrollSource | String | - | 是 | 指定滚动元素的选择器（只支持 scroll-view），该元素滚动时会驱动动画的进度
orientation | String | vertical | 否 | 指定滚动的方向。有效值为 horizontal 或 vertical
startScrollOffset | Number | - | 是 | 指定开始驱动动画进度的滚动偏移量，单位 px
endScrollOffset | Number | - | 是 | 指定停止驱动动画进度的滚动偏移量，单位 px
timeRange | Number | - | 是 | 起始和结束的滚动范围映射的时间长度，该时间可用于与关键帧动画里的时间 (duration) 相匹配，单位 ms

```js
this.animate('.avatar', [{
  borderRadius: '0',
  borderColor: 'red',
  transform: 'scale(1) translateY(-20px)',
  offset: 0,
}, {
  borderRadius: '25%',
  borderColor: 'blue',
  transform: 'scale(.65) translateY(-20px)',
  offset: .5,
}, {
  borderRadius: '50%',
  borderColor: 'blue',
  transform: `scale(.3) translateY(-20px)`,
  offset: 1
}], 2000, {
  scrollSource: '#scroller',
  timeRange: 2000,
  startScrollOffset: 0,
  endScrollOffset: 85,
})

this.animate('.search_input', [{
  opacity: '0',
  width: '0%',
}, {
  opacity: '1',
  width: '100%',
}], 1000, {
  scrollSource: '#scroller',
  timeRange: 1000,
  startScrollOffset: 120,
  endScrollOffset: 252
})
```

**高级的动画方式**
在一些复杂场景下，上述的动画方法可能并不适用。

WXS 响应事件 的方式可以通过使用 WXS 来响应事件的方法来动态调整节点的 style 属性。通过不断改变 style 属性的值可以做到动画效果。同时，这种方式也可以根据用户的触摸事件来动态地生成动画。

连续使用 `setData` 来改变界面的方法也可以达到动画的效果。这样可以任意地改变界面，但通常会产生较大的延迟或卡顿，甚至导致小程序僵死。此时可以通过将页面的 `setData` 改为 自定义组件 中的 `setData` 来提升性能。

#### 2.3.10 初始渲染缓存

> 基础库 2.11.1 开始支持，低版本需做 [兼容处理][compatibility]。

**初始渲染缓存工作原理**
小程序页面的初始化分为两个部分。

- 逻辑层初始化：载入必需的小程序代码、初始化页面 this 对象（也包括它涉及到的所有自定义组件的 this 对象）、将相关数据发送给视图层。
- 视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发送的数据，最后渲染页面。

在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。

启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 data 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：

- 在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；
- 在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；
- 如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。

利用初始渲染缓存，可以：

- 快速展示出页面中永远不会变的部分，如导航栏
- 预先展示一个骨架页，提升用户体验
- 展示自定义的加载提示
- 提前展示广告，等等

**支持的组件**
在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。

目前支持的内置组件：

- `<view />`
- `<text />`
- `<button />`
- `<image />`
- `<scroll-view />`
- `<rich-text />`

自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。

**静态初始渲染缓存**
若想启用初始渲染缓存，最简单的方法是在页面的 json 文件中添加配置项 `"initialRenderingCache": "static"` ，如果想要对所有页面启用，可以在 app.json 的 window 配置段中添加这个配置：

添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。

> 注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML 上的结果，不包含任何 setData 的结果。

例如，如果想要在页面中展示出"正在加载"几个字，这几个字受到 `loading` 数据字段控制：

```wxml
<view wx:if="{{loading}}">正在加载</view>
```

这种情况下， **loading** 应当在 data 中指定为 true ，如：

```js
// 正确的做法
Page({
  data: {
    loading: true
  }
})
```

**在初始渲染缓存中添加动态内容**
有些场景中，只是页面 data 的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片 URL 等。

这种情况下可以使用"动态"初始渲染缓存的方式。首先，配置 `"initialRenderingCache": "dynamic"` 。

此时，初始渲染缓存不会被自动启用，还需要在页面中调用 `this.setInitialRenderingCache(dynamicData)` 才能启用。其中， `dynamicData` 是一组数据，与 `data` 一起参与页面 WXML 渲染。

```js
Page({
  data: {
    loading: true
  },
  onReady: function() {
    this.setInitialRenderingCache({
      loadingHint: "正在加载" // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
    })
  }
})
```

```wxml
<view wx:if="{{loading}}">{{loadingHint}}</view>
```

> **注意**：
> 从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而 **开销相对较大**。因而要尽量避免频繁调用 `this.setInitialRenderingCache` ，如果在一个页面内多次调用，仅最后一次调用生效。
> `this.setInitialRenderingCache` 调用时机不能早于 Page 的 `onReady` 或 Component 的 `ready` 生命周期，否则可能对性能有负面影响。
> 如果想禁用初始渲染缓存，调用 `this.setInitialRenderingCache(null)` 。

## 三. 小程序运行时

### 3.1 运行环境

微信小程序运行在多种平台上：iOS（iPhone/iPad）微信客户端、Android 微信客户端、PC 微信客户端、Mac 微信客户端和用于调试的微信开发者工具。

各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：

- 在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS 12、iOS 13 等；
- 在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 内核来渲染的；
- 在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的。
- 在 PC 上，小程序逻辑层 javascript 和视图层 javascript 都是用 Chrome 内核
- 在 Mac 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，与 iOS 一致

**平台差异**
尽管各运行环境是十分相似的，但是还是有些许区别：

- JavaScript 语法和 API 支持不一致：语法上可以通过开启 ES6 转 ES5 的功能来规避（[详情](https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#es6-%E8%BD%AC-es5)）；此外，小程序基础库内置了必要的Polyfill，来弥补API的差异。
- WXSS 渲染表现不一致：尽管可以通过开启样式补全来规避大部分的问题，但还是需要在 iOS 和 Android 上分别检查小程序的真实表现。

### 3.2 JavaScript 支持情况

**运行限制**
基于安全考虑，小程序中不支持动态执行 JS 代码，即：

- 不支持使用 `eval` 执行 JS 代码
- 不支持使用 `new Function` 创建函数

**客户端 ES6 API 支持情况**
微信小程序已经支持了绝大部分的 ES6 API，具体情况查询 [API支持情况](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/js-support.html)

### 3.3 运行机制

**前台后台状态**
小程序启动后，界面被展示给用户，此时小程序处于前台状态。

当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有完全终止运行，而是进入了后台状态，小程序还可以运行一小段时间。

当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。但如果用户很久没有再进入小程序，或者系统资源紧张，小程序可能被销毁，即完全终止运行。

**小程序启动**
小程序启动可以分为两种情况，一种是冷启动，一种是热启动。

- 冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。
- 热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。

**小程序销毁时机**
通常，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被销毁。具体而言包括以下几种情形：

- 当小程序进入后台，可以维持一小段时间的运行状态，如果这段时间内都未进入前台，小程序会被销毁。
- 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。
  - 在 iOS 上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户 「运行内存不足，请重新打开该小程序」。具体策略会持续进行调整优化。
  - 建议小程序在必要时使用 `wx.onMemoryWarning` 监听内存告警事件，进行必要的内存清理。

> 基础库 1.1.0 及以上，1.4.0 以下版本： 当用户从扫一扫、转发等入口（[场景值](#21-场景值)为1007, 1008, 1011, 1025）进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。

**启动场景分类**
用户打开小程序时，场景可分为以下 A、B 两类：

**A. 保留上次的浏览状态**。场景值有以下几项：

场景值ID | 说明
--------|------
1001 | 发现栏小程序主入口，「最近使用」列表（基础库2.2.4版本起包含「我的小程序」列表）
1003 | 星标小程序列表
1023 | 系统桌面小图标打开小程序
1038 | 从其他小程序返回小程序
1056 | 聊天顶部音乐播放器右上角菜单，打开小程序
1080 | 客服会话菜单小程序入口，打开小程序
1083 | 公众号会话菜单小程序入口 ，打开小程序（只有腾讯客服小程序有）
1089 | 聊天主界面下拉，打开小程序/微信聊天主界面下拉，「最近使用」栏（基础库2.2.4版本起包含「我的小程序」栏）
1090 | 长按小程序右上角菜单，打开小程序
1103 | 发现-小程序主入口我的小程序，打开小程序
1104 | 聊天主界面下拉，从我的小程序，打开小程序
1113 | 安卓手机负一屏，打开小程序
1114 | 安卓手机侧边栏，打开小程序
1117 | 后台运行小程序的管理页中，打开小程序

- 若进入的场景中带有 path，则每次打开小程序时都进入对应的 path 页面
- 若进入的场景中不带 path：
  - 若小程序是热启动，则保留原来状态
  - 若小程序是冷启动，则遵循下一节的重启策略，可能是首页或上次退出的页面

**B. relaunch 到指定页或首页**
包括除 A 类外的其他场景

- 若进入的场景中带有 path，则每次点击时都进入对应的 path 页面
- 若进入的场景中不带 path，则每次进入都打开首页

**A 类场景的重新启动策略**:

> 基础库 2.8.0 开始支持，低版本需做 [兼容处理][compatibility]。

- 小程序被销毁后，下次冷启动如果属于 B 类场景，将会进入特定的页面。
- 下次冷启动如果属于 A 类场景，默认情况下将会进入小程序的首页。在页面对应的 json 文件中（也可以全局配置在 app.json 的 window 段中），指定 `restartStrategy` 配置项可以改变这个默认的行为，使得从某个页面退出后，下次 A 类场景的冷启动可以回到这个页面。

`restartStrategy` 可选值:

可选值 | 含义
------|------
homePage | （默认值）如果从这个页面退出小程序，下次将从首页冷启动
homePageAndLatestPage | 如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）

> 注意：
> 即使不配置为 **homePage** ，小程序如果退出过久（当前默认**一天**时间，可以使用退出状态来调整），下次冷启动时也将不再遵循 **restartStrategy** 的配置，而是直接从首页冷启动。
> 无论如何，页面中的状态并不会被保留，如输入框中的文本内容、 checkbox 的勾选状态等都不会还原。如果需要还原或部分还原，需要利用退出状态。

**退出状态**
每当小程序可能被销毁之前，页面回调函数 `onSaveExitState` 会被调用。如果想保留页面中的状态，可以在这个回调函数中"保存"一些数据，下次启动时可以通过 `exitState` 获得这些已保存数据。需要 `restartStrategy` 为 `homePageAndLatestPage`。

```js
Page({
  onLoad: function() {
    var prevExitState = this.exitState; // 尝试获得上一次退出前 onSaveExitState 保存的数据
    if(prevExitState !== undefined) {
      prevExitState.myDataField === "myData"; // 如果是根据 restartStrategy 配置进行的冷启动，就可以获取到
    }
  },
  onSaveExitState: function() {
    var exitState = { myDataField : "myData"} // 需要保存的数据
    return {
      data: exitState,
      expireTimeStamp: Date.now() + 24 * 60 * 60 * 1000 // 超时时刻
    }
  }
})
```

`onSaveExitState` 返回值可以包含两项:

字段名 | 类型 | 含义
------|-------|-----
data | Any | 需要保存的数据（只能是 JSON 兼容的数据）
expireTimeStamp | Number | 超时时刻，在这个时刻后，保存的数据保证一定被丢弃，默认为 (当前时刻 + 1 天)

> 注意：
>
> 1. 如果超过 `expireTimeStamp` ，保存的数据将被丢弃，且冷启动时不遵循 `restartStrategy` 的配置，而是直接从首页冷启动。
> 2. `expireTimeStamp` 有可能被自动提前，如微信客户端需要清理数据的时候。
> 3. 在小程序存活期间， `onSaveExitState` 可能会被多次调用，此时以最后一次的调用结果作为最终结果。
> 4. 在某些特殊情况下（如微信客户端直接被系统杀死），这个方法将不会被调用，下次冷启动也不遵循 `restartStrategy` 的配置，而是直接从首页冷启动。
> 5. 不能是 tabBar 的页面，否则不起作用

### 3.4 更新机制

**未启动时更新**
在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现有用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。

**启动时更新**
小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。

如果需要马上应用最新版本，可以使用 [wx.getUpdateManager](https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html) API 进行处理。

```js
const updateManager = wx.getUpdateManager();

updateManager.onCheckForUpdate(function() {
  // 请求完新版本信息的回调
  console.log(res.hasUpdate)
})

updateManager.onUpdateReady(function() {
  wx.showModel({
    title : "更新提示",
    content : '新版本已准备好，是否重启应用？'，
    success(res) {
      if(res.confirm) {
        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate();
      }
    }
  })
})

updateManager.onUpdateFailed(function() {
  // 新版本下载失败
})
```

## 四. 自定义组件

从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。

可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

**创建自定义组件**
类似于页面，一个自定义组件由 **json** **wxml** **wxss** **js** 4个文件组成。要编写一个自定义组件，首先需要在 **json** 文件中进行自定义组件声明（将 `component` 字段设为 `true`）。

> 注意：在组件wxss中不应使用ID选择器、属性选择器 和 标签名选择器。

在自定义组件的 js 文件中，需要使用 `Component()` 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，属性值是可由组件外部传入的。

**使用自定义组件**
使用已注册的自定义组件前，首先要在页面的 **json** 文件或 **app.json** 中声明 `usingComponents` 字段，在 **app.json** 中声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。

```json
{
  "usingComponents" : {
     "component-tag-name": "path/to/the/custom/component"
  }
}
```

这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

> 注意事项:
>
> 1. 因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
> 2. 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 `usingComponents` 字段）。
> 3. 自定义组件和页面所在项目根目录名不能以 "wx-" 为前缀，否则会报错。
> 4. 是否在页面文件中使用 `usingComponents` 会使得页面的 `this` 对象的原型稍有差异
>     - 使用 usingComponents 页面的原型与不使用时不一致，即 Object.getPrototypeOf(this) 结果不同。
>     - 使用 usingComponents 时会多一些方法，如 selectComponent 。
>     - 出于性能考虑，使用 usingComponents 时， setData 内容不会被直接深复制，即 this.setData({ field: obj }) 后 this.data.field === obj 。（深复制会在这个值被组件间传递时发生。）

### 4.1 组件模板与样式

类似于页面，自定义组件拥有自己的 `wxml` 模板和 `wxss` 样式。

**组件模板**
组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

在组件模板中可以提供一个 `<slot>` 节点，用于承载组件引用时提供的子节点。

```wxml
<!-- 组件模板 -->
<view class="wrapper">
  <view>这里是组件的内部节点</view>
  <slot></slot>
</view>
```

```wxml
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```

> 注意 : 在模板中引用到的自定义组件及其对应的节点名需要在 json 文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为 [抽象节点](#49-抽象节点)。

**模板数据绑定**
与普通的 WXML 模板类似，可以使用数据绑定，向子组件的属性传递动态数据。

```wxml
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```

在以上例子中，组件的属性 **propA** 和 **propB** 将收到页面传递的数据。页面可以通过 **setData** 来改变绑定的数据字段。

> 注意：这样的数据绑定只能传递 JSON 兼容数据。自基础库版本 2.0.9 开始，还可以在数据中包含函数（但这些函数不能在 WXML 中直接调用，只能传递给子组件）。

**组件 wxml 的 slot**
在组件的 wxml 中可以包含 `slot` 节点，用于承载组件使用者提供的 wxml 结构。

默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。

```js
Component({
  options: {
    multipleSlots: true // 在组件定义时的选项中启用多slot支持
  },
  properties: { /* ... */ },
  methods: { /* ... */ }
})
```

此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 name 来区分。

```wxml
<!-- 组件模板 -->
<view class="wrapper">
  <slot name="before"></slot>
  <view>这里是组件的内部细节</view>
  <slot name="after"></slot>
</view>
```

使用时，用 `slot` 属性来将节点插入到不同的 slot 上。

```wxml
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
    <view slot="before">这里是插入到组件slot name="before"中的内容</view>
    <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
    <view slot="after">这里是插入到组件slot name="after"中的内容</view>
  </component-tag-name>
</view>
```

**组件样式**
组件对应 wxss 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点：

- 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。
- 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。
- 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。
- 继承样式，如 font 、 color ，会从组件外继承到组件内。
- 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。

除此以外，组件可以指定它所在节点的默认样式，使用 `:host` 选择器（需要包含基础库 1.7.2 或更高版本的开发者工具支持）。

例: [:host](./test/pages/component-show/component-show.wxss)

**组件样式隔离**
默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：

- `app.wxss` 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
- 指定特殊的样式隔离选项 `styleIsolation`(在Component构造器的 **options** 中定义) 。

`styleIsolation` 选项从基础库版本 2.6.5 开始支持。它支持以下取值：

- **isolated** : 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；
- **apply-shared** : 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；
- **shared** : 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 `apply-shared` 或 `shared` 的自定义组件。（这个选项在插件中不可用）

> 使用后两者时，请务必注意组件间样式的相互影响。

如果这个 Component 构造器用于构造页面 ，则默认值为 shared ，且还有以下几个额外的样式隔离选项可用：

- **page-isolated** : 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；
- **page-apply-shared** : 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；
- **page-shared** : 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 styleIsolation （这样就不需在 js 文件的 options 中再配置）。
小程序基础库版本 2.2.3 以上支持 `addGlobalClass` 选项，即在 Component 的 options 中设置 `addGlobalClass: true` 。 这个选项等价于设置 `styleIsolation: apply-shared` ，但设置了 styleIsolation 选项后这个选项会失效。

**外部样式类**:

> 基础库 1.9.90 开始支持，低版本需做 [兼容处理](compatibility) 。

有时，组件希望接受外部传入的样式类。此时可以在 `Component` 中用 `externalClasses` 定义段定义若干个外部样式类。

这个特性可以用于实现类似于 **view** 组件的 `hover-class` 属性：页面可以提供**一个**样式类，赋予 view 的 hover-class ，这个样式类本身写在页面中而非 view 组件的实现中。

> **注意**：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。

```js
/* 组件 custom-component.js */
Component({
  externalClasses: ['my-class']
})
```

```wxml
<!-- 组件 custom-component.wxml -->
<custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>
```

这样，组件的使用者可以指定这个样式类对应的 class ，就像使用普通属性一样。在 2.7.1 之后，可以指定多个对应的 class 。

**引用页面或父组件的样式**:

> 基础库 2.9.2 开始支持，低版本需做 [兼容处理](compatibility)。

即使启用了样式隔离 **isolated** ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。

例如，如果在页面 wxss 中定义了：

```wxss
.blue-text {
  color: blue;
}
```

在这个组件中可以使用 `~` 来引用这个类的样式：

```wxml
<view class="~blue-text"> 这段文本是蓝色的 </text>
```

如果在一个组件的父组件 wxss 中定义了：

```wxss
.red-text {
  color: red;
}
```

在这个组件中可以使用 `^` 来引用这个类的样式：

```wxml
<view class="^red-text"> 这段文本是红色的 </view>
```

也可以连续使用多个 `^` 来引用祖先组件中的样式。

> 注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。

**虚拟化组件节点**:

> 基础库 2.11.2 开始支持，低版本需做兼容处理。

默认情况下，自定义组件本身的那个节点是一个"普通"的节点，使用时可以在这个节点上设置 **class**、**style** 、**动画**、 **flex** 布局等，就如同普通的 view 组件节点一样。

但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex 布局等，而是希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定。

这种情况下，可以将这个自定义组件设置为"虚拟的"：

```js
Component({
  options: {
    virtualHost: true
  },
  properties: {
    style: { // 定义 style 属性可以拿到 style 属性上设置的值
      type: String
    }
  },
  externalClasses:['my-class']
})
```

这样，可以将 flex 放入自定义组件内：

```wxml
<!-- 页面的 WXML -->
<view style="display: flex">
  <!-- 如果设置了 virtualHost ，节点上的样式将失效 -->
  <custom-component class="my-class" style="color: blue">不是蓝色的</custom-component>
</view>
```

```wxml
<!-- custom-component.wxml -->
<view style="flex: 1">
  <text>满宽的</text>
  <slot></slot>
</view>
```

> 需要注意的是
>
> 1. 自定义组件节点上的 **class** **style** 和 **动画** 将不再生效
> 2. 将 style 定义成 `properties` 属性来获取 style 上设置的值
> 3. 将 class 定义成 `externalClasses` 外部样式类使得自定义组件 wxml 可以使用 class 值。

### 4.2 Component 构造器

`Component` 构造器可用于定义组件，调用 `Component` 构造器时可以指定组件的属性、数据、方法等。

```js
Component({

  behaviors: [],

  properties: {
    myProperty: { // 属性名
      type: String,
      value: ''
    },
    myProperty2: String // 简化的定义方式
  },

  data: {}, // 私有数据，可用于模板渲染

  lifetimes: {
    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
    attached: function () { },
    moved: function () { },
    detached: function () { },
  },

  pageLifetimes: {
    // 组件所在页面的生命周期函数
    show: function () { },
    hide: function () { },
    resize: function () { },
  },

  methods: {
    onMyButtonTap: function(){
      this.setData({
        // 更新属性和数据的方法与更新页面数据的方法类似
      })
    },
    // 内部方法建议以下划线开头
    _myPrivateMethod: function(){
      // 这里将 data.A[0].B 设为 'myPrivateData'
      this.setData({
        'A[0].B': 'myPrivateData'
      })
    }
  }

})
```

**使用 Component 构造器构造页面**
事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 `Component` 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 *json* 文件中包含 `usingComponents` 定义段。

此时，组件的属性可以用于接收页面的参数，如访问页面 **/pages/index/index?paramA=123&paramB=xyz** ，如果声明有属性 **paramA** 或 **paramB** ，则它们会被赋值为 123 或 xyz 。

页面的生命周期方法（即 `on` 开头的方法），应写在 `methods` 定义段中。

```js
Component({
  properties: {
    paramA: Number,
    paramB: String
  },

  methods: {
    onLoad: function() {
      this.data.paramA // 页面参数 paramA 的值
      this.data.paramB // 页面参数 paramB 的值
    }
  }
})
```

使用 Component 构造器来构造页面的一个好处是可以使用 `behaviors` 来提取所有页面中公用的代码段。

例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 `behaviors` 中。

```js
// page-common-behavior.js
module.exports = Behaviors({
  attached: function() {
    // 页面创建时执行
    console.info('Page loaded!')
  },
  detached: function() {
    // 页面销毁时执行
    console.info('Page unloaded!')
  }
})
```

```js
// 页面 A 或 B
var pageCommonBehavior = require("./page-common-behavior");
Component({
  behavior: [pageCommonBehavior],
  data: { ... },
  methods: { ... }
})
```

### 4.3 组件间通信与事件

**组件间通信**
组件间的基本通信方式有以下几种：

- **WXML 数据绑定** ：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 [组件模板和样式](#41-组件模板与样式)
- **事件** ：用于子组件向父组件传递数据，可以传递任意数据。
- 如果以上两种方式不足以满足需要，父组件还可以通过 `this.selectComponent` 方法获取子组件实例对象，这样就可以直接访问子组件的任意数据和方法。

**监听事件**
事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见 [事件系统](#234-事件系统)

监听自定义组件事件的方法与监听基础组件事件的方法完全一致。

**触发自定义事件**
自定义组件触发事件时，需要使用 `triggerEvent` 方法，指定 事件名、detail对象 和 事件选项：

```wxml
<!-- 在自定义组件中 -->
<button bindtap="onTap">点击这个按钮将触发"myEvent"事件</button>
```

```js
Component({
  properties: {},
  methods: {
    onTap: function() {
      var myEventDetail = {}; // detail对象，提供给事件监听函数
      var myEventOption = {}; // 触发事件的选项
      this.triggerEvent("myEvent", myEventDetail, myEventOption);
    }
  }
})
```

触发事件的选项包括：

选项名 | 类型 | 是否必填 |默认值 | 描述
------|------|---------|-------|------
bubbles | Boolean | 否 | false | 事件是否冒泡
composed | Boolean | 否 | false | 事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部
captruePhase | Boolean | 否 | false | 事件是否拥有捕获阶段

```wxml
// 页面 page.wxml
<another-component bindcustomevent="pageEventListener1">
  <my-component bindcustomevent="pageEventListener2"></my-component>
</another-component>
```

```wxml
// 组件 another-component.wxml
<view bindcustomevent="anotherEventListener">
  <slot />
</view>
```

```wxml
// 组件 my-component.wxml
<view bindcustomevent="myEventListener">
  <slot />
</view>
```

```js
// 组件 my-component.js
Component({
  methods: {
    onTap: function() {
      this.triggerEvent('customevent', {}) // 只会触发 pageEventListener2
      this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1
      this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
    }
  }
})
```

**获取组件实例**
可在父组件里调用 `this.selectComponent` ，获取子组件的实例对象。（插件的自定义组件将返回 null）

调用时需要传入一个匹配选择器 `selector`，如：this.selectComponent(".my-component")。

`selector` 类似于 CSS 的选择器，但仅支持下列语法。

- ID选择器：`#the-id`
- class选择器（可以连续指定多个）：`.a-class.another-class`
- 子元素选择器：`.the-parent > .the-child`
- 后代选择器：`.the-ancestor` `.the-descendant`
- 跨自定义组件的后代选择器：`.the-ancestor >>> .the-descendant`
- 多选择器的并集：`#a-node, .some-other-nodes`

```js
// 父组件
Page({
  data: {},
  getChildComponent: function() {
    const child = this.selectComponent(".my-component");
    console.log(child);
  }
})
```

在上例中，父组件将会获取 `class` 为 `my-component` 的子组件实例对象，即子组件的 `this` 。

若需要自定义 `selectComponent` 返回的数据，可使用内置 `behavior: wx://component-export`，从基础库版本 2.2.3 开始提供支持。

使自定义组件中支持 `export` 定义段，这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值。

```js
// 自定义组件 my-component 内部
Component({
  behavior: ['wx://component-export'],
  export: function() {
    return { myField: 'myValue' }
  }
})
```

```wxml
<!-- 使用自定义组件时 -->
<my-component id="the-id" />
```

```js
// 父组件调用
const child = this.selectComponent('#the-id') // 等于 { myField: 'myValue' }
```

### 4.4 组件生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

其中，最重要的生命周期是 `created` `attached` `detached` ，包含一个组件实例生命流程的最主要时间点。

- 组件实例刚刚被创建好时， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 `setData`** 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。
- 在组件完全初始化完毕、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
- 在组件离开页面节点树后， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发。

**定义生命周期方法**
生命周期方法可以直接定义在 `Component` 构造器的第一级参数中。
自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。

```js
Component({
  lifetimes: {
    created: function() {
      // 组件实例刚刚被创建好时执行
    },
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    }
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {},
  detached: function() {},
  // ...
})
```

在 `behaviors` 中也可以编写生命周期方法，同时不会与其他 `behaviors` 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。

可用的全部生命周期如下表所示。

生命周期 | 参数 | 描述 | 最低版本
--------|------|------|--------
created | 无 | 在组件实例刚刚被创建时执行 | 1.6.3
attached | 无 | 在组件实例进入页面节点树时执行 | 1.6.3
ready | 无 | 在组件在视图层布局完成后执行 | 1.6.3
moved | 无 |  在组件实例被移动到节点树另一个位置时执行 | 1.6.3
detached | 无 | 在组件实例被从页面节点树移除时执行 | 1.6.3
error | Object Error | 每当组件方法抛出错误时执行 | 2.4.1

**组件所在页面的声明周期**
还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为 "组件所在页面的生命周期"，在 `pageLifetimes` 定义段中定义。其中可用的生命周期包括：

生命周期 | 参数| 描述 | 最低版本
--------|-----|-----|---------
show | 无 | 组件所在的页面被展示时执行 | 2.2.3
hide | 无 | 组件所在的页面被隐藏时执行 | 2.2.3
resize | Object Size | 组件所在的页面尺寸变化时执行 | 2.4.0

```js
Component({
  pageLifetimes: {
    show: function() {
      //  页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
    resize: function() {
      // 页面尺寸变化
    }
  }
})
```

### 4.5 behaviors

`behaviors` 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。

每个 `behavior` 可以包含一组 属性、数据、生命周期函数 和 方法。**组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。** 每个组件可以引用多个 behavior ，behavior 也可以引用其它 behavior 。

#### 4.5.1 参数与含义

定义段 | 类型 | 是否必填 | 描述
------|------|----------|-----
properties | Object Map | 否 | 同组件的属性
data | Object | 否 | 同组件的数据
methods | Object | 否 | 同自定义组件的方法
behaviors | String Array | 否 | 引入其它的 behavior
created | Function | 否 | 在组件实例刚刚被创建时执行
attached | Function | 否 | 进入页面节点树时执行
ready | Function | 否 | 在视图层布局完成后执行
moved | Function | 否  | 被移动到节点树另一个位置时执行
detached | Function | 否 | 被从页面节点树移除时执行

```js
// my-behavior.js
module.exports = Behaviors({
  behaviors: [],
  properties: {
    myBehaviorProperty: function() {
      type: String
    }
  },
  data: {
    myBehaviorData: {}
  },
  attached: function() {},
  created: function() {},
  ready: function() {},
  methods: {
    myBehaviorMethod: function(){}
  }
})
```

```js
// my-component.js
var myBehavior = require('my-behavior')
Component({
  behaviors: [myBehavior],
  properties: {
    myProperty: {
      type: String
    }
  },
  data: {
    myData: "my-component-data"
  },
  created: function() {
    console.log('[my-component] created')
  },
  attached: function () {
    console.log('[my-component] attached')
  },
  ready: function () {
    console.log('[my-component] ready')
  },
  methods: {
    myMethod: function() {
      console.log('[my-component] log by myMethod')
    }
  }
})
```

在上例中， my-component 组件定义中加入了 my-behavior，

而 my-behavior 结构为：

- 属性：myBehaviorProperty
- 数据字段：myBehaviorData
- 方法：myBehaviorMethod
- 生命周期函数：attached、created、ready

这将使 my-component 最终结构为：

- 属性：myBehaviorProperty、myProperty
- 数据字段：myBehaviorData、myData
- 方法：myBehaviorMethod、myMethod
- 生命周期函数：attached、created、ready

当组件触发生命周期时，上例生命周期函数执行顺序为：

- [my-behavior] created
- [my-component] created
- [my-behavior] attached
- [my-component] attached
- [my-behavior] ready
- [my-component] ready

详细规则参考下面的 同名字段的覆盖和组合规则。

**同名字段的覆盖和组合规则**
组件和它引用的 `behavior` 中可以包含同名的字段，对这些字段的处理方法如下：

- 如果有同名的属性 (properties) 或方法 (methods)：
  1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 behavior 中的同名属性或方法；
  2. 若组件本身无这个属性或方法，则在组件的 behaviors 字段中定义靠后的 behavior 的属性或方法会覆盖靠前的同名属性或方法；
  3. 在 2 的基础上，若存在嵌套引用 behavior 的情况，则规则为：父 behavior 覆盖 子 behavior 中的同名属性或方法。
- 如果有同名的数据字段 (data)：
  - 若同名的数据字段都是对象类型，会进行对象合并；
  - 其余情况会进行数据覆盖，覆盖规则为：组件 > 父 behavior > 子 behavior 、 靠后的 behavior > 靠前的 behavior。（优先级高的覆盖优先级低的，最大的为优先级最高）
- 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：
  - 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序
  - 对于同种生命周期函数，遵循如下规则：
    - behavior 优先于组件执行
    - 子 behavior 优先于 父 behavior 执行
    - 靠前的 behavior 优先于 靠后的 behavior 执行
  - 如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次

#### 4.5.2 内置 behaviors

自定义组件可以通过引用内置的 `behavior` 来获得内置组件的一些行为。

```js
Component({
  behaviors: ['wx://form-field']
})
```

在上例中， `wx://form-field` 代表一个内置 `behavior` ，它使得这个自定义组件有类似于表单控件的行为。

内置 `behavior` 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的 `type` 或添加 `observer` 。

- **wx://form-field**
  使自定义组件有类似于表单控件的行为。 form 组件可以识别这些自定义组件，并在 submit 事件中返回组件的字段名及其对应字段值。这将为它添加以下两个属性。

  属性名 | 类型 | 字段
  ------|------|------
  name | String | 在表单中的字段名
  value | Any | 在表单中的字段值

  ```js
  Component({
    behaviors: ['wx://form-field'],
    data: {
      value: ''
    },
    methods: {
      onChange: function(e) {
        this.setData({
          value: e.detail.value
        })
      }
    }
  })
  ```

- **wx://form-field-group**
  从基础库版本 2.10.2 开始提供支持。
  使 form 组件可以识别到这个自定义组件内部的所有表单控件。 例如，页面的结构如下：

  ```wxml
  <form bindsubmit="submit">
    <custom-comp></custom-comp>
    <button form-type="submit">submit</button>
  </form>
  ```

  组件 **custom-comp** 自身结构如下：

  ```wxml
  <input name="name">
  <switch name="student"></switch>
  ```

  如果组件 **custom-comp** 配置有：

  ```js
  Component({
    behaviors: ['wx://form-field-group']
  })
  ```

  此时，表单的 **submit** 事件的 value 中将包含 `name` 和 `student` 两个字段。

- **wx://form-field-button**
  从基础库版本 2.10.3 开始提供支持。
  使 form 组件可以识别到这个自定义组件内部的 button 。如果自定义组件内部有设置了 **form-type** 的 button ，它将被组件外的 form 接受。 例如，页面的结构如下：

  ```wxml
  <form>
    <input name="name" placeholder="请输入名字" />
    <custom-comp></custom-comp>
  </form>
  ```

  组件 **custom-comp** 自身结构如下：

  ```wxml
  <button form-type="submit">submit</button>
  ```

  如果组件 custom-comp 配置有：

  ```js
  Component({
    behaviors: ['wx://form-field-button']
  })
  ```

  此时点击组件内的 button ，将触发 form 的 submit 事件。

- **wx://component-export**
  从基础库版本 2.2.3 开始提供支持。
  使自定义组件支持 `export` 定义段。这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值。
  详细用法 [selectComponent](#43-组件间通信与事件)

### 4.6 组件间关系

#### 4.6.1 定义和使用组件间关系

有时需要实现这样的组件：

```wxml
<custom-ul>
  <custom-li> item 1 </custom-li>
  <custom-li> item 2 </custom-li>
</custom-ul>
```

这个例子中， custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入 `relations` 定义段，可以解决这样的问题。示例：

```js
// path/to/custom-ul.js
Component({
  relations: {
    './custom-li': {
      type: 'child', // 关联的目标节点应为子节点
      linked: function(target) {
        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
      },
      linkChanged: function(target) {
        // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
      },
      unlinked: function(target) {
        // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
      }
    }
  },
  methods: {
    _getAllLi: function() {
      // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
      var nodes = this.getRelationNodes('./custom-li-component');
    }
  },
  ready: function() {
    this._getAllLi();
  }
})
```

```js
// path/to/custom-li.js
Component({
  relations: {
    './custom-ul': {
      type: "parent",
      linked: function(target) {
        // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
      },
      linkChanged: function(target) {
        // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
      },
      unlinked: function(target) {
        // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
      }
    }
  }
})
```

> 注意：必须在两个组件定义中都加入relations定义，否则不会生效。

#### 4.6.2 关联一类组件

有时，需要关联的是一类组件，如：

```wxml
<custom-from>
  <view>
    <text>input</text>
    <custom-input></custom-input>
  </view>
  <custom-submit> submit </submit-submit>
</custom-from>
```

`custom-form` 组件想要关联 `custom-input` 和 `custom-submit` 两个组件。此时，如果这两个组件都有同一个 `behavior`：

```js
// path/to/custom-submit.js
var customFormControls = require('./custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    './custom-form': {
      type: 'ancestor' // 关联的目标节点应为祖先节点
    }
  }
})
```

则在 `relations` 关系定义中，可使用这个 `behavior` 来代替组件路径作为关联的目标节点：

```wxml
// path/to/custom-form.js
var customFormControls = require('./custom-form-controls')
Component({
  relations: {
    'customFormControls': {
      type: 'descendant', // 关联的目标节点应为子孙节点
      target: customFormControls // 替组件路径作为关联的目标节点
    }
  }
})
```

#### 4.6.3 relations 定义段

`relations` 定义段包含目标组件路径及其对应选项，可包含的选项见下表。

选项 | 类型 | 是否必填 | 描述
----|------|----------|-----
type | String | 是 | 目标组件的相对关系，可选的值为 `parent` 、 `child` 、 `ancestor` 、 `descendant`
linked | Function | 否 | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件attached生命周期之后
linkChanged | Function | 否 | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件moved生命周期之后
unlinked | Function | 否 | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件detached生命周期之后
target | String | 否 | 如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联

### 4.7 数据监听器

数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。

**使用数据监听器**
有时，在一些数据字段被 `setData` 设置时，需要执行一些操作。

例如， this.data.sum 永远是 this.data.numberA 与 this.data.numberB 的和。此时，可以使用数据监听器进行如下实现。

```js
Component({
  attached: function() {
    this.setData({
      numberA: 1,
      numberB: 2
    })
  },
  observers: {
    'numberA, numberB': function(numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    }
  }
})
```

**监听字段语法**
数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。

同时，监听器可以监听子数据字段，如下例所示。

```js
Component({
  observers: {
    'some.subfield': function(subfield) {
      // 使用 setData 设置 this.data.some.subfield 时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      console.log(subfield === this.data.some.subfield);
    },
    'arr[12]': function(arr12) {
      // 使用 setData 设置 this.data.arr[12] 时触发
      // （除此以外，使用 setData 设置 this.data.arr 也会触发）
      console.log(arr12 === this.data.arr[12]);
    }
  }
})
```

如果需要监听所有子数据字段的变化，可以使用通配符 `**` 。

```js
Component({
  observers: {
    'some.field.**': function(field) {
      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      console.log(field === this.data.some.field);
    }
  },
  attached: function() {
    // 这样会触发上面的 observer
    this.setData({
      'some.field': { /* ... */ }
    })
    // 这样也会触发上面的 observer
    this.setData({
      'some.field.xxx': { /* ... */ }
    })
    // 这样还是会触发上面的 observer
    this.setData({
      'some': { /* ... */ }
    })
  }
})
```

特别地，仅使用通配符 `**` 可以监听全部 `setData`

```js
Component({
  observers: {
    '**': function() {
      // 每次 setData 都触发
    },
  },
})
```

**Bugs & Tips**:

- 数据监听器监听的是 `setData` 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
- 如果在数据监听器函数中使用 `setData` 设置本身监听的数据字段，可能会导致死循环，需要特别留意。
- 数据监听器和属性的 `observer` 相比，数据监听器更强大且通常具有更好的性能。

### 4.8 纯数据字段

纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能。从小程序基础库版本 2.8.2 开始支持。

**组件数据中的纯数据字段**
有些情况下，某些 `data` 中的字段（包括 `setData` 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。

此时，可以指定这样的数据字段为 "纯数据字段"，它们将仅仅被记录在 `this.data` 中，而 **不参与任何界面渲染过程**，这样有助于提升页面更新性能。

指定 “纯数据字段” 的方法是在 `Component` 构造器的 `options` 定义段中指定 `pureDataPattern` 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

```js
Component({
  options: {
    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true,
    _b: true // 纯数据字段
  },
  methods: function() {
    myMethod: function() {
      this.data._b // 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, // 普通数据字段
        _d: true, // 纯数据字段
      })
    }
  }
})
```

**组件属性中的纯数据字段**
属性也可以被指定为纯数据字段（遵循 pureDataPattern 的正则表达式）。

属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的 WXML 中。

```js
Component({
  options: {
    pureDataPattern: /^_/
  },
  properties: {
    a: Boolean,
    _b: {
      type: Boolean,
      observer() {
        // 不要这样做！这个 observer 永远不会被触发
      }
    }
  }
})
```

> 注意：属性中的纯数据字段的属性 `observer` 永远不会触发！如果想要监听属性值变化，使用 数据监听器 代替。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 `pureDataPattern` （这样就不需在 js 文件的 options 中再配置）。此时，其值应当写成字符串形式：

```js
"pureDataPattern": "^_"
```

**使用数据监听器监听纯数据字段**
数据监听器 可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

下面的示例是一个将 JavaScript 时间戳转换为可读时间的自定义组件。

```js
Component({
  options: {
    pureDataPattern: /^timestamp$/
  },
  properties: {
    timestamp: Number
  },
  observers: {
    timestamp: function() {
      // timestamp 被设置时，将它展示为可读时间字符串
      var timeString = new Date(this.data.timestamp).toLocaleString();
      this.setData({
        timestamp: timeString
      })
    }
  }
})
```

### 4.9 抽象节点

> 这个特性自小程序基础库版本 1.9.6 开始支持。

**在组件中使用抽象节点**
有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

例如，实现一个“选框组”（selectable-group）组件，它其中可以放置单选框（custom-radio）或者复选框（custom-checkbox）。这个组件的 wxml 可以这样编写：

```wxml
<!-- selectable-group.wxml -->
<view wx:for="{{labels}}">
  <label>
    <selectable disabled="{{false}}"></selectable>
  </label>
</view>
```

其中，“selectable” 不是任何在 json 文件的 `usingComponents` 字段中声明的组件，而是一个抽象节点。它需要在 `componentGenerics` 字段中声明：

```json
{
  "componentGenerics": {
    "selectable": true
  }
}
```

例: [selectable-group](./test/pages/selectable-group)

**使用包含抽象节点的组件**
在使用 selectable-group 组件时，必须指定“selectable”具体是哪个组件：

```wxml
<selectable-group generic:selectable="custom-radio" ></selectable-group>
```

这样，在生成这个 selectable-group 组件的实例时，“selectable”节点会生成“custom-radio”组件实例。类似地，如果这样使用

```wxml
<selectable-group generic:selectable="custom-checkbox" />
```

“selectable”节点则会生成“custom-checkbox”组件实例。

例：[tests](./test/pages/tests)

> 注意：上述的 custom-radio 和 custom-checkbox 需要包含在这个 wxml 对应 json 文件的 `usingComponents` 定义段中。**selectable** 是在抽象节点 json 文件的 `componentGenerics` 字段中声明的。

**抽象节点的默认组件**
抽象节点可以指定一个默认组件，当具体组件未被指定时，将创建默认组件的实例。默认组件可以在 `componentGenerics` 字段中指定：

```json
{
  "componentGenerics": {
    "selectable": {
      "default": "path/to/default/component"
    }
  }
}
```

> Tips: 节点的 `generic` 引用 `generic:xxx="yyy"` 中，值 yyy 只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。

### 4.10 自定义组件扩展

为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。从小程序基础库版本 2.2.3 开始支持。

**扩展后的效果**
自定义组件的扩展其实就是提供了修改自定义组件定义段的能力，下面的例子就是修改了自定义组件中的 `data` 定义段里的内容。

```js
// behavior.js
module.exports = Behaviors({
  definitionFilter(defFields) {
    defFields.data.from = "behavior"
  }
})

// component.js
Component({
  data: {
    from: "component"
  },
  behaviors: [require("./behavior.js"],
  ready() {
    console.log(this.data.from); // 此处会发现输出 behavior 而不是 component
  }
})
```

**使用扩展**
`Behavior()` 构造器提供了新的定义段 `definitionFilter` ，用于支持自定义组件扩展。 `definitionFilter` 是一个函数，在被调用时会注入两个参数，第一个参数是使用该 behavior 的 `component/behavior` 的定义对象，第二个参数是该 behavior 所使用的 `behavior` 的 `definitionFilter` 函数列表。

```js
// behavior3.js
module.exports = Behavior({
  definitionFilter(defFields, definitionFilter) {}
})

// behavior2.js
module.exports = Behavior2({
  behavior: [require(./behavior3.js)],
  definitionFilter(defFields, definitionFilter) {
    // definitionFilterArr[0](defFields)
  }
})

// behavior1.js
module.exports = Behavior({
  behaviors: [require('behavior2.js')],
  definitionFilter(defFields, definitionFilterArr) {}
})

// component.js
Component({
  behaviors: [require('behavior1.js')],
})
```

上述代码中声明了1个自定义组件和3个 behavior，每个 behavior 都使用了 `definitionFilter` 定义段。那么按照声明的顺序会有如下事情发生：

1. 当进行 behavior2 的声明时就会调用 behavior3 的 definitionFilter 函数，其中 defFields 参数是 behavior2 的定义段， definitionFilterArr 参数即为空数组，因为 behavior3 没有使用其他的 behavior 。
2. 当进行 behavior1 的声明时就会调用 behavior2 的 definitionFilter 函数，其中 defFields 参数是 behavior1 的定义段， definitionFilterArr 参数是一个长度为1的数组，definitionFilterArr[0] 即为 behavior3 的 definitionFilter 函数，因为 behavior2 使用了 behavior3。在此处可以自行决定在进行 behavior1 的声明时要不要调用 behavior3 的 definitionFilter 函数，如果需要调用，在此处补充代码 `definitionFilterArr[0](defFields)` 即可，definitionFilterArr 参数会由基础库补充传入。
3. 同理，在进行 component 的声明时就会调用 behavior1 的 definitionFilter 函数。

简单概括，definitionFilter 函数可以理解为当 A 使用了 B 时，A 声明就会调用 B 的 definitionFilter 函数并传入 A 的定义对象让 B 去过滤。此时如果 B 还使用了 C 和 D ，那么 B 可以自行决定要不要调用 C 和 D 的 definitionFilter 函数去过滤 A 的定义对象。

### 4.11 单元测试

在编写高质量的自定义组件过程中，单元测试是永远避不开的一个话题。完善的测试用例是提高自定义组件可用性的保证，同时测试代码覆盖率也是必不可少的一个环节。小程序从基础库版本 2.2.1 开始拥抱开源，支持使用 npm 安装自定义组件，那针对自定义组件的单元测试也是必须支持的。

**测试框架**
现在市面上流行的测试框架均可使用，只要它能兼顾 nodejs 端和 dom 环境。因为需要依赖到 nodejs 的一些库来完善测试环境，同时 dom 环境也是必须的，因为需要建成完整的 dom 树结构，才能更好的模拟自定义组件的运行。例如可以选用 mocha + jsdom 的组合，亦可选用 jest。

**自定义组件测试工具集**
小程序的运行环境比较特殊，不同于常见的浏览器环境，它采用的是双线程的架构。而在进行单元测试时，并不需要用到这样复杂的架构带来的利好，进行的是功能测试而无需苛求性能、安全等因素，因此小程序提供了一个测试工具集以支持自定义组件在 nodejs 单线程中也能运行起来。

我们先安装一下测试工具集—— [miniprogram-simulate](https://github.com/wechat-miniprogram/miniprogram-simulate)：

```npm
npm i --save-dev miniprogram-simulate
```

**编写测试用例**:

```js
// /test/components/index.test.js
const simulate = require('miniprogram-simulate')

test('components/index', () => {
    const id = simulate.load('/components/index') // 此处必须传入绝对路径
    const comp = simulate.render(id) // 渲染成自定义组件树实例

    const parent = document.createElement('parent-wrapper') // 创建父亲节点
    comp.attach(parent) // attach 到父亲节点上，此时会触发自定义组件的 attached 钩子

    const view = comp.querySelector('.index') // 获取子组件 view
    expect(view.dom.innerHTML).toBe('index.properties') // 测试渲染结果
    expect(window.getComputedStyle(view.dom).color).toBe('green') // 测试渲染结果
})
```

> 注意：
> 测试工具集中的 wx 对象和内置组件都不会实现真正的功能，如果需要测试一些特殊场景的话，可以自行覆盖掉测试工具集中的 api 接口和内置组件。
> 目前因为有部分自定义组件功能仍未支持（如抽象节点等），故测试工具暂无法全部覆盖自定义组件的特性。

测试工具集中提供了一些方便测试的接口，比如：

- 模拟 touch 事件、自定义事件触发
- 选取子节点
- 更新自定义组件数据
- 触发生命周期
- ...

更多详细的用法可以参阅 [github](https://github.com/wechat-miniprogram/miniprogram-simulate) 仓库上的文档。

### 4.12 获取更新性能统计信息

> 基础库 2.12.0 开始支持，低版本需做 [兼容处理](compatibility)。

如果想要知道 `setData` 引发界面更新的开销，可以使用更新性能统计信息接口(`setUpdatePerformanceListener`)。它将返回每次更新中主要更新步骤发生的时间戳，可以用来大体上估计自定义组件（或页面）更新性能。例如：

```js
Component({
  attached: function() { // 调用时机不能早于 attached
    this.setUpdatePerformanceListener({withDataPaths: true}, (res) => {
      console.log(res);
    })
  }
})
```

`setUpdatePerformanceListener` 方法接受一个 `options` 对象和回调函数 `listener` 作为参数。

其中， options 对象包含以下字段：

字段 | 类型 | 说明
-----|------|-----
withDataPaths | Boolean | 是否返回变更的 data 字段信息

`listeners` 返回携带一个 `res` 对象，表示一次由 `setData` 引发的 更新过程 。根据 `setData` 调用时机的不同，更新过程大体可以分为三类：

  1. **基本更新** : 它有一个唯一的 `updateProcessId`
  2. **子更新** : 它是另一个基本更新的一个子步骤，也有唯一的 `updateProcessId` ，但还有一个 `parentUpdateProcessId`
  3. **被合并更新** : 它被合并到了另一个基本更新或子更新过程中，无法被独立统计

每次成功的 `setData` 调用都会产生一个更新过程，使得 `listener` 回调一次。不过 `setData` 究竟触发了哪类更新过程很难判断，更新性能好坏与其具体是哪类更新也没有必然联系，只是它们的返回值参数有所不同。

`res` 中包含以下字段：

字段 | 类型 | 说明
-----|-----|------
updateProcessId | Number | 此次更新过程的 ID
parentUpdateProcessId | Number | 对于子更新，返回它所属的更新过程 ID
isMergedUpdate | Boolean | 是否是被合并更新，如果是，则 updateProcessId 表示被合并到的更新过程 ID
dataPaths | Array | 此次更新的 data 字段信息，只有 withDataPaths 设为 true 时才会返回
pendingStartTimestamp | Number | 此次更新进入等待队列时的时间戳
updateStartTimestamp | Number | 更新运算开始时的时间戳
updateEndTimestamp | Number | 更新运算结束时的时间戳

> 说明：
> `setUpdatePerformanceListener` 只会激活当前组件或页面的统计， `parentUpdateProcessId` 有可能是其他组件或者页面的更新过程 ID 而未被统计回调，如果想要知道页面内所有的更新过程，需要在所有组件中都调用 `setUpdatePerformanceListener` ；
> 统计本身有一点点开销，如果想要禁用统计，调用 `setUpdatePerformanceListener` 时传入第二个参数 `listener` 为 `null` 即可。

## 五. 基础能力

### 5.1 网络

#### 5.1.1 使用说明

在小程序/小游戏中使用网络相关的 API 时，需要注意下列问题。

- 服务器域名配置
  服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置，配置时需要注意：
  - **注意事项**
    1. 每个微信小程序需要事先设置通讯域名
    2. 小程序只可以跟指定的域名进行网络通信。包括普通 HTTPS 请求（[wx.request][wx.request]）、上传文件（[wx.uploadFile][wx.uploadFile]）、下载文件（[wx.downloadFile][wx.downloadFile]) 和 WebSocket 通信（[wx.connectSocket][wx.connectSocket]）。
    3. 从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意 **不允许与本机 IP 通信**。
    4. 从 2.7.0 开始，提供了 UDP 通信（[wx.createUDPSocket][wx.createUDPSocket])。
    5. 出于安全考虑，`api.weixin.qq.com` 不能被配置为服务器域名，相关API也不能在小程序内调用。 应将 `AppSecret` 保存到后台服务器中，通过服务器使用 `getAccessToken` 接口获取 `access_token`，并调用相关 API；
    6. 域名必须经过 ICP 备案；
    7. 域名不能使用 IP 地址（小程序的局域网 IP 除外）或 localhost；
    8. 不支持配置父域名，使用子域名。
    9. 可以配置端口，如 `https://myserver.com:8080`，但是配置后只能向 `https://myserver.com:8080` 发起请求。如果向 `https://myserver.com` 、`https://myserver.com:9091` 等 URL 请求则会失败。
    10. 如果不配置端口。如 `https://myserver.com`，那么请求的 URL 中也不能包含端口，甚至是默认的 443 端口也不可以。如果向 `https://myserver.com:443` 请求则会失败。

- 网络请求
  - **超时时间**
    - 默认超时时间和最大超时时间都是 60s；
    - 超时时间可以在 app.json 或 game.json 中通过 `networkTimeout` 配置。

  - **使用限制**
    - 网络请求的 `referer` header 不可设置。其格式固定为 `https://servicewechat.com/{appid}/{version}/page-frame.html`，其中 {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0 表示为开发版、体验版以及审核版本，版本号为 devtools 表示为开发者工具，其余为正式版本；
    - [wx.request][wx.request]、[wx.uploadFile][wx.uploadFile]、[wx.downloadFile][wx.downloadFile] 的最大并发限制是 **10** 个
    - [wx.connectSocket][wx.connectSocket] 的最大并发限制是 **5** 个。
    - 小程序进入后台运行后，如果 **5s** 内网络请求没有结束，会回调错误信息 `fail interrupted`；在回到前台之前，网络请求接口调用都会无法调用。

  - **返回值编码**
    - 建议服务器返回值使用 `UTF-8` 编码。对于非 UTF-8 编码，小程序会尝试进行转换，但是会有转换失败的可能。
    - 小程序会自动对 BOM 头进行过滤（只过滤一个BOM头）。

  - **回调函数**
    - 只要成功接收到服务器返回，无论 `statusCode` 是多少，都会进入 `success` 回调。根据业务逻辑对返回值进行判断。

- 常见问题
  - **HTTPS 证书**
    小程序必须使用 `HTTPS/WSS` 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。对证书要求如下：
    - HTTPS 证书必须有效
      - 证书必须被系统信任，即根证书被已系统内置
      - 部署 SSL 证书的网站域名必须与证书颁发的域名一致
      - 证书必须在有效期内
      - 证书的信任链必需完整（需要服务器配置）
    - `iOS` 不支持自签名证书
    - `iOS` 下证书必须满足苹果 [App Transport Security (ATS)](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33) 的要求;
    - TLS 必须支持 1.2 及以上版本。部分旧 Android 机型还未支持 TLS 1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
    - 部分 CA 可能不被操作系统信任，请在选择证书时注意小程序和各系统的相关通告
      - [Chrome 56/57 内核对 WoSign、StartCom 证书限制周知](https://developers.weixin.qq.com/community/develop/doc/800026caeb042e45681583652b70910a)
    > 证书有效性可以使用 `openssl s_client -connect example.com:443` 命令验证，也可以使用其他[在线工具](https://myssl.com/ssl.html)。
    > 除了网络请求 API 外，小程序中其他 HTTPS 请求如果出现异常，也请按上述流程进行检查。如 https 的图片无法加载、音视频无法播放等。

  - 跳过域名校验
    在微信开发者工具中，可以临时开启 开发环境不校验请求域名、TLS版本及HTTPS证书 选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。
    在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。
    > 如果手机上出现 “打开调试模式可以发出请求，关闭调试模式无法发出请求” 的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。

#### 5.1.2 局域网通信

基础库 2.4.0 提供了 [wx.startLocalServiceDiscovery][wx.startLocalServiceDiscovery] 等一系列 mDNS API，可以用来获取局域网内提供 mDNS 服务的设备的 IP。 [wx.request][wx.request]/[wx.connectSocket][wx.connectSocket]/[wx.uploadFile][wx.uploadFile]/[wx.downloadFile][wx.downloadFile] 的 url 参数允许为 `${IP}:${PORT}/${PATH}` 的格式，当且仅当 IP 与手机 IP 处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个 wifi 下）时，请求/连接才会成功。

在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用 http/ws。

```js
wx.request({
  url: 'http://10.9.176.40:828'
   // 省略其他参数
})

wx.connectSocket({
  url: 'ws://10.9.176.42:828'
  // 省略其他参数
})
```

基础库 2.7.0 开始，提供了 [wx.createUDPSocket][wx.createUDPSocket] 接口用于进行 UDP 通信。通信规则同上，仅允许同一局域网下的非本机 IP。

**mDNS**
目前小程序只支持通过 mDNS 协议获取局域网内其他设备的 IP。iOS 上 mDNS API 的实现基于 [Bonjour](https://developer.apple.com/bonjour/)，Android 上则是基于 [Android 系统接口](https://developer.android.com/training/connect-devices-wirelessly/nsd)。

**serviceType**
发起 mDNS 服务搜索 [wx.startLocalServiceDiscovery][wx.startLocalServiceDiscovery] 的接口有 `serviceType` 参数，指定要搜索的服务类型。

serviceType 的格式和规范，iOS Bonjour Overview 在 Bonjour Names for Existing Service Types 有提及。

### 5.2 存储

每个微信小程序都可以有自己的本地缓存，可以通过 一下 API 对本地缓存进行读写和清理。

- 将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB
  - [wx.setStorage][wx.setStorage] / [wx.setStorageSync][wx.setStorageSync]
  - **参数 Object object**

    属性 | 类型 | 必填 | 说明
    -----|------|-----|-----
    key |  string |  是 |  本地缓存中指定的 key
    data |  any |  是 |  需要存储的内容。只支持原生类型、Date、及能够通过JSON.stringify序列化的对象。
    success |  function |  否 |  接口调用成功的回调函数
    fail |  function |  否 |  接口调用失败的回调函数
    complete |  function |  否 |  接口调用结束的回调函数（调用成功、失败都会执行）

    ```js
    wx.setStorage({
      key: 'key',
      data: 'value'
    })

    try {
      wx.setStorageSync('key', 'value');
    } catch(e) {}
    ```

- **从本地缓存中异步获取指定 `key` 的内容**
  - [wx.getStorage][wx.getStorage] / [wx.getStorageSync][wx.getStorageSync]
  - **参数 Object object**

    属性 | 类型 | 必填 | 说明
    -----|------|-----|-----
    key |  string |  是 |  本地缓存中指定的 key
    success |  function |  否 |  接口调用成功的回调函数
    fail |  function |  否 |  接口调用失败的回调函数
    complete |  function |  否 |  接口调用结束的回调函数（调用成功、失败都会执行）

  - object.success 回调函数参数 Object res

    属性 | 类型 | 说明
    ----|------|------
    data | any | key对应的内容

    ```js
    wx.getStorage({
      key: 'key',
      success (res) {
        console.log(res.data)
      }
    })

    try {
      var value = wx.getStorageSync("key");
      if(value) {
        // ...
      }
    } catch(e) {
        // ...
    }
    ```

- **清理本地数据缓存**
  - [wx.clearStorage][wx.clearStorage] / [wx.clearStorageSync][wx.clearStorageSync]
  - **参数 Object object**

    属性 | 类型 | 必填 | 说明
    -----|------|-----|-----
    success |  function |  否 |  接口调用成功的回调函数
    fail |  function |  否 |  接口调用失败的回调函数
    complete |  function |  否 |  接口调用结束的回调函数（调用成功、失败都会执行）

    ```js
    wx.clearStorage();

    try {
      wx.clearStorageSync()
    } catch(e) {
      // Do something when catch error
    }
    ```

- **从本地缓存中移除指定 key**
  - [wx.removeStorage][wx.removeStorage] / [wx.removeStorageSync][wx.removeStorageSync]
  - **参数 Object object**

    属性 | 类型 | 必填 | 说明
    -----|------|-----|-----
    key |  string |  是 |  本地缓存中指定的 key
    success |  function |  否 |  接口调用成功的回调函数
    fail |  function |  否 |  接口调用失败的回调函数
    complete |  function |  否 |  接口调用结束的回调函数（调用成功、失败都会执行）

    ```js
    wx.removeStorage({
      key: 'key',
      success (res) {
        console.log(res)
      }
    })

    try {
      wx.removeStorageSync('key')
    } catch(e) {
      // Do something when catch error
    }
    ```

**隔离策略**
同一个微信用户，同一个小程序 storage 上限为 10MB。storage 以用户维度隔离，同一台设备上，A 用户无法读取到 B 用户的数据；不同小程序之间也无法互相读写数据。

**插件隔离策略**:

1. 同一小程序使用不同插件：不同插件之间，插件与小程序之间 storage 不互通。
2. 不同小程序使用同一插件：同一插件 storage 不互通。

**清理策略**
本地缓存的清理时机跟代码包一样，只有在代码包被清理的时候本地缓存才会被清理。

### 5.3 文件系统

文件系统是小程序提供的一套以小程序和用户维度隔离的存储以及一套相应的管理接口。通过 [wx.getFileSystemManager()][wx.getFileSystemManager] 可以获取到全局唯一的文件系统管理器，所有文件系统的管理操作通过 [FileSystemManager][FileSystemManager] 来调用。

文件主要分为两大类：

- 代码包文件：代码包文件指的是在项目目录中添加的文件。
- 本地文件：通过调用接口本地产生，或通过网络下载下来，存储到本地的文件。
  1. 本地临时文件：临时产生，随时会被回收的文件。不限制存储大小。
  2. 本地缓存文件：小程序通过接口把本地临时文件缓存后产生的文件，不能自定义目录和文件名。跟本地用户文件共计，小程序（含小游戏）最多可存储 200MB。
  3. 本地用户文件：小程序通过接口把本地临时文件缓存后产生的文件，允许自定义目录和文件名。跟本地缓存文件共计，小程序（含小游戏）最多可存储 200MB。

**代码包文件**
由于代码包文件大小限制，代码包文件适用于放置首次加载时需要的文件，对于内容较大或需要动态替换的文件，不推荐用添加到代码包中，推荐在小游戏启动之后再用下载接口下载到本地。

**访问代码包文件**
代码包文件的访问方式是从项目根目录开始写文件路径，不支持相对路径的写法。如：`/a/b/c`、`a/b/c` 都是合法的，`./a/b/c` `../a/b/c` 则不合法。

**修改代码包文件**
代码包内的文件无法在运行后动态修改或删除，修改代码包文件需要重新发布版本。

**本地文件**
本地文件指的是小程序被用户添加到手机后，会有一块独立的文件存储区域，以用户维度隔离。即同一台手机，每个微信用户不能访问到其他登录用户的文件，同一个用户不同 appId 之间的文件也不能互相访问。

本地文件的文件路径均为 `{{协议名}}://文件路径` 格式。

> 其中，协议名在 iOS/Android 客户端为 "wxfile"，在开发者工具上为 "http"，无需关注这个差异，也不应在代码中去硬编码完整文件路径。

**本地临时文件**
本地临时文件只能通过调用特定接口产生，不能直接写入内容。本地临时文件产生后，仅在当前生命周期内有效，重启之后即不可用。因此，不可把本地临时文件路径存储起来下次使用。如果需要下次在使用，可通过 [FileSystemManager.saveFile()][FileSystemManager.saveFile] 或 [FileSystemManager.copyFile()][FileSystemManager.copyFile] 接口把本地临时文件转换成本地缓存文件或本地用户文件。

```js
wx.chooseImage({
  success: function(res) {
    var tempFilePaths = res.tempFilePaths; // tempFilePaths 的每一项是一个本地临时文件路径
  }
})
```

**本地缓存文件**
本地缓存文件只能通过调用特定接口产生，不能直接写入内容。本地缓存文件产生后，重启之后仍可用。本地缓存文件只能通过 [FileSystemManager.saveFile()][FileSystemManager.saveFile] 接口将本地临时文件保存获得。

```js
fs.saveFile({
  tempFilePath: '', // 传入一个本地临时文件路径
  success(res) {
    console.log(res.savedFilePath); // res.savedFilePath 为一个本地缓存文件路径
  }
})
```

> **注意：本地缓存文件是最初的设计，1.7.0 版本开始，提供了功能更完整的本地用户文件，可以完全覆盖本地缓存文件的功能，如果不需要兼容低于 1.7.0 版本，可以不使用本地缓存文件。**

**本地用户文件**
本地用户文件是从 1.7.0 版本开始新增的概念。提供了一个用户文件目录给开发者，开发者对这个目录有完全自由的读写权限。通过 `wx.env.USER_DATA_PATH` 可以获取到这个目录的路径。

```js
// 在本地用户文件目录下创建一个文件 hello.txt，写入内容 "hello, world"
const fs = wx.getFileSystemManager();
fs.writeFileSync(`${wx.env.USER_DATA_PATH}/hello.txt`, 'hello', 'utf8')
```

**读写权限**:

接口、组件 | 读 | 写
----------|----|---
代码包文件 |  有 |  无
本地临时文件 |  有 |  无
本地缓存文件 |  有 |  无
本地用户文件 |  有 |  有

**清理策略**:

- 本地临时文件只保证在小程序当前生命周期内，一旦小程序被关闭就可能被清理，即下次冷启动不保证可用。
- 本地缓存文件和本地用户文件的清理时机跟代码包一样，只有在代码包被清理的时会被清理。

### 5.4 画布

所有在 [canvas][canvas] 中的画图必须用 JavaScript 完成：

WXML：（接下来的例子中如无特殊声明都会用这个 WXML 为模板，不再重复）

```wxml
<canvas canvas-id="myCanvas" style="border: 1px solid;"></canvas>
```

JS：（接下来的例子中会将 JS 放在 onLoad 中）

```js
// 1. 创建一个 Canvas 绘图上下文 [CanvasContext][CanvasContext]。CanvasContext 是小程序内建的一个对象，有一些绘图的方法
const ctx = wx.createCanvasContext('myCanvas')
// 2. 使用 Canvas 绘图上下文进行绘图描述
ctx.setFillStyle('red')
// 用 fillRect(x, y, width, height) 方法画一个矩形，填充为刚刚设置的红色
ctx.fillRect(10, 10, 150, 75)
// 3. 画图，告诉 canvas 组件要将刚刚的描述绘制上去
ctx.draw()
```

#### 5.4.1 坐标系

canvas 是在一个二维的网格当中。左上角的坐标为(0, 0)。

可以在 [canvas][canvas] 中加上一些事件，来观测它的坐标系

```wxml
<canvas canvas-id="myCanvas"
  style="margin: 5px; border:1px solid #d3d3d3;"
  bindtouchstart="start"
  bindtouchmove="move"
  bindtouchend="end"/>

<view hidden="{{hidden}}">
  Coordinates: {{x}}，{{y}}
</view>
```

```js
Page({
  data: {
    x: 0,
    y: 0,
    hidden: true
  },
  start: function(e) {
    this.setData({
      hidden: false,
      x: e.touches[0].x,
      y: e.touches[0].y
    })
  },
  move: function(e) {
    this.setData({
      x: e.touches[0].x,
      y: e.touches[0].y
    })
  },
  end: function(e) {
    this.setData({
      hidden: true
    })
  }
})
```

#### 5.4.2 渐变

渐变能用于填充一个矩形，圆，线，文字等。填充色可以不固定为固定的一种颜色。

小程序提供了两种颜色渐变的方式：

- [createLinearGradient(x, y, x1, y1)][CanvasContext.createCircularGradient] 创建一个线性的渐变
- [createCircularGradient(x, y, r)][CanvasContext.createLinearGradient] 创建一个从圆心开始的渐变

一旦创建了一个渐变对象，必须添加两个颜色渐变点。

[addColorStop(position, color)][CanvasGradient.addColorStop] 方法用于指定颜色渐变点的位置和颜色，位置必须位于0到1之间。

可以用 fillStyle 和 setStrokeStyle 方法设置渐变，然后进行画图描述。

使用 `createLinearGradient()`

```js
const ctx = wx.createLinearGradient('myCanvas');

// Create linear gradient
const grd = ctx.createLinearGradient(0, 0, 200, 0)
grd.addColorStop(0, 'red')
  .addColorStop(1, 'white')

// fill with gradient
ctx.setFillStyle(grd);
  .fillRect(10, 10, 150, 80)
  .draw();
```

使用 `createCircularGradient()`

```js
const ctx = wx.createCanvasContext('myCanvas')

// Create circular gradient
ctx.createCircularGradient(75, 50, 50)
grd.addColorStop(0, 'red')
  .addColorStop(1, 'white')

// Fill with gradient
ctx.setFillStyle(grd)
  .fillRect(10, 10, 150, 80)
  .draw()
```

### 5.5 分包加载

某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。

在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个 **主包**。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而分包则是根据开发者的配置进行划分。

在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。

目前小程序分包大小有以下限制：

- 整个小程序所有分包大小不超过 20M
- 单个分包/主包大小不能超过 2M

对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。

#### 5.5.1 使用分包

**配置方法**
假设支持分包的小程序目录结构如下：

```txt
├── app.js
├── app.json
├── app.wxss
├── packageA
│   └── pages
│       ├── cat
│       └── dog
├── packageB
│   └── pages
│       ├── apple
│       └── banana
├── pages
│   ├── index
│   └── logs
└── utils
```

可以通过在 **app.json** `subpackages` 字段声明项目分包结构：

```json
{
  "pages":[
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat",
        "pages/dog"
      ]
    }, {
      "root": "packageB",
      "name": "pack2",
      "pages": [
        "pages/apple",
        "pages/banana"
      ]
    }
  ]
}
```

`subpackages` 中，每个分包的配置有以下几项：

字段 | 类型 | 说明
----|------|-----
root | String | 分包根目录
name | String | 分包别名，分包预下载时可以使用
pages | StringArray | 分包页面路径，相对与分包根目录
independent | Boolean | 分包是否是独立分包

**打包原则**:

- 声明 `subpackages` 后，将按 `subpackages` 配置路径进行打包，`subpackages` 配置路径外的目录将被打包到 app（主包） 中
- app（主包）也可以有自己的 pages（即最外层的 pages 字段）
- `subpackage` 的根目录不能是另外一个 `subpackage` 内的子目录
- `tabBar` 页面必须在 app（主包）内

**引用原则**:

- packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件
- packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 template
- packageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源

**低版本兼容**
由微信后台编译来处理旧版本客户端的兼容，后台会编译两份代码包，一份是分包后代码，另外一份是整包的兼容代码。 新客户端用分包，老客户端还是用的整包，完整包会把各个 `subpackage` 里面的路径放到 pages 中。

#### 5.5.2 独立分包

> 基础库 2.3.0 及以上版本开始支持。

独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。

开发者可以按需将某些具有一定功能独立性的页面配置到独立分包中。当小程序从普通的分包页面启动时，需要首先下载主包；而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度。

一个小程序中可以有多个独立分包。

**配置方法**
假设小程序目录结构如下：

```txt
├── app.js
├── app.json
├── app.wxss
├── moduleA
│   └── pages
│       ├── rabbit
│       └── squirrel
├── moduleB
│   └── pages
│       ├── pear
│       └── pineapple
├── pages
│   ├── index
│   └── logs
└── utils
```

通过在 `app.json` 的 `subpackages` 字段中对应的分包配置项中定义 `independent` 字段声明对应分包为独立分包。

```json
{
  "pages": [
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "moduleA",
      "pages": [
        "pages/rabbit",
        "pages/squirrel"
      ]
    }, {
      "root": "moduleB",
      "pages": [
        "pages/pear",
        "pages/pineapple"
      ],
      "independent": true
    }
  ]
}
```

**限制**
独立分包属于分包的一种。普通分包的所有限制都对独立分包有效。独立分包中插件、自定义组件的处理方式同普通分包。

此外，使用独立分包时要注意：

- **独立分包中不能依赖主包和其他分包中的内容**，包括js文件、template、wxss、自定义组件、插件等。主包中的 `app.wxss` 对独立分包无效，应避免在独立分包页面中使用 `app.wxss` 中的样式；
- `App` 只能在主包内定义，独立分包中不能定义 `App`，会造成无法预期的行为；
- 独立分包中暂时不支持使用插件。

**注意事项**:

- 关于 getApp()
  与普通分包不同，独立分包运行时，`App` 并不一定被注册，因此 `getApp()` 也不一定可以获得 `App` 对象：
  - 当用户从独立分包页面启动小程序时，主包不存在，`App` 也不存在，此时调用 `getApp()` 获取到的是 `undefined`。 当用户进入普通分包或主包内页面时，主包才会被下载，`App` 才会被注册。
  由于这一限制，无法通过 `App` 对象实现独立分包和小程序其他部分的全局变量共享。
  为了在独立分包中满足这一需求，基础库 2.2.4 版本开始 `getApp` 支持 [`allowDefault`] 参数，在 App 未定义时返回一个默认实现。当主包加载，App 被注册时，默认实现中定义的属性会被覆盖合并到真正的 App 中。

  ```js
  // 独立分包中
  const app = wx.getApp({allowDefault: true});
  app.data = 456
  app.global = {}

  App({
    data: 123,
    other: 'hello'
  })
  console.log(getApp()) // {global: {}, data: 456, other: 'hello'}
  ```

- 关于 App 生命周期
  当从独立分包启动小程序时，主包中 App 的 `onLaunch` 和首次 `onShow` 会在从独立分包页面首次进入主包或其他普通分包页面时调用。
  由于独立分包中无法定义 App，小程序生命周期的监听可以使用 [wx.onAppShow][wx.onAppShow]，[wx.onAppHide][wx.onAppHide] 完成。App 上的其他事件可以使用 [wx.onError][wx.onError]，[wx.onPageNotFound][wx.onPageNotFound] 监听。

**低版本兼容**
在低于6.7.2版本的微信中运行时，独立分包视为普通分包处理，不具备独立运行的特性。

> 注意：在兼容模式下，主包中的 `app.wxss` 可能会对独立分包中的页面产生影响，因此应避免在独立分包页面中使用 `app.wxss` 中的样式。

#### 5.5.3 分包预下载

> 基础库 2.3.0 开始支持，低版本需做 [兼容处理][compatibility]。

开发者可以通过配置，在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度。对于独立分包，也可以预下载主包。

**分包预下载目前只支持通过配置方式使用，暂不支持通过调用API完成。**

> vConsole 里有 `preloadSubpackages` 开头的日志信息，可以用来验证预下载的情况。

**配置方法**
预下载分包行为在进入某个页面时触发，通过在 `app.json` 增加 `preloadRule` 配置来控制。

```json
{
  "pages": ["pages/index"],
  "subpackages": [
    {
      "root": "important",
      "pages": ["index"],
    },
    {
      "root": "sub1",
      "pages": ["index"],
    },
    {
      "name": "hello",
      "root": "path/to",
      "pages": ["index"]
    },
    {
      "root": "sub3",
      "pages": ["index"]
    },
    {
      "root": "indep",
      "pages": ["index"],
      "independent": true
    }
  ],
  "preloadRule": {
    "pages/index": {
      "network": "all",
      "packages": ["important"]
    },
    "sub1/index": {
      "packages": ["hello", "sub3"]
    },
    "sub3/index": {
      "packages": ["path/to"]
    },
    "indep/index": {
      "packages": ["__APP__"]
    }
  }
}
```

`preloadRule` 中，`key` 是页面路径，`value` 是进入此页面的预下载配置，每个配置有以下几项：

字段 | 类型 | 必填 | 默认值 | 说明
-----|-----|------|-------|-----
package | StringArray | 是 | 无 | 进入页面后预下载分包的 `root` 或 `name`。`__APP__` 表示主包。
network | String | 否 | wifi | 在指定网络下预下载，可选值为： `all`: 不限网络，`wifi`: 仅wifi下预下载

**限制**
同一个分包中的页面享有共同的预下载大小限额 **2M**，限额会在工具中打包时校验。
如，页面 A 和 B 都在同一个分包中，A 中预下载总大小 0.5M 的分包，B中最多只能预下载总大小 1.5M 的分包。

### 5.6 多线程Worker

一些异步处理的任务，可以放置于 Worker 中运行，待运行结束后，再把结果返回到小程序主线程。Worker 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法。

Worker 与主线程之间的数据传输，双方使用 [Worker.postMessage()][Worker.postMessage] 来发送数据，[Worker.onMessage()][Worker.onMessage] 来接收数据，传输的数据并不是直接共享，而是**被复制**的。

**使用流程**:

1. 配置Worker 信息
  在 `app.json` 中可配置 `Worker` 代码放置的目录，目录下的代码将被打包成一个文件：

    ```json
    {
      "workers": "workers"
    }
    ```

2. 添加 Worker 代码文件
  根据步骤 1 中的配置，在代码目录下新建以下两个入口文件：

    ```txt
    workers/request/index.js
    workers/request/utils.js
    workers/response/index.js
    ```

    添加后，目录结构如下：

    ```txt
    ├── app.js
    ├── app.json
    ├── project.config.json
    └── workers
        ├── request
        │   ├── index.js
        │   └── utils.js
        └── response
            └── index.js
    ```

3. 编写 Worker 代码
  在 `workers/request/index.js` 编写 Worker 响应代码

    ```js
    const utils = require("./utils")
    // 在 Worker 线程执行上下文会全局暴露一个 worker 对象，直接调用 worker.onMessage/postMessage 即可
    worker.onMessage(function (res) {
      console.log(res)
    })
    ```

4. 在主线程中初始化 Worker
  在主线程的代码 app.js 中初始化 Worker

    ```js
    // 文件名指定 worker 的入口文件路径，绝对路径
    const worker = wx.createWorker('/workers/request/index.js')
    ```

5. 主线程向 Worker 发送消息

  ```js
  worker.postMessage({
    msg: 'hello worker'
  })
  ```

worker 对象的其它接口看 [worker接口指南][https://developers.weixin.qq.com/miniprogram/dev/api/worker/wx.createWorker.html]

> 注意:
>
> 1. Worker 最大并发数量限制为 1 个，创建下一个前请用 `Worker.terminate()` 结束当前 Worker
> 2. Worker 内代码只能 `require` 指定 `Worker` 路径内的文件，无法引用其它路径
> 3. Worker 的入口文件由 `wx.createWorker()` 时指定，开发者可动态指定 Worker 入口文件
> 4. Worker 内不支持 `wx` 系列的 API
> 5. Workers 之间不支持发送消息

### 5.7 服务端能力

#### 5.7.1 服务端API

小程序还提供了一系列在后端服务器使用 HTTPS 请求调用的 API，帮助开发者在后台完成各类数据分析、管理和查询等操作。如 getAccessToken，code2Session 等。详细介绍参考 [服务端文档][服务端]。

**access_token**
`access_token` 是小程序全局唯一后台接口调用凭据，调用绝大多数后台接口时都需使用。开发者可以通过 `getAccessToken` 接口获取并进行妥善保存。
为了 access_token 的安全性，后端 API 不能直接在小程序内通过 [wx.request][wx.request] 调用，即 `api.weixin.qq.com` 不能被配置为服务器域名。开发者应在后端服务器使用 `getAccessToken` 获取 `access_token`，并调用相关 API；

**请求参数说明**:

- 对于 GET 请求，请求参数应以 `QueryString` 的形式写在 URL 中。
- 对于 POST 请求，部分参数需以 `QueryString` 的形式写在 URL 中（一般只有 `access_token`，如有额外参数会在文档里的 URL 中体现），其他参数如无特殊说明均以 JSON 字符串格式写在 POST 请求的 body 中。

**返回参数说明**:

> 注意：当API调用成功时，部分接口不会返回 `errcode` 和 `errmsg`，只有调用失败时才会返回。

#### 5.7.2 消息推送

接入微信小程序消息推送服务，可以两种方式选择其一：

1. 开发者服务器接收消息推送
2. 云函数接收消息推送

##### 5.7.2.1 开发者服务器接收消息推送

**第一步：填写服务器配置**
登录小程序后台后，在「开发」-「开发设置」-「消息推送」中，管理员扫码启用消息服务，填写服务器地址（URL）、令牌（Token） 和 消息加密密钥（EncodingAESKey）等信息。

- URL: 用来接收微信消息和事件的接口 URL。所填写的URL 必须以 `http://` 或 `https://` 开头，分别支持 80 端口和 443 端口。
- Token: 可以任意填写，用作生成签名（该 Token 会和接口 URL 中包含的 Token 进行比对，从而验证安全性）。
- EncodingAESKey: 手动填写或随机生成，将用作消息体加解密密钥。

同时，可选择消息加解密方式：明文模式（默认）、兼容模式和安全模式。可以选择消息数据格式：XML 格式（默认）或 JSON 格式。

模式的选择与服务器配置在提交后都会立即生效，请谨慎填写及选择。切换加密方式和数据格式需要提前配置好相关代码，详情参考 [消息加解密说明][消息加解密说明]。

**第二步：验证消息的确来自微信服务器**
提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带参数如下表所示：

参数 | 描述
-----|-----
signature | 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。
timestamp | 时间戳
nonce | 随机数
echostr | 随机字符串

通过检验 `signature` 对请求进行校验（下面有校验方式）。若确认此次 GET 请求来自微信服务器，原样返回 `echostr` 参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：

1. 将token、timestamp、nonce三个参数进行字典序排序
2. 将三个参数字符串拼接成一个字符串进行sha1加密
3. 获得加密后的字符串可与signature对比，标识该请求来源于微信

验证URL有效性成功后即接入生效

**第三步：接收消息和事件**
当某些特定的用户操作引发事件推送时（如用户向小程序客服发送消息、或者进入会话等情况），微信服务器会将消息（或事件）的数据包以 POST 请求发送到开发者配置的 URL，开发者可以依据自身业务逻辑进行响应。

微信服务器在将用户的消息发给开发者服务器地址后，微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。如果在调试中，发现用户无法收到响应的消息，可以检查是否消息处理超时。关于重试的消息排重，有 msgid 的消息推荐使用 msgid 排重。事件类型消息推荐使用 `FromUserName + CreateTime` 排重。

服务器收到请求必须做出下述回复，这样微信服务器才不会对此作任何处理，并且不会发起重试，否则，将出现严重的错误提示。详细说明：

1. 直接回复success（推荐方式）
2. 直接回复空串（指字节长度为0的空字符串，而不是结构体中content字段的内容为空）
3. 若接口文档有指定返回内容，应按文档说明返回

对于客服消息，一旦遇到以下情况，微信会在小程序会话中向用户下发系统提示“该小程序客服暂时无法提供服务，请稍后再试”：

1. 在5秒内未回复任何内容
2. 回复了异常数据

如果希望增强安全性，可以在开发者中心处开启消息加密，这样，用户发给小程序的消息以及小程序被动回复用户消息都会继续加密，详见 [消息加解密说明][消息加解密说明]。

##### 5.7.2.2 云函数接收消息推送

开通了 [云开发][云开发] 的小程序可以使用云函数接收消息推送，目前仅支持客服消息推送。

**第一步：开发者工具云开发控制台中增加配置**
打开云开发控制台，到设置 tab 中选择全局设置 - 添加消息推送配置。消息类型对应收包的 `MsgType`，事件类型对应收包的 `Event`，同一个 <消息类型, 事件类型> 二元组只能推到一个环境的一个云函数。例如客服消息文本消息对应的就是消息类型为 `text`，事件类型为空。具体值查看各个消息的消息格式。

**第二步：云函数中处理消息**
云函数被触发时，其 `event` 参数即是接口所定义的 JSON 结构的对象（统一 JSON 格式，不支持 XML 格式）。

以客服消息为例，接收到客服消息推送时，`event` 结构如下：

```json
{
  "FromUserName": "ohl4L07T_DaNQa4ePaz0",
  "ToUserName": "wx3d289323f5900f8e",
  "Content": "测试",
  "CreateTime": 1555684067,
  "MsgId": "49d72d67b16d115e7935ac386f2f0fa41535298877_1555684067",
  "MsgType": "text"
}
```

此时可调用客服消息 [发送](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.send.html) 接口回复消息，一个简单的接收到消息后统一回复 “收到” 的示例如下：

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()

  await cloud.openapi.customerServiceMessage.send({
    touser: wxContext.OPENID,
    msgtype: 'text',
    text: {
      content: '收到',
    },
  })

  return 'success'
}
```

### 5.8 自定义 tabBar

> 基础库 2.5.0 开始支持，低版本需做 [兼容处理][compatibility]。

自定义 tabBar 可以让开发者更加灵活地设置 tabBar 样式，以满足更多个性化的场景。

**在自定义 tabBar 模式下**:

- 为了保证低版本兼容以及区分哪些页面是 tab 页，tabBar 的相关配置项需完整声明，但这些字段不会作用于自定义 tabBar 的渲染。
- 此时需要提供一个自定义组件来渲染 tabBar，所有 tabBar 的样式都由该自定义组件渲染。推荐用 fixed 在底部的 cover-view + cover-image 组件渲染样式，以保证 tabBar 层级相对较高。
- 与 tabBar 样式相关的接口，如 wx.setTabBarItem 等将失效
- 每个 tab 页下的自定义 tabBar 组件实例是不同的，可通过自定义组件下的 `getTabBar` 接口，获取当前页面的自定义 tabBar 组件实例。

> 注意：如需实现 tab 选中态，要在当前页面下，通过 `getTabBar` 接口获取组件实例，并调用 `setData` 更新选中态。

**使用流程**:

1. 配置信息
    - 在 app.json 中的 tabBar 项指定 `custom` 字段，同时其余 tabBar 相关配置也补充完整。
    - 所有 tab 页的 json 里需声明 `usingComponents` 项，也可以在 app.json 全局开启。

      ```json
      {
        "tabBar": {
          "custom": true,
          "color": "#000000",
          "selectedColor": "#000000",
          "backgroundColor": "#000000",
          "list": [{
            "pagePath": "page/component/index",
            "text": "组件"
          }, {
            "pagePath": "page/API/index",
            "text": "接口"
          }]
        },
        "usingComponents": {}
      }
      ```

2. 添加 tabBar 代码文件
  在代码根目录下添加入口文件:

    ```txt
    custom-tab-bar/index.js
    custom-tab-bar/index.json
    custom-tab-bar/index.wxml
    custom-tab-bar/index.wxss
    ```

3. 编写 tabBar 代码
  用自定义组件的方式编写即可，该自定义组件完全接管 `tabBar` 的渲染。另外，自定义组件新增 `getTabBar` 接口，可获取当前页面下的自定义 `tabBar` 组件实例。

### 5.9 周期性更新

> 基础库 2.8.0 开始支持，低版本需做 [兼容处理][compatibility]。
> 生效条件：用户七天内使用过小程序

周期性更新能够在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间，增强在弱网条件下的可用性。

**使用流程**:

1. 配置数据下载地址
  登录小程序管理后台，进入设置 -> 开发设置 -> 数据周期性更新，点击开启，填写数据下载地址。

2. 设置 TOKEN
  第一次启动小程序时，调用 [wx.setBackgroundFetchToken()][wx.setBackgroundFetchToken] 设置一个 TOKEN 字符串，可以跟用户态相关，会在后续微信客户端向开发者服务器请求时带上，便于给后者校验请求合法性。

    ```js
    APP({
      onLaunch: function() {
        wx.setBackgroundFetchToken({
          token: 'xxx'
        })
      }
    })
    ```

3. 微信客户端定期拉取数据
  微信客户端会在一定的网络条件下，每隔 12 小时（以上一次成功更新的时间为准）向配置的数据下载地址发起一个 HTTP GET 请求，其中包含的 `query` 参数如下，数据获取到后会将整个 `HTTP body` 缓存到本地。

    参数 | 类型 | 说明
    -----|-----|------
    appid | String | 小程序标识
    token | String | 前面设置的 TOKEN
    timestamp | Number | 时间戳，微信客户端发起请求的时间

    > query 参数会使用 urlencode 处理
    > 服务器接口返回的数据类型应为字符串，且大小应不超过 256KB，否则将无法缓存数据

4. 读取数据
  用户启动小程序时，调用 [wx.getBackgroundFetchData()][wx.getBackgroundFetchData] 获取已缓存到本地的数据。

    ```js
    App({
      onLaunch: function() {
        wx.getBackgroundFetchData({
          fetch: 'periodic',
          success(res) {
            console.log(res.fetchedData) // 缓存数据
            console.log(res.timeStamp) // 客户端拿到缓存数据的时间戳
          }
        })
      }
    })
    ```

**调试方法**
为了方便调试周期性数据，工具提供了调试能力，具体查看 [周期性数据调试](https://developers.weixin.qq.com/miniprogram/dev/devtools/periodic-data.html)。

### 5.10 数据预拉取

预拉取能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度 。

**使用流程**:

1. 配置数据下载地址
  登录小程序 MP 管理后台，进入设置 -> 开发设置 -> 数据预加载，点击开启，填写数据下载地址，只支持 HTTPS 。

2. 设置 TOKEN
  第一次启动小程序时，调用 [wx.setBackgroundFetchToken()][wx.setBackgroundFetchToken] 设置一个 TOKEN 字符串，可以跟用户态相关，会在后续微信客户端向开发者服务器请求时带上，便于给后者校验请求合法性。

    ```js
    App({
      onLaunch() {
        wx.setBackgroundFetchToken({
          token: 'xxx'
        })
      }
    })
    ```

3. 微信客户端提前拉取数据
  当用户打开小程序时，微信服务器将向开发者服务器（上面配置的数据下载地址）发起一个 HTTP GET 请求，其中包含的 `query` 参数如下，数据获取到后会将整个 HTTP body 缓存到本地。

    参数 | 类型 | 必填 | 说明
    ----|------|------|-----
    appid | String | 是 | 小程序标识。
    token | String | 否 | 前面设置的 TOKEN。
    code | String | 否 | 用户登录凭证，未设置TOKEN时由微信侧预生成，可在开发者后台调用 [auth.code2Session][auth.code2Session]，换取 openid 等信息。
    timestamp | Number | 是 | 时间戳，微信客户端发起请求的时间
    path | String | 否 | 打开小程序的路径。
    query | String | 否 | 打开小程序的query。
    scene | Number | 否 | 打开小程序的场景值。

    > query 参数会使用 urlencode 处理
    > token和code只会存在一个，用于标识用户身份。
    > 服务器接口返回的数据类型应为字符串，且大小应不超过 256KB，否则将无法缓存数据

4. 读取数据
  用户启动小程序时，调用 wx.getBackgroundFetchData() 获取已缓存到本地的数据。

    ```js
    App({
      onLaunch() {
        wx.getBackgroundFetchData({
          fetchType: 'pre',
          success(res) {
            console.log(res.fetchedData) // 缓存数据
            console.log(res.timeStamp) // 客户端拿到缓存数据的时间戳
            console.log(res.path) // 页面路径
            console.log(res.query) // query 参数
            console.log(res.scene) // 场景值
          }
        })
      }
    })
    ```

**调试方法**
工具提供了调试能力，具体查看 [预拉取数据调试](https://developers.weixin.qq.com/miniprogram/dev/devtools/prefetch-data.html)。

### 5.11 DarkModel 适配指南

> 基础库 v2.11.0 开始支持

**开启 DarkMode**
在 app.json 中配置 `darkmode` 为true，即表示当前小程序已适配 DarkMode，所有基础组件均会根据系统主题展示不同的默认样式，navigation bar 和 tab bar 也会根据下面的配置自动切换。

**相关配置**
当 app.json 中配置 `darkmode` 为true时，小程序部分配置项可通过变量的形式配置，在变量配置文件中定义不同主题下的颜色或图标，方法如下：

1. 在 app.json 中配置 `themeLocation`，指定变量配置文件 theme.json 路径，例如：在根目录下新增 theme.json，需要配置 `"themeLocation":"theme.json"`
2. 在 theme.json 中定义相关变量；
3. 在 app.json 中以 `@` 开头引用变量。

支持通过变量配置的属性：

- 全局配置的 window 属性与页面配置下的属性
  - navigationBarBackgroundColor
  - navigationBarTextStyle
  - backgroundColor
  - backgroundTextStyle
  - backgroundColorTop
  - backgroundColorBottom
- 全局配置 window.tabBar 的属性
  - color
  - selectedColor
  - backgroundColor
  - borderStyle
  - list
    - iconPath
    - selectedIconPath

**变量配置文件 theme.json**
`theme.json` 用于颜色主题相关的变量定义，需要先在 `themeLocation` 中配置 `theme.json` 的路径，否则无法读取变量配置。

配置文件须包含以下属性：

属性 | 类型 | 必填 | 描述
-----|-----|------|-----
light | object | 是 | 浅色模式下的变量定义
dark | object | 是 | 深色模式下的变量定义

light和dark下均可以key: value的方式定义变量名和值，例如：

```json
{
  "light": {
    "navBgColor": "#f6f6f6",
    "navTxtStyle": "black"
  },
  "dark": {
    "navBgColor": "#191919",
    "navTxtStyle": "white"
  }
}
```

完成定义后，可在全局配置或页面配置的相关属性中以 `@` 开头引用，例如：

```json
// 全局配置
{
  "window": {
    "navigationBarBackgroundColor": "@navBgColor",
    "navigationBarTextStyle": "@navTxtStyle"
  }
}
// 页面配置
{
  "navigationBarBackgroundColor": "@navBgColor",
  "navigationBarTextStyle": "@navTxtStyle"
}
```

配置完成后，小程序框架会自动根据系统主题，为小程序展示对应主题下的颜色。

**获取当前系统主题**
如果app.json中声明了 "darkmode": true，`wx.getSystemInfo` 或 `wx.getSystemInfoSync` 的返回结果中会包含 `theme` 属性，值为light或dark。

如果 app.json 未声明 "darkmode": true，则无法获取到 theme 属性（即theme为undefined）。

**监听主题切换事件**
支持2种方式：

1. 在 `App()` 中传入 onThemeChange 回调方法，主题切换时会触发此回调
2. 通过 [wx.onThemeChange][wx.onThemeChange] 监听主题变化，[wx.offThemeChange][wx.offThemeChange] 取消监听

**WXSS 适配**
WXSS中，支持通过媒体查询 `prefers-color-scheme` 适配不同主题，与 Web 中适配方式一致，例如：

```wxss
/* 一般情况下的样式 begin */
.some-background {
  background: white;
}
.some-text {
  color: black;
}
/* 一般情况下的样式 end */

@media (prefers-color-scheme: dark) {
  /* DarkMode 下的样式 start */
  .some-background {
      background: #1b1b1b;
  }
  .some-text {
      color: #ffffff;
  }
  /* DarkMode 下的样式 end */
}
```

> 注意:
>
> 1. WXSS 中的媒体查询不受 `app.json` 中的 `darkmode` 开关配置影响，只要微信客户端（iOS 7.0.12、Android 7.0.13）支持 `DarkMode`，无论是否配置"darkmode": true，在系统切换到 DarkMode 时，媒体查询都将生效。
> 2. 主题切换事件需要在配置 `"darkmode": true` 时，才会触发。

### 5.12 大屏适配指南

目前市面上的用户设备大致可分为小屏的手机端、中屏的平板、大屏的 PC 端三类，而在这三类设备中又会有细小的尺寸差别，也称作屏幕碎片化。

随着小程序能够在越来越多的设备终端上运行，应该针对不同的屏幕尺寸进行相应的适配。

按照一般的适配原则，结合小程序特点，通常在以下三种情况中需要进行适配：

1. 同一类设备下，尺寸有细微差别
  使用小程序提供的 [rpx](#232-wxss) 单位，在尺寸差别不大的情况下对页面布局进行等比缩放。

2. 在允许屏幕旋转的情况下，可分为横屏与竖屏
  手机端设置 `"pageOrientation": "auto"` 或 iPad 上设置 `"resizable": true` 时会允许屏幕旋转，此时使用 Page 的 `onResize` 事件或者 `wx.onWindowResize` 方法可对该操作进行监听，进而判断是使用横屏还是竖屏布局。

3. 不同类设备或者能够自由拖拽窗口的 PC 小程序
  小程序目前是基于 Webview 实现，利用 CSS 媒体查询 可实时监听屏幕尺寸大小，在不同的屏幕下展现不同的 UI 布局，结合 Flex 弹性布局、Grid 网格布局便能实现更加响应式的适配方案。
  matchMedia - 抽象式媒体查询，小程序基础库基于 `window.matchMedia` API 新增了一组过程式与定义式接口 `match-media` 。可以通过 `<match-media></match-media>` 和 `wx.createMediaQueryObserver` 来显式地使用媒体查询能力，对于多端适配来说，它有以下优势：

    1. 能够更方便、显式地使用 Media Query 能力，而不是耦合在 CSS 文件中，难以复用。
    2. 能够在 WXML 中结合数据绑定动态地使用，不仅能做到组件的显示或隐藏，在过程式 API 中可塑性更高，例如能够根据尺寸变化动态地添加 class 类名，改变样式。
    3. 能够嵌套式地使用 Media Query 组件，即能够满足局部组件布局样式的改变。
    4. 组件化之后，封装性更强，能够隔离样式、模版以及绑定在模版上的交互事件，还能够提供更高的可复用性。
    5. 浏览器内置 API ，能够在所有基于 Webview 的小程序上使用，兼容性良好。 match-media 具体使用方法可参考相关 [文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia)

4. 自适应布局
  为了更好的自适应大屏，小程序提供了 [row/col 组件][grid] 供开发者使用。自适应的主要特性是：
    - 整行最多只有 24 份，多余的排列会自动向下换行
    - 每个尺寸设置并不会影响到其它尺寸的布局

    设计指引与代码示例
      关于如何在设计、用户体验上实现更好的多端适配小程序，可参考[小程序适配设计指南](https://developers.weixin.qq.com/miniprogram/design/adapt.html#_1-%E5%9F%BA%E6%9C%AC%E9%80%82%E9%85%8D%E5%8E%9F%E5%88%99)。

## 六. 硬件能力

### 6.1 蓝牙

蓝牙适配器模块生效周期为调用 [wx.openBluetoothAdapter][wx.openBluetoothAdapter] 至调用 [wx.closeBluetoothAdapter][wx.closeBluetoothAdapter] 或小程序被销毁为止。

在小程序蓝牙适配器模块生效期间，才能够正常调用蓝牙相关的小程序 API，并收到蓝牙模块相关的事件回调。

> 注意:
> 由于系统限制，Android 上获取到的 deviceId 为设备 MAC 地址，iOS 上则为设备 uuid。因此 deviceId 不能硬编码到代码中。
> 目前不支持在开发者工具上进行蓝牙功能的调试，需要使用真机才能正常调用小程序蓝牙接口。

**低功耗蓝牙（BLE）注意事项**
wx.getBLEDeviceServices
iOS 上对特征值的 read、write、notify操作，由于系统需要获取特征值实例，传入的 `serviceId` 与 `characteristicId` 必须由 [wx.getBLEDeviceServices][wx.getBLEDeviceServices] 与 [wx.getBLEDeviceCharacteristics][wx.getBLEDeviceCharacteristics] 中获取到后才能使用。建议双平台统一在建立连接后先执行 [wx.getBLEDeviceServices][wx.getBLEDeviceServices] 与 [wx.getBLEDeviceCharacteristics][wx.getBLEDeviceCharacteristics] 后再进行与蓝牙设备的数据交互。

### 6.2 NFC

支持 HCE（基于主机的卡模拟）模式，即将安卓手机模拟成实体智能卡。 支持 NFC 读写，即手机作为读卡器使用。

- 适用机型：支持 NFC 功能，且系统版本为 Android 5.0 及以上的手机
- 适用卡范围：符合ISO 14443-4 标准的 CPU 卡
- 支持 Reader/Writer（读取器/写入器）模式，即支持 NFC 设备读取和/或写入被动 NFC 标签和贴纸。
- 适用机型：支持 NFC 功能，且系统版本为 Android 5.0 及以上的手机
- 适用范围：
  - 支持NFC-A (ISO 14443-3A)/NFC-B (ISO 14443-3B)/NFC-F (JIS 6319-4)/NFC-V (ISO 15693)/ISO-DEP (ISO 14443-4)标准的读写
（部分Android手机）支持MIFARE Classic/MIFARE Ultralight标签的读写
  - 支持对NDEF格式的NFC标签上的NDEF数据的读写

**基本流程**
以往NFC-A卡片写入apdu指令为例

- 调用 wx.getNFCAdapter() 获取NFC适配器实例
- 调用 NFCAdapter.onDiscovered(function callback) 注册贴卡监听回调
- 调用 NFCAdapter.startDiscovery(Object object) 开始监听贴卡
- 贴卡，onDiscovered 回调
  - 根据 onDiscovered 回调res对象的techs字段匹配到卡片支持NFC-A标准
  - 通过 NFCAdapter.getNfcA() 获取NfcA实例
- 使用NfcA实例进行读写
  - 调用 NfcA.connect() 和 NFC卡片 建立连接
  - 调用 NfcA.transceive(Object object) 往NFC卡片写入apdu指令并接收卡片返回数据
  - 读写完毕，调用NfcA.close()断开连接
- 调用 NFCAdapter.stopDiscovery(Object object) 结束监听贴卡

### 6.3 WI-FI

在小程序中支持搜索周边的 Wi-Fi，同时可以针对指定 Wi-Fi，传入密码发起连接。

该系列接口为系统原生能力，如需查看「微信连Wi-Fi」能力及配置跳转小程序，参考 [文档](https://developers.weixin.qq.com/doc/offiaccount/WiFi_via_WeChat/WiFi_mini_programs.html)。

连接指定 Wi-Fi 接口调用时序：

- Android：startWifi —> connectWifi —> onWifiConnected
- iOS（仅iOS 11及以上版本支持）：startWifi —> connectWifi —> onWifiConnected

连周边 Wi-Fi 接口调用时序：

- Android：startWifi —> getWifiList —> onGetWifiList —> connectWifi —> onWifiConnected
- iOS（iOS 11.0及11.1版本因系统原因暂不支持）：startWifi —> getWifiList —> onGetWifiList —> setWifiList —> onWifiConnected

> 注意：
> Wi-Fi 相关接口暂不可用 wx.canIUse 接口判断。
> Android 6.0 以上版本，在没有打开定位开关的时候会导致设备不能正常获取周边的 Wi-Fi 信息。

## 七. 开放能力

### 7.1 用户信息

#### 7.1.1 小程序登录

小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。

登录流程时序
![登录流程时序](./image/登录流程时序.jpg)

说明：

1. 调用 [wx.login()][wx.login] 获取 **临时登录凭证code** ，并回传到开发者服务器。
2. 调用 [auth.code2Session][auth.code2Session] 接口，换取 **用户唯一标识 OpenID** 和 **会话密钥 session_key**。

之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。

> 注意：
> 会话密钥 `session_key` 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。
> 临时登录凭证 code 只能使用一次

#### 7.1.2 UnionID 机制说明

如果拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。

**UnionID获取途径**
绑定了开发者帐号的小程序，可以通过以下途径获取 UnionID。

1. 调用接口 [wx.getUserInfo][wx.getUserInfo] ，从解密数据中获取 UnionID。注意本接口需要用户授权，请妥善处理用户拒绝授权后的情况。

2. 如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过 [wx.login][wx.login] + `code2Session` 获取到该用户 UnionID，无须用户再次授权。

3. 如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过 [wx.login][wx.login] + `code2Session` 获取到该用户 UnionID ，无须用户再次授权。

4. 用户在小程序（暂不支持小游戏）中支付完成后，开发者可以直接通过 `getPaidUnionId` 接口获取该用户的 UnionID，无需用户授权。注意：本接口仅在用户支付完成后的5分钟内有效，请妥善处理。

5. 小程序端调用云函数时，如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号，可在云函数中通过 [cloud.getWXContext][cloud.getWXContext] 获取 UnionID。

6. 小程序端调用云函数时，如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用，也可在云函数中通过 [cloud.getWXContext][cloud.getWXContext] 获取 UnionID。

**微信开放平台绑定小程序流程**
登录微信开放平台 — 管理中心 — 小程序 — 绑定小程序

#### 7.1.3 授权

部分接口需要经过用户授权同意才能调用。小程序把这些接口按使用范围分成多个 `scope` ，用户选择对 `scope` 来进行授权，当授权给一个 `scope` 之后，其对应的所有接口都可以直接使用。

此类接口调用时：

- 如果用户未接受或拒绝过此权限，会弹窗询问用户，用户点击同意后方可调用接口；
- 如果用户已授权，可以直接调用接口；
- 如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调。请兼容用户拒绝授权的场景。

**获取用户授权设置**
可以使用 [wx.getSetting][wx.getSetting] 获取用户当前的授权状态。

**打开设置界面**
用户可以在小程序设置界面（「右上角」 - 「关于」 - 「右上角」 - 「设置」）中控制对该小程序的授权状态。

可以调用 [wx.openSetting][wx.openSetting] 打开设置界面，引导用户开启授权。

**提前发起授权请求**
可以使用 [wx.authorize][wx.authorize] 在调用需授权 API 之前，提前向用户发起授权请求。

**scope 列表**:

scope | 对应接口 | 描述
------|----------|-----
scope.userInfo | [wx.getUserInfo][wx.getUserInfo] | 用户信息
scope.userLocation | [wx.getLocation][wx.getLocation], [wx.chooseLocation][wx.chooseLocation] | 地理位置
scope.userLocationBackground | [wx.startLocationUpdateBackground][wx.startLocationUpdateBackground] | 后台定位
scope.address | [wx.chooseAddress][wx.chooseAddress] | 通讯地址（已取消授权，可以直接调用对应接口）
scope.invoiceTitle | [wx.chooseInvoiceTitle][wx.chooseInvoiceTitle] | 发票抬头（已取消授权，可以直接调用对应接口）
scope.invoice | [wx.chooseInvoice][wx.chooseInvoice] | 获取发票（已取消授权，可以直接调用对应接口）
scope.werun | [wx.getWeRunData][wx.getWeRunData] | 微信运动步数
scope.record | [wx.startRecord][wx.startRecord] | 录音功能
scope.writePhotosAlbum | [wx.saveImageToPhotosAlbum][wx.saveImageToPhotosAlbum], [wx.saveVideoToPhotosAlbum][wx.saveVideoToPhotosAlbum] | 保存到相册
scope.camera | [camera][camera] 组件 | 摄像头

**授权有效期**
一旦用户明确同意或拒绝过授权，其授权关系会记录在后台，直到用户主动删除小程序。

**最佳实践**
在真正需要使用授权接口时，才向用户发起授权申请，并在授权申请中说明清楚要使用该功能的理由。

> 注意:
> `wx.authorize({scope: "scope.userInfo"})`，不会弹出授权窗口，请使用 `<button open-type="getUserInfo"/>`
> 需要授权 `scope.userLocation`、`scope.userLocationBackground` 时必须 [配置地理位置用途说明](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#permission)。

**后台定位**
与其它类型授权不同的是，`scope.userLocationBackground` 不会弹窗提醒用户。需要用户在设置页中，主动将“位置信息”选项设置为“使用小程序期间和离开小程序后”。开发者可以通过调用 [wx.openSetting][wx.openSetting]，打开设置页。

#### 7.1.4 开放数据校验与解密

小程序可以通过各种前端接口获取微信提供的开放数据。考虑到开发者服务端也需要获取这些开放数据，微信提供了两种获取方式：

##### 7.1.4.1 开发者后台校验与解密开放数据

微信会对这些开放数据做签名和加密处理。后台拿到开放数据后可以对数据进行校验签名和解密，来保证数据不被篡改。

![开放数据加密解密过程](./image/开放数据加密解密过程.jpg)

签名校验以及数据加解密涉及用户的会话密钥 `session_key`。 开发者应该事先通过 [wx.login][wx.login] 登录流程获取会话密钥 session_key 并保存在服务器。为了数据不被篡改，开发者不应该把 session_key 传到小程序客户端等服务器外的环境。

**数据签名校验**
为了确保开放接口返回用户数据的安全性，微信会对明文数据进行签名。可以根据业务需要对数据包进行签名校验，确保数据的完整性。

1. 通过调用接口（如 [wx.getUserInfo][wx.getUserInfo]）获取数据时，接口会同时返回 rawData、signature，其中 signature = sha1( rawData + session_key )
2. 将 signature、rawData 发送到开发者服务器进行校验。服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的完整性。

如 wx.getUserInfo的数据校验：

接口返回的rawData：

```json
{
  "nickName": "Band",
  "gender": 1,
  "language": "zh_CN",
  "city": "Guangzhou",
  "province": "Guangdong",
  "country": "CN",
  "avatarUrl": "http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"
}
```

用户的 session-key：

```string
HyVFkGl5F5OQWJZZaNzBBg==
```

用于签名的字符串为：

```string
{"nickName":"Band","gender":1,"language":"zh_CN","city":"Guangzhou","province":"Guangdong","country":"CN","avatarUrl":"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"}HyVFkGl5F5OQWJZZaNzBBg==
```

使用sha1得到的结果为

```string
75e81ceda165f4ffa64f4068af58c64b8f54b88c
```

**加密数据解密算法**
接口如果涉及敏感数据（如 [wx.getUserInfo][wx.getUserInfo] 当中的 openId 和 unionId），接口的明文内容将不包含这些敏感数据。如需要获取敏感数据，需要对接口返回的 **加密数据(encryptedData)** 进行对称解密。 解密算法如下：

1. 对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。
2. 对称解密的目标密文为 Base64_Decode(encryptedData)。
3. 对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。
4. 对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。

微信官方提供了多种编程语言的示例代码（[点击下载](https://res.wx.qq.com/wxdoc/dist/assets/media/aes-sample.eae1f364.zip)）。每种语言类型的接口名字均一致。调用方式可以参照示例。

另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印( watermark )

**watermark参数说明**：

参数 | 类型 | 说明
-----|-----|-----
appid | String | 敏感数据归属 appId，开发者可校验此参数与自身 appId 是否一致
timestamp | Int | 敏感数据获取的时间戳, 开发者可以用于数据时效性校验

> 注意：解密后得到的json数据根据需求可能会增加新的字段，旧字段不会改变和删减，需要预留足够的空间

**session_key的注意事项**:

1. [wx.login][wx.login] 调用时，用户的 session_key 可能会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 wx.login，并非每次调用都导致 session_key 刷新）。应该在明确需要重新登录时才调用 wx.login，及时通过 [auth.code2Session][auth.code2Session] 接口更新服务器存储的 session_key。
2. 微信不会把 session_key 的有效期告知开发者。微信会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。
3. 开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 [wx.checkSession][wx.checkSession] 可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。
4. 当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。

##### 7.1.4.2 云调用直接获取开放数据

接口如果涉及敏感数据（如[wx.getWeRunData][wx.getWeRunData]），接口的明文内容将不包含这些敏感数据，而是在返回的接口中包含对应敏感数据的 cloudID 字段，数据可以通过云函数获取。完整流程如下：

1. 获取 cloudID
  使用 2.7.0 或以上版本的基础库，如果小程序已开通云开发，在开放数据接口的返回值中可以通过 cloudID 字段获取（与 encryptedData 同级），cloudID 有效期五分钟。

2. 调用云函数
  调用云函数时，对传入的 data 参数，如果有顶层字段的值为通过 `wx.cloud.CloudID` 构造的 CloudID，则调用云函数时，这些字段的值会被替换为 cloudID 对应的开放数据，一次调用最多可替换 5 个 CloudID。
  示例：在小程序获取到 cloudID 之后发起调用

    ```js
    wx.cloud.CloudID({
      name: 'myFunction',
      data: {
        weRunData: wx.cloud.CloudID('xxx'), // 这个 CloudID 值到云函数端会被替换
        obj: {
          shareInfo:  wx.cloud.CloudID('yyy'), // 非顶层字段的 CloudID 不会被替换，会原样字符串展示
        }
      }
    })
    ```

    在云函数收到的 event 示例：

    ```json
    // event
    {
      // weRunData 的值已被替换为开放数据
      "weRunData": {
        "cloudID": "xxx",
        "data": {
          "stepInfoList": [
            {
              "step": 5000,
              "timestamp": 1554814312,
            }
          ],
          "watermark": {
            "appid": "wx1111111111",
            "timestamp": 1554815786
          }
        }
      },
      "obj": {
        // 非顶层字段维持原样
        "shareInfo": "yyy",
      }
    }
    ```

    如果 `cloudID` 非法或过期，则在 `event` 中获取得到的将是一个有包含错误码、错误信息和原始 `cloudID` 的对象。过期 `cloudID` 换取结果示例：

    ```json
    // event
    {
      "weRunData": {
        "cloudID": "xxx",
        "errCode": -601006,
        "errMsg": "cloudID expired."
      },
      // ...
    }
    ```

#### 7.1.5 获取手机号

获取微信用户绑定的手机号，需先调用 [wx.login][wx.login] 接口。

因为需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 button 组件的点击来触发。

> **注意：目前该接口针对非个人开发者，且完成了认证的小程序开放（不包含海外主体）。需谨慎使用，若用户举报较多或被发现在不必要场景下使用，微信有权永久回收该小程序的该接口权限。**

**使用方法**
需要将 button 组件 `open-type` 的值设置为 `getPhoneNumber`，当用户点击并同意之后，可以通过 `bindgetphonenumber` 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。

> 注意
> 在回调中调用 [wx.login][wx.login] 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议提前进行 `login`；或者在回调中先使用 `checkSession` 进行登录态检查，避免 `login` 刷新登录态。

**代码示例**:

```wxml
<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"></button>
```

```js
Page({
  getPhoneNumber (e) {
    console.log(e.detail.errMsg)
    console.log(e.detail.iv)
    console.log(e.detail.encryptedData)
  }
})
```

**返回参数说明**:

参数 | 类型 | 说明
-----|-----|------
encryptedData | String | 包括敏感数据在内的完整用户信息的加密数据，详细见[加密数据解密算法](#714-开放数据校验与解密)
iv | String | 加密算法的初始向量，详细见加密数据解密算法
cloudID | string | 敏感数据对应的云 ID，开通云开发的小程序才会返回，可通过云调用直接获取开放数据，详细见[云调用直接获取开放数据](#7142-云调用直接获取开放数据)

获取得到的开放数据为以下 json 结构：

```json
{
  "phoneNumber": "13580006666",
  "purePhoneNumber": "13580006666",
  "countryCode": "86",
  "watermark":
  {
      "appid":"APPID",
      "timestamp": TIMESTAMP
  }
}
```

参数 | 类型 | 说明
-----|------|-----
phoneNumber | String | 用户绑定的手机号（国外手机号会有区号）
purePhoneNumber | String | 没有区号的手机号
countryCode | String | 区号

#### 7.1.7 生物认证

小程序通过 SOTER 提供以下生物认证方式。

目前暂时只支持指纹识别认证。设备支持的生物认证方式可使用 [wx.checkIsSupportSoterAuthentication][wx.checkIsSupportSoterAuthentication] 查询

调用流程

![生物认证调用流程](./image/生物认证调用流程.png)

**流程步骤说明**:

1. 调用 [wx.startSoterAuthentication][wx.startSoterAuthentication]，获取 `resultJSON` 和 `resultJSONSignature`

2. （可选）签名校验。此处 `resultJSONSignature` 使用 SHA256withRSA/PSS 作为签名算法进行验签。此公式数学定义如下: `bool` 验签结果=verify(用于签名的原串，签名串，验证签名的公钥)

3. 微信提供后台接口用于可信的密钥验签服务，微信将保证该接口返回的验签结果的正确性与可靠性，并且对于 Android root 情况下该接口具有上述特征（将返回是否保证root情况安全性）。

接口地址：

```txt
POST http://api.weixin.qq.com/cgi-bin/soter/verify_signature?access_token=%access_token
```

post 数据内容（JSON 编码）:

```json
{"openid":"$openid", "json_string" : "$resultJSON", "json_signature" : "$resultJSONSignature" }
```

请求返回数据内容（JSON 编码）:

```txt
// 验证成功返回
{"is_ok":true}
// 验证失败返回
{"is_ok":false}
// 接口调用失败
{"errcode":"xxx,"errmsg":"xxxxx"}
```

#### 7.1.8 转发

##### 7.1.8.1 转发

**获取更多转发信息**
通常希望转发出去的小程序被二次打开的时候能够获取到一些信息，例如群的标识。现在通过调用 [wx.showShareMenu][wx.showShareMenu] 并且设置 `withShareTicket` 为 `true` ，当用户将小程序转发到任一群聊之后，此转发卡片在群聊中被其他用户打开时，可以在 App.onLaunch 或 App.onShow 获取到一个 `shareTicket`。通过调用 [wx.getShareInfo][wx.getShareInfo] 接口传入此 `shareTicket` 可以获取到转发信息。

**页面内发起转发**
通过给 button 组件设置属性 `open-type="share"`，可以在用户点击按钮后触发 Page.onShareAppMessage 事件。

**使用指引**
转发按钮，旨在帮助用户更流畅地与好友分享内容和服务。转发，应是用户自发的行为，且在需要时触手可及。在使用时若遵从以下指引，会得到更佳的用户体验。

1. **含义清晰** : 明确、一目了然的图形按钮，将为用户减少理解的时间。在资源下载中心，可以找到这样的按钮素材并直接使用。或者可以根据业务的设计风格，灵活设计含义清晰的按钮的样式。当然，也可以直接使用带文案的按钮，“转发给好友”。
2. **方便点击** : 按钮点击热区不宜过小，亦不宜过大。同时，转发按钮与其他按钮一样，热区也不宜过密，以免用户误操作。
3. **按需出现** : 并非所有页面都适合放置转发按钮，涉及用户隐私的非公开内容，或可能打断用户完成当前操作体验的场景，该功能并不推荐使用。同时，由于转发过程中，将截取用户屏幕图像作为配图，因此，需要注意帮助用户屏蔽个人信息。
4. **尊重意愿** : 它不应该成为一个诱导或强制行为，如转发后才能解锁某项功能等。注意，这类做法不仅不被推荐，还可能违反《运营规范》。

> 提示：
>
> 1. 不自定义转发图片的情况下，默认会取当前页面，从顶部开始，高度为 80% 屏幕宽度的图像作为转发图片。
> 2. 转发的调试支持请查看 [普通转发的调试支持](https://developers.weixin.qq.com/miniprogram/dev/devtools/different.html#%E6%99%AE%E9%80%9A%E7%9A%84%E8%BD%AC%E5%8F%91) 和 [带 shareTicket 的转发](https://developers.weixin.qq.com/miniprogram/dev/devtools/different.html#%E5%B8%A6-shareticket-%E7%9A%84%E8%BD%AC%E5%8F%91)
> 3. 只有转发到群聊中打开才可以获取到 `shareTickets` 返回值，单聊没有 `shareTickets`
> 4. `shareTicket` 仅在当前小程序生命周期内有效
> 5. 由于策略变动，小程序群相关能力进行调整，可先使用 [wx.getShareInfo][wx.getShareInfo] 接口中的群 ID 进行功能开发。
> 6. 微信7.0.12开始，支持群主转发小程序时同时把消息设为该群的群待办消息，群待办消息会以气泡形式出现在聊天窗口底部。默认每次转发一个群待办消息，都会生成一个待办消息气泡。通过 [wx.updateShareMenu][wx.updateShareMenu] 接口修改 `toDoActivityId` 属性可以把多个待办消息聚合为同一个，即转发相同 `toDoActivityId` 的群待办消息，只会出现一个待办消息气泡。`toDoActivityId` 需要在转发前通过 [updatableMessage.createActivityId][updatableMessage.createActivityId] 接口创建。

##### 7.1.8.2 动态消息

从基础库 2.4.0 开始，支持转发动态消息。动态消息对比普通消息，有以下特点：

1. 消息发出去之后，可以通过后台接口修改部分消息内容。
2. 消息有对应的提醒按钮，用户点击提醒按钮可以订阅提醒，开发者可以通过后台修改消息状态并推送一次提醒消息给订阅了提醒的用户

**消息状态**
消息有两个状态，分别有其对应的文字内容和颜色。其中状态 0 可以转移到状态 0 和 1，状态 1 无法再转移。

状态 | 文字内容 | 颜色 | 允许转移的状态
-----|---------|------|--------------
0 | "成员正在加入，当前 {member_count}/{room_limit} 人" | #FA9D39 | 0, 1
1 | "已开始" | #CCCCCC | 无

**状态参数**
每个状态转移的时候可以携带参数，具体参数说明如下。

参数 | 类型 | 说明
-----|-----|------
member_count | string | 状态 0 时有效，文字内容模板中 member_count 的值
room_limit | string | 状态 0 时有效，文字内容模板中 room_limit 的值
path | string | 状态 1 时有效，点击「进入」启动小程序时使用的路径。对于小游戏，没有页面的概念，可以用于传递查询字符串（query），如 "?foo=bar"
version_type | string | 状态 1 时有效，点击「进入」启动小程序时使用的版本。有效参数值为：develop（开发版），trial（体验版），release（正式版）

**使用方法**
