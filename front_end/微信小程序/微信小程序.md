---
title : 微信小程序
author: dsy
keyword: "wxml wxss wxs 小程序框架"
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [微信小程序](#微信小程序)
  - [一. 基础](#一-基础)
    - [1.1 申请账号并预览小程序](#11-申请账号并预览小程序)
    - [1.2 小程序代码构成](#12-小程序代码构成)
      - [1.2.1 JSON 配置](#121-json-配置)
        - [1.2.1.1 全局配置 app.js](#1211-全局配置-appjs)
        - [1.2.1.2 工具配置 project.config.json](#1212-工具配置-projectconfigjson)
        - [1.2.1.3 页面配置 page.json](#1213-页面配置-pagejson)
        - [1.2.1.4 网站地图配置 sitemap.json](#1214-网站地图配置-sitemapjson)
        - [1.2.1.5 JSON 语法注意事项](#1215-json-语法注意事项)
      - [1.2.2 WXML 模板](#122-wxml-模板)
      - [1.2.3 WXSS 样式](#123-wxss-样式)
      - [1.2.4 JS 逻辑交互](#124-js-逻辑交互)
    - [1.3 小程序宿主环境](#13-小程序宿主环境)
      - [1.3.1 渲染层和逻辑层](#131-渲染层和逻辑层)
      - [1.3.2 程序与页面](#132-程序与页面)
      - [1.3.3 组件](#133-组件)
      - [1.3.4 API](#134-api)
    - [1.4 小程序协同工作与发布](#14-小程序协同工作与发布)
      - [1.4.1 小程序的版本](#141-小程序的版本)
      - [1.4.2 发布上线](#142-发布上线)
      - [1.4.3 运营数据](#143-运营数据)
    - [1.5 目录结构](#15-目录结构)
  - [二. 小程序框架](#二-小程序框架)
    - [2.1 场景值](#21-场景值)
    - [2.2 逻辑层](#22-逻辑层)
      - [2.2.1 注册小程序实例](#221-注册小程序实例)
      - [2.2.2 注册页面](#222-注册页面)
        - [2.2.2.1 使用 Page 构造器注册页面](#2221-使用-page-构造器注册页面)
        - [2.2.2.2 在页面中使用 behaviors](#2222-在页面中使用-behaviors)
        - [2.2.2.3 使用 Component 构造器构造页面](#2223-使用-component-构造器构造页面)
      - [2.2.3 页面生命周期](#223-页面生命周期)
      - [2.2.4 页面路由](#224-页面路由)
      - [2.2.5 模块化](#225-模块化)
      - [2.2.6 API](#226-api)
    - [2.3 视图层](#23-视图层)
      - [2.3.1 WXML](#231-wxml)
        - [2.3.1.1 数据绑定](#2311-数据绑定)
        - [2.3.1.2 列表渲染](#2312-列表渲染)
        - [2.3.1.3 条件渲染](#2313-条件渲染)
        - [2.3.1.4 模板](#2314-模板)
        - [2.3.1.5 引用](#2315-引用)
      - [2.3.2 WXSS](#232-wxss)
      - [2.3.3 WXS 语法参考](#233-wxs-语法参考)
        - [2.3.3.1 模块](#2331-模块)
        - [2.3.3.2 变量](#2332-变量)
        - [2.3.3.3 注释](#2333-注释)
        - [2.3.3.4 运算符](#2334-运算符)
        - [2.3.3.5 数据类型](#2335-数据类型)
        - [2.3.3.6 基础类库](#2336-基础类库)
      - [2.3.4 事件系统](#234-事件系统)
        - [2.3.4.1 事件的使用方式](#2341-事件的使用方式)
        - [2.3.4.2 事件详解](#2342-事件详解)
        - [2.3.4.3 事件对象](#2343-事件对象)
        - [2.3.4.4 使用WXS函数响应事件](#2344-使用wxs函数响应事件)
      - [2.3.5 简易双向绑定](#235-简易双向绑定)
      - [2.3.6 基础组件](#236-基础组件)
      - [2.3.7 获取界面上的信息节点](#237-获取界面上的信息节点)
      - [2.3.8 响应显示区域的变化](#238-响应显示区域的变化)
      - [2.3.9 动画](#239-动画)
      - [2.3.10 初始渲染缓存](#2310-初始渲染缓存)
  - [三. 小程序运行时](#三-小程序运行时)
    - [3.1 运行环境](#31-运行环境)
    - [3.2 JavaScript 支持情况](#32-javascript-支持情况)
    - [3.3 运行机制](#33-运行机制)
    - [3.4 更新机制](#34-更新机制)
  - [四. 自定义组件](#四-自定义组件)
    - [4.1 组件模板与样式](#41-组件模板与样式)
    - [4.2 Component 构造器](#42-component-构造器)
    - [4.3 组件间通信与事件](#43-组件间通信与事件)
    - [4.4 组件生命周期](#44-组件生命周期)
    - [4.5 behaviors](#45-behaviors)
      - [4.5.1 参数与含义](#451-参数与含义)
      - [4.5.2 内置 behaviors](#452-内置-behaviors)
    - [4.6 组件间关系](#46-组件间关系)
      - [4.6.1 定义和使用组件间关系](#461-定义和使用组件间关系)
      - [4.6.2 关联一类组件](#462-关联一类组件)
      - [4.6.3 relations 定义段](#463-relations-定义段)

<!-- \code_chunk_output -->

[compatibility]: https:\\developers.weixin.qq.com\miniprogram\dev\framework\compatibility.html
[api]: https:\\developers.weixin.qq.com\miniprogram\dev\api\
[组件]: https:\\developers.weixin.qq.com\miniprogram\dev\component\

# 微信小程序

## 一. 基础

**小程序与普通网页开发的区别**:

1. ​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。
2. 网页开发可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。
3. JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。
4. 小程序开发过程中需要面对的是两大操作系统 **iOS** 和 **Android** 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的

运行环境 | 逻辑层 | 渲染层
--------|-------|-------
iOS  | JavaScriptCore | WKWebView
安卓 | V8 | 定制内核
小程序开发工具 | NWJS | Chrome WebView

### 1.1 申请账号并预览小程序

进入 [小程序注册页](https:\\mp.weixin.qq.com\wxopen\waregister?action=step1) 根据指引填写信息和提交相应的资料，申请账号

在小程序管理平台，可以管理小程序的权限，查看数据报表，发布小程序等操作。

登录 [微信公众平台](https:\\mp.weixin.qq.com\) ，可以在菜单 "开发"-"开发设置"-"开发设置" 中看到小程序的 **AppID** 。

小程序的 AppID 相当于小程序平台的一个身份证，后续会在很多地方要用到 AppID （注意这里要区别于服务号或订阅号的 AppID）。

新建项目选择小程序项目，选择代码存放的硬盘路径，填入小程序的 AppID，给项目起名字，勾选 "不使用云服务"，点击新建，点击顶部菜单编译就可以在微信开发者工具中预览小程序。

### 1.2 小程序代码构成

#### 1.2.1 JSON 配置

JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的是静态配置的角色。
在项目的根目录有一个 *app.json*、*sitemap.json* 和 *project.config.json*，此外在 *pages\logs* 目录下还有一个 *logs.json*

##### 1.2.1.1 全局配置 app.js

app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。完整配置项说明参考 [小程序全局配置](https:\\developers.weixin.qq.com\miniprogram\dev\reference\configuration\app.html)

以下是一个包含了部分常用配置选项的 app.json ：

```json
{
  "pages": [
    "pages\index\index",
    "pages\logs\index"
  ],
  "window": {
    "navigationBarTitleText": "Demo"
  },
  "tabBar": {
    "list": [{
      "pagePath": "pages\index\index",
      "text": "首页"
    }, {
      "pagePath": "pages\logs\index",
      "text": "日志"
    }]
  },
  "networkTimeout": {
    "request": 10000,
    "downloadFile": 10000
  },
  "debug": true
}
```

##### 1.2.1.2 工具配置 project.config.json

在工具上做的任何配置都会写入到 project.config.json，当重新安装工具或者换电脑工作时，只要载入同一个项目的代码包，开发者工具就自动会恢复到开发项目时的个性化配置。其他配置项细节可以参考文档 [开发者工具配置](https:\\developers.weixin.qq.com\miniprogram\dev\devtools\projectconfig.html)

##### 1.2.1.3 页面配置 page.json

这里的 page.json 是用来表示 pages\logs 目录下的 logs.json 这类和小程序页面相关的配置。每一个小程序页面也可以使用同名 .json 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。例如: 顶部颜色、是否允许下拉刷新等等。完整配置项说明可以参考文档 [小程序页面配置](https:\\developers.weixin.qq.com\miniprogram\dev\reference\configuration\page.html)

```json
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

##### 1.2.1.4 网站地图配置 sitemap.json

微信现已开放小程序内搜索，可以通过 **sitemap.json** 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的**搜索词条触发**该索引时，小程序的页面将可能展示在搜索结果中。
爬虫访问小程序内页面时，会携带特定的 user-agent：mpcrawler 及 [场景值](#21-场景值)：1129。

当在小程序项目中设置了 sitemap 的配置文件（默认为 sitemap.json）时，便可在开发者工具控制台上显示当前页面是否被索引的调试信息
完整配置项说明参考 [小程序 sitemap 配置](https:\\developers.weixin.qq.com\miniprogram\dev\reference\configuration\sitemap.html)

所有页面都会被微信索引（默认情况）

```json
{
  "rules" : {
    "action" : "allow",
    "page" : "*"
  }
}
```

> 注意:
>
> 1. 若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。
> 2. 没有 sitemap.json 则默认所有页面都能被索引
> 3. {"action": "allow", "page": "*"} 是优先级最低的默认规则，未显式指明 "disallow" 的都默认被索引
> 4. sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false
> 5. sitemap 文件内容最大为 5120 个 UTF8 字符

##### 1.2.1.5 JSON 语法注意事项

1. JSON文件都是被包裹在一个大括号中 {}，通过key-value的方式来表达数据。
2. JSON的Key必须包裹在一个双引号中
3. JSON的值只能是以下几种数据格式，其他任何格式都会触发报错
    - 数字，包含浮点数和整数
    - 字符串，需要包裹在双引号中
    - boolean值，true 或者 false
    - 数组，需要包裹在方括号中 []
    - 对象，需要包裹在大括号中 {}
    - Null
4. JSON 文件中无法使用注释，试图添加注释将会引发报错。

#### 1.2.2 WXML 模板

在小程序中 WXML 充当的是类似 HTML 的角色。和 HTML 非常相似，WXML 由标签、属性等等构成。但是也有很多不一样的地方:

1. 小程序的 WXML 用的标签是 view, button, text 等等，这些标签是小程序包装好的基本能力，还提供了地图、视频、音频等等组件能力。
2. 多了一些 **wx:if** 这样的属性以及 **{{ }}** 这样的表达式
  现在提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理**状态**，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路。

WXML这样写

```wxml
<text>{{msg}}<\text>
```

JS只需要管理状态即可

```js
this.setData({
  msg : "This is a cat"
})
```

通过 {{ }} 的语法把一个变量绑定到界面上，称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if\else, for 等控制能力，在小程序里边，这些控制能力都用 `wx:` 开头的属性来表达。详细的文档可以参考 [WXML](#231-wxml)

#### 1.2.3 WXSS 样式

WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。更详细的文档可以参考 [WXSS](#232-wxss)

1. WXSS 在底层支持新的尺寸单位 `rpx` ，可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。
2. 提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，可以写一个 **app.wxss** 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 **page.wxss** 仅对当前页面生效。
3. WXSS 仅支持部分 CSS 选择器

#### 1.2.4 JS 逻辑交互

一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，可以通过编写 **JS** 脚本文件来处理用户的操作。更详细的事件可以参考文档 [WXML事件](#234-事件系统)

```wxml
<view>{{msg}}<\view>
<button bindtap="clickMe">点击<\button>
```

点击 button 按钮的时候，希望把界面上 msg 显示成 "this is a cat"，于是在 button 上声明一个属性: **bindtap** ，在 JS 文件里边声明了 **clickMe** 方法来响应这次点击操作

```js
page({
  clickMe : function () {
    this.setData({msg: "this is a cat"});
  }
})
```

此外还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。更多 API 可以参考文档 [小程序的API][api] 。

### 1.3 小程序宿主环境

微信客户端给小程序所提供的环境叫宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。

#### 1.3.1 渲染层和逻辑层

小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了 **WebView** 进行渲染；逻辑层采用 **JsCore** 线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由微信客户端转发，小程序的通信模型如下图所示。

![微信小程序通信模型](.\image\微信小程序通信模型.png)

有关渲染层和逻辑层的详细文档参考 [小程序框架](#二-小程序框架)

#### 1.3.2 程序与页面

微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。紧接着通过 app.json 的 **pages** 字段知道当前小程序的所有页面路径。

如果没有定义 `entryPagePath` 属性，默认 pages 列表的第一项为小程序的默认启动路径（首页）。不支持带页面路径参数。

然后，微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，渲染出首页。

小程序启动之后，在 app.js 定义的 App 实例的 `onLaunch` 回调会被执行。整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 [注册程序 App](https:\\developers.weixin.qq.com\miniprogram\dev\reference\api\App.html) 。

**pages\logs\logs** 下包括了4种文件，微信客户端会先根据 logs.json 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 WXML 结构和 WXSS 样式。最后客户端会装载 logs.js，logs.js 的大体内容就是:

```js
\\ 代码示例
Page({
  data: { \\ 参与页面渲染的数据
    logs: []
  },
  onLoad: function () {
    \\ 页面渲染后 执行
  }
})
```

`Page` 是一个页面构造器，这个构造器生成了一个页面。在生成页面的时候，小程序框架会把 data 数据和 logs.wxml 一起渲染出最终的结构。在渲染完界面之后，页面实例就会收到一个 `onLoad` 的回调，可以在这个回调处理需要的逻辑。Page 构造器详细文档参考 [注册页面 Page](#222-注册页面)

#### 1.3.3 组件

小程序提供了丰富的基础组件，可以像搭积木一样，组合各种组件拼合成小程序。

在小程序里边，只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，在界面显示地图：

```wxml
<map><\map>
```

使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，希望地图一开始的中心的经纬度是北京，那么需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:

```wxml
<map longitude="116.397128" latitude="39.916527" ><\map>
```

组件的内部行为也会通过事件的形式感知，例如用户点击了地图上的某个标记，可以在 js 编写 markertap 函数来处理：

```wxml
<map bind:markertap="markertap" longitude="116.397128" latitude="39.916527"><\map>
```

也可以通过 style 或者 class 来控制组件的外层样式，以便适应界面宽度高度等等。更多的组件可以参考 [小程序组件][组件] 。

#### 1.3.4 API

为了很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 。更多的 API 可以参考文档 [小程序的API][api]。

要获取用户的地理位置时，只需要：

```js
wx.getLocation({
  type: 'wgs84',
  success: (res) => {
    var latitude = res.latitude \\ 纬度
    var longitude = res.longitude \\ 经度
  }
})
```

> 注意：多数 API 的回调都是 **异步**，需要处理好代码逻辑的异步问题。

### 1.4 小程序协同工作与发布

#### 1.4.1 小程序的版本

一般的软件开发流程，编写代码自测开发版程序，直到程序达到一个稳定可体验的状态时，然后把这个体验版本给到产品经理和测试人员进行体验测试，最后修复完程序的Bug后发布供外部用户正式使用。小程序的版本根据这个流程设计了小程序版本的概念。

版本 | 说明
----|------
开发版本 | 使用开发者工具，可将代码上传到开发版本中。开发版本只保留每人最新的一份上传的代码。点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码
体验版本 | 可以选择某个开发版本作为体验版，并且选取一份体验版。
审核中版本 | 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。
线上版本 | 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。

考虑到项目是协同开发的模式，一个小程序可能同时由多个开发者进行开发，往往开发者在小程序开发者工具上编写完代码后需要到手机进行真机体验，所以每个开发者拥有自己对应的一个开发版本。因为处于开发中的版本是不稳定的，开发者随时会修改代码覆盖开发版，为了让测试和产品经理有一个完整稳定的版本可以体验测试，小程序平台允许把其中一个开发版本设置成体验版，因此建议在项目开发阶段特殊分配一个开发角色，用于上传稳定可供体验测试的代码，并把他上传的开发版本设置成体验版。

#### 1.4.2 发布上线

一个小程序从开发完到上线一般要经过 预览-> 上传代码 -> 提交审核 -> 发布等步骤。

**预览**
使用开发者工具可以预览小程序，帮助开发者检查小程序在移动客户端上的真实表现。

点击开发者工具顶部操作栏的预览按钮，开发者工具会自动打包当前项目，并上传小程序代码至微信的服务器，成功之后会在界面上显示一个二维码。使用当前小程序开发者的微信扫码即可看到小程序在手机客户端上的真实表现。

**上传代码**
同预览不同，上传代码是用于提交体验或者审核使用的。

点击开发者工具顶部操作栏的上传按钮，填写版本号以及项目备注，需要注意的是，这里版本号以及项目备注是为了方便管理员检查版本使用的，开发者可以根据自己的实际要求来填写这两个字段。

上传成功之后，登录小程序管理后台 - 开发管理 - 开发版本 就可以找到刚提交上传的版本了。

可以将这个版本设置 体验版 或者是 提交审核

**提交审核**
为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过审核的。

在开发者工具中上传了小程序代码之后，登录 小程序管理后台 - 开发管理 - 开发版本 找到提交上传的版本。

在开发版本的列表中，点击 提交审核 按照页面提示，填写相关的信息，即可以将小程序提交审核。

> 注意: 严格测试了版本之后，再提交审核，过多的审核不通过，可能会影响后续的时间。

**发布**
审核通过之后，管理员的微信中会收到小程序通过审核的通知，此时登录 小程序管理后台 - 开发管理 - 审核版本中可以看到通过审核的版本。

点击发布后，即可发布小程序。小程序提供了两种发布模式：**全量发布** 和 **分阶段发布**。全量发布是指当点击发布之后，所有用户访问小程序时都会使用当前最新的发布版本。分阶段发布是指分不同时间段来控制部分用户使用最新的发布版本，分阶段发布我们也称为灰度发布。一般来说，普通小程序发布时采用全量发布即可，当小程序承载的功能越来越多，使用的用户数越来越多时，采用分阶段发布是一个非常好的控制风险的办法。

#### 1.4.3 运营数据

有两种方式可以方便的看到小程序的 [运营数据](https:\\developers.weixin.qq.com\miniprogram\analysis\)

1. 登录 [小程序管理后台](https:\\mp.weixin.qq.com\) - 数据分析，点击相应的 tab 可以看到相关的数据。

2. 使用小程序数据助手，在微信中方便的查看运营数据

### 1.5 目录结构

小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。

一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

文件 | 必需 | 作用
-----|------|----
app.js | 是 | 小程序逻辑
app.json | 是 | 小程序公共配置
app.wxss | 否 | 小程序公共样式表

一个小程序页面由四个文件组成，分别是：

文件类型 | 必需 | 作用
--------|------|----
js | 是 | 页面逻辑
wxml | 是 | 页面结构
json | 否 | 页面配置
wxss | 否 | 页面样式表

> **注意**：为了减少配置项，描述页面的四个文件必须具有相同的路径与文件名。

**允许上传的文件**
在项目目录中，以下文件会经过编译，因此上传之后无法直接访问到：.js、app.json、.wxml、*.wxss（其中 wxml 和 wxss 文件仅针对在 app.json 中配置了的页面）。除此之外，只有后缀名在白名单内的文件可以被上传，不在白名单列表内文件在开发工具能被访问到，但无法被上传。具体白名单列表如下：

1. wxs
2. png
3. jpg
4. jpeg
5. gif
6. svg
7. json
8. cer
9. mp3
10. aac
11. m4a
12. mp4
13. wav
14. ogg
15. silk

## 二. 小程序框架

### 2.1 场景值

场景值用来描述用户进入小程序的路径。部分场景值下还可以获取来源应用、公众号或小程序的appId。完整场景值的含义可查看 [场景值列表](https:\\developers.weixin.qq.com\miniprogram\dev\reference\scene-list.html)。

**获取场景值** :

- 对于小程序，可以在 App 的 **onLaunch** 和 **onShow**，或 **wx.getLaunchOptionsSync** 中获取场景值。
- 对于小游戏，可以在 **wx.getLaunchOptionsSync** 和 **wx.onShow** 中获取场景值

> 注 : 由于Android系统限制，目前还无法获取到按 Home 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值。

### 2.2 逻辑层

小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供 JavaScript 代码的运行环境以及微信小程序的特有功能。

逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。

写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。

小程序在 JavaScript 的基础上，增加了一些其他功能:

- 增加 App 和 Page 方法，进行程序注册和页面注册。
- 增加 `getApp` 和 `getCurrentPages` 方法，分别用来获取 App 实例和当前页面栈。
- 提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。
- 提供模块化能力，每个页面有独立的作用域。

> 注 : 小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 浏览器 中一些能力都无法使用，如 window，document 等。

#### 2.2.1 注册小程序实例

每个小程序都需要在 **app.js** 中调用 **App** 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。
详细的参数含义和使用 [App 参考文档](https:\\developers.weixin.qq.com\miniprogram\dev\reference\api\App.html) 。

整个小程序只有一个 App 实例，是全部页面共享的。可以通过 `getApp` 方法获取到全局唯一的 App 实例，获取App上的数据或调用注册在 App 上的函数。
**例** : [app.js](.\test\app.js)

> 注 : 调用 **App** 方法注册小程序实例，必须调用且只能调用一次。不然会出现无法预期的后果。

#### 2.2.2 注册页面

对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。

##### 2.2.2.1 使用 Page 构造器注册页面

简单的页面可以使用 Page() 进行构造。详细的参数含义和使用参考 [Page 参考文档](https:\\developers.weixin.qq.com\miniprogram\dev\reference\api\Page.html) 。

**例** : [index.js](.\test\pages\index\index.js)

##### 2.2.2.2 在页面中使用 behaviors

> 基础库 2.9.2 开始支持，低版本需做 [兼容处理][compatibility]。

页面可以引用 `behaviors` 。 behaviors 可以用来让多个页面有相同的数据字段和方法。具体用法参见 [behaviors](#45-behaviors)

##### 2.2.2.3 使用 Component 构造器构造页面

> 基础库 1.6.3 开始支持，低版本需做 [兼容处理][compatibility]。

Page 构造器适用于简单的页面。但对于复杂的页面， Page 构造器可能并不好用。

此时，可以使用 `Component` 构造器来构造页面。 `Component` 构造器的主要区别是：方法需要放在 `methods: { }` 里面。
这种创建方式非常类似于 *自定义组件* ，可以像自定义组件一样使用 `behaviors` 等高级特性。具体细节阅读 [Component 构造器](#42-component-构造器) 。

#### 2.2.3 页面生命周期

![小程序页面Page实例的生命周期](.\image\小程序页面Page实例的生命周期.png)

#### 2.2.4 页面路由

在小程序中所有页面的路由全部由框架进行管理。

**页面栈**
框架以栈的形式维护了当前的所有页面。可以使用 `getCurrentPages()` 函数获取当前页面栈。当发生路由切换的时候，页面栈的表现如下：

路由方式 | 页面栈表现
--------|------------
初始化 | 新页面入栈
打开新页面 | 新页面入栈
页面重定向 | 当前页面出栈，新页面入栈
页面返回 | 页面不断出栈，直到目标返回页
Tab 切换 | 页面全部出栈，只留下新的 Tab 页面
重加载 | 页面全部出栈，只留下新的页面

**路由方式**
对于路由的触发方式以及页面生命周期函数如下：

路由方式 | 触发时机 | 路由前页面 | 路由后页面
--------|----------|-----------|----------
初始化 | 小程序打开的第一个页面 | - | onLoad, onShow
打开新页面 | 调用 API `wx.navigateTo`；使用组件 `<navigator open-type="navigateTo"\>` | onHide | onLoad, onShow
页面重定向 | 调用 API `wx.redirectTo`；使用组件 `<navigator open-type="redirectTo"\>` | onUnload | onLoad, onShow
页面返回 | 调用 API `wx.navigateBack`；使用组件`<navigator open-type="navigateBack">`；用户按左上角返回按钮 | onUnload | onShow
Tab 切换 | 调用 API `wx.switchTab`；使用组件 `<navigator open-type="switchTab"\>`；用户切换 Tab | - | 各种情况请参考下表
重启动 | 调用 API `wx.reLaunch`；使用组件 `<navigator open-type="reLaunch"\>` | onUnload | onLoad, onShow

Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：

当前页面 | 路由后页面 | 触发的生命周期（按顺序）
--------|------------|--------------------
A | A | Nothing happen
A | B | A.onHide(), B.onLoad(), B.onShow()
A | B（再次打开） | A.onHide(), B.onShow()
C | A | C.onUnload(), A.onShow()
C | B | C.onUnload(), B.onLoad(), B.onShow()
D | B | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()
D（从转发进入） | A | D.onUnload(), A.onLoad(), A.onShow()
D（从转发进入） | B | D.onUnload(), B.onLoad(), B.onShow()

**Tips**:

- `navigateTo`, `redirectTo` 只能打开非 tabBar 页面。
- `switchTab` 只能打开 tabBar 页面。
- `reLaunch` 可以打开任意页面。
- 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
- 调用页面路由带的参数可以在目标页面的 `onLoad` 中获取。

#### 2.2.5 模块化

可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 `module.exports` 才能暴露。
​在需要使用这些模块的文件中，使用 `require` 将公共代码引入

> **注意** : 小程序目前不支持直接引入 node_modules , 需要使用到 node_modules 时候需要拷贝出相关的代码到小程序的目录中，或者使用小程序支持的 npm 功能。

**文件作用域**
在 JS 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。

通过全局函数 `getApp` 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置。

#### 2.2.6 API

小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍参考 [API 文档][api]。

常用的小程序API有以下几种:

**事件监听API**
小程序约定，以 `on` 开头的 API 用来监听某个事件是否触发，如：`wx.onSocketOpen`，`wx.onCompassChange` 等

这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

```js
\\ 代码示例
wx.onCompassChange(function (res) {
  console.log(res.direction)
})
```

**同步API**
小程序约定，以 **Sync** 结尾的 API 都是同步 API， 如 `wx.setStorageSync`，`wx.getSystemInfoSync` 等。此外，也有一些其他的同步 API，如 `wx.createWorker`，`wx.getBackgroundAudioManager` 等

同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。

```js
\\ 代码示例
try {
  wx.getStorageSync('key', 'value')
} catch (e) {
  console.log(e)
}
```

**异步API**
大多数 API 都是异步 API，如 `wx.request`，`wx.login` 等。这类 API 接口通常都接受一个 `Object` 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：

Object 参数说明

参数名 | 类型 | 必填 | 说明
-------|-----|------|------
success | function | 否 | 接口调用成功的回调函数
fail | function | 否 | 接口调用失败的回调函数
complete | function | 否 | 接口调用结束的回调函数（调用成功、失败都会执行）
其他 | Any | - | 接口定义的其他参数

回调函数的参数

success，fail，complete 函数调用时会传入一个 Object 类型参数，包含以下字段:

属性 | 类型 | 说明
----|-------|-----
errMsg | string | 错误信息，如果调用成功返回 `${apiName}:ok`
errCode | number | 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 0。
其他 | Any | 接口返回的其他数据

异步 API 的执行结果需要通过 `Object` 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能，如 `wx.request`，`wx.connectSocket` 等。

```js
\\ 代码示例
wx.login({
  success(res) {
    if(res.code) {
      \\ 发起网络请求
      wx.request({
        url: 'https:\\test.com\onLogin',
        data: {
          code : res.code
        }
      })
    } else {
      console.log('登录失败' + res.message);
    }
  }
})
```

**异步 API 返回 Promise**
基础库 2.10.2 版本起，异步 API 支持 **callback & promise** 两种调用方式。当接口参数 Object 对象中不包含 success\fail\complete 时将默认返回 promise，否则仍按回调方式执行，无返回值。

> 注意:
>
> 1. 部分接口如 `downloadFile`, `request`, `uploadFile`, `connectSocket`, `createCamera`（小游戏）本身就有返回值， 它们的 promisify 需要自行封装。
> 2. 当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 Uncaught (in promise)，可通过 catch 来进行捕获。
> 3. `wx.onUnhandledRejection` 可以监听未处理的 Promise 拒绝事件。

```js
\\ 代码示例
\\ callback 形式调用
wx.chooseImage({
  count: 1,
  sizeType:['original', 'compressed'],
  success(res) {
    console.log('res:')
  }
})
```

**云开发API**
需要开通并使用 [小程序云开发](https:\\developers.weixin.qq.com\miniprogram\dev\wxcloud\basis\getting-started.html)，即可使用云开发API，在小程序端直接调用服务端的 [云函数](https:\\developers.weixin.qq.com\miniprogram\dev\wxcloud\guide\functions.html#%E4%BA%91%E5%87%BD%E6%95%B0)。

```js
\\ 代码示例
wx.cloud.callFunction({
  \\ 云函数名称
  name: 'cloudFunc',
  \\ 传给云函数的参数
  data: {
    a: 1,
    b: 2,
  },
  success: function(res) {
    console.log(res.result) \\ 示例
  },
  fail: console.error
})

\\ 此外，云函数同样支持promise形式调用
```

### 2.3 视图层

框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。

将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。

WXML(WeiXin Markup language) 用于描述页面的结构。

WXS(WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。

WXSS(WeiXin Style Sheet) 用于描述页面的样式。

组件(Component)是视图的基本组成单元。

#### 2.3.1 WXML

WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合 [基础组件][组件]、[事件系统][#234-事件系统]，可以构建出页面的结构。

##### 2.3.1.1 数据绑定

WXML 中的动态数据均来自对应 Page 的 data。

**简单绑定**
数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于:

- 内容

```wxml
<view>{{message}}<\view>
```

```js
Page({
  data: {
    message: 'This is a cat.'
  }
})
```

- 组件属性(需要在双引号以内)

```wxml
<view id="item-{{id}}"><\view>
```

```js
Page({
  data: {
    id: 0
  }
})
```

- 控制属性(需要在双引号以内)

```wxml
<view wx:if="{{condition}}"><\view>
```

```js
Page({
  data:{
    condition: true
  }
})
```

- 关键字(需要在双引号以内)

**true**
: boolean 类型的 true，代表真值。

**false**
: boolean 类型的 false，代表假值。

```wxml
<view checked="{{false}}"><\view>
```

> 特别注意：不要直接写 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值

**运算**
可以在 `{{}}` 内进行简单的运算，支持的有如下几种方式：

- 三元运算

```wxml
<view hidden="{{flag != 0 ? true : true}}">{{flag}}<\view>
```

- 算术运算

```wxml
<view>{{a + b}} + {{c}} + d<\view> \\ 3 + 3 + d
```

```js
Page({
  data: {
    a: 1,
    b: 2,
    c: 3
  }
})
```

- 逻辑判断

```wxml
<view wx:if="{{length > 5}}"> <\view>
```

- 字符串运算

```wxml
<view>{{"hello" + name}}<\view>
```

```js
Page({
  data: {
    name: 'Tom'
  }
})
```

- 数据路径运算

```wxml
<view>{{object.key}} {{array[0]}}<\view>
```

```js
Page({
  data: {
    object: {
      key: "hello"
    },
    array: ['Tom']
  }
})
```

**组合**
也可以在 Mustache 内直接进行组合，构成新的对象或者数组。

- 数组

```wxml
<view wx:for="{{[zero, 1, 2, 3, 4]}}">{{item}}<\view> \\ 最终组合成数组[0, 1, 2, 3, 4]
```

```js
Page({
  data: {
    zero: 0
  }
})
```

- 对象

```wxml
<template is="objectCombine" data="{{for: a, bar: b}}"><\template> \\ 最终组合成的对象是 {for: 1, bar: 2}
```

```js
Page({
  data: {
    a: 1,
    b: 2
  }
})
```

也可以用扩展运算符 `...` 来将一个对象展开

```wxml
<template is="objectCombine" data="{{...obj, ...obj2, e: 5}}"><\template> \\ 最终组合成的对象是 {a: 1, b: 2, c: 3, d: 4, e: 5}
```

```js
Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      c: 3,
      d: 4
    }
  }
})
```

如果对象的 key 和 value 相同，也可以间接地表达。

```wxml
<template is="objectCombine" data="{{foo, bar}}"><\template> \\ 最终组合成的对象是 {foo: 'my-foo', bar:'my-bar'}
```

```js
Page({
  data: {
    foo: 'my-foo',
    bar: 'my-bar'
  }
})
```

> **注意** : 上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如：

```wxml
<template is="objectCombine" data="{{...obj1, ...obj2, a, c: 6}}"><\template> \\ 最终组合成的对象是 {a: 5, b: 3, c: 6}
```

```js
Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      c: 1,
      d: 2
    }
  },
  a: 5
})
```

> **注意** : 花括号与引号之间如果有空格，将最终被解析成为字符串

```wxml
<view wx:for="{{[1, 2, 3]}} ">
  {{item}}
<\view>
```

等同于

```wxml
<view wx:for="{{[1, 2, 3] + ' '}}">
  {{item}}
<\view>
```

##### 2.3.1.2 列表渲染

**wx:for**
在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item` 。

```wxml
<view wx:for="{{array}}">
  {{index}} : {{item.message}}
<\view>
```

```js
Page({
  data: {
    array: [{
      message: 'foo'
    }, {
      message: 'bar'
    }]
  }
})
```

使用 `wx:for-item` 可以指定数组当前元素的变量名，使用 `wx:for-index` 可以指定数组当前下标的变量名：

```wxml
<view wx:for="{{array}}" wx:for-index="i" wx:for-item="li">
  {{i}} : {{li.message}}
<\view>
```

`wx:for` 也可以嵌套，下边是一个九九乘法表:

```wxml
<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
  <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    <view wx:if="{{i <= j}}">
      {{i}} * {{j}} = {{i * j}}
    <\view>
  <\view>
<\view>
```

**block wx:for**
类似 **block wx:if**，也可以将 `wx:for` 用在 `<block\>` 标签上，以渲染一个包含多节点的结构块。例如：

```wxml
<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: <\view>
  <view> {{item}} <\view>
<\block>
```

**wx:key**
如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

wx:key 的值以两种形式提供:

1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2. 保留关键字 `*this` 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。

当数据改变触发渲染层重新渲染的时候，会校正带有 `key` 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

> 如不提供 `wx:key`，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。

[示例代码](https:\\developers.weixin.qq.com\s\tpg5tKmv6kZt)

> 注意:
> 当 `wx:for` 的值为字符串时，会将字符串解析成字符串数组
> 花括号和引号之间如果有空格，将最终被解析成为字符串

##### 2.3.1.3 条件渲染

**wx:if**
在框架中，使用 `wx:if=""` 来判断是否需要渲染该代码块：

```wxml
<view wx:if="{{condition}}"> True <\view>
```

也可以用 `wx:elif` 和 `wx:else` 来添加一个 else 块：

```wxml
<view wx:if="{{length > 9}}">1<\view>
<view wx:elif="{{length > 6}}">2<\view>
<view wx:else>3<\view>
```

**block wx:if**
因为 `wx:if` 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 `<block\>` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```wxml
<block wx:if="{{condition}}">
  <view>1<\view>
  <view>2<\view>
<\block>
```

> 注意： `<block\>` 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。

**wx:if 与 hidden 的区别**
因为 `wx:if` 之中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。

同时 `wx:if` 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。

##### 2.3.1.4 模板

WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。

**定义模板**
使用 `name` 属性，作为模板的名字。然后在 `<template\>` 内定义代码片段，如：

```wxml
<!--
  index: int
  msg: string
  time: string
-->
<template name="msgItem">
  <view>
    <text>{{index}} : {{msg}}<\text>
    <text>{{time}}<\text>
  <\view>
<\template>
```

**使用模板**
使用 `is` 属性，声明需要的使用的模板，然后将模板所需要的 `data` 传入，如：

```wxml
<template is="msgItem" data="{{...item}}" \>
```

```js
Page({
  data: {
    item: {
      index: 0,
      msg: 'this is a template',
      time: '2020-12-24'
    }
  }
})
```

`is` 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板：

```js
<template name="odd">
  <view> odd <\view>
<\template>
<template name="even">
  <view> even <\view>
<\template>

<block wx:for="{{[1, 2, 3, 4]}}">
  <template is="{{item % 2 == 0 ? 'even' : 'odd'}}" \>
<\block>
```

**模板的作用域**
模板拥有自己的作用域，只能使用 `data` 传入的数据以及模板定义文件中定义的 `<wxs \>` 模块。

##### 2.3.1.5 引用

WXML 提供两种文件引用方式 `import` 和 `include`。

**import**
`import` 可以在该文件中使用目标文件定义的 `template` ，如：

在 item.wxml 中定义了一个叫 item 的 template：

```wxml
<!-- item.wxml -->
<template name="item">
  <text>{{text}}<\text>
<\template>
```

在 index.wxml 中引用了 item.wxml，就可以使用item模板：

```wxml
<import src="item.wxml">
<template is="item" data="{{text: 'footer'}}">
```

**import 的作用域**
import 有作用域的概念，即只会 `import` 目标文件中定义的 template，而不会 import 目标文件 import 的 template。

> 例 : C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。

**include**
include 可以将目标文件除了 `<template\>` `<wxs\>` 外的整个代码引入，相当于是拷贝到 `include` 位置，如：

```wxml
<!-- index.wxml -->
<include src="header.wxml"\>
<view> body <\view>
<include src="footer.wxml"\>
```

```wxml
<!-- header.wxml -->
<view> header <\view>
```

```wxml
<!-- footer.wxml -->
<view> footer <\view>
```

#### 2.3.2 WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。

WXSS 用来决定 WXML 的组件应该怎么显示。WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。

与 CSS 相比，WXSS 扩展的特性有：

- **尺寸单位**
  `rpx`（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。

  设备 | rpx换算px (屏幕宽度\750) | px换算rpx (750\屏幕宽度)
  -----|-------------------------|------------------------
  iPhone5 | 1rpx = 0.42px | 1px = 2.34rpx
  iPhone6 | 1rpx = 0.5px | 1px = 2rpx
  iPhone6 Plus | 1rpx = 0.552px | 1px = 1.81rpx

- **样式导入**
  使用 `@import` 语句可以导入外联样式表，`@import` 后跟需要导入的外联样式表的相对路径，用 **;** 表示语句结束。

**内联样式**
框架组件上支持使用 style、class 属性来控制组件的样式。

- **style** : 静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，尽量避免将静态的样式写进 style 中，以免影响渲染速度。

```wxss
<view style="color:{{color}}"><\view>
```

- **class** : 用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上 *.* ，样式类名之间用 空格 分隔。

```wxss
<view class="normal_view left_view"><\view>
```

**选择器**
目前支持的选择器有:

选择器 | 样例 | 样例描述
-------|-----|---------
.class | .intro | 选择所有拥有 class="intro" 的组件
**#id** | #first_name | 选择拥有 id="first_name" 的组件
element | view | 选择所有 view 组件
element, element | view, checkbox | 选择所有文档的 view 组件和所有的 checkbox 组件
::after | view::after | 在 view 组件后边插入内容
::before | view::before | 在 view 组件前边插入内容

**全局样式与局部样式**
定义在 **app.wxss** 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 **app.wxss** 中相同的选择器。

#### 2.3.3 WXS 语法参考

WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。WXS 与 JS 是不同的语言，有自己的语法，并不和 JS 一致。

> 注意:
>
> 1. WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
> 2. WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。
> 3. WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。
> 4. WXS 函数不能作为组件的事件回调。
> 5. 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。
> 6. const、let 不能使用，只能使用 var
> 7. WXS 里数据类型与基础类库中的属性 除 constructor 外的具体含义参考 ES5 标准。
> 8. WXS 里的方法具体使用参考 ES5 标准。

##### 2.3.3.1 模块

WXS 代码可以编写在 **wxml** 文件中的 `<wxs>` 标签内，或以 `.wxs` 为后缀名的文件内。

**模块**
: 每一个 **.wxs** 文件和 **<wxs>** 标签都是一个单独的模块。每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。一个模块要想对外暴露其内部的私有变量与函数，只能通过 **module.exports** 实现。

**.wxs 文件**
: 在微信开发者工具里面，右键可以直接创建 .wxs 文件，在其中直接编写 WXS 脚本。`.wxs` 文件可以被其他的 `.wxs` 文件 或 WXML 中的 `<wxs>` 标签引用。

**module 对象**
每个 **wxs** 模块均有一个内置的 **module** 对象。

**属性**:

- **exports** : 通过该属性，可以对外共享本模块的私有变量与函数。

> 例 : [test.wxs](.\test\pages\tests\test.wxs)

**require函数**
在 .wxs 模块中引用其他 wxs 文件模块，可以使用 `require` 函数。

引用的时候，要注意如下几点：

- 只能引用 .wxs 文件模块，且必须使用相对路径。
- wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
- 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

**<wxs> 标签**

属性名 | 类型 | 说明
-------|-----|-----
module | String | 当前 `<wxs>` 标签的模块名。必填字段。
src | String | 引用 .wxs 文件的相对路径。仅当本标签为单闭合标签或标签的内容为空时有效

- module属性
  module 属性是当前 `<wxs>` 标签的模块名。在单个 wxml 文件内，建议其值唯一。有重复模块名则按照先后顺序覆盖（后者覆盖前者）。不同文件之间的 wxs 模块名不会相互覆盖。
  module 属性值的命名必须符合下面两个规则：
  - 首字符必须是：字母（a-zA-Z），下划线（_）
  - 剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）

- src属性
  src 属性可以用来引用其他的 wxs 文件模块。
  引用的时候，要注意如下几点：
  - 只能引用 .wxs 文件模块，且必须使用相对路径。
  - wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
  - 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

> 注意:
> 1.`<wxs>` 模块只能在定义模块的 WXML 文件中被访问到。使用 `<include>` 或 `<import>` 时，`<wxs>` 模块不会被引入到对应的 WXML 文件中。
> 2.`<template>` 标签中，只能使用定义该 `<template>` 的 WXML 文件中定义的 `<wxs>` 模块。

##### 2.3.3.2 变量

**概念**:

- WXS 中的变量均为值的引用。
- 没有声明的变量直接赋值使用，会被定义为全局变量。
- 如果只声明变量而不赋值，则默认值为 undefined。
- var表现与javascript一致，会有变量提升。

**变量名**
变量命名必须符合下面两个规则：

- 首字符必须是：字母（a-zA-Z），下划线（_）
- 剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）

**保留标识符**
以下标识符不能作为变量名：

```js
delete void typeof

null undefined NaN Infinity var

if else

true false

require

this function arguments return

for while do break continue switch case default
```

##### 2.3.3.3 注释

WXS 主要有 3 种注释的方法。

```wxml
<!-- 示例代码 -->

\\ 方法一：单行注释

\**
* 方法二：多行注释
*\

\*
方法三：结尾注释。即从 \* 开始往后的所有 WXS 代码均被注释
```

##### 2.3.3.4 运算符

**一元运算符**:

```js
var a = 10, b = 20;

\\ 自增运算
console.log(10 === a++);
console.log(12 === ++a);
\\ 自减运算
console.log(12 === a--);
console.log(10 === --a);
\\ 正值运算
console.log(10 === +a);
\\ 负值运算
console.log(0-10 === -a);
\\ 否运算
console.log(-11 === ~a);
\\ 取反运算
console.log(false === !a);
\\ delete 运算
console.log(true === delete a.fake);
\\ void 运算
console.log(undefined === void a);
\\ typeof 运算
console.log("number" === typeof a);
```

**位运算符**:

```js
var a = 10, b = 20;

\\ 左移运算
console.log(80 === (a << 3));
\\ 无符号右移运算
console.log(2 === (a >> 2));
\\ 带符号右移运算
console.log(2 === (a >>> 2));
\\ 与运算
console.log(2 === (a & 3));
\\ 异或运算
console.log(9 === (a ^ 3));
\\ 或运算
console.log(11 === (a | 3));
```

**运算符优先级**:

优先级 | 运算符 | 说明 | 结合性
-------|-------|------|------
20 | ( ... ) | 括号 | n\a
19 | ... . ... | 成员访问 | 从左到右
-| ... [ ... ] | 成员访问 | 从左到右
-| ... ( ... ) | 函数调用 | 从左到右
17 | ... ++ | 后置递增 | n\a
-| ... -- | 后置递减 | n\a
16 | ! ... | 逻辑非 | 从右到左
-| ~ ... | 按位非 | 从右到左
-| **+ ...** | 一元加法 | 从右到左
-| **- ...** | 一元减法 | 从右到左
-| ++ ... | 前置递增 | 从右到左
-| -- ... | 前置递减 | 从右到左
-| typeof ... | typeof | 从右到左
-| void ... | void | 从右到左
-| delete ... | delete | 从右到左
14 | ... * ... | 乘法 | 从左到右
-| ... \ ... | 除法 | 从左到右
-| ... % ... | 取模 | 从左到右
13 | ... + ... | 加法 | 从左到右
-| ... - ... | 减法 | 从左到右
12 | ... << ... | 按位左移 | 从左到右
-| ... >> ... | 按位右移 | 从左到右
-| ... >>> ... | 无符号右移 | 从左到右
11 | ... < ... | 小于 | 从左到右
-| ... <= ... | 小于等于 | 从左到右
-| ... > ... | 大于 | 从左到右
-| ... >= ... | 大于等于 | 从左到右
10 | ... == ... | 等号 | 从左到右
-| ... != ... | 非等号 | 从左到右
-| ... === ... | 全等号 | 从左到右
-| ... !== ... | 非全等号 | 从左到右
9 | ... & ... | 按位与 | 从左到右
8 | ... ^ ... | 按位异或 | 从左到右
7 | ... ｜ ... | 按位或 | 从左到右
6 | ... && ... | 逻辑与 | 从左到右
5 | ... ｜｜ ... | 逻辑或 | 从左到右
4 | ... ? ... : ... | 条件运算符 | 从右到左
3 | ... = ... | 赋值 | 从右到左
-| ... += ... | 赋值 | 从右到左
-| ... -= ... | 赋值 | 从右到左
-| ... *= ... | 赋值 | 从右到左
-| ... \= ... | 赋值 | 从右到左
-| ... %= ... | 赋值 | 从右到左
-| ... <<= ... | 赋值 | 从右到左
-| ... >>= ... | 赋值 | 从右到左
-| ... >>>= ... | 赋值 | 从右到左
-| ... &= ... | 赋值 | 从右到左
-| ... ^= ... | 赋值 | 从右到左
-| ... ｜= ... | 赋值 | 从右到左
0 | ... , ... | 逗号 | 从左到右

##### 2.3.3.5 数据类型

WXS 语言目前共有以下几种数据类型：

1. number ： 数值
2. string ：字符串
3. boolean：布尔值
4. object：对象
5. function：函数
6. array : 数组
7. date：日期
8. regexp：正则

- **number**
  - 语法 : number 包括两种数值：整数，小数。
  - 属性
    - constructor: 返回字符串 "Number"
  - 方法
    - toString
    - toLocaleString
    - valueOf
    - toFixed
    - toExponential
    - toPrecision

- **string**
  - 语法 : 单引号 和 双引号 都可以
  - 属性
    - constructor : 返回字符串 "String"
    - length
  - 方法
    - toString
      valueOf
    - charAt
    - charCodeAt
    - concat
    - indexOf
    - lastIndexOf
    - localeCompare
    - match
    - replace
    - search
    - slice
    - split
    - substring
    - toLowerCase
    - toLocaleLowerCase
    - toUpperCase
    - toLocaleUpperCase
    - trim

- **boolean**
  - 语法 : 只有两个特定的值：true 和 false
  - 属性
    - constructor : 返回字符串 "Boolean"
  - 方法
    - toString
    - valueOf

- **object**
  - 语法 : object 是一种无序的键值对
  - 属性
    - constructor : 返回字符串"Object"
  - 方法
    - toString : 返回字符串 "[Object Object]"

- **function**
  - 语法 : 支持常用的两种定义，以及 匿名函数，闭包等
  - arguments : function 里面可以使用 arguments 关键词。该关键词目前只支持以下的属性
    - length : 传递给函数的参数个数。
    - [index]: 通过 *index* 下标可以遍历传递给函数的每个参数。
  - 属性
    - constructor : 返回字符串 "Function"
    - length : 返回函数的形参个数
  - 方法
    - toString : 返回字符串"[Function Function]"

- **Array**
  - 语法 : 支持 `var a = []` 和 `var b = [1,"2",{},function(){}]`
  - 属性
    - constructor : 返回字符串 "Array"
    - length
  - 方法
    - toString
    - concat
    - join
    - pop
    - push
    - reverse
    - shift
    - slice
    - sort
    - splice
    - unshift
    - indexOf
    - lastIndexOf
    - every
    - some
    - forEach
    - map
    - filter
    - reduce
    - reduceRight

- **date**
  - 语法 : 生成 date 对象需要使用 `getDate()` 函数, 返回一个当前时间的对象。

    ```wxs
    \\ 格式
    getDate()
    getDate(milliseconds)
    getDate(dateString)
    getDate(year, month[, date[, hours[, minutes[, seconds[, milliseconds]]]]])
    ```

  - 参数
    - milliseconds : 从1970年1月1日00:00:00 UTC开始计算的毫秒数
    - dateString : 日期字符串，其格式为："month day, year hours:minutes:seconds"

    ```wxs
    \\ 示例
    var date = getDate(); \\返回当前时间对象

    date = getDate(1500000000000);
    \\ Fri Jul 14 2017 10:40:00 GMT+0800 (中国标准时间)
    date = getDate('2017-7-14');
    \\ Fri Jul 14 2017 00:00:00 GMT+0800 (中国标准时间)
    date = getDate(2017, 6, 14, 10, 40, 0, 0);
    \\ Fri Jul 14 2017 10:40:00 GMT+0800 (中国标准时间)
    ```

  - 属性
    - constructor : 返回字符串 "Date"
  - 方法
    - toString
    - toDateString
    - toTimeString
    - toLocaleString
    - toLocaleDateString
    - toLocaleTimeString
    - valueOf
    - getTime
    - getFullYear
    - getUTCFullYear
    - getMonth
    - getUTCMonth
    - getDate
    - getUTCDate
    - getDay
    - getUTCDay
    - getHours
    - getUTCHours
    - getMinutes
    - getUTCMinutes
    - getSeconds
    - getUTCSeconds
    - getMilliseconds
    - getUTCMilliseconds
    - getTimezoneOffset
    - setTime
    - setMilliseconds
    - setUTCMilliseconds
    - setSeconds
    - setUTCSeconds
    - setMinutes
    - setUTCMinutes
    - setHours
    - setUTCHours
    - setDate
    - setUTCDate
    - setMonth
    - setUTCMonth
    - setFullYear
    - setUTCFullYear
    - toUTCString
    - toISOString
    - toJSON

- **regexp**
  - 语法 : 生成 regexp 对象需要使用 getRegExp() 函数。

    ```wxs
      getRegExp(pattern[, flags])
    ``

  - 参数
    - pattern : 正则表达式的内容
    - flags : 修饰符，该字段只能包含以下内容 `g`、`i`、`m`
  - 属性
    - constructor : 返回字符串 "RegExp"
    - source
    - global
    - ignoreCase
    - multiline
    - lastIndex
  - 方法
    - exec
    - test
    - toString

- **数据类型判断**
  - constructor : 数据类型的判断可以使用 constructor 属性。
  - typeof : 使用 typeof 也可以区分部分数据类型。

##### 2.3.3.6 基础类库

- **console**
  - console.log 方法用于在 console 窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。

- **Math**
  - 属性
    - E
    - LN10
    - LN2
    - LOG2E
    - LOG10E
    - PI
    - SQRT1_2
    - SQRT2
  - 方法
    - abs
    - acos
    - asin
    - atan
    - atan2
    - ceil
    - cos
    - exp
    - floor
    - log
    - max
    - min
    - pow
    - random
    - round
    - sin
    - sqrt
    - tan

- **JSON**
  - 方法
    - stringify(object) : 将 object 对象转换为 JSON 字符串，并返回该字符串。
    - parse(string) : 将 JSON 字符串转化成对象，并返回该对象。

- **Number**
  - 属性
    - MAX_VALUE
    - MIN_VALUE
    - NEGATIVE_INFINITY
    - POSITIVE_INFINITY

- **Date**
  - 属性
    - parse
    - UTC
    - now

- **Global**
  - 属性
    - NaN
    - Infinity
    - undefined
  - 方法
    - parseInt
    - parseFloat
    - isNaN
    - isFinite
    - decodeURI
    - decodeURIComponent
    - encodeURI
    - encodeURIComponent

#### 2.3.4 事件系统

**什么是事件**:

- 事件是视图层到逻辑层的通讯方式
- 事件可以将用户的行为反馈到逻辑层进行处理
- 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数
- 事件对象可以携带额外信息，如 id，dataset，touches

##### 2.3.4.1 事件的使用方式

- **在组件中绑定一个事件处理函数**
  - 如 `bindtap`，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。

  ```wxml
  <view id="tapTest" data-hi="WeiXin" bindtap="topName"> Click Me! <\view>
  ```

  - 在相应的Page定义中写上相应的事件处理函数，参数是event。

  ```js
  Page({
    tapName: function(event) {
      console.log(event);
    }
  })
  ```

##### 2.3.4.2 事件详解

- **事件分类**
  事件分为 冒泡事件 和 非冒泡事件：

  WXML的冒泡事件列表:

  类型 | 触发条件
  -----|--------
  touchstart | 手指触摸动作开始
  touchmove | 手指触摸后移动
  touchcancel | 手指触摸动作被打断，如来电提醒，弹窗
  touchend | 手指触摸动作结束
  tap | 手指触摸后马上离开
  longpress | 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发，最低版本 1.5.0
  longtap | 手指触摸后，超过350ms再离开（推荐使用longpress事件代替）
  transitionend | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发
  animationstart | 会在一个 WXSS animation 动画开始时触发
  animationiteration | 会在一个 WXSS animation 一次迭代结束时触发
  animationend | 会在一个 WXSS animation 动画完成时触发
  touchforcechange | 在支持 3D Touch 的 iPhone 设备，重按时会触发，最低版本 1.9.9

  > 注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的submit事件，input 的input事件，scroll-view 的scroll事件，(详见各个 [组件][组件] )

- **普通事件绑定**
  事件绑定的写法类似于组件的属性，如：

  ```wxml
  <view bindtap="handleTap"> Click Me! <\view>
  ```

  如果用户点击这个 view ，则页面的 handleTap 会被调用。
  事件绑定函数可以是一个数据绑定，如：

  ```wxml
  <view bindtap="{{handleName}}"> Click Me! <\view>
  ```

  此时，页面的 `this.data.handlerName` 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。
  > 自基础库版本 1.5.0 起，在大多数组件和自定义组件中， bind 后可以紧跟一个冒号，其含义不变，如 `bind:tap` 。基础库版本 2.8.1 起，在所有组件中开始提供这个支持。

- **绑定并阻止事件冒泡**
  除 `bind` 外，也可以用 `catch` 来绑定事件。与 `bind` 不同，`catch` 会阻止事件向上冒泡。

  例如：在下边这个例子中，点击 inner view 会先后调用 handleTap3 和 handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outer view 会触发 handleTap1。

  ```wxml
  <view id="outer" bindtap="handleTap1">
    <view id="middle" catch:tap="handleTap2">
      <view id="inner" bindtap="handleTap3">
    <\view>
  <\view>
  ```

- **互斥事件绑定**
  自基础库版本 2.8.2 起，除 bind 和 catch 外，还可以使用 `mut-bind` 来绑定事件。一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。

- **事件的捕获阶段**
  自基础库版本 1.5.0 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用 `capture-bind`、`capture-catch` 关键字，后者将中断捕获阶段和取消冒泡阶段。

  在下面的代码中，点击 inner view 会先后调用handleTap2、handleTap4、handleTap3、handleTap1。

  ```wxml
  <view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">
    <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4"><\view>
  <\view>
  ```

  如果将上面代码中的第一个 `capture-bind` 改为 `capture-catch`，将只触发 handleTap2。

##### 2.3.4.3 事件对象

如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

- **BaseEvent 基础事件对象属性列表**:

  属性 | 类型 | 说明
  -----|------|-----
  type | String | 事件类型
  timeStamp | Integer | 事件生成的时间戳
  [target](#target) | Object | 触发事件的组合的一些属性值集合
  [currentTarget](#currentTarget) | Object | 当前组件的一些属性值集合
  [mark](#mark) | Object | 事件标记数据，基础库版本 2.7.1

- **CustomEvent 自定义事件对象属性列表** (继承BaseEvent)

  属性 | 类型 | 说明
  -----|------|-------
  [detail](#detail) | Object | 说明

- **TouchEvent 触摸事件对象属性列表** (继承BaseEvent)

  属性 | 类型 | 说明
  ----|------|------
  [touches](#touches) | Array | 触摸事件，当前停留在屏幕中的触摸点信息的数组
  [changedTouches](#changedTouches) | Array | 触摸事件，当前变化的触摸点信息的数组

  > 特殊事件：canvas 中的触摸事件不可冒泡，所以没有 currentTarget

- <span id="target">**target**<\span>
  触发事件的源组件

  属性 | 类型 | 说明
  ----|------|-----
  id | String | 事件源组件的id
  [dataset](#dateset) | Object | 事件源组件上由 `data-` 开头的自定义属性组合的集合

- <span id="currentTarget">**currentTarget**<\span>
  事件绑定的当前组件

  属性 | 类型 | 说明
  -----|-----|-----
  id | String | 当前组件的id
  [dataset](#dateset) | Object | 当前组件上由 `data-` 开头的自定义属性组合的集合

- <span id="dataset">dataset<\span>
  在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。
  在 WXML 中，这些自定义数据以 data- 开头，多个单词由连字符 - 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：
  - data-element-type ，最终会呈现为 event.currentTarget.dataset.elementType ；
  - data-elementType ，最终会呈现为 event.currentTarget.dataset.elementtype 。

- <span id="mark">mark<\span>
  在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点。此外， mark 还可以用于承载一些自定义数据（类似于 dataset ）。
  当事件触发时，事件冒泡路径上所有的 mark 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 mark 。）

  ```wxml
  <view mark:myMark="last" bindtap="bindViewTap">
    <button mark:anotherMark="leaf" bindtap="bindButtonTap">按钮<\button>
  <\view>
  ```

  在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。

  ```js
  Page({
    bindViewTap: function (e) {
      e.mark.myMark === "last"; \\ true
      e.mark.anotherMark === "leaf"; \\ true
    }
  })
  ```

  mark 和 dataset 很相似，主要区别在于： mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值；而 dataset 仅包含一个节点的 data- 属性值。
  细节注意事项：

  - 如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。
  - 在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark 。
  - 不同于 dataset ，节点的 mark 不会做连字符和大小写转换

- <span id="touches">touches<\span>
  touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。
  - Touch对象

    属性 | 类型 | 说明
    ----|------|-----
    identifier | Number | 触摸点的标识符
    pageX, pageY | Number | 距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴
    clientX, clientY | Number | 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴

  - CanvasTouch 数组

    属性 | 类型 | 说明
    ----|------|-----
    identifier | Number | 触摸点的标识符
    x，y | Number | 距离 Canvas 左上角的距离，Canvas 的左上角为原点，横向为X轴，纵向为Y轴

- <span id="changedTouches">changedTouches<\span>
  changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。

- <span id="detail">detail<\span>
  自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义。
  点击事件的detail 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。

##### 2.3.4.4 使用WXS函数响应事件

> 基础库 2.4.4 开始支持，低版本需做 [兼容处理][compatibility]。

从基础库版本2.4.4开始，支持使用WXS函数绑定事件，WXS函数接受2个参数，第一个是event，在原有的event的基础上加了 **event.instance** 对象，第二个参数是 **ownerInstance**，和 event.instance 一样是一个**ComponentDescriptor** 对象。具体使用如下：

- **组件中绑定和注册事件处理的WXS函数**

  ```wxml
  <wxs module="wxs" src=".\test.wxs"><\wxs>
  <!-- 注：绑定的WXS函数必须用 {{}} 括起来 -->
  <view id="tapTest" data-hi="WeiXin" bindtap="{{wxs.tapName}}"> Click Me! <\view>
  ```

- **test.wxs文件实现tapName函数**

  ```wxs
  function tapName(event, ownerInstance) {
    console.log('top WeiXin', JSON.stringify(event));
  }
  module.exports = {
    tapName : tapName
  }
  ```

ownerInstance包含了一些方法，可以设置组件的 样式 和 class，具体包含的方法以及为什么要用 WXS函数响应事件，[点击查看详情](https:\\developers.weixin.qq.com\miniprogram\dev\framework\view\interactive-animation.html)。

#### 2.3.5 简易双向绑定

> 基础库 2.9.3 开始支持，低版本需做 [兼容处理][compatibility]。

**双向绑定语法**
在 WXML 中，普通的属性的绑定是单向的。如果使用 `this.setData({ value: 'leaf' })` 来更新 value ，`this.data.value` 和输入框的中显示的值都会被更新为 `leaf` ；但如果用户修改了输入框里的值，却不会同时改变 `this.data.value` 。

如果需要在用户输入的同时改变 `this.data.value` ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 `model:` 前缀：

```wxml
<input model:value="{{value}}">
```

这样，如果输入框的值被改变了，`this.data.value` 也会同时改变。同时，WXML 中所有绑定了 value 的位置也会被一同更新， 数据监听器 也会被正常触发。

用于双向绑定的表达式有如下限制：

- 只能是一个单一字段的绑定，不能是

  ```wxml
  <input model:value="值为 {{value}}" \>
  <input model:value="{{ a + b }}" \>
  ```

- 不能 data 路径，如

  ```wxml
  <input model:value="{{a.b}}" \>
  ```

**在自定义组件中传递双向绑定**
双向绑定同样可以使用在自定义组件上。如下的自定义组件：

```js
\\ custom-component.js
Component({
  properties : {
    myValue: String
  }
})
```

```wxml
<!-- custom-component.wxml -->
<input model:input="{{myValue}}">
```

这个自定义组件将自身的 myValue 属性双向绑定到了组件内输入框的 value 属性上。这样，如果页面这样使用这个组件:

```wxml
<custom-component model:my-value="{{pageValue}}" \>
```

当输入框的值变更时，自定义组件的 myValue 属性会同时变更，这样，页面的 `this.data.pageValue` 也会同时变更，页面 WXML 中所有绑定了 pageValue 的位置也会被一同更新。

**在自定义组件中触发双向绑定更新**
自定义组件还可以自己触发双向绑定更新，做法就是：使用 `setData` 设置自身的属性。例如：

```js
\\ custom-component.js
Component({
  properties: {
    myValue: String
  },
  methods: {
    update: function() {
      \\ 更新 myValue
      this.setData({
        myValue : "leaf"
      })
    }
  }
})
```

如果页面这样使用这个组件：

```wxml
<custom-component model:my-value="{{pageValue}}" \>
```

当组件使用 `setData` 更新 **myValue** 时，页面的 `this.data.pageValue` 也会同时变更，页面 WXML 中所有绑定了 **pageValue** 的位置也会被一同更新。

#### 2.3.6 基础组件

框架提供了一系列基础组件，可以通过组合这些基础组件进行快速开发。详细介绍参考 [组件文档][组件]

什么是组件：

- 组件是视图层的基本组成单元。
- 组件自带一些功能与微信风格一致的样式。
- 一个组件通常包括 **开始标签** 和 **结束标签**，**属性** 用来修饰这个组件，**内容** 在两个标签之内。

> 注意：所有组件与属性都是小写，以连字符-连接

**属性类型**:

类型 | 描述 | 注解
-----|------|-----
Boolean | 布尔值 | 组件写上该属性，不管是什么值都被当作 true；只有组件上没有该属性时，属性值才为false。如果属性值为变量，变量的值会被转换为Boolean类型
Number | 数字 | 1, 2.5
String | 字符串 | "string"
Array | 数组 | [ 1, "string" ]
Object | 对象 | { key: value }
EventHandler | 事件处理函数名 | "handlerName" 是 Page 中定义的事件处理函数名
Any | 任意属性

**公共属性**
所有组件都有以下属性：

属性名 | 类型 | 描述 | 注解
-------|-----|------|-----
id | String | 组件的唯一标示 | 保持整个页面唯一
class | String | 组件的样式类 | 在对应的 WXSS 中定义的样式类
style | String | 组件的内联样式 | 可以动态设置的内联样式
hidden | Boolean | 组件是否显示 | 所有组件默认显示
data-* | Any | 自定义属性 | 组件上触发的事件时，会发送给事件处理函数
`bind*` \ `catch*` | EventHandler | 组件的事件 | 详见[事件系统](#234-事件系统)

**特殊属性**
几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，参考各个 [组件][组件] 的定义。

#### 2.3.7 获取界面上的信息节点

**WXML信息节点**
`wx.createSelectorQuery()` 可以用于获取节点属性、样式、在界面上的位置等信息。
最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

```js
const query = wx.createSelectorQuery();
query.select("#the-id").boundingClientRect(function(res) {
  res.top; \\ #the-id 节点的上边界坐标（相对于显示区域）
})
query.selectViewport().scrollOffSet(function(res) {
  res.scrollTop; \\ 显示区域的竖直滚动位置
})
\\ 执行所有的请求。请求结果按请求次序构成数组，在callback的第一个参数中返回
query.exec((e) => {
  console.log(e);
});
```

上述示例中，`#the-id` 是一个节点选择器，与 CSS 的选择器相近但略有区别，参见 [SelectorQuery.select](https:\\developers.weixin.qq.com\miniprogram\dev\api\wxml\SelectorQuery.select.html) 的相关说明。

> 在 **自定义组件** 或包含 **自定义组件的页面** 中，推荐使用 `this.createSelectorQuery` 来代替 `wx.createSelectorQuery` ，这样可以确保在正确的范围内选择节点。

**WXML节点布局相交状态**
`wx.createIntersectionObserver(Object component, Object options)` API， 可用于监听两个或多个组件节点在布局位置上的相交状态。这一组API常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。

这一组API涉及的主要概念如下:

- 参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的 交集 作为参照区域。页面显示区域也可作为参照区域之一。
- 目标节点：监听的目标，默认只能是一个节点（使用 `selectAll` 选项时，可以同时监听多个节点）。
- 相交区域：目标节点的布局区域与参照区域的相交区域。
- 相交比例：相交区域占参照区域的比例。
- 阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。

以下示例代码可以在目标节点（用选择器 `.target-class` 指定）每次进入或离开页面显示区域时，触发回调函数。

```js
Page({
  onLoad: function(){
    wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
      res.id \\ 目标节点 id
      res.dataset \\ 目标节点 dataset
      res.intersectionRatio \\ 相交区域占目标节点的布局区域的比例
      res.intersectionRect \\ 相交区域
      res.intersectionRect.left \\ 相交区域的左边界坐标
      res.intersectionRect.top \\ 相交区域的上边界坐标
      res.intersectionRect.width \\ 相交区域的宽度
      res.intersectionRect.height \\ 相交区域的高度
    })
  }
})
```

以下示例代码可以在目标节点（用选择器 .target-class 指定）与参照节点（用选择器 .relative-class 指定）在页面显示区域内相交或相离，且相交或相离程度达到目标节点布局区域的20%和50%时，触发回调函数。

```js
Page({
  onLoad: function(){
    wx.createIntersectionObserver(this, {
      thresholds: [0.2, 0.5]
    }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
      res.intersectionRatio \\ 相交区域占目标节点的布局区域的比例
      res.intersectionRect \\ 相交区域
      res.intersectionRect.left \\ 相交区域的左边界坐标
      res.intersectionRect.top \\ 相交区域的上边界坐标
      res.intersectionRect.width \\ 相交区域的宽度
      res.intersectionRect.height \\ 相交区域的高度
    })
  }
})
```

> 注意：
> 与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是 "布局区域"，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中 overflow 样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。
> 在 **自定义组件或包含自定义组件的页面中**，推荐使用 `this.createIntersectionObserver` 来代替 `wx.createIntersectionObserver` ，这样可以确保在正确的范围内选择节点。

#### 2.3.8 响应显示区域的变化

**显示区域尺寸**
显示区域指小程序界面中可以自由布局展示的区域。在默认情况下，小程序显示区域的尺寸自页面初始化起就不会发生变化。但以下两种方式都可以改变这一默认行为。

- **在手机上启用屏幕旋转支持**
  从小程序基础库版本 2.4.0 开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持屏幕旋转的方法是：在 **app.json** 的 **window** 段中设置 `"pageOrientation": "auto"` ，或在页面 json 文件中配置 `"pageOrientation": "auto"` 。

  如果页面添加声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。

  从小程序基础库版本 2.5.0 开始， `pageOrientation` 还可以被设置为 `landscape` ，表示固定为横屏显示。

- **在 iPad 上启用屏幕旋转支持**
从小程序基础库版本 2.3.0 开始，在 iPad 上运行的小程序可以支持屏幕旋转。使小程序支持 iPad 屏幕旋转的方法是：在 **app.json** 中添加 `"resizable": true` 。

> 注意：
> 如果小程序添加了声明，则在屏幕旋转时，小程序将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。
> 在 iPad 上不能单独配置某个页面是否支持屏幕旋转。

**Media Query**
有时，对于不同尺寸的显示区域，页面的布局会有所差异。此时可以使用 `media query` 来解决大多数问题。

```wxss
.my-class {
  width: 400px;
}
@media (max-width:480px) {
  \* 仅在 480px 或更窄的屏幕上生效的样式规则 *\
  .my-class {
    width: 200px;
  }
}
```

在 WXML 中，可以使用 [match-media](https:\\developers.weixin.qq.com\miniprogram\dev\component\match-media.html) 组件来根据 media query 匹配状态展示、隐藏节点。

此外，可以在页面或者自定义组件 JS 中使用 `this.createMediaQueryObserver()` 方法来创建一个 `MediaQueryObserver` 对象，用于监听指定的 media query 的匹配状态。

**屏幕旋转事件**
有时，仅仅使用 media query 无法控制一些精细的布局变化。此时可以使用 js 作为辅助。

在 js 中读取页面的显示区域尺寸，可以使用 `selectorQuery.selectViewport` 。

页面尺寸发生改变的事件，可以使用页面的 `onResize` 来监听。对于自定义组件，可以使用 `resize` 生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库版本 2.4.0 开始支持。）

```js
Page({
  onResize: function(res) {
    res.size.windowWidth \\ 新的显示区域宽度
    res.size.windowHeight \\ 新的显示区域高度
  }
})
```

```js
Component({
  pageLifetimes: {
    resize(res) {
      res.size.windowWidth \\ 新的显示区域宽度
      res.size.windowHeight \\ 新的显示区域高度
    }
  }
})
```

#### 2.3.9 动画

**界面动画的常见方式**
在小程序中，通常可以使用 CSS 渐变 和 CSS 动画 来创建简易的界面动画。

动画过程中，可以使用 `bindtransitionend` `bindanimationstart` `bindanimationiteration` `bindanimationend` 来监听动画事件。

事件名 | 含义
------|------
transitionend | CSS 渐变结束或 wx.createAnimation 结束一个阶段
animationstart | CSS动画开始
animationiteration | CSS 动画结束一个阶段
animationend | CSS动画结束

> 注意：
> 这几个事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。
> 同时，还可以使用 `wx.createAnimation` 接口来动态创建简易的动画效果。（新版小程序基础库中推荐使用下面的关键帧动画接口代替。）

**关键帧动画**:

> 基础库 2.9.0 开始支持，低版本需做 [兼容处理][compatibility]。

从小程序基础库 2.9.0 开始支持一种更友好的动画创建方式，用于代替旧的 `wx.createAnimation` 。它具有更好的性能和更可控的接口。
在页面或自定义组件中，当需要进行关键帧动画时，可以使用 `this.animate` 接口：

```js
this.animate(selector, keyframes, duration, callback)
```

参数说明

属性 | 类型 | 必填 | 说明
-----|-----|------|-----
selector | String | 是 | 选择器（同 SelectorQuery.select 的选择器格式）
keyframes | Array | 是 | 关键帧信息
duration | Number | 是 | 动画持续时长(单位：毫秒)
callback | function | 是 | 动画完成后的回调函数

keyframes 中对象的结构

属性 | 类型 | 默认值 | 必填 | 说明
-----|-----|--------|------|-----
offset | Number | - | 否 | 关键帧的偏移，范围[0-1]
ease | String | linear | 否 | 动画缓动函数
transformOrigin | String | - | 否 | 基点位置，即 CSS transform-origin
backgroundColor | String | - | 否 | 背景颜色，即 CSS background-color
bottom | Number\String | - | 否 | 底边位置，即 CSS bottom
height | Number\String | - | 否 | 高度，即 CSS height
left | Number\String | - | 否 | 左边位置，即 CSS left
width | Number\String | - | 否 | 宽度，即 CSS width
opacity | Number | - | 否 | 不透明度，即 CSS opacity
right | Number | - | 否 | 右边位置，即 CSS right
top | Number\String | - | 否 | 顶边位置，即 CSS top
matrix | Array | - | 否 | 变换矩阵，即 CSS transform matrix
matrix3d | Array | - | 否 | 三维变换矩阵，即 CSS transform matrix3d
rotate | Number | - | 否 | 旋转，即 CSS transform rotate
rotate3d | Array | - | 否 | 三维旋转，即 CSS transform rotate3d
rotateX | Number | - | 否 | X 方向旋转，即 CSS transform rotateX
rotateY | Number | - | 否 | Y 方向旋转，即 CSS transform rotateY
rotateZ | Number | - | 否 | Z 方向旋转，即 CSS transform rotateZ
scale | Array | - | 否 | 缩放，即 CSS transform scale
scale3d | Array | - | 否 | 三维缩放，即 CSS transform scale3d
scaleX | Number | - | 否 | X 方向缩放，即 CSS transform scaleX
scaleY | Number | - | 否 | Y 方向缩放，即 CSS transform scaleY
scaleZ | Number | - | 否 | Z 方向缩放，即 CSS transform scaleZ
skew | Array | - | 否 | 倾斜，即 CSS transform skew
skewX | Number | - | 否 | X 方向倾斜，即 CSS transform skewX
skewY | Number | - | 否 | Y 方向倾斜，即 CSS transform skewY
translate | Array | - | 否 | 位移，即 CSS transform translate
translate3d | Array | - | 否 | 三维位移，即 CSS transform translate3d
translateX | Number | - | 否 | X 方向位移，即 CSS transform translateX
translateY | Number | - | 否 | Y 方向位移，即 CSS transform translateY
translateZ | Number | - | 否 | Z 方向位移，即 CSS transform translateZ

```js
this.animate('#container', [
  { opacity: 1.0, rotate: 0, backgroundColor: '#FF0000' },
  { opacity: 0.5, rotate: 45, backgroundColor: '#00FF00'},
  { opacity: 0.0, rotate: 90, backgroundColor: '#FF0000' },
  ], 5000, function () {
    this.clearAnimation('#container', { opacity: true, rotate: true }, function () {
      console.log("清除了#container上的opacity和rotate属性")
    })
}.bind(this))

this.animate('.block', [
  { scale: [1, 1], rotate: 0, ease: 'ease-out'  },
  { scale: [1.5, 1.5], rotate: 45, ease: 'ease-in', offset: 0.9},
  { scale: [2, 2], rotate: 90 },
], 5000, function () {
  this.clearAnimation('.block', function () {
    console.log("清除了.block上的所有动画属性")
  })
}.bind(this))
```

调用 animate API 后会在节点上新增一些样式属性覆盖掉原有的对应样式。如果需要清除这些样式，可在该节点上的动画全部执行完毕后使用 `this.clearAnimation` 清除这些属性。

```js
this.clearAnimation(selector, options, callback)
```

参数说明

属性 | 类型 | 必填 | 说明
-----|-----|------|-----
selector| String | 是 | 选择器（同 SelectorQuery.select 的选择器格式）
options | Object | 否 | 需要清除的属性，不填写则全部清除
callback | Function | 否 | 清除完成后的回调函数

**滚动驱动的动画**
根据滚动位置而不断改变动画的进度是一种比较常见的场景，这类动画可以让人感觉到界面交互很连贯自然，体验更好。因此，从小程序基础库 2.9.0 开始支持一种由滚动驱动的动画机制。

基于上面关键帧动画接口，新增一个 `ScrollTimeline` 的参数，用来绑定滚动元素（目前只支持 `scroll-view`）。接口定义如下：

```js
this.animate(selector, keyframes, duration, ScrollTimeline)
```

ScrollTimeline 中对象的结构

属性 | 类型 | 默认值 | 必填 | 说明
-----|-----|--------|------|-----
scrollSource | String | - | 是 | 指定滚动元素的选择器（只支持 scroll-view），该元素滚动时会驱动动画的进度
orientation | String | vertical | 否 | 指定滚动的方向。有效值为 horizontal 或 vertical
startScrollOffset | Number | - | 是 | 指定开始驱动动画进度的滚动偏移量，单位 px
endScrollOffset | Number | - | 是 | 指定停止驱动动画进度的滚动偏移量，单位 px
timeRange | Number | - | 是 | 起始和结束的滚动范围映射的时间长度，该时间可用于与关键帧动画里的时间 (duration) 相匹配，单位 ms

```js
this.animate('.avatar', [{
  borderRadius: '0',
  borderColor: 'red',
  transform: 'scale(1) translateY(-20px)',
  offset: 0,
}, {
  borderRadius: '25%',
  borderColor: 'blue',
  transform: 'scale(.65) translateY(-20px)',
  offset: .5,
}, {
  borderRadius: '50%',
  borderColor: 'blue',
  transform: `scale(.3) translateY(-20px)`,
  offset: 1
}], 2000, {
  scrollSource: '#scroller',
  timeRange: 2000,
  startScrollOffset: 0,
  endScrollOffset: 85,
})

this.animate('.search_input', [{
  opacity: '0',
  width: '0%',
}, {
  opacity: '1',
  width: '100%',
}], 1000, {
  scrollSource: '#scroller',
  timeRange: 1000,
  startScrollOffset: 120,
  endScrollOffset: 252
})
```

**高级的动画方式**
在一些复杂场景下，上述的动画方法可能并不适用。

WXS 响应事件 的方式可以通过使用 WXS 来响应事件的方法来动态调整节点的 style 属性。通过不断改变 style 属性的值可以做到动画效果。同时，这种方式也可以根据用户的触摸事件来动态地生成动画。

连续使用 `setData` 来改变界面的方法也可以达到动画的效果。这样可以任意地改变界面，但通常会产生较大的延迟或卡顿，甚至导致小程序僵死。此时可以通过将页面的 `setData` 改为 自定义组件 中的 `setData` 来提升性能。

#### 2.3.10 初始渲染缓存

> 基础库 2.11.1 开始支持，低版本需做 [兼容处理][compatibility]。

**初始渲染缓存工作原理**
小程序页面的初始化分为两个部分。

- 逻辑层初始化：载入必需的小程序代码、初始化页面 this 对象（也包括它涉及到的所有自定义组件的 this 对象）、将相关数据发送给视图层。
- 视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发送的数据，最后渲染页面。

在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。

启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 data 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：

- 在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；
- 在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；
- 如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。

利用初始渲染缓存，可以：

- 快速展示出页面中永远不会变的部分，如导航栏
- 预先展示一个骨架页，提升用户体验
- 展示自定义的加载提示
- 提前展示广告，等等

**支持的组件**
在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。

目前支持的内置组件：

- `<view \>`
- `<text \>`
- `<button \>`
- `<image \>`
- `<scroll-view \>`
- `<rich-text \>`

自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。

**静态初始渲染缓存**
若想启用初始渲染缓存，最简单的方法是在页面的 json 文件中添加配置项 `"initialRenderingCache": "static"` ，如果想要对所有页面启用，可以在 app.json 的 window 配置段中添加这个配置：

添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。

> 注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML 上的结果，不包含任何 setData 的结果。

例如，如果想要在页面中展示出"正在加载"几个字，这几个字受到 `loading` 数据字段控制：

```wxml
<view wx:if="{{loading}}">正在加载<\view>
```

这种情况下， **loading** 应当在 data 中指定为 true ，如：

```js
\\ 正确的做法
Page({
  data: {
    loading: true
  }
})
```

**在初始渲染缓存中添加动态内容**
有些场景中，只是页面 data 的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片 URL 等。

这种情况下可以使用"动态"初始渲染缓存的方式。首先，配置 `"initialRenderingCache": "dynamic"` 。

此时，初始渲染缓存不会被自动启用，还需要在页面中调用 `this.setInitialRenderingCache(dynamicData)` 才能启用。其中， `dynamicData` 是一组数据，与 `data` 一起参与页面 WXML 渲染。

```js
Page({
  data: {
    loading: true
  },
  onReady: function() {
    this.setInitialRenderingCache({
      loadingHint: "正在加载" \\ 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
    })
  }
})
```

```wxml
<view wx:if="{{loading}}">{{loadingHint}}<\view>
```

> **注意**：
> 从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而 **开销相对较大**。因而要尽量避免频繁调用 `this.setInitialRenderingCache` ，如果在一个页面内多次调用，仅最后一次调用生效。
> `this.setInitialRenderingCache` 调用时机不能早于 Page 的 `onReady` 或 Component 的 `ready` 生命周期，否则可能对性能有负面影响。
> 如果想禁用初始渲染缓存，调用 `this.setInitialRenderingCache(null)` 。

## 三. 小程序运行时

### 3.1 运行环境

微信小程序运行在多种平台上：iOS（iPhone\iPad）微信客户端、Android 微信客户端、PC 微信客户端、Mac 微信客户端和用于调试的微信开发者工具。

各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：

- 在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS 12、iOS 13 等；
- 在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 内核来渲染的；
- 在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的。
- 在 PC 上，小程序逻辑层 javascript 和视图层 javascript 都是用 Chrome 内核
- 在 Mac 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，与 iOS 一致

**平台差异**
尽管各运行环境是十分相似的，但是还是有些许区别：

- JavaScript 语法和 API 支持不一致：语法上可以通过开启 ES6 转 ES5 的功能来规避（[详情](https:\\developers.weixin.qq.com\miniprogram\dev\devtools\codecompile.html#es6-%E8%BD%AC-es5)）；此外，小程序基础库内置了必要的Polyfill，来弥补API的差异。
- WXSS 渲染表现不一致：尽管可以通过开启样式补全来规避大部分的问题，但还是需要在 iOS 和 Android 上分别检查小程序的真实表现。

### 3.2 JavaScript 支持情况

**运行限制**
基于安全考虑，小程序中不支持动态执行 JS 代码，即：

- 不支持使用 `eval` 执行 JS 代码
- 不支持使用 `new Function` 创建函数

**客户端 ES6 API 支持情况**
微信小程序已经支持了绝大部分的 ES6 API，具体情况查询 [API支持情况](https:\\developers.weixin.qq.com\miniprogram\dev\framework\runtime\js-support.html)

### 3.3 运行机制

**前台后台状态**
小程序启动后，界面被展示给用户，此时小程序处于前台状态。

当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有完全终止运行，而是进入了后台状态，小程序还可以运行一小段时间。

当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。但如果用户很久没有再进入小程序，或者系统资源紧张，小程序可能被销毁，即完全终止运行。

**小程序启动**
小程序启动可以分为两种情况，一种是冷启动，一种是热启动。

- 冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。
- 热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。

**小程序销毁时机**
通常，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被销毁。具体而言包括以下几种情形：

- 当小程序进入后台，可以维持一小段时间的运行状态，如果这段时间内都未进入前台，小程序会被销毁。
- 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。
  - 在 iOS 上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户 「运行内存不足，请重新打开该小程序」。具体策略会持续进行调整优化。
  - 建议小程序在必要时使用 `wx.onMemoryWarning` 监听内存告警事件，进行必要的内存清理。

> 基础库 1.1.0 及以上，1.4.0 以下版本： 当用户从扫一扫、转发等入口（[场景值](#21-场景值)为1007, 1008, 1011, 1025）进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。

**启动场景分类**
用户打开小程序时，场景可分为以下 A、B 两类：

**A. 保留上次的浏览状态**。场景值有以下几项：

场景值ID | 说明
--------|------
1001 | 发现栏小程序主入口，「最近使用」列表（基础库2.2.4版本起包含「我的小程序」列表）
1003 | 星标小程序列表
1023 | 系统桌面小图标打开小程序
1038 | 从其他小程序返回小程序
1056 | 聊天顶部音乐播放器右上角菜单，打开小程序
1080 | 客服会话菜单小程序入口，打开小程序
1083 | 公众号会话菜单小程序入口 ，打开小程序（只有腾讯客服小程序有）
1089 | 聊天主界面下拉，打开小程序\微信聊天主界面下拉，「最近使用」栏（基础库2.2.4版本起包含「我的小程序」栏）
1090 | 长按小程序右上角菜单，打开小程序
1103 | 发现-小程序主入口我的小程序，打开小程序
1104 | 聊天主界面下拉，从我的小程序，打开小程序
1113 | 安卓手机负一屏，打开小程序
1114 | 安卓手机侧边栏，打开小程序
1117 | 后台运行小程序的管理页中，打开小程序

- 若进入的场景中带有 path，则每次打开小程序时都进入对应的 path 页面
- 若进入的场景中不带 path：
  - 若小程序是热启动，则保留原来状态
  - 若小程序是冷启动，则遵循下一节的重启策略，可能是首页或上次退出的页面

**B. relaunch 到指定页或首页**
包括除 A 类外的其他场景

- 若进入的场景中带有 path，则每次点击时都进入对应的 path 页面
- 若进入的场景中不带 path，则每次进入都打开首页

**A 类场景的重新启动策略**:

> 基础库 2.8.0 开始支持，低版本需做 [兼容处理][compatibility]。

- 小程序被销毁后，下次冷启动如果属于 B 类场景，将会进入特定的页面。
- 下次冷启动如果属于 A 类场景，默认情况下将会进入小程序的首页。在页面对应的 json 文件中（也可以全局配置在 app.json 的 window 段中），指定 `restartStrategy` 配置项可以改变这个默认的行为，使得从某个页面退出后，下次 A 类场景的冷启动可以回到这个页面。

`restartStrategy` 可选值:

可选值 | 含义
------|------
homePage | （默认值）如果从这个页面退出小程序，下次将从首页冷启动
homePageAndLatestPage | 如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）

> 注意：
> 即使不配置为 **homePage** ，小程序如果退出过久（当前默认**一天**时间，可以使用退出状态来调整），下次冷启动时也将不再遵循 **restartStrategy** 的配置，而是直接从首页冷启动。
> 无论如何，页面中的状态并不会被保留，如输入框中的文本内容、 checkbox 的勾选状态等都不会还原。如果需要还原或部分还原，需要利用退出状态。

**退出状态**
每当小程序可能被销毁之前，页面回调函数 `onSaveExitState` 会被调用。如果想保留页面中的状态，可以在这个回调函数中"保存"一些数据，下次启动时可以通过 `exitState` 获得这些已保存数据。需要 `restartStrategy` 为 `homePageAndLatestPage`。

```js
Page({
  onLoad: function() {
    var prevExitState = this.exitState; \\ 尝试获得上一次退出前 onSaveExitState 保存的数据
    if(prevExitState !== undefined) {
      prevExitState.myDataField === "myData"; \\ 如果是根据 restartStrategy 配置进行的冷启动，就可以获取到
    }
  },
  onSaveExitState: function() {
    var exitState = { myDataField : "myData"} \\ 需要保存的数据
    return {
      data: exitState,
      expireTimeStamp: Date.now() + 24 * 60 * 60 * 1000 \\ 超时时刻
    }
  }
})
```

`onSaveExitState` 返回值可以包含两项:

字段名 | 类型 | 含义
------|-------|-----
data | Any | 需要保存的数据（只能是 JSON 兼容的数据）
expireTimeStamp | Number | 超时时刻，在这个时刻后，保存的数据保证一定被丢弃，默认为 (当前时刻 + 1 天)

> 注意：
>
> 1. 如果超过 `expireTimeStamp` ，保存的数据将被丢弃，且冷启动时不遵循 `restartStrategy` 的配置，而是直接从首页冷启动。
> 2. `expireTimeStamp` 有可能被自动提前，如微信客户端需要清理数据的时候。
> 3. 在小程序存活期间， `onSaveExitState` 可能会被多次调用，此时以最后一次的调用结果作为最终结果。
> 4. 在某些特殊情况下（如微信客户端直接被系统杀死），这个方法将不会被调用，下次冷启动也不遵循 `restartStrategy` 的配置，而是直接从首页冷启动。
> 5. 不能是 tabBar 的页面，否则不起作用

### 3.4 更新机制

**未启动时更新**
在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现有用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。

**启动时更新**
小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。

如果需要马上应用最新版本，可以使用 [wx.getUpdateManager](https:\\developers.weixin.qq.com\miniprogram\dev\api\base\update\wx.getUpdateManager.html) API 进行处理。

```js
const updateManager = wx.getUpdateManager();

updateManager.onCheckForUpdate(function() {
  \\ 请求完新版本信息的回调
  console.log(res.hasUpdate)
})

updateManager.onUpdateReady(function() {
  wx.showModel({
    title : "更新提示",
    content : '新版本已准备好，是否重启应用？'，
    success(res) {
      if(res.confirm) {
        \\ 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate();
      }
    }
  })
})

updateManager.onUpdateFailed(function() {
  \\ 新版本下载失败
})
```

## 四. 自定义组件

从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。

可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

**创建自定义组件**
类似于页面，一个自定义组件由 **json** **wxml** **wxss** **js** 4个文件组成。要编写一个自定义组件，首先需要在 **json** 文件中进行自定义组件声明（将 `component` 字段设为 `true`）。

> 注意：在组件wxss中不应使用ID选择器、属性选择器 和 标签名选择器。

在自定义组件的 js 文件中，需要使用 `Component()` 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，属性值是可由组件外部传入的。

**使用自定义组件**
使用已注册的自定义组件前，首先要在页面的 **json** 文件或 **app.json** 中声明 `usingComponents` 字段，在 **app.json** 中声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。

```json
{
  "usingComponents" : {
     "component-tag-name": "path\to\the\custom\component"
  }
}
```

这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

> 注意事项:
>
> 1. 因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
> 2. 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 `usingComponents` 字段）。
> 3. 自定义组件和页面所在项目根目录名不能以 "wx-" 为前缀，否则会报错。
> 4. 是否在页面文件中使用 `usingComponents` 会使得页面的 `this` 对象的原型稍有差异
>     - 使用 usingComponents 页面的原型与不使用时不一致，即 Object.getPrototypeOf(this) 结果不同。
>     - 使用 usingComponents 时会多一些方法，如 selectComponent 。
>     - 出于性能考虑，使用 usingComponents 时， setData 内容不会被直接深复制，即 this.setData({ field: obj }) 后 this.data.field === obj 。（深复制会在这个值被组件间传递时发生。）

### 4.1 组件模板与样式

类似于页面，自定义组件拥有自己的 `wxml` 模板和 `wxss` 样式。

**组件模板**
组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

在组件模板中可以提供一个 `<slot>` 节点，用于承载组件引用时提供的子节点。

```wxml
<!-- 组件模板 -->
<view class="wrapper">
  <view>这里是组件的内部节点<\view>
  <slot><\slot>
<\view>
```

```wxml
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容<\view>
  <\component-tag-name>
<\view>
```

> 注意 : 在模板中引用到的自定义组件及其对应的节点名需要在 json 文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为抽象节点。

**模板数据绑定**
与普通的 WXML 模板类似，可以使用数据绑定，向子组件的属性传递动态数据。

```wxml
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容<\view>
  <\component-tag-name>
<\view>
```

在以上例子中，组件的属性 **propA** 和 **propB** 将收到页面传递的数据。页面可以通过 **setData** 来改变绑定的数据字段。

> 注意：这样的数据绑定只能传递 JSON 兼容数据。自基础库版本 2.0.9 开始，还可以在数据中包含函数（但这些函数不能在 WXML 中直接调用，只能传递给子组件）。

**组件 wxml 的 slot**
在组件的 wxml 中可以包含 `slot` 节点，用于承载组件使用者提供的 wxml 结构。

默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。

```js
Component({
  options: {
    multipleSlots: true \\ 在组件定义时的选项中启用多slot支持
  },
  properties: { \* ... *\ },
  methods: { \* ... *\ }
})
```

此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 name 来区分。

```wxml
<!-- 组件模板 -->
<view class="wrapper">
  <slot name="before"><\slot>
  <view>这里是组件的内部细节<\view>
  <slot name="after"><\slot>
<\view>
```

使用时，用 `slot` 属性来将节点插入到不同的 slot 上。

```wxml
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
    <view slot="before">这里是插入到组件slot name="before"中的内容<\view>
    <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
    <view slot="after">这里是插入到组件slot name="after"中的内容<\view>
  <\component-tag-name>
<\view>
```

**组件样式**
组件对应 wxss 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点：

- 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。
- 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。
- 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。
- 继承样式，如 font 、 color ，会从组件外继承到组件内。
- 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。

除此以外，组件可以指定它所在节点的默认样式，使用 `:host` 选择器（需要包含基础库 1.7.2 或更高版本的开发者工具支持）。

例: [:host](.\test\pages\component-show\component-show.wxss)

**组件样式隔离**
默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：

- `app.wxss` 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
- 指定特殊的样式隔离选项 `styleIsolation`(在Component构造器的 **options** 中定义) 。

`styleIsolation` 选项从基础库版本 2.6.5 开始支持。它支持以下取值：

- **isolated** : 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；
- **apply-shared** : 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；
- **shared** : 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 `apply-shared` 或 `shared` 的自定义组件。（这个选项在插件中不可用）

> 使用后两者时，请务必注意组件间样式的相互影响。

如果这个 Component 构造器用于构造页面 ，则默认值为 shared ，且还有以下几个额外的样式隔离选项可用：

- **page-isolated** : 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；
- **page-apply-shared** : 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；
- **page-shared** : 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 styleIsolation （这样就不需在 js 文件的 options 中再配置）。
小程序基础库版本 2.2.3 以上支持 `addGlobalClass` 选项，即在 Component 的 options 中设置 `addGlobalClass: true` 。 这个选项等价于设置 `styleIsolation: apply-shared` ，但设置了 styleIsolation 选项后这个选项会失效。

**外部样式类**:

> 基础库 1.9.90 开始支持，低版本需做 [兼容处理](compatibility) 。

有时，组件希望接受外部传入的样式类。此时可以在 `Component` 中用 `externalClasses` 定义段定义若干个外部样式类。

这个特性可以用于实现类似于 **view** 组件的 `hover-class` 属性：页面可以提供**一个**样式类，赋予 view 的 hover-class ，这个样式类本身写在页面中而非 view 组件的实现中。

> **注意**：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。

```js
\* 组件 custom-component.js *\
Component({
  externalClasses: ['my-class']
})
```

```wxml
<!-- 组件 custom-component.wxml -->
<custom-component class="my-class">这段文本的颜色由组件外的 class 决定<\custom-component>
```

这样，组件的使用者可以指定这个样式类对应的 class ，就像使用普通属性一样。在 2.7.1 之后，可以指定多个对应的 class 。

**引用页面或父组件的样式**:

> 基础库 2.9.2 开始支持，低版本需做 [兼容处理](compatibility)。

即使启用了样式隔离 **isolated** ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。

例如，如果在页面 wxss 中定义了：

```wxss
.blue-text {
  color: blue;
}
```

在这个组件中可以使用 `~` 来引用这个类的样式：

```wxml
<view class="~blue-text"> 这段文本是蓝色的 <\text>
```

如果在一个组件的父组件 wxss 中定义了：

```wxss
.red-text {
  color: red;
}
```

在这个组件中可以使用 `^` 来引用这个类的样式：

```wxml
<view class="^red-text"> 这段文本是红色的 <\view>
```

也可以连续使用多个 `^` 来引用祖先组件中的样式。

> 注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。

**虚拟化组件节点**:

> 基础库 2.11.2 开始支持，低版本需做兼容处理。

默认情况下，自定义组件本身的那个节点是一个"普通"的节点，使用时可以在这个节点上设置 **class**、**style** 、**动画**、 **flex** 布局等，就如同普通的 view 组件节点一样。

但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex 布局等，而是希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定。

这种情况下，可以将这个自定义组件设置为"虚拟的"：

```js
Component({
  options: {
    virtualHost: true
  },
  properties: {
    style: { \\ 定义 style 属性可以拿到 style 属性上设置的值
      type: String
    }
  },
  externalClasses:['my-class']
})
```

这样，可以将 flex 放入自定义组件内：

```wxml
<!-- 页面的 WXML -->
<view style="display: flex">
  <!-- 如果设置了 virtualHost ，节点上的样式将失效 -->
  <custom-component class="my-class" style="color: blue">不是蓝色的<\custom-component>
<\view>
```

```wxml
<!-- custom-component.wxml -->
<view style="flex: 1">
  <text>满宽的<\text>
  <slot><\slot>
<\view>
```

> 需要注意的是
>
> 1. 自定义组件节点上的 **class** **style** 和 **动画** 将不再生效
> 2. 将 style 定义成 `properties` 属性来获取 style 上设置的值
> 3. 将 class 定义成 `externalClasses` 外部样式类使得自定义组件 wxml 可以使用 class 值。

### 4.2 Component 构造器

`Component` 构造器可用于定义组件，调用 `Component` 构造器时可以指定组件的属性、数据、方法等。

```js
Component({

  behaviors: [],

  properties: {
    myProperty: { \\ 属性名
      type: String,
      value: ''
    },
    myProperty2: String \\ 简化的定义方式
  },

  data: {}, \\ 私有数据，可用于模板渲染

  lifetimes: {
    \\ 生命周期函数，可以为函数，或一个在methods段中定义的方法名
    attached: function () { },
    moved: function () { },
    detached: function () { },
  },

  pageLifetimes: {
    \\ 组件所在页面的生命周期函数
    show: function () { },
    hide: function () { },
    resize: function () { },
  },

  methods: {
    onMyButtonTap: function(){
      this.setData({
        \\ 更新属性和数据的方法与更新页面数据的方法类似
      })
    },
    \\ 内部方法建议以下划线开头
    _myPrivateMethod: function(){
      \\ 这里将 data.A[0].B 设为 'myPrivateData'
      this.setData({
        'A[0].B': 'myPrivateData'
      })
    }
  }

})
```

**使用 Component 构造器构造页面**
事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 `Component` 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 *json* 文件中包含 `usingComponents` 定义段。

此时，组件的属性可以用于接收页面的参数，如访问页面 **\pages\index\index?paramA=123&paramB=xyz** ，如果声明有属性 **paramA** 或 **paramB** ，则它们会被赋值为 123 或 xyz 。

页面的生命周期方法（即 `on` 开头的方法），应写在 `methods` 定义段中。

```js
Component({
  properties: {
    paramA: Number,
    paramB: String
  },

  methods: {
    onLoad: function() {
      this.data.paramA \\ 页面参数 paramA 的值
      this.data.paramB \\ 页面参数 paramB 的值
    }
  }
})
```

使用 Component 构造器来构造页面的一个好处是可以使用 `behaviors` 来提取所有页面中公用的代码段。

例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 `behaviors` 中。

```js
\\ page-common-behavior.js
module.exports = Behaviors({
  attached: function() {
    \\ 页面创建时执行
    console.info('Page loaded!')
  },
  detached: function() {
    \\ 页面销毁时执行
    console.info('Page unloaded!')
  }
})
```

```js
\\ 页面 A 或 B
var pageCommonBehavior = require(".\page-common-behavior");
Component({
  behavior: [pageCommonBehavior],
  data: { ... },
  methods: { ... }
})
```

### 4.3 组件间通信与事件

**组件间通信**
组件间的基本通信方式有以下几种：

- **WXML 数据绑定** ：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 [组件模板和样式](#41-组件模板与样式)
- **事件** ：用于子组件向父组件传递数据，可以传递任意数据。
- 如果以上两种方式不足以满足需要，父组件还可以通过 `this.selectComponent` 方法获取子组件实例对象，这样就可以直接访问子组件的任意数据和方法。

**监听事件**
事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见 [事件系统](#234-事件系统)

监听自定义组件事件的方法与监听基础组件事件的方法完全一致。

**触发自定义事件**
自定义组件触发事件时，需要使用 `triggerEvent` 方法，指定 事件名、detail对象 和 事件选项：

```wxml
<!-- 在自定义组件中 -->
<button bindtap="onTap">点击这个按钮将触发"myEvent"事件<\button>
```

```js
Component({
  properties: {},
  methods: {
    onTap: function() {
      var myEventDetail = {}; \\ detail对象，提供给事件监听函数
      var myEventOption = {}; \\ 触发事件的选项
      this.triggerEvent("myEvent", myEventDetail, myEventOption);
    }
  }
})
```

触发事件的选项包括：

选项名 | 类型 | 是否必填 |默认值 | 描述
------|------|---------|-------|------
bubbles | Boolean | 否 | false | 事件是否冒泡
composed | Boolean | 否 | false | 事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部
captruePhase | Boolean | 否 | false | 事件是否拥有捕获阶段

```wxml
\\ 页面 page.wxml
<another-component bindcustomevent="pageEventListener1">
  <my-component bindcustomevent="pageEventListener2"><\my-component>
<\another-component>
```

```wxml
\\ 组件 another-component.wxml
<view bindcustomevent="anotherEventListener">
  <slot \>
<\view>
```

```wxml
\\ 组件 my-component.wxml
<view bindcustomevent="myEventListener">
  <slot \>
<\view>
```

```js
\\ 组件 my-component.js
Component({
  methods: {
    onTap: function() {
      this.triggerEvent('customevent', {}) \\ 只会触发 pageEventListener2
      this.triggerEvent('customevent', {}, { bubbles: true }) \\ 会依次触发 pageEventListener2 、 pageEventListener1
      this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) \\ 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
    }
  }
})
```

**获取组件实例**
可在父组件里调用 `this.selectComponent` ，获取子组件的实例对象。（插件的自定义组件将返回 null）

调用时需要传入一个匹配选择器 `selector`，如：this.selectComponent(".my-component")。

`selector` 类似于 CSS 的选择器，但仅支持下列语法。

- ID选择器：`#the-id`
- class选择器（可以连续指定多个）：`.a-class.another-class`
- 子元素选择器：`.the-parent > .the-child`
- 后代选择器：`.the-ancestor` `.the-descendant`
- 跨自定义组件的后代选择器：`.the-ancestor >>> .the-descendant`
- 多选择器的并集：`#a-node, .some-other-nodes`

```js
\\ 父组件
Page({
  data: {},
  getChildComponent: function() {
    const child = this.selectComponent(".my-component");
    console.log(child);
  }
})
```

在上例中，父组件将会获取 `class` 为 `my-component` 的子组件实例对象，即子组件的 `this` 。

若需要自定义 `selectComponent` 返回的数据，可使用内置 `behavior: wx:\\component-export`，从基础库版本 2.2.3 开始提供支持。

使自定义组件中支持 `export` 定义段，这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值。

```js
\\ 自定义组件 my-component 内部
Component({
  behavior: ['wx:\\component-export'],
  export: function() {
    return { myField: 'myValue' }
  }
})
```

```wxml
<!-- 使用自定义组件时 -->
<my-component id="the-id" \>
```

```js
\\ 父组件调用
const child = this.selectComponent('#the-id') \\ 等于 { myField: 'myValue' }
```

### 4.4 组件生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

其中，最重要的生命周期是 `created` `attached` `detached` ，包含一个组件实例生命流程的最主要时间点。

- 组件实例刚刚被创建好时， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 `setData`** 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。
- 在组件完全初始化完毕、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
- 在组件离开页面节点树后， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发。

**定义生命周期方法**
生命周期方法可以直接定义在 `Component` 构造器的第一级参数中。
自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。

```js
Component({
  lifetimes: {
    created: function() {
      \\ 组件实例刚刚被创建好时执行
    },
    attached: function() {
      \\ 在组件实例进入页面节点树时执行
    },
    detached: function() {
      \\ 在组件实例被从页面节点树移除时执行
    }
  },
  \\ 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {},
  detached: function() {},
  \\ ...
})
```

在 `behaviors` 中也可以编写生命周期方法，同时不会与其他 `behaviors` 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。

可用的全部生命周期如下表所示。

生命周期 | 参数 | 描述 | 最低版本
--------|------|------|--------
created | 无 | 在组件实例刚刚被创建时执行 | 1.6.3
attached | 无 | 在组件实例进入页面节点树时执行 | 1.6.3
ready | 无 | 在组件在视图层布局完成后执行 | 1.6.3
moved | 无 |  在组件实例被移动到节点树另一个位置时执行 | 1.6.3
detached | 无 | 在组件实例被从页面节点树移除时执行 | 1.6.3
error | Object Error | 每当组件方法抛出错误时执行 | 2.4.1

**组件所在页面的声明周期**
还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为 "组件所在页面的生命周期"，在 `pageLifetimes` 定义段中定义。其中可用的生命周期包括：

生命周期 | 参数| 描述 | 最低版本
--------|-----|-----|---------
show | 无 | 组件所在的页面被展示时执行 | 2.2.3
hide | 无 | 组件所在的页面被隐藏时执行 | 2.2.3
resize | Object Size | 组件所在的页面尺寸变化时执行 | 2.4.0

```js
Component({
  pageLifetimes: {
    show: function() {
      \\  页面被展示
    },
    hide: function() {
      \\ 页面被隐藏
    },
    resize: function() {
      \\ 页面尺寸变化
    }
  }
})
```

### 4.5 behaviors

`behaviors` 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。

每个 `behavior` 可以包含一组 属性、数据、生命周期函数 和 方法。**组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。** 每个组件可以引用多个 behavior ，behavior 也可以引用其它 behavior 。

#### 4.5.1 参数与含义

定义段 | 类型 | 是否必填 | 描述
------|------|----------|-----
properties | Object Map | 否 | 同组件的属性
data | Object | 否 | 同组件的数据
methods | Object | 否 | 同自定义组件的方法
behaviors | String Array | 否 | 引入其它的 behavior
created | Function | 否 | 在组件实例刚刚被创建时执行
attached | Function | 否 | 进入页面节点树时执行
ready | Function | 否 | 在视图层布局完成后执行
moved | Function | 否  | 被移动到节点树另一个位置时执行
detached | Function | 否 | 被从页面节点树移除时执行

```js
\\ my-behavior.js
module.exports = Behaviors({
  behaviors: [],
  properties: {
    myBehaviorProperty: function() {
      type: String
    }
  },
  data: {
    myBehaviorData: {}
  },
  attached: function() {},
  created: function() {},
  ready: function() {},
  methods: {
    myBehaviorMethod: function(){}
  }
})
```

```js
\\ my-component.js
var myBehavior = require('my-behavior')
Component({
  behaviors: [myBehavior],
  properties: {
    myProperty: {
      type: String
    }
  },
  data: {
    myData: "my-component-data"
  },
  created: function() {
    console.log('[my-component] created')
  },
  attached: function () {
    console.log('[my-component] attached')
  },
  ready: function () {
    console.log('[my-component] ready')
  },
  methods: {
    myMethod: function() {
      console.log('[my-component] log by myMethod')
    }
  }
})
```

在上例中， my-component 组件定义中加入了 my-behavior，

而 my-behavior 结构为：

- 属性：myBehaviorProperty
- 数据字段：myBehaviorData
- 方法：myBehaviorMethod
- 生命周期函数：attached、created、ready

这将使 my-component 最终结构为：

- 属性：myBehaviorProperty、myProperty
- 数据字段：myBehaviorData、myData
- 方法：myBehaviorMethod、myMethod
- 生命周期函数：attached、created、ready

当组件触发生命周期时，上例生命周期函数执行顺序为：

- [my-behavior] created
- [my-component] created
- [my-behavior] attached
- [my-component] attached
- [my-behavior] ready
- [my-component] ready

详细规则参考下面的 同名字段的覆盖和组合规则。

**同名字段的覆盖和组合规则**
组件和它引用的 `behavior` 中可以包含同名的字段，对这些字段的处理方法如下：

- 如果有同名的属性 (properties) 或方法 (methods)：
  1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 behavior 中的同名属性或方法；
  2. 若组件本身无这个属性或方法，则在组件的 behaviors 字段中定义靠后的 behavior 的属性或方法会覆盖靠前的同名属性或方法；
  3. 在 2 的基础上，若存在嵌套引用 behavior 的情况，则规则为：父 behavior 覆盖 子 behavior 中的同名属性或方法。
- 如果有同名的数据字段 (data)：
  - 若同名的数据字段都是对象类型，会进行对象合并；
  - 其余情况会进行数据覆盖，覆盖规则为：组件 > 父 behavior > 子 behavior 、 靠后的 behavior > 靠前的 behavior。（优先级高的覆盖优先级低的，最大的为优先级最高）
- 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：
  - 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序
  - 对于同种生命周期函数，遵循如下规则：
    - behavior 优先于组件执行
    - 子 behavior 优先于 父 behavior 执行
    - 靠前的 behavior 优先于 靠后的 behavior 执行
  - 如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次

#### 4.5.2 内置 behaviors

自定义组件可以通过引用内置的 `behavior` 来获得内置组件的一些行为。

```js
Component({
  behaviors: ['wx:\\form-field']
})
```

在上例中， `wx:\\form-field` 代表一个内置 `behavior` ，它使得这个自定义组件有类似于表单控件的行为。

内置 `behavior` 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的 `type` 或添加 `observer` 。

- **wx:\\form-field**
  使自定义组件有类似于表单控件的行为。 form 组件可以识别这些自定义组件，并在 submit 事件中返回组件的字段名及其对应字段值。这将为它添加以下两个属性。

  属性名 | 类型 | 字段
  ------|------|------
  name | String | 在表单中的字段名
  value | Any | 在表单中的字段值

  ```js
  Component({
    behaviors: ['wx:\\form-field'],
    data: {
      value: ''
    },
    methods: {
      onChange: function(e) {
        this.setData({
          value: e.detail.value
        })
      }
    }
  })
  ```

- **wx:\\form-field-group**
  从基础库版本 2.10.2 开始提供支持。
  使 form 组件可以识别到这个自定义组件内部的所有表单控件。 例如，页面的结构如下：

  ```wxml
  <form bindsubmit="submit">
    <custom-comp><\custom-comp>
    <button form-type="submit">submit<\button>
  <\form>
  ```

  组件 **custom-comp** 自身结构如下：

  ```wxml
  <input name="name">
  <switch name="student"><\switch>
  ```

  如果组件 **custom-comp** 配置有：

  ```js
  Component({
    behaviors: ['wx:\\form-field-group']
  })
  ```

  此时，表单的 **submit** 事件的 value 中将包含 `name` 和 `student` 两个字段。

- **wx:\\form-field-button**
  从基础库版本 2.10.3 开始提供支持。
  使 form 组件可以识别到这个自定义组件内部的 button 。如果自定义组件内部有设置了 **form-type** 的 button ，它将被组件外的 form 接受。 例如，页面的结构如下：

  ```wxml
  <form>
    <input name="name" placeholder="请输入名字" \>
    <custom-comp><\custom-comp>
  <\form>
  ```

  组件 **custom-comp** 自身结构如下：

  ```wxml
  <button form-type="submit">submit<\button>
  ```

  如果组件 custom-comp 配置有：

  ```js
  Component({
    behaviors: ['wx:\\form-field-button']
  })
  ```

  此时点击组件内的 button ，将触发 form 的 submit 事件。

- **wx:\\component-export**
  从基础库版本 2.2.3 开始提供支持。
  使自定义组件支持 `export` 定义段。这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值。
  详细用法 [selectComponent](#43-组件间通信与事件)

### 4.6 组件间关系

#### 4.6.1 定义和使用组件间关系

有时需要实现这样的组件：

```wxml
<custom-ul>
  <custom-li> item 1 <\custom-li>
  <custom-li> item 2 <\custom-li>
<\custom-ul>
```

这个例子中， custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入 `relations` 定义段，可以解决这样的问题。示例：

```js
\\ path\to\custom-ul.js
Component({
  relations: {
    '.\custom-li': {
      type: 'child', \\ 关联的目标节点应为子节点
      linked: function(target) {
        \\ 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
      },
      linkChanged: function(target) {
        \\ 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
      },
      unlinked: function(target) {
        \\ 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
      }
    }
  },
  methods: {
    _getAllLi: function() {
      \\ 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
      var nodes = this.getRelationNodes('.\custom-li-component');
    }
  },
  ready: function() {
    this._getAllLi();
  }
})
```

```js
\\ path\to\custom-li.js
Component({
  relations: {
    '.\custom-ul': {
      type: "parent",
      linked: function(target) {
        \\ 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
      },
      linkChanged: function(target) {
        \\ 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
      },
      unlinked: function(target) {
        \\ 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
      }
    }
  }
})
```

> 注意：必须在两个组件定义中都加入relations定义，否则不会生效。

#### 4.6.2 关联一类组件

有时，需要关联的是一类组件，如：

```wxml
<custom-from>
  <view>
    <text>input<\text>
    <custom-input><\custom-input>
  <\view>
  <custom-submit> submit <\submit-submit>
<\custom-from>
```

`custom-form` 组件想要关联 `custom-input` 和 `custom-submit` 两个组件。此时，如果这两个组件都有同一个 `behavior`：

```js
\\ path\to\custom-submit.js
var customFormControls = require('.\custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    '.\custom-form': {
      type: 'ancestor' \\ 关联的目标节点应为祖先节点
    }
  }
})
```

则在 `relations` 关系定义中，可使用这个 `behavior` 来代替组件路径作为关联的目标节点：

```wxml
\\ path\to\custom-form.js
var customFormControls = require('.\custom-form-controls')
Component({
  relations: {
    'customFormControls': {
      type: 'descendant', \\ 关联的目标节点应为子孙节点
      target: customFormControls \\ 替组件路径作为关联的目标节点
    }
  }
})
```

#### 4.6.3 relations 定义段

`relations` 定义段包含目标组件路径及其对应选项，可包含的选项见下表。

选项 | 类型 | 是否必填 | 描述
----|------|----------|-----
type | String | 是 | 目标组件的相对关系，可选的值为 `parent` 、 `child` 、 `ancestor` 、 `descendant`
linked | Function | 否 | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件attached生命周期之后
linkChanged | Function | 否 | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件moved生命周期之后
unlinked | Function | 否 | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件detached生命周期之后
target | String | 否 | 如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联

### 4.7 数据监听器

数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。

**使用数据监听器**
有时，在一些数据字段被 `setData` 设置时，需要执行一些操作。

例如， this.data.sum 永远是 this.data.numberA 与 this.data.numberB 的和。此时，可以使用数据监听器进行如下实现。

```js
Component({
  attached: function() {
    this.setData({
      numberA: 1,
      numberB: 2
    })
  },
  observers: {
    'numberA, numberB': function(numberA, numberB) {
      \\ 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    }
  }
})
```

**监听字段语法**
数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。

同时，监听器可以监听子数据字段，如下例所示。

```js
Component({
  observers: {
    'some.subfield': function(subfield) {
      \\ 使用 setData 设置 this.data.some.subfield 时触发
      \\ （除此以外，使用 setData 设置 this.data.some 也会触发）
      console.log(subfield === this.data.some.subfield);
    },
    'arr[12]': function(arr12) {
      \\ 使用 setData 设置 this.data.arr[12] 时触发
      \\ （除此以外，使用 setData 设置 this.data.arr 也会触发）
      console.log(arr12 === this.data.arr[12]);
    }
  }
})
```

如果需要监听所有子数据字段的变化，可以使用通配符 `**` 。

```js
Component({
  observers: {
    'some.field.**': function(field) {
      \\ 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      \\ （除此以外，使用 setData 设置 this.data.some 也会触发）
      console.log(field === this.data.some.field);
    }
  },
  attached: function() {
    \\ 这样会触发上面的 observer
    this.setData({
      'some.field': { \* ... *\ }
    })
    \\ 这样也会触发上面的 observer
    this.setData({
      'some.field.xxx': { \* ... *\ }
    })
    \\ 这样还是会触发上面的 observer
    this.setData({
      'some': { \* ... *\ }
    })
  }
})
```

特别地，仅使用通配符 `**` 可以监听全部 `setData`

```js
Component({
  observers: {
    '**': function() {
      \\ 每次 setData 都触发
    },
  },
})
```

**Bugs & Tips**:

- 数据监听器监听的是 `setData` 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
- 如果在数据监听器函数中使用 `setData` 设置本身监听的数据字段，可能会导致死循环，需要特别留意。
- 数据监听器和属性的 `observer` 相比，数据监听器更强大且通常具有更好的性能。

### 4.8 纯数据字段

纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能。从小程序基础库版本 2.8.2 开始支持。

**组件数据中的纯数据字段**
有些情况下，某些 `data` 中的字段（包括 `setData` 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。

此时，可以指定这样的数据字段为 "纯数据字段"，它们将仅仅被记录在 `this.data` 中，而 **不参与任何界面渲染过程**，这样有助于提升页面更新性能。

指定 “纯数据字段” 的方法是在 `Component` 构造器的 `options` 定义段中指定 `pureDataPattern` 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

```js
Component({
  options: {
    pureDataPattern: \^_\ \\ 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true,
    _b: true \\ 纯数据字段
  },
  methods: function() {
    myMethod: function() {
      this.data._b \\ 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, \\ 普通数据字段
        _d: true, \\ 纯数据字段
      })
    }
  }
})
```

**组件属性中的纯数据字段**
属性也可以被指定为纯数据字段（遵循 pureDataPattern 的正则表达式）。

属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的 WXML 中。

```js
Component({
  options: {
    pureDataPattern: \^_\
  },
  properties: {
    a: Boolean,
    _b: {
      type: Boolean,
      observer() {
        \\ 不要这样做！这个 observer 永远不会被触发
      }
    }
  }
})
```

> 注意：属性中的纯数据字段的属性 `observer` 永远不会触发！如果想要监听属性值变化，使用 数据监听器 代替。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 `pureDataPattern` （这样就不需在 js 文件的 options 中再配置）。此时，其值应当写成字符串形式：

```js
"pureDataPattern": "^_"
```

**使用数据监听器监听纯数据字段**
数据监听器 可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

下面的示例是一个将 JavaScript 时间戳转换为可读时间的自定义组件。

```js
Component({
  options: {
    pureDataPattern: /^timestamp$/
  },
  properties: {
    timestamp: Number
  },
  observers: {
    timestamp: function() {
      // timestamp 被设置时，将它展示为可读时间字符串
      var timeString = new Date(this.data.timestamp).toLocaleString();
      this.setData({
        timestamp: timeString
      })
    }
  }
})
```
