---
title : 微信小程序
author: dsy
keyword: "wxml wxss wxs 小程序框架"
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [微信小程序](#微信小程序)
  - [一. 基础](#一-基础)
    - [1.1 申请账号并预览小程序](#11-申请账号并预览小程序)
    - [1.2 小程序代码构成](#12-小程序代码构成)
      - [1.2.1 JSON 配置](#121-json-配置)
        - [1.2.1.1 全局配置 app.js](#1211-全局配置-appjs)
        - [1.2.1.2 工具配置 project.config.json](#1212-工具配置-projectconfigjson)
        - [1.2.1.3 页面配置 page.json](#1213-页面配置-pagejson)
        - [1.2.1.4 网站地图配置 sitemap.json](#1214-网站地图配置-sitemapjson)
        - [1.2.1.5 JSON 语法注意事项](#1215-json-语法注意事项)
      - [1.2.2 WXML 模板](#122-wxml-模板)
      - [1.2.3 WXSS 样式](#123-wxss-样式)
      - [1.2.4 JS 逻辑交互](#124-js-逻辑交互)
    - [1.3 小程序宿主环境](#13-小程序宿主环境)
      - [1.3.1 渲染层和逻辑层](#131-渲染层和逻辑层)
      - [1.3.2 程序与页面](#132-程序与页面)
      - [1.3.3 组件](#133-组件)
      - [1.3.4 API](#134-api)
    - [1.4 小程序协同工作与发布](#14-小程序协同工作与发布)
      - [1.4.1 小程序的版本](#141-小程序的版本)
      - [1.4.2 发布上线](#142-发布上线)
      - [1.4.3 运营数据](#143-运营数据)
    - [1.5 目录结构](#15-目录结构)
  - [二. 小程序框架](#二-小程序框架)
    - [2.1 场景值](#21-场景值)
    - [2.2 逻辑层](#22-逻辑层)
      - [2.2.1 注册小程序实例](#221-注册小程序实例)
      - [2.2.2 注册页面](#222-注册页面)
        - [2.2.2.1 使用 Page 构造器注册页面](#2221-使用-page-构造器注册页面)
        - [2.2.2.2 在页面中使用 behaviors](#2222-在页面中使用-behaviors)
        - [2.2.2.3 使用 Component 构造器构造页面](#2223-使用-component-构造器构造页面)
      - [2.2.3 页面生命周期](#223-页面生命周期)
      - [2.2.4 页面路由](#224-页面路由)
      - [2.2.5 模块化](#225-模块化)
      - [2.2.6 API](#226-api)
    - [2.3 视图层](#23-视图层)
      - [2.3.1 WXML](#231-wxml)
        - [2.3.1.1 数据绑定](#2311-数据绑定)
        - [2.3.1.2 列表渲染](#2312-列表渲染)
        - [2.3.1.3 条件渲染](#2313-条件渲染)
        - [2.3.1.4 模板](#2314-模板)
        - [2.3.1.5 引用](#2315-引用)
      - [2.3.2 WXSS](#232-wxss)
      - [2.3.3 WXS 语法参考](#233-wxs-语法参考)
        - [2.3.3.1 模块](#2331-模块)
        - [2.3.3.2 变量](#2332-变量)
        - [2.3.3.3 注释](#2333-注释)
        - [2.3.3.4 运算符](#2334-运算符)
        - [2.3.3.5 数据类型](#2335-数据类型)
        - [2.3.3.6 基础类库](#2336-基础类库)
      - [2.3.4 事件系统](#234-事件系统)
        - [2.3.4.1 事件的使用方式](#2341-事件的使用方式)
        - [2.3.4.2 事件详解](#2342-事件详解)
        - [2.3.4.3 事件对象](#2343-事件对象)
        - [2.3.4.4 使用WXS函数响应事件](#2344-使用wxs函数响应事件)
      - [2.3.5 简易双向绑定](#235-简易双向绑定)
      - [2.3.6 基础组件](#236-基础组件)
      - [2.3.7 获取界面上的信息节点](#237-获取界面上的信息节点)
      - [2.3.8 响应显示区域的变化](#238-响应显示区域的变化)
      - [2.3.9 动画](#239-动画)
      - [2.3.10 初始渲染缓存](#2310-初始渲染缓存)
    - [2.4 框架接口](#24-框架接口)
      - [2.4.1 小程序App](#241-小程序app)
        - [2.4.1.1  App](#2411-app)
        - [2.4.1.2 getApp](#2412-getapp)
      - [2.4.2 页面](#242-页面)
        - [2.4.2.1 Page](#2421-page)
        - [2.4.2.2 getCurrentPages](#2422-getcurrentpages)
      - [2.4.3 自定义页面组件](#243-自定义页面组件)
        - [2.4.3.1 Component](#2431-component)
        - [2.4.3.2 Behavior](#2432-behavior)
      - [2.4.4 基础功能](#244-基础功能)
        - [2.4.4.1 wx](#2441-wx)
        - [2.4.4.2 env](#2442-env)
        - [2.4.4.3 console](#2443-console)
      - [2.4.5 定时器](#245-定时器)
        - [2.4.5.1 一次性定时器](#2451-一次性定时器)
        - [2.4.5.2 循环定时器](#2452-循环定时器)
  - [三. 小程序运行时](#三-小程序运行时)
    - [3.1 运行环境](#31-运行环境)
    - [3.2 JavaScript 支持情况](#32-javascript-支持情况)
    - [3.3 运行机制](#33-运行机制)
    - [3.4 更新机制](#34-更新机制)
  - [四. 自定义组件](#四-自定义组件)
    - [4.1 组件模板与样式](#41-组件模板与样式)
    - [4.2 Component 构造器](#42-component-构造器)
    - [4.3 组件间通信与事件](#43-组件间通信与事件)
    - [4.4 组件生命周期](#44-组件生命周期)
    - [4.5 behaviors](#45-behaviors)
      - [4.5.1 参数与含义](#451-参数与含义)
      - [4.5.2 内置 behaviors](#452-内置-behaviors)
    - [4.6 组件间关系](#46-组件间关系)
      - [4.6.1 定义和使用组件间关系](#461-定义和使用组件间关系)
      - [4.6.2 关联一类组件](#462-关联一类组件)
      - [4.6.3 relations 定义段](#463-relations-定义段)
    - [4.7 数据监听器](#47-数据监听器)
    - [4.8 纯数据字段](#48-纯数据字段)
    - [4.9 抽象节点](#49-抽象节点)
    - [4.10 自定义组件扩展](#410-自定义组件扩展)
    - [4.11 单元测试](#411-单元测试)
    - [4.12 获取更新性能统计信息](#412-获取更新性能统计信息)
  - [五. 基础能力](#五-基础能力)
    - [5.1 网络](#51-网络)
      - [5.1.1 使用说明](#511-使用说明)
      - [5.1.2 局域网通信](#512-局域网通信)
    - [5.2 存储](#52-存储)
    - [5.3 文件系统](#53-文件系统)
    - [5.4 画布](#54-画布)
      - [5.4.1 坐标系](#541-坐标系)
      - [5.4.2 渐变](#542-渐变)
    - [5.5 分包加载](#55-分包加载)
      - [5.5.1 使用分包](#551-使用分包)
      - [5.5.2 独立分包](#552-独立分包)
      - [5.5.3 分包预下载](#553-分包预下载)
    - [5.6 多线程Worker](#56-多线程worker)
    - [5.7 服务端能力](#57-服务端能力)
      - [5.7.1 服务端API](#571-服务端api)
      - [5.7.2 消息推送](#572-消息推送)
        - [5.7.2.1 开发者服务器接收消息推送](#5721-开发者服务器接收消息推送)
        - [5.7.2.2 云函数接收消息推送](#5722-云函数接收消息推送)
    - [5.8 自定义 tabBar](#58-自定义-tabbar)
    - [5.9 周期性更新](#59-周期性更新)
    - [5.10 数据预拉取](#510-数据预拉取)
    - [5.11 DarkModel 适配指南](#511-darkmodel-适配指南)
    - [5.12 大屏适配指南](#512-大屏适配指南)
  - [六. 硬件能力](#六-硬件能力)
    - [6.1 蓝牙](#61-蓝牙)
    - [6.2 NFC](#62-nfc)
    - [6.3 WI-FI](#63-wi-fi)
  - [七. 开放能力](#七-开放能力)
    - [7.1 用户信息](#71-用户信息)
      - [7.1.1 小程序登录](#711-小程序登录)
      - [7.1.2 UnionID 机制说明](#712-unionid-机制说明)
      - [7.1.3 授权](#713-授权)
      - [7.1.4 开放数据校验与解密](#714-开放数据校验与解密)
        - [7.1.4.1 开发者后台校验与解密开放数据](#7141-开发者后台校验与解密开放数据)
        - [7.1.4.2 云调用直接获取开放数据](#7142-云调用直接获取开放数据)
      - [7.1.5 获取手机号](#715-获取手机号)
      - [7.1.7 生物认证](#717-生物认证)
    - [7.2 转发](#72-转发)
      - [7.2.1 转发](#721-转发)
      - [7.2.2 动态消息](#722-动态消息)
      - [7.2.3 小程序私密消息](#723-小程序私密消息)
    - [7.3 收藏](#73-收藏)
    - [7.4 多人音视频通话](#74-多人音视频通话)
    - [7.5 打开APP](#75-打开app)
    - [7.6 消息](#76-消息)
      - [7.6.1 订阅消息](#761-订阅消息)
      - [7.6.2 统一服务消息](#762-统一服务消息)
      - [7.6.3 客服消息](#763-客服消息)
        - [7.6.3.1 概述](#7631-概述)
        - [7.6.3.2 接收消息和事件](#7632-接收消息和事件)
          - [7.6.3.2.1 文本消息](#76321-文本消息)
          - [7.6.3.2.2 图片消息](#76322-图片消息)
          - [7.6.3.2.3 小程序卡片消息](#76323-小程序卡片消息)
          - [7.6.3.2.4 进入会话事件](#76324-进入会话事件)
        - [7.6.3.3 发送消息](#7633-发送消息)
        - [7.6.3.4 转发消息](#7634-转发消息)
        - [7.6.3.5 下发客服输入状态](#7635-下发客服输入状态)
        - [7.6.3.6 临时素材](#7636-临时素材)
      - [7.6.4 位置消息](#764-位置消息)
    - [7.7 获取小程序码](#77-获取小程序码)
    - [7.8 获取URL scheme](#78-获取url-scheme)
    - [7.9 数据分析](#79-数据分析)
  - [八. 安全指引](#八-安全指引)
    - [8.1 开发原则与注意事项](#81-开发原则与注意事项)
    - [8.2 通用](#82-通用)
      - [8.2.1 接口鉴权](#821-接口鉴权)
      - [8.2.2 代码管理与泄漏](#822-代码管理与泄漏)
      - [8.2.3 信息泄露](#823-信息泄露)
    - [8.3 后台](#83-后台)
      - [8.3.1 注入漏洞](#831-注入漏洞)
      - [8.3.2 弱口令](#832-弱口令)
      - [8.3.3 文件上传漏洞](#833-文件上传漏洞)
      - [8.3.4 文件下载](#834-文件下载)
      - [8.3.5 目录遍历](#835-目录遍历)
      - [8.3.6 条件竞争](#836-条件竞争)
    - [8.4 安全风控](#84-安全风控)
  - [九. 调试](#九-调试)
  - [十. 性能与体验](#十-性能与体验)
    - [10.1 启动性能](#101-启动性能)
      - [10.1.1 启动流程](#1011-启动流程)
        - [10.1.1.1 资源准备](#10111-资源准备)
        - [10.1.1.2 开发者代码注入（逻辑层）](#10112-开发者代码注入逻辑层)
        - [10.1.1.3 开发者代码注入（渲染层）](#10113-开发者代码注入渲染层)
        - [10.1.1.4  首页（初次）渲染](#10114-首页初次渲染)
      - [10.1.2 关键概念](#1012-关键概念)
      - [10.1.3 启动性能优化](#1013-启动性能优化)
      - [10.1.4 启动性能分析](#1014-启动性能分析)
    - [10.2 运行时性能](#102-运行时性能)
    - [10.3 性能分析工具](#103-性能分析工具)
    - [10.4 体验评分](#104-体验评分)
      - [10.4.1 简介](#1041-简介)
      - [10.4.2 评分方法与规则](#1042-评分方法与规则)
      - [10.4.3 性能](#1043-性能)
      - [10.4.4 体验](#1044-体验)
      - [10.4.5 最佳实践](#1045-最佳实践)
  - [十一. 基础库](#十一-基础库)
    - [11.1 低版本兼容](#111-低版本兼容)
  - [十二. 实时日志](#十二-实时日志)
  - [十三. 小程序测速](#十三-小程序测速)
  - [十四. 小程序搜索](#十四-小程序搜索)
    - [14.1 小程序搜索优化指南](#141-小程序搜索优化指南)
  - [十五. 设计](#十五-设计)

<!-- /code_chunk_output -->

[api]: https://developers.weixin.qq.com/miniprogram/dev/api/
[组件]: https://developers.weixin.qq.com/miniprogram/dev/component/
[服务端]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/
[消息加解密说明]: https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/Message_Encryption/Message_encryption_and_decryption.html
[云开发]: https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html
[微信公众平台]: https://mp.weixin.qq.com/
[grid]: https://developers.weixin.qq.com/miniprogram/dev/extended/component-plus/grid.html

<!-- 组件 -->
[official-account]: https://developers.weixin.qq.com/miniprogram/dev/component/official-account.html
[camera]: https://developers.weixin.qq.com/miniprogram/dev/component/camera.html
[navigator]: https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html

[voip-room]: https://developers.weixin.qq.com/miniprogram/dev/component/voip-room.html
[canvas]: https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html
[CanvasContext]: https://developers.weixin.qq.com/miniprogram/dev/api/canvas/CanvasContext.html
[CanvasContext.createCircularGradient]: https://developers.weixin.qq.com/miniprogram/dev/api/canvas/CanvasContext.createCircularGradient.html
[CanvasContext.createLinearGradient]: https://developers.weixin.qq.com/miniprogram/dev/api/canvas/CanvasContext.createLinearGradient.html
[CanvasGradient.addColorStop]: https://developers.weixin.qq.com/miniprogram/dev/api/canvas/CanvasGradient.addColorStop.html

[Worker.postMessage]: https://developers.weixin.qq.com/miniprogram/dev/api/worker/Worker.postMessage.html
[Worker.onMessage]: https://developers.weixin.qq.com/miniprogram/dev/api/worker/Worker.onMessage.html

[wx.login]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html
[wx.request]: https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html
[wx.uploadFile]: https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/wx.uploadFile.html
[wx.downloadFile]: https://developers.weixin.qq.com/miniprogram/dev/api/network/download/wx.downloadFile.html
[wx.connectSocket]: https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.connectSocket.html
[wx.createUDPSocket]: https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/wx.createUDPSocket.html
[wx.startLocalServiceDiscovery]: https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.startLocalServiceDiscovery.html
[wx.setStorage]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorage.html
[wx.setStorageSync]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html
[wx.getStorage]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.getStorage.html
[wx.getStorageSync]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.getStorageSync.html
[wx.clearStorage]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.clearStorage.html
[wx.clearStorageSync]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.clearStorageSync.html
[wx.removeStorage]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.removeStorage.html
[wx.removeStorageSync]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.removeStorageSync.html
[wx.getFileSystemManager]: https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.getFileSystemManager.html
[wx.setBackgroundFetchToken]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.setBackgroundFetchToken.html
[wx.getBackgroundFetchData]: https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.getBackgroundFetchData.html
[wx.getUserInfo]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html
[wx.getSetting]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.getSetting.html
[wx.openSetting]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.openSetting.html
[wx.authorize]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorize.html
[wx.getLocation]: https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html
[wx.chooseLocation]: https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.chooseLocation.html
[wx.startLocationUpdateBackground]: https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.startLocationUpdateBackground.html
[wx.chooseAddress]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/address/wx.chooseAddress.html
[wx.chooseInvoiceTitle]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/invoice/wx.chooseInvoiceTitle.html
[wx.chooseInvoice]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/invoice/wx.chooseInvoice.html
[wx.getWeRunData]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/werun/wx.getWeRunData.html
[wx.startRecord]: https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/wx.startRecord.html
[wx.saveImageToPhotosAlbum]: https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.saveImageToPhotosAlbum.html
[wx.saveVideoToPhotosAlbum]: https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.saveVideoToPhotosAlbum.html
[wx.checkSession]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.checkSession.html
[wx.checkIsSupportSoterAuthentication]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/soter/wx.checkIsSupportSoterAuthentication.html
[wx.startSoterAuthentication]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/soter/wx.startSoterAuthentication.html
[wx.showShareMenu]: https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.showShareMenu.html
[wx.getShareInfo]: https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.getShareInfo.html
[wx.updateShareMenu]: https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.updateShareMenu.html
[wx.requestSubscribeMessage]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html
[subscribeMessage.send]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html
[wx.getPerformance]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/performance/wx.getPerformance.html
[wx.reportPerformance]: https://developers.weixin.qq.com/miniprogram/dev/api/open-api/performance/wx.reportPerformance.html
[wx.getSystemInfo]: https://developers.weixin.qq.com/miniprogram/dev/api/base/system/system-info/wx.getSystemInfo.html
[wx.getSystemInfoSync]: https://developers.weixin.qq.com/miniprogram/dev/api/base/system/system-info/wx.getSystemInfoSync.html
[wx.canIUse]: https://developers.weixin.qq.com/miniprogram/dev/api/base/wx.canIUse.html
[wx.getRealtimeLogManager]: https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getRealtimeLogManager.html
[wx.setNavigationBarTitle]: https://developers.weixin.qq.com/miniprogram/dev/api/ui/navigation-bar/wx.setNavigationBarTitle.html
[wx.navigateTo]: https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html

<!-- 实时语音 -->
[wx.authPrivateMessage]: https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.authPrivateMessage.html
[wx.joinVoIPChat]: https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.joinVoIPChat.html
[wx.exitVoIPChat]: https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.exitVoIPChat.html
[wx.updateVoIPChatMuteConfig]: https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.updateVoIPChatMuteConfig.html
[wx.onVoIPChatMembersChanged]: https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatMembersChanged.html
[wx.onVoIPChatInterrupted]: https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatInterrupted.html
[wx.onVoIPVideoMembersChanged]: https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPVideoMembersChanged.html
[wx.subscribeVoIPVideoMembers]: https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.subscribeVoIPVideoMembers.html

[wx.openBluetoothAdapter]: https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.openBluetoothAdapter.html
[wx.closeBluetoothAdapter]: https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.closeBluetoothAdapter.html
[wx.getBLEDeviceServices]: https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.getBLEDeviceServices.html
[wx.getBLEDeviceCharacteristics]: https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.getBLEDeviceCharacteristics.html

[wx.offThemeChange]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offThemeChange.html
[wx.onThemeChange]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onThemeChange.html
[wx.onAppShow]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppShow.html
[wx.onAppHide]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppHide.html
[wx.onError]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onError.html
[wx.onPageNotFound]: https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html

<!-- 文件管理器 -->
[FileSystemManager]: https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.html
[FileSystemManager.saveFile]: https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.saveFile.html
[FileSystemManager.copyFile]: https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.copyFile.html

[cloud.getWXContext]:https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-server-api/utils/getWXContext.html
[cloud.getVoIPSign]: https://developers.weixin.qq.com/minigame/dev/wxcloud/reference-server-api/open/getVoIPSign.html
[jump-miniprogram]: https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/staticstorage/jump-miniprogram.html
[msg-miniprogram]: https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/staticstorage/msg-miniprogram.html
[auth.code2Session]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html
[updatableMessage.createActivityId]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/updatable-message/updatableMessage.createActivityId.html
[updatableMessage.setUpdatableMsg]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/updatable-message/updatableMessage.setUpdatableMsg.html
[mydev]: https://developers.weixin.qq.com/miniprogram/dev/devtools/mydev.html

<!-- 客服消息 -->
[customerServiceMessage.send]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.send.html
[customerServiceMessage.getTempMedia]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.getTempMedia.html
[customerServiceMessage.setTyping]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.setTyping.html
[customerServiceMessage.uploadTempMedia]: https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.uploadTempMedia.html

# 微信小程序

---

## 一. 基础

**小程序与普通网页开发的区别**:

1. ​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。
2. 网页开发可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。
3. JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。
4. 小程序开发过程中需要面对的是两大操作系统 **iOS** 和 **Android** 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的

运行环境 | 逻辑层 | 渲染层
--------|-------|-------
iOS  | JavaScriptCore | WKWebView
安卓 | V8 | 定制内核
小程序开发工具 | NWJS | Chrome WebView

### 1.1 申请账号并预览小程序

进入 [小程序注册页](https://mp.weixin.qq.com/wxopen/waregister?action=step1) 根据指引填写信息和提交相应的资料，申请账号

在小程序管理平台，可以管理小程序的权限，查看数据报表，发布小程序等操作。

登录 [微信公众平台][微信公众平台] ，可以在菜单 "开发"-"开发设置"-"开发设置" 中看到小程序的 **AppID** 。

小程序的 AppID 相当于小程序平台的一个身份证，后续会在很多地方要用到 AppID （注意这里要区别于服务号或订阅号的 AppID）。

新建项目选择小程序项目，选择代码存放的硬盘路径，填入小程序的 AppID，给项目起名字，勾选 "不使用云服务"，点击新建，点击顶部菜单编译就可以在微信开发者工具中预览小程序。

### 1.2 小程序代码构成

#### 1.2.1 JSON 配置

JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的是静态配置的角色。
在项目的根目录有一个 *app.json*、*sitemap.json* 和 *project.config.json*，此外在 *pages/logs* 目录下还有一个 *logs.json*

##### 1.2.1.1 全局配置 app.js

app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。完整配置项说明参考 [小程序全局配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

以下是一个包含了部分常用配置选项的 app.json ：

```json
{
  "pages": [
    "pages/index/index",
    "pages/logs/index"
  ],
  "window": {
    "navigationBarTitleText": "Demo"
  },
  "tabBar": {
    "list": [{
      "pagePath": "pages/index/index",
      "text": "首页"
    }, {
      "pagePath": "pages/logs/index",
      "text": "日志"
    }]
  },
  "networkTimeout": {
    "request": 10000,
    "downloadFile": 10000
  },
  "debug": true
}
```

##### 1.2.1.2 工具配置 project.config.json

在工具上做的任何配置都会写入到 project.config.json，当重新安装工具或者换电脑工作时，只要载入同一个项目的代码包，开发者工具就自动会恢复到开发项目时的个性化配置。其他配置项细节可以参考文档 [开发者工具配置](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)

##### 1.2.1.3 页面配置 page.json

这里的 page.json 是用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。每一个小程序页面也可以使用同名 .json 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。例如: 顶部颜色、是否允许下拉刷新等等。完整配置项说明可以参考文档 [小程序页面配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)

```json
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

##### 1.2.1.4 网站地图配置 sitemap.json

微信现已开放小程序内搜索，可以通过 **sitemap.json** 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的**搜索词条触发**该索引时，小程序的页面将可能展示在搜索结果中。
爬虫访问小程序内页面时，会携带特定的 user-agent：mpcrawler 及 [场景值](#21-场景值)：1129。

当在小程序项目中设置了 sitemap 的配置文件（默认为 sitemap.json）时，便可在开发者工具控制台上显示当前页面是否被索引的调试信息
完整配置项说明参考 [小程序 sitemap 配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html)

所有页面都会被微信索引（默认情况）

```json
{
  "rules" : {
    "action" : "allow",
    "page" : "*"
  }
}
```

> 注意:
>
> 1. 若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。
> 2. 没有 sitemap.json 则默认所有页面都能被索引
> 3. {"action": "allow", "page": "*"} 是优先级最低的默认规则，未显式指明 "disallow" 的都默认被索引
> 4. sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false
> 5. sitemap 文件内容最大为 5120 个 UTF8 字符

##### 1.2.1.5 JSON 语法注意事项

1. JSON文件都是被包裹在一个大括号中 {}，通过key-value的方式来表达数据。
2. JSON的Key必须包裹在一个双引号中
3. JSON的值只能是以下几种数据格式，其他任何格式都会触发报错
    - 数字，包含浮点数和整数
    - 字符串，需要包裹在双引号中
    - boolean值，true 或者 false
    - 数组，需要包裹在方括号中 []
    - 对象，需要包裹在大括号中 {}
    - Null
4. JSON 文件中无法使用注释，试图添加注释将会引发报错。

#### 1.2.2 WXML 模板

在小程序中 WXML 充当的是类似 HTML 的角色。和 HTML 非常相似，WXML 由标签、属性等等构成。但是也有很多不一样的地方:

1. 小程序的 WXML 用的标签是 view, button, text 等等，这些标签是小程序包装好的基本能力，还提供了地图、视频、音频等等组件能力。
2. 多了一些 **wx:if** 这样的属性以及 **{{ }}** 这样的表达式
  现在提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理**状态**，然后再通过一种模板语法来描述状态和界面结构的关系即可。小程序的框架也是用到了这个思路。

WXML这样写

```wxml
<text>{{msg}}</text>
```

JS只需要管理状态即可

```js
this.setData({
  msg : "This is a cat"
})
```

通过 {{ }} 的语法把一个变量绑定到界面上，称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for 等控制能力，在小程序里边，这些控制能力都用 `wx:` 开头的属性来表达。详细的文档可以参考 [WXML](#231-wxml)

#### 1.2.3 WXSS 样式

WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。更详细的文档可以参考 [WXSS](#232-wxss)

1. WXSS 在底层支持新的尺寸单位 `rpx` ，可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。
2. 提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，可以写一个 **app.wxss** 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 **page.wxss** 仅对当前页面生效。
3. WXSS 仅支持部分 CSS 选择器

#### 1.2.4 JS 逻辑交互

一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，可以通过编写 **JS** 脚本文件来处理用户的操作。更详细的事件可以参考文档 [WXML事件](#234-事件系统)

```wxml
<view>{{msg}}</view>
<button bindtap="clickMe">点击</button>
```

点击 button 按钮的时候，希望把界面上 msg 显示成 "this is a cat"，于是在 button 上声明一个属性: **bindtap** ，在 JS 文件里边声明了 **clickMe** 方法来响应这次点击操作

```js
page({
  clickMe : function () {
    this.setData({msg: "this is a cat"});
  }
})
```

此外还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。更多 API 可以参考文档 [小程序的API][api] 。

### 1.3 小程序宿主环境

微信客户端给小程序所提供的环境叫宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。

#### 1.3.1 渲染层和逻辑层

小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了 **WebView** 进行渲染；逻辑层采用 **JsCore** 线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由微信客户端转发，小程序的通信模型如下图所示。

![微信小程序通信模型](./image/微信小程序通信模型.png)

有关渲染层和逻辑层的详细文档参考 [小程序框架](#二-小程序框架)

#### 1.3.2 程序与页面

微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。紧接着通过 app.json 的 **pages** 字段知道当前小程序的所有页面路径。

如果没有定义 `entryPagePath` 属性，默认 pages 列表的第一项为小程序的默认启动路径（首页）。不支持带页面路径参数。

然后，微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，渲染出首页。

小程序启动之后，在 app.js 定义的 App 实例的 `onLaunch` 回调会被执行。整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 [注册程序 App](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html) 。

**pages/logs/logs** 下包括了4种文件，微信客户端会先根据 logs.json 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 WXML 结构和 WXSS 样式。最后客户端会装载 logs.js，logs.js 的大体内容就是:

```js
// 代码示例
Page({
  data: { // 参与页面渲染的数据
    logs: []
  },
  onLoad: function () {
    // 页面渲染后 执行
  }
})
```

`Page` 是一个页面构造器，这个构造器生成了一个页面。在生成页面的时候，小程序框架会把 data 数据和 logs.wxml 一起渲染出最终的结构。在渲染完界面之后，页面实例就会收到一个 `onLoad` 的回调，可以在这个回调处理需要的逻辑。Page 构造器详细文档参考 [注册页面 Page](#222-注册页面)

#### 1.3.3 组件

小程序提供了丰富的基础组件，可以像搭积木一样，组合各种组件拼合成小程序。

在小程序里边，只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，在界面显示地图：

```wxml
<map></map>
```

使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，希望地图一开始的中心的经纬度是北京，那么需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:

```wxml
<map longitude="116.397128" latitude="39.916527" ></map>
```

组件的内部行为也会通过事件的形式感知，例如用户点击了地图上的某个标记，可以在 js 编写 markertap 函数来处理：

```wxml
<map bind:markertap="markertap" longitude="116.397128" latitude="39.916527"></map>
```

也可以通过 style 或者 class 来控制组件的外层样式，以便适应界面宽度高度等等。更多的组件可以参考 [小程序组件][组件] 。

#### 1.3.4 API

为了很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 。更多的 API 可以参考文档 [小程序的API][api]。

要获取用户的地理位置时，只需要：

```js
wx.getLocation({
  type: 'wgs84',
  success: (res) => {
    var latitude = res.latitude // 纬度
    var longitude = res.longitude // 经度
  }
})
```

> 注意：多数 API 的回调都是 **异步**，需要处理好代码逻辑的异步问题。

### 1.4 小程序协同工作与发布

#### 1.4.1 小程序的版本

一般的软件开发流程，编写代码自测开发版程序，直到程序达到一个稳定可体验的状态时，然后把这个体验版本给到产品经理和测试人员进行体验测试，最后修复完程序的Bug后发布供外部用户正式使用。小程序的版本根据这个流程设计了小程序版本的概念。

版本 | 说明
----|------
开发版本 | 使用开发者工具，可将代码上传到开发版本中。开发版本只保留每人最新的一份上传的代码。点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码
体验版本 | 可以选择某个开发版本作为体验版，并且选取一份体验版。
审核中版本 | 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。
线上版本 | 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。

考虑到项目是协同开发的模式，一个小程序可能同时由多个开发者进行开发，往往开发者在小程序开发者工具上编写完代码后需要到手机进行真机体验，所以每个开发者拥有自己对应的一个开发版本。因为处于开发中的版本是不稳定的，开发者随时会修改代码覆盖开发版，为了让测试和产品经理有一个完整稳定的版本可以体验测试，小程序平台允许把其中一个开发版本设置成体验版，因此建议在项目开发阶段特殊分配一个开发角色，用于上传稳定可供体验测试的代码，并把他上传的开发版本设置成体验版。

#### 1.4.2 发布上线

一个小程序从开发完到上线一般要经过 预览-> 上传代码 -> 提交审核 -> 发布等步骤。

**预览**
使用开发者工具可以预览小程序，帮助开发者检查小程序在移动客户端上的真实表现。

点击开发者工具顶部操作栏的预览按钮，开发者工具会自动打包当前项目，并上传小程序代码至微信的服务器，成功之后会在界面上显示一个二维码。使用当前小程序开发者的微信扫码即可看到小程序在手机客户端上的真实表现。

**上传代码**
同预览不同，上传代码是用于提交体验或者审核使用的。

点击开发者工具顶部操作栏的上传按钮，填写版本号以及项目备注，需要注意的是，这里版本号以及项目备注是为了方便管理员检查版本使用的，开发者可以根据自己的实际要求来填写这两个字段。

上传成功之后，登录小程序管理后台 - 开发管理 - 开发版本 就可以找到刚提交上传的版本了。

可以将这个版本设置 体验版 或者是 提交审核

**提交审核**
为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过审核的。

在开发者工具中上传了小程序代码之后，登录 小程序管理后台 - 开发管理 - 开发版本 找到提交上传的版本。

在开发版本的列表中，点击 提交审核 按照页面提示，填写相关的信息，即可以将小程序提交审核。

> 注意: 严格测试了版本之后，再提交审核，过多的审核不通过，可能会影响后续的时间。

**发布**
审核通过之后，管理员的微信中会收到小程序通过审核的通知，此时登录 小程序管理后台 - 开发管理 - 审核版本中可以看到通过审核的版本。

点击发布后，即可发布小程序。小程序提供了两种发布模式：**全量发布** 和 **分阶段发布**。全量发布是指当点击发布之后，所有用户访问小程序时都会使用当前最新的发布版本。分阶段发布是指分不同时间段来控制部分用户使用最新的发布版本，分阶段发布我们也称为灰度发布。一般来说，普通小程序发布时采用全量发布即可，当小程序承载的功能越来越多，使用的用户数越来越多时，采用分阶段发布是一个非常好的控制风险的办法。

#### 1.4.3 运营数据

有两种方式可以方便的看到小程序的 [运营数据](https://developers.weixin.qq.com/miniprogram/analysis/)

1. 登录 [小程序管理后台](https://mp.weixin.qq.com/) - 数据分析，点击相应的 tab 可以看到相关的数据。

2. 使用小程序数据助手，在微信中方便的查看运营数据

### 1.5 目录结构

小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。

一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

文件 | 必需 | 作用
-----|------|----
app.js | 是 | 小程序逻辑
app.json | 是 | 小程序公共配置
app.wxss | 否 | 小程序公共样式表

一个小程序页面由四个文件组成，分别是：

文件类型 | 必需 | 作用
--------|------|----
js | 是 | 页面逻辑
wxml | 是 | 页面结构
json | 否 | 页面配置
wxss | 否 | 页面样式表

> **注意**：为了减少配置项，描述页面的四个文件必须具有相同的路径与文件名。

**允许上传的文件**
在项目目录中，以下文件会经过编译，因此上传之后无法直接访问到：.js、app.json、.wxml、*.wxss（其中 wxml 和 wxss 文件仅针对在 app.json 中配置了的页面）。除此之外，只有后缀名在白名单内的文件可以被上传，不在白名单列表内文件在开发工具能被访问到，但无法被上传。具体白名单列表如下：

1. wxs
2. png
3. jpg
4. jpeg
5. gif
6. svg
7. json
8. cer
9. mp3
10. aac
11. m4a
12. mp4
13. wav
14. ogg
15. silk

## 二. 小程序框架

### 2.1 场景值

场景值用来描述用户进入小程序的路径。部分场景值下还可以获取来源应用、公众号或小程序的appId。完整场景值的含义可查看 [场景值列表](https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html)。

**获取场景值** :

- 对于小程序，可以在 App 的 **onLaunch** 和 **onShow**，或 **wx.getLaunchOptionsSync** 中获取场景值。
- 对于小游戏，可以在 **wx.getLaunchOptionsSync** 和 **wx.onShow** 中获取场景值

> 注 : 由于Android系统限制，目前还无法获取到按 Home 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值。

### 2.2 逻辑层

小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供 JavaScript 代码的运行环境以及微信小程序的特有功能。

逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。

写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。

小程序在 JavaScript 的基础上，增加了一些其他功能:

- 增加 App 和 Page 方法，进行程序注册和页面注册。
- 增加 [getApp](#2421-page) 和 [getCurrentPages](#2422-getcurrentpages) 方法，分别用来获取 App 实例和当前页面栈。
- 提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。
- 提供模块化能力，每个页面有独立的作用域。

> 注 : 小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 浏览器 中一些能力都无法使用，如 window，document 等。

#### 2.2.1 注册小程序实例

每个小程序都需要在 **app.js** 中调用 **App** 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。
详细的参数含义和使用 [App 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html) 。

整个小程序只有一个 App 实例，是全部页面共享的。可以通过 `getApp` 方法获取到全局唯一的 App 实例，获取App上的数据或调用注册在 App 上的函数。
**例** : [app.js](./test/app.js)

> 注 : 调用 **App** 方法注册小程序实例，必须调用且只能调用一次。不然会出现无法预期的后果。

#### 2.2.2 注册页面

对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。

##### 2.2.2.1 使用 Page 构造器注册页面

简单的页面可以使用 Page() 进行构造。详细的参数含义和使用参考 [Page 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html) 。

**例** : [index.js](./test/pages/index/index.js)

##### 2.2.2.2 在页面中使用 behaviors

> 基础库 2.9.2 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

页面可以引用 `behaviors` 。 behaviors 可以用来让多个页面有相同的数据字段和方法。具体用法参见 [behaviors](#45-behaviors)

##### 2.2.2.3 使用 Component 构造器构造页面

> 基础库 1.6.3 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

Page 构造器适用于简单的页面。但对于复杂的页面， Page 构造器可能并不好用。

此时，可以使用 `Component` 构造器来构造页面。 `Component` 构造器的主要区别是：方法需要放在 `methods: { }` 里面。
这种创建方式非常类似于 *自定义组件* ，可以像自定义组件一样使用 `behaviors` 等高级特性。具体细节阅读 [Component 构造器](#42-component-构造器) 。

#### 2.2.3 页面生命周期

![小程序页面Page实例的生命周期](./image/小程序页面Page实例的生命周期.png)

#### 2.2.4 页面路由

在小程序中所有页面的路由全部由框架进行管理。

**页面栈**
框架以栈的形式维护了当前的所有页面。可以使用 [getCurrentPages()](#2422-getcurrentpages) 函数获取当前页面栈。当发生路由切换的时候，页面栈的表现如下：

路由方式 | 页面栈表现
--------|------------
初始化 | 新页面入栈
打开新页面 | 新页面入栈
页面重定向 | 当前页面出栈，新页面入栈
页面返回 | 页面不断出栈，直到目标返回页
Tab 切换 | 页面全部出栈，只留下新的 Tab 页面
重加载 | 页面全部出栈，只留下新的页面

**路由方式**
对于路由的触发方式以及页面生命周期函数如下：

路由方式 | 触发时机 | 路由前页面 | 路由后页面
--------|----------|-----------|----------
初始化 | 小程序打开的第一个页面 | - | onLoad, onShow
打开新页面 | 调用 API `wx.navigateTo`；使用组件 `<navigator open-type="navigateTo"/>` | onHide | onLoad, onShow
页面重定向 | 调用 API `wx.redirectTo`；使用组件 `<navigator open-type="redirectTo"/>` | onUnload | onLoad, onShow
页面返回 | 调用 API `wx.navigateBack`；使用组件`<navigator open-type="navigateBack">`；用户按左上角返回按钮 | onUnload | onShow
Tab 切换 | 调用 API `wx.switchTab`；使用组件 `<navigator open-type="switchTab"/>`；用户切换 Tab | - | 各种情况请参考下表
重启动 | 调用 API `wx.reLaunch`；使用组件 `<navigator open-type="reLaunch"/>` | onUnload | onLoad, onShow

Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：

当前页面 | 路由后页面 | 触发的生命周期（按顺序）
--------|------------|--------------------
A | A | Nothing happen
A | B | A.onHide(), B.onLoad(), B.onShow()
A | B（再次打开） | A.onHide(), B.onShow()
C | A | C.onUnload(), A.onShow()
C | B | C.onUnload(), B.onLoad(), B.onShow()
D | B | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()
D（从转发进入） | A | D.onUnload(), A.onLoad(), A.onShow()
D（从转发进入） | B | D.onUnload(), B.onLoad(), B.onShow()

> 注意：
>
> 1. `navigateTo`, `redirectTo` 只能打开非 tabBar 页面。
> 2. `switchTab` 只能打开 tabBar 页面。
> 3. `reLaunch` 可以打开任意页面。
> 4. 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
> 5. 调用页面路由带的参数可以在目标页面的 `onLoad` 中获取。

#### 2.2.5 模块化

可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 `module.exports` 才能暴露。
​在需要使用这些模块的文件中，使用 `require` 将公共代码引入

> **注意** : 小程序目前不支持直接引入 node_modules , 需要使用到 node_modules 时候需要拷贝出相关的代码到小程序的目录中，或者使用小程序支持的 npm 功能。

**文件作用域**
在 JS 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。

通过全局函数 `getApp` 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置。

#### 2.2.6 API

小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍参考 [API 文档][api]。

常用的小程序API有以下几种:

**事件监听API**
小程序约定，以 `on` 开头的 API 用来监听某个事件是否触发，如：`wx.onSocketOpen`，`wx.onCompassChange` 等

这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

```js
// 代码示例
wx.onCompassChange(function (res) {
  console.log(res.direction)
})
```

**同步API**
小程序约定，以 **Sync** 结尾的 API 都是同步 API， 如 `wx.setStorageSync`，`wx.getSystemInfoSync` 等。此外，也有一些其他的同步 API，如 `wx.createWorker`，`wx.getBackgroundAudioManager` 等

同步 API 的执行结果可以通过函数返回值直接获取，如果执行出错会抛出异常。

```js
// 代码示例
try {
  wx.getStorageSync('key', 'value')
} catch (e) {
  console.log(e)
}
```

**异步API**
大多数 API 都是异步 API，如 `wx.request`，`wx.login` 等。这类 API 接口通常都接受一个 `Object` 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果：

Object 参数说明

参数名 | 类型 | 必填 | 说明
-------|-----|------|------
success | function | 否 | 接口调用成功的回调函数
fail | function | 否 | 接口调用失败的回调函数
complete | function | 否 | 接口调用结束的回调函数（调用成功、失败都会执行）
其他 | Any | - | 接口定义的其他参数

回调函数的参数

success，fail，complete 函数调用时会传入一个 Object 类型参数，包含以下字段:

属性 | 类型 | 说明
----|-------|-----
errMsg | string | 错误信息，如果调用成功返回 `${apiName}:ok`
errCode | number | 错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 0。
其他 | Any | 接口返回的其他数据

异步 API 的执行结果需要通过 `Object` 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能，如 `wx.request`，`wx.connectSocket` 等。

```js
// 代码示例
wx.login({
  success(res) {
    if(res.code) {
      // 发起网络请求
      wx.request({
        url: 'https://test.com/onLogin',
        data: {
          code : res.code
        }
      })
    } else {
      console.log('登录失败' + res.message);
    }
  }
})
```

**异步 API 返回 Promise**
基础库 2.10.2 版本起，异步 API 支持 **callback & promise** 两种调用方式。当接口参数 Object 对象中不包含 success/fail/complete 时将默认返回 promise，否则仍按回调方式执行，无返回值。

> 注意:
>
> 1. 部分接口如 `downloadFile`, `request`, `uploadFile`, `connectSocket`, `createCamera`（小游戏）本身就有返回值， 它们的 promisify 需要自行封装。
> 2. 当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 Uncaught (in promise)，可通过 catch 来进行捕获。
> 3. `wx.onUnhandledRejection` 可以监听未处理的 Promise 拒绝事件。

```js
// 代码示例
// callback 形式调用
wx.chooseImage({
  count: 1,
  sizeType:['original', 'compressed'],
  success(res) {
    console.log('res:')
  }
})
```

**云开发API**
需要开通并使用 [小程序云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)，即可使用云开发API，在小程序端直接调用服务端的 [云函数](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html#%E4%BA%91%E5%87%BD%E6%95%B0)。

```js
// 代码示例
wx.cloud.callFunction({
  // 云函数名称
  name: 'cloudFunc',
  // 传给云函数的参数
  data: {
    a: 1,
    b: 2,
  },
  success: function(res) {
    console.log(res.result) // 示例
  },
  fail: console.error
})

// 此外，云函数同样支持promise形式调用
```

### 2.3 视图层

框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。

将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。

WXML(WeiXin Markup language) 用于描述页面的结构。

WXS(WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。

WXSS(WeiXin Style Sheet) 用于描述页面的样式。

组件(Component)是视图的基本组成单元。

#### 2.3.1 WXML

WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合 [基础组件][组件]、[事件系统][#234-事件系统]，可以构建出页面的结构。

##### 2.3.1.1 数据绑定

WXML 中的动态数据均来自对应 Page 的 data。

**简单绑定**
数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于:

- 内容

```wxml
<view>{{message}}</view>
```

```js
Page({
  data: {
    message: 'This is a cat.'
  }
})
```

- 组件属性(需要在双引号以内)

```wxml
<view id="item-{{id}}"></view>
```

```js
Page({
  data: {
    id: 0
  }
})
```

- 控制属性(需要在双引号以内)

```wxml
<view wx:if="{{condition}}"></view>
```

```js
Page({
  data:{
    condition: true
  }
})
```

- 关键字(需要在双引号以内)

**true**
: boolean 类型的 true，代表真值。

**false**
: boolean 类型的 false，代表假值。

```wxml
<view checked="{{false}}"></view>
```

> 特别注意：不要直接写 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值

**运算**
可以在 `{{}}` 内进行简单的运算，支持的有如下几种方式：

- 三元运算

```wxml
<view hidden="{{flag != 0 ? true : true}}">{{flag}}</view>
```

- 算术运算

```wxml
<view>{{a + b}} + {{c}} + d</view> // 3 + 3 + d
```

```js
Page({
  data: {
    a: 1,
    b: 2,
    c: 3
  }
})
```

- 逻辑判断

```wxml
<view wx:if="{{length > 5}}"> </view>
```

- 字符串运算

```wxml
<view>{{"hello" + name}}</view>
```

```js
Page({
  data: {
    name: 'Tom'
  }
})
```

- 数据路径运算

```wxml
<view>{{object.key}} {{array[0]}}</view>
```

```js
Page({
  data: {
    object: {
      key: "hello"
    },
    array: ['Tom']
  }
})
```

**组合**
也可以在 Mustache 内直接进行组合，构成新的对象或者数组。

- 数组

```wxml
<view wx:for="{{[zero, 1, 2, 3, 4]}}">{{item}}</view> // 最终组合成数组[0, 1, 2, 3, 4]
```

```js
Page({
  data: {
    zero: 0
  }
})
```

- 对象

```wxml
<template is="objectCombine" data="{{for: a, bar: b}}"></template> // 最终组合成的对象是 {for: 1, bar: 2}
```

```js
Page({
  data: {
    a: 1,
    b: 2
  }
})
```

也可以用扩展运算符 `...` 来将一个对象展开

```wxml
<template is="objectCombine" data="{{...obj, ...obj2, e: 5}}"></template> // 最终组合成的对象是 {a: 1, b: 2, c: 3, d: 4, e: 5}
```

```js
Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      c: 3,
      d: 4
    }
  }
})
```

如果对象的 key 和 value 相同，也可以间接地表达。

```wxml
<template is="objectCombine" data="{{foo, bar}}"></template> // 最终组合成的对象是 {foo: 'my-foo', bar:'my-bar'}
```

```js
Page({
  data: {
    foo: 'my-foo',
    bar: 'my-bar'
  }
})
```

> **注意** : 上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如：

```wxml
<template is="objectCombine" data="{{...obj1, ...obj2, a, c: 6}}"></template> // 最终组合成的对象是 {a: 5, b: 3, c: 6}
```

```js
Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      c: 1,
      d: 2
    }
  },
  a: 5
})
```

> **注意** : 花括号与引号之间如果有空格，将最终被解析成为字符串

```wxml
<view wx:for="{{[1, 2, 3]}} ">
  {{item}}
</view>
```

等同于

```wxml
<view wx:for="{{[1, 2, 3] + ' '}}">
  {{item}}
</view>
```

##### 2.3.1.2 列表渲染

**wx:for**
在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item` 。

```wxml
<view wx:for="{{array}}">
  {{index}} : {{item.message}}
</view>
```

```js
Page({
  data: {
    array: [{
      message: 'foo'
    }, {
      message: 'bar'
    }]
  }
})
```

使用 `wx:for-item` 可以指定数组当前元素的变量名，使用 `wx:for-index` 可以指定数组当前下标的变量名：

```wxml
<view wx:for="{{array}}" wx:for-index="i" wx:for-item="li">
  {{i}} : {{li.message}}
</view>
```

`wx:for` 也可以嵌套，下边是一个九九乘法表:

```wxml
<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
  <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    <view wx:if="{{i <= j}}">
      {{i}} * {{j}} = {{i * j}}
    </view>
  </view>
</view>
```

**block wx:for**
类似 **block wx:if**，也可以将 `wx:for` 用在 `<block/>` 标签上，以渲染一个包含多节点的结构块。例如：

```wxml
<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: </view>
  <view> {{item}} </view>
</block>
```

**wx:key**
如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

wx:key 的值以两种形式提供:

1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2. 保留关键字 `*this` 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。

当数据改变触发渲染层重新渲染的时候，会校正带有 `key` 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

> 如不提供 `wx:key`，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。

[示例代码](https://developers.weixin.qq.com/s/tpg5tKmv6kZt)

> 注意:
> 当 `wx:for` 的值为字符串时，会将字符串解析成字符串数组
> 花括号和引号之间如果有空格，将最终被解析成为字符串

##### 2.3.1.3 条件渲染

**wx:if**
在框架中，使用 `wx:if=""` 来判断是否需要渲染该代码块：

```wxml
<view wx:if="{{condition}}"> True </view>
```

也可以用 `wx:elif` 和 `wx:else` 来添加一个 else 块：

```wxml
<view wx:if="{{length > 9}}">1</view>
<view wx:elif="{{length > 6}}">2</view>
<view wx:else>3</view>
```

**block wx:if**
因为 `wx:if` 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```wxml
<block wx:if="{{condition}}">
  <view>1</view>
  <view>2</view>
</block>
```

> 注意： `<block/>` 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。

**wx:if 与 hidden 的区别**
因为 `wx:if` 之中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。

同时 `wx:if` 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。

##### 2.3.1.4 模板

WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。

**定义模板**
使用 `name` 属性，作为模板的名字。然后在 `<template/>` 内定义代码片段，如：

```wxml
<!--
  index: int
  msg: string
  time: string
-->
<template name="msgItem">
  <view>
    <text>{{index}} : {{msg}}</text>
    <text>{{time}}</text>
  </view>
</template>
```

**使用模板**
使用 `is` 属性，声明需要的使用的模板，然后将模板所需要的 `data` 传入，如：

```wxml
<template is="msgItem" data="{{...item}}" />
```

```js
Page({
  data: {
    item: {
      index: 0,
      msg: 'this is a template',
      time: '2020-12-24'
    }
  }
})
```

`is` 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板：

```js
<template name="odd">
  <view> odd </view>
</template>
<template name="even">
  <view> even </view>
</template>

<block wx:for="{{[1, 2, 3, 4]}}">
  <template is="{{item % 2 == 0 ? 'even' : 'odd'}}" />
</block>
```

**模板的作用域**
模板拥有自己的作用域，只能使用 `data` 传入的数据以及模板定义文件中定义的 `<wxs />` 模块。

##### 2.3.1.5 引用

WXML 提供两种文件引用方式 `import` 和 `include`。

**import**
`import` 可以在该文件中使用目标文件定义的 `template` ，如：

在 item.wxml 中定义了一个叫 item 的 template：

```wxml
<!-- item.wxml -->
<template name="item">
  <text>{{text}}</text>
</template>
```

在 index.wxml 中引用了 item.wxml，就可以使用item模板：

```wxml
<import src="item.wxml">
<template is="item" data="{{text: 'footer'}}">
```

**import 的作用域**
import 有作用域的概念，即只会 `import` 目标文件中定义的 template，而不会 import 目标文件 import 的 template。

> 例 : C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。

**include**
include 可以将目标文件除了 `<template/>` `<wxs/>` 外的整个代码引入，相当于是拷贝到 `include` 位置，如：

```wxml
<!-- index.wxml -->
<include src="header.wxml"/>
<view> body </view>
<include src="footer.wxml"/>
```

```wxml
<!-- header.wxml -->
<view> header </view>
```

```wxml
<!-- footer.wxml -->
<view> footer </view>
```

#### 2.3.2 WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。

WXSS 用来决定 WXML 的组件应该怎么显示。WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。

与 CSS 相比，WXSS 扩展的特性有：

- **尺寸单位**
  `rpx`（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。

  设备 | rpx换算px (屏幕宽度/750) | px换算rpx (750/屏幕宽度)
  -----|-------------------------|------------------------
  iPhone5 | 1rpx = 0.42px | 1px = 2.34rpx
  iPhone6 | 1rpx = 0.5px | 1px = 2rpx
  iPhone6 Plus | 1rpx = 0.552px | 1px = 1.81rpx

- **样式导入**
  使用 `@import` 语句可以导入外联样式表，`@import` 后跟需要导入的外联样式表的相对路径，用 **;** 表示语句结束。

**内联样式**
框架组件上支持使用 style、class 属性来控制组件的样式。

- **style** : 静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，尽量避免将静态的样式写进 style 中，以免影响渲染速度。

```wxss
<view style="color:{{color}}"></view>
```

- **class** : 用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上 *.* ，样式类名之间用 空格 分隔。

```wxss
<view class="normal_view left_view"></view>
```

**选择器**
目前支持的选择器有:

选择器 | 样例 | 样例描述
-------|-----|---------
.class | .intro | 选择所有拥有 class="intro" 的组件
**#id** | #first_name | 选择拥有 id="first_name" 的组件
element | view | 选择所有 view 组件
element, element | view, checkbox | 选择所有文档的 view 组件和所有的 checkbox 组件
::after | view::after | 在 view 组件后边插入内容
::before | view::before | 在 view 组件前边插入内容

**全局样式与局部样式**
定义在 **app.wxss** 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 **app.wxss** 中相同的选择器。

#### 2.3.3 WXS 语法参考

WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。WXS 与 JS 是不同的语言，有自己的语法，并不和 JS 一致。

> 注意:
>
> 1. WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
> 2. WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。
> 3. WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API。
> 4. WXS 函数不能作为组件的事件回调。
> 5. 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。
> 6. const、let 不能使用，只能使用 var
> 7. WXS 里数据类型与基础类库中的属性 除 constructor 外的具体含义参考 ES5 标准。
> 8. WXS 里的方法具体使用参考 ES5 标准。

##### 2.3.3.1 模块

WXS 代码可以编写在 **wxml** 文件中的 `<wxs>` 标签内，或以 `.wxs` 为后缀名的文件内。

**模块**
: 每一个 **.wxs** 文件和 **<wxs>** 标签都是一个单独的模块。每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。一个模块要想对外暴露其内部的私有变量与函数，只能通过 **module.exports** 实现。

**.wxs 文件**
: 在微信开发者工具里面，右键可以直接创建 .wxs 文件，在其中直接编写 WXS 脚本。`.wxs` 文件可以被其他的 `.wxs` 文件 或 WXML 中的 `<wxs>` 标签引用。

**module 对象**
每个 **wxs** 模块均有一个内置的 **module** 对象。

**属性**:

- **exports** : 通过该属性，可以对外共享本模块的私有变量与函数。

> 例 : [test.wxs](./test/pages/tests/test.wxs)

**require函数**
在 .wxs 模块中引用其他 wxs 文件模块，可以使用 `require` 函数。

引用的时候，要注意如下几点：

- 只能引用 .wxs 文件模块，且必须使用相对路径。
- wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
- 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

**<wxs> 标签**

属性名 | 类型 | 说明
-------|-----|-----
module | String | 当前 `<wxs>` 标签的模块名。必填字段。
src | String | 引用 .wxs 文件的相对路径。仅当本标签为单闭合标签或标签的内容为空时有效

- module属性
  module 属性是当前 `<wxs>` 标签的模块名。在单个 wxml 文件内，建议其值唯一。有重复模块名则按照先后顺序覆盖（后者覆盖前者）。不同文件之间的 wxs 模块名不会相互覆盖。
  module 属性值的命名必须符合下面两个规则：
  - 首字符必须是：字母（a-zA-Z），下划线（_）
  - 剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）

- src属性
  src 属性可以用来引用其他的 wxs 文件模块。
  引用的时候，要注意如下几点：
  - 只能引用 .wxs 文件模块，且必须使用相对路径。
  - wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
  - 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

> 注意:
> 1.`<wxs>` 模块只能在定义模块的 WXML 文件中被访问到。使用 `<include>` 或 `<import>` 时，`<wxs>` 模块不会被引入到对应的 WXML 文件中。
> 2.`<template>` 标签中，只能使用定义该 `<template>` 的 WXML 文件中定义的 `<wxs>` 模块。

##### 2.3.3.2 变量

**概念**:

- WXS 中的变量均为值的引用。
- 没有声明的变量直接赋值使用，会被定义为全局变量。
- 如果只声明变量而不赋值，则默认值为 undefined。
- var表现与javascript一致，会有变量提升。

**变量名**
变量命名必须符合下面两个规则：

- 首字符必须是：字母（a-zA-Z），下划线（_）
- 剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）

**保留标识符**
以下标识符不能作为变量名：

```js
delete void typeof

null undefined NaN Infinity var

if else

true false

require

this function arguments return

for while do break continue switch case default
```

##### 2.3.3.3 注释

WXS 主要有 3 种注释的方法。

```wxml
<!-- 示例代码 -->

// 方法一：单行注释

/**
* 方法二：多行注释
*/

/*
方法三：结尾注释。即从 /* 开始往后的所有 WXS 代码均被注释
```

##### 2.3.3.4 运算符

**一元运算符**:

```js
var a = 10, b = 20;

// 自增运算
console.log(10 === a++);
console.log(12 === ++a);
// 自减运算
console.log(12 === a--);
console.log(10 === --a);
// 正值运算
console.log(10 === +a);
// 负值运算
console.log(0-10 === -a);
// 否运算
console.log(-11 === ~a);
// 取反运算
console.log(false === !a);
// delete 运算
console.log(true === delete a.fake);
// void 运算
console.log(undefined === void a);
// typeof 运算
console.log("number" === typeof a);
```

**位运算符**:

```js
var a = 10, b = 20;

// 左移运算
console.log(80 === (a << 3));
// 无符号右移运算
console.log(2 === (a >> 2));
// 带符号右移运算
console.log(2 === (a >>> 2));
// 与运算
console.log(2 === (a & 3));
// 异或运算
console.log(9 === (a ^ 3));
// 或运算
console.log(11 === (a | 3));
```

**运算符优先级**:

优先级 | 运算符 | 说明 | 结合性
-------|-------|------|------
20 | ( ... ) | 括号 | n/a
19 | ... . ... | 成员访问 | 从左到右
-| ... [ ... ] | 成员访问 | 从左到右
-| ... ( ... ) | 函数调用 | 从左到右
17 | ... ++ | 后置递增 | n/a
-| ... -- | 后置递减 | n/a
16 | ! ... | 逻辑非 | 从右到左
-| ~ ... | 按位非 | 从右到左
-| **+ ...** | 一元加法 | 从右到左
-| **- ...** | 一元减法 | 从右到左
-| ++ ... | 前置递增 | 从右到左
-| -- ... | 前置递减 | 从右到左
-| typeof ... | typeof | 从右到左
-| void ... | void | 从右到左
-| delete ... | delete | 从右到左
14 | ... * ... | 乘法 | 从左到右
-| ... / ... | 除法 | 从左到右
-| ... % ... | 取模 | 从左到右
13 | ... + ... | 加法 | 从左到右
-| ... - ... | 减法 | 从左到右
12 | ... << ... | 按位左移 | 从左到右
-| ... >> ... | 按位右移 | 从左到右
-| ... >>> ... | 无符号右移 | 从左到右
11 | ... < ... | 小于 | 从左到右
-| ... <= ... | 小于等于 | 从左到右
-| ... > ... | 大于 | 从左到右
-| ... >= ... | 大于等于 | 从左到右
10 | ... == ... | 等号 | 从左到右
-| ... != ... | 非等号 | 从左到右
-| ... === ... | 全等号 | 从左到右
-| ... !== ... | 非全等号 | 从左到右
9 | ... & ... | 按位与 | 从左到右
8 | ... ^ ... | 按位异或 | 从左到右
7 | ... ｜ ... | 按位或 | 从左到右
6 | ... && ... | 逻辑与 | 从左到右
5 | ... ｜｜ ... | 逻辑或 | 从左到右
4 | ... ? ... : ... | 条件运算符 | 从右到左
3 | ... = ... | 赋值 | 从右到左
-| ... += ... | 赋值 | 从右到左
-| ... -= ... | 赋值 | 从右到左
-| ... *= ... | 赋值 | 从右到左
-| ... /= ... | 赋值 | 从右到左
-| ... %= ... | 赋值 | 从右到左
-| ... <<= ... | 赋值 | 从右到左
-| ... >>= ... | 赋值 | 从右到左
-| ... >>>= ... | 赋值 | 从右到左
-| ... &= ... | 赋值 | 从右到左
-| ... ^= ... | 赋值 | 从右到左
-| ... ｜= ... | 赋值 | 从右到左
0 | ... , ... | 逗号 | 从左到右

##### 2.3.3.5 数据类型

WXS 语言目前共有以下几种数据类型：

1. number ： 数值
2. string ：字符串
3. boolean：布尔值
4. object：对象
5. function：函数
6. array : 数组
7. date：日期
8. regexp：正则

- **number**
  - 语法 : number 包括两种数值：整数，小数。
  - 属性
    - constructor: 返回字符串 "Number"
  - 方法
    - toString
    - toLocaleString
    - valueOf
    - toFixed
    - toExponential
    - toPrecision

- **string**
  - 语法 : 单引号 和 双引号 都可以
  - 属性
    - constructor : 返回字符串 "String"
    - length
  - 方法
    - toString
      valueOf
    - charAt
    - charCodeAt
    - concat
    - indexOf
    - lastIndexOf
    - localeCompare
    - match
    - replace
    - search
    - slice
    - split
    - substring
    - toLowerCase
    - toLocaleLowerCase
    - toUpperCase
    - toLocaleUpperCase
    - trim

- **boolean**
  - 语法 : 只有两个特定的值：true 和 false
  - 属性
    - constructor : 返回字符串 "Boolean"
  - 方法
    - toString
    - valueOf

- **object**
  - 语法 : object 是一种无序的键值对
  - 属性
    - constructor : 返回字符串"Object"
  - 方法
    - toString : 返回字符串 "[Object Object]"

- **function**
  - 语法 : 支持常用的两种定义，以及 匿名函数，闭包等
  - arguments : function 里面可以使用 arguments 关键词。该关键词目前只支持以下的属性
    - length : 传递给函数的参数个数。
    - [index]: 通过 *index* 下标可以遍历传递给函数的每个参数。
  - 属性
    - constructor : 返回字符串 "Function"
    - length : 返回函数的形参个数
  - 方法
    - toString : 返回字符串"[Function Function]"

- **Array**
  - 语法 : 支持 `var a = []` 和 `var b = [1,"2",{},function(){}]`
  - 属性
    - constructor : 返回字符串 "Array"
    - length
  - 方法
    - toString
    - concat
    - join
    - pop
    - push
    - reverse
    - shift
    - slice
    - sort
    - splice
    - unshift
    - indexOf
    - lastIndexOf
    - every
    - some
    - forEach
    - map
    - filter
    - reduce
    - reduceRight

- **date**
  - 语法 : 生成 date 对象需要使用 `getDate()` 函数, 返回一个当前时间的对象。

    ```wxs
    // 格式
    getDate()
    getDate(milliseconds)
    getDate(dateString)
    getDate(year, month[, date[, hours[, minutes[, seconds[, milliseconds]]]]])
    ```

  - 参数
    - milliseconds : 从1970年1月1日00:00:00 UTC开始计算的毫秒数
    - dateString : 日期字符串，其格式为："month day, year hours:minutes:seconds"

    ```wxs
    // 示例
    var date = getDate(); //返回当前时间对象

    date = getDate(1500000000000);
    // Fri Jul 14 2017 10:40:00 GMT+0800 (中国标准时间)
    date = getDate('2017-7-14');
    // Fri Jul 14 2017 00:00:00 GMT+0800 (中国标准时间)
    date = getDate(2017, 6, 14, 10, 40, 0, 0);
    // Fri Jul 14 2017 10:40:00 GMT+0800 (中国标准时间)
    ```

  - 属性
    - constructor : 返回字符串 "Date"
  - 方法
    - toString
    - toDateString
    - toTimeString
    - toLocaleString
    - toLocaleDateString
    - toLocaleTimeString
    - valueOf
    - getTime
    - getFullYear
    - getUTCFullYear
    - getMonth
    - getUTCMonth
    - getDate
    - getUTCDate
    - getDay
    - getUTCDay
    - getHours
    - getUTCHours
    - getMinutes
    - getUTCMinutes
    - getSeconds
    - getUTCSeconds
    - getMilliseconds
    - getUTCMilliseconds
    - getTimezoneOffset
    - setTime
    - setMilliseconds
    - setUTCMilliseconds
    - setSeconds
    - setUTCSeconds
    - setMinutes
    - setUTCMinutes
    - setHours
    - setUTCHours
    - setDate
    - setUTCDate
    - setMonth
    - setUTCMonth
    - setFullYear
    - setUTCFullYear
    - toUTCString
    - toISOString
    - toJSON

- **regexp**
  - 语法 : 生成 regexp 对象需要使用 getRegExp() 函数。

    ```wxs
      getRegExp(pattern[, flags])
    ``

  - 参数
    - pattern : 正则表达式的内容
    - flags : 修饰符，该字段只能包含以下内容 `g`、`i`、`m`
  - 属性
    - constructor : 返回字符串 "RegExp"
    - source
    - global
    - ignoreCase
    - multiline
    - lastIndex
  - 方法
    - exec
    - test
    - toString

- **数据类型判断**
  - constructor : 数据类型的判断可以使用 constructor 属性。
  - typeof : 使用 typeof 也可以区分部分数据类型。

##### 2.3.3.6 基础类库

- **console**
  - console.log 方法用于在 console 窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。

- **Math**
  - 属性
    - E
    - LN10
    - LN2
    - LOG2E
    - LOG10E
    - PI
    - SQRT1_2
    - SQRT2
  - 方法
    - abs
    - acos
    - asin
    - atan
    - atan2
    - ceil
    - cos
    - exp
    - floor
    - log
    - max
    - min
    - pow
    - random
    - round
    - sin
    - sqrt
    - tan

- **JSON**
  - 方法
    - stringify(object) : 将 object 对象转换为 JSON 字符串，并返回该字符串。
    - parse(string) : 将 JSON 字符串转化成对象，并返回该对象。

- **Number**
  - 属性
    - MAX_VALUE
    - MIN_VALUE
    - NEGATIVE_INFINITY
    - POSITIVE_INFINITY

- **Date**
  - 属性
    - parse
    - UTC
    - now

- **Global**
  - 属性
    - NaN
    - Infinity
    - undefined
  - 方法
    - parseInt
    - parseFloat
    - isNaN
    - isFinite
    - decodeURI
    - decodeURIComponent
    - encodeURI
    - encodeURIComponent

#### 2.3.4 事件系统

**什么是事件**:

- 事件是视图层到逻辑层的通讯方式
- 事件可以将用户的行为反馈到逻辑层进行处理
- 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数
- 事件对象可以携带额外信息，如 id，dataset，touches

##### 2.3.4.1 事件的使用方式

- **在组件中绑定一个事件处理函数**
  - 如 `bindtap`，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。

  ```wxml
  <view id="tapTest" data-hi="WeiXin" bindtap="topName"> Click Me! </view>
  ```

  - 在相应的Page定义中写上相应的事件处理函数，参数是event。

  ```js
  Page({
    tapName: function(event) {
      console.log(event);
    }
  })
  ```

##### 2.3.4.2 事件详解

- **事件分类**
  事件分为 冒泡事件 和 非冒泡事件：

  WXML的冒泡事件列表:

  类型 | 触发条件
  -----|--------
  touchstart | 手指触摸动作开始
  touchmove | 手指触摸后移动
  touchcancel | 手指触摸动作被打断，如来电提醒，弹窗
  touchend | 手指触摸动作结束
  tap | 手指触摸后马上离开
  longpress | 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发，最低版本 1.5.0
  longtap | 手指触摸后，超过350ms再离开（推荐使用longpress事件代替）
  transitionend | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发
  animationstart | 会在一个 WXSS animation 动画开始时触发
  animationiteration | 会在一个 WXSS animation 一次迭代结束时触发
  animationend | 会在一个 WXSS animation 动画完成时触发
  touchforcechange | 在支持 3D Touch 的 iPhone 设备，重按时会触发，最低版本 1.9.9

  > 注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的submit事件，input 的input事件，scroll-view 的scroll事件，(详见各个 [组件][组件] )

- **普通事件绑定**
  事件绑定的写法类似于组件的属性，如：

  ```wxml
  <view bindtap="handleTap"> Click Me! </view>
  ```

  如果用户点击这个 view ，则页面的 handleTap 会被调用。
  事件绑定函数可以是一个数据绑定，如：

  ```wxml
  <view bindtap="{{handleName}}"> Click Me! </view>
  ```

  此时，页面的 `this.data.handlerName` 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。
  > 自基础库版本 1.5.0 起，在大多数组件和自定义组件中， bind 后可以紧跟一个冒号，其含义不变，如 `bind:tap` 。基础库版本 2.8.1 起，在所有组件中开始提供这个支持。

- **绑定并阻止事件冒泡**
  除 `bind` 外，也可以用 `catch` 来绑定事件。与 `bind` 不同，`catch` 会阻止事件向上冒泡。

  例如：在下边这个例子中，点击 inner view 会先后调用 handleTap3 和 handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outer view 会触发 handleTap1。

  ```wxml
  <view id="outer" bindtap="handleTap1">
    <view id="middle" catch:tap="handleTap2">
      <view id="inner" bindtap="handleTap3">
    </view>
  </view>
  ```

- **互斥事件绑定**
  自基础库版本 2.8.2 起，除 bind 和 catch 外，还可以使用 `mut-bind` 来绑定事件。一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。

- **事件的捕获阶段**
  自基础库版本 1.5.0 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用 `capture-bind`、`capture-catch` 关键字，后者将中断捕获阶段和取消冒泡阶段。

  在下面的代码中，点击 inner view 会先后调用handleTap2、handleTap4、handleTap3、handleTap1。

  ```wxml
  <view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">
    <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4"></view>
  </view>
  ```

  如果将上面代码中的第一个 `capture-bind` 改为 `capture-catch`，将只触发 handleTap2。

##### 2.3.4.3 事件对象

如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

- **BaseEvent 基础事件对象属性列表**:

  属性 | 类型 | 说明
  -----|------|-----
  type | String | 事件类型
  timeStamp | Integer | 事件生成的时间戳
  [target](#target) | Object | 触发事件的组合的一些属性值集合
  [currentTarget](#currentTarget) | Object | 当前组件的一些属性值集合
  [mark](#mark) | Object | 事件标记数据，基础库版本 2.7.1

- **CustomEvent 自定义事件对象属性列表** (继承BaseEvent)

  属性 | 类型 | 说明
  -----|------|-------
  [detail](#detail) | Object | 说明

- **TouchEvent 触摸事件对象属性列表** (继承BaseEvent)

  属性 | 类型 | 说明
  ----|------|------
  [touches](#touches) | Array | 触摸事件，当前停留在屏幕中的触摸点信息的数组
  [changedTouches](#changedTouches) | Array | 触摸事件，当前变化的触摸点信息的数组

  > 特殊事件：canvas 中的触摸事件不可冒泡，所以没有 currentTarget

- <span id="target">**target**</span>
  触发事件的源组件

  属性 | 类型 | 说明
  ----|------|-----
  id | String | 事件源组件的id
  [dataset](#dateset) | Object | 事件源组件上由 `data-` 开头的自定义属性组合的集合

- <span id="currentTarget">**currentTarget**</span>
  事件绑定的当前组件

  属性 | 类型 | 说明
  -----|-----|-----
  id | String | 当前组件的id
  [dataset](#dateset) | Object | 当前组件上由 `data-` 开头的自定义属性组合的集合

- <span id="dataset">dataset</span>
  在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。
  在 WXML 中，这些自定义数据以 data- 开头，多个单词由连字符 - 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：
  - data-element-type ，最终会呈现为 event.currentTarget.dataset.elementType ；
  - data-elementType ，最终会呈现为 event.currentTarget.dataset.elementtype 。

- <span id="mark">mark</span>
  在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点。此外， mark 还可以用于承载一些自定义数据（类似于 dataset ）。
  当事件触发时，事件冒泡路径上所有的 mark 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 mark 。）

  ```wxml
  <view mark:myMark="last" bindtap="bindViewTap">
    <button mark:anotherMark="leaf" bindtap="bindButtonTap">按钮</button>
  </view>
  ```

  在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。

  ```js
  Page({
    bindViewTap: function (e) {
      e.mark.myMark === "last"; // true
      e.mark.anotherMark === "leaf"; // true
    }
  })
  ```

  mark 和 dataset 很相似，主要区别在于： mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值；而 dataset 仅包含一个节点的 data- 属性值。
  细节注意事项：

  - 如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。
  - 在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark 。
  - 不同于 dataset ，节点的 mark 不会做连字符和大小写转换

- <span id="touches">touches</span>
  touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。
  - Touch对象

    属性 | 类型 | 说明
    ----|------|-----
    identifier | Number | 触摸点的标识符
    pageX, pageY | Number | 距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴
    clientX, clientY | Number | 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴

  - CanvasTouch 数组

    属性 | 类型 | 说明
    ----|------|-----
    identifier | Number | 触摸点的标识符
    x，y | Number | 距离 Canvas 左上角的距离，Canvas 的左上角为原点，横向为X轴，纵向为Y轴

- <span id="changedTouches">changedTouches</span>
  changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。

- <span id="detail">detail</span>
  自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义。
  点击事件的detail 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。

##### 2.3.4.4 使用WXS函数响应事件

> 基础库 2.4.4 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

从基础库版本2.4.4开始，支持使用WXS函数绑定事件，WXS函数接受2个参数，第一个是event，在原有的event的基础上加了 **event.instance** 对象，第二个参数是 **ownerInstance**，和 event.instance 一样是一个**ComponentDescriptor** 对象。具体使用如下：

- **组件中绑定和注册事件处理的WXS函数**

  ```wxml
  <wxs module="wxs" src="./test.wxs"></wxs>
  <!-- 注：绑定的WXS函数必须用 {{}} 括起来 -->
  <view id="tapTest" data-hi="WeiXin" bindtap="{{wxs.tapName}}"> Click Me! </view>
  ```

- **test.wxs文件实现tapName函数**

  ```wxs
  function tapName(event, ownerInstance) {
    console.log('top WeiXin', JSON.stringify(event));
  }
  module.exports = {
    tapName : tapName
  }
  ```

ownerInstance包含了一些方法，可以设置组件的 样式 和 class，具体包含的方法以及为什么要用 WXS函数响应事件，[点击查看详情](https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html)。

#### 2.3.5 简易双向绑定

> 基础库 2.9.3 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

**双向绑定语法**
在 WXML 中，普通的属性的绑定是单向的。如果使用 `this.setData({ value: 'leaf' })` 来更新 value ，`this.data.value` 和输入框的中显示的值都会被更新为 `leaf` ；但如果用户修改了输入框里的值，却不会同时改变 `this.data.value` 。

如果需要在用户输入的同时改变 `this.data.value` ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 `model:` 前缀：

```wxml
<input model:value="{{value}}">
```

这样，如果输入框的值被改变了，`this.data.value` 也会同时改变。同时，WXML 中所有绑定了 value 的位置也会被一同更新， 数据监听器 也会被正常触发。

用于双向绑定的表达式有如下限制：

- 只能是一个单一字段的绑定，不能是

  ```wxml
  <input model:value="值为 {{value}}" />
  <input model:value="{{ a + b }}" />
  ```

- 不能 data 路径，如

  ```wxml
  <input model:value="{{a.b}}" />
  ```

**在自定义组件中传递双向绑定**
双向绑定同样可以使用在自定义组件上。如下的自定义组件：

```js
// custom-component.js
Component({
  properties : {
    myValue: String
  }
})
```

```wxml
<!-- custom-component.wxml -->
<input model:input="{{myValue}}">
```

这个自定义组件将自身的 myValue 属性双向绑定到了组件内输入框的 value 属性上。这样，如果页面这样使用这个组件:

```wxml
<custom-component model:my-value="{{pageValue}}" />
```

当输入框的值变更时，自定义组件的 myValue 属性会同时变更，这样，页面的 `this.data.pageValue` 也会同时变更，页面 WXML 中所有绑定了 pageValue 的位置也会被一同更新。

**在自定义组件中触发双向绑定更新**
自定义组件还可以自己触发双向绑定更新，做法就是：使用 `setData` 设置自身的属性。例如：

```js
// custom-component.js
Component({
  properties: {
    myValue: String
  },
  methods: {
    update: function() {
      // 更新 myValue
      this.setData({
        myValue : "leaf"
      })
    }
  }
})
```

如果页面这样使用这个组件：

```wxml
<custom-component model:my-value="{{pageValue}}" />
```

当组件使用 `setData` 更新 **myValue** 时，页面的 `this.data.pageValue` 也会同时变更，页面 WXML 中所有绑定了 **pageValue** 的位置也会被一同更新。

#### 2.3.6 基础组件

框架提供了一系列基础组件，可以通过组合这些基础组件进行快速开发。详细介绍参考 [组件文档][组件]

什么是组件：

- 组件是视图层的基本组成单元。
- 组件自带一些功能与微信风格一致的样式。
- 一个组件通常包括 **开始标签** 和 **结束标签**，**属性** 用来修饰这个组件，**内容** 在两个标签之内。

> 注意：所有组件与属性都是小写，以连字符-连接

**属性类型**:

类型 | 描述 | 注解
-----|------|-----
Boolean | 布尔值 | 组件写上该属性，不管是什么值都被当作 true；只有组件上没有该属性时，属性值才为false。如果属性值为变量，变量的值会被转换为Boolean类型
Number | 数字 | 1, 2.5
String | 字符串 | "string"
Array | 数组 | [ 1, "string" ]
Object | 对象 | { key: value }
EventHandler | 事件处理函数名 | "handlerName" 是 Page 中定义的事件处理函数名
Any | 任意属性

**公共属性**
所有组件都有以下属性：

属性名 | 类型 | 描述 | 注解
-------|-----|------|-----
id | String | 组件的唯一标示 | 保持整个页面唯一
class | String | 组件的样式类 | 在对应的 WXSS 中定义的样式类
style | String | 组件的内联样式 | 可以动态设置的内联样式
hidden | Boolean | 组件是否显示 | 所有组件默认显示
data-* | Any | 自定义属性 | 组件上触发的事件时，会发送给事件处理函数
`bind*` / `catch*` | EventHandler | 组件的事件 | 详见[事件系统](#234-事件系统)

**特殊属性**
几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，参考各个 [组件][组件] 的定义。

#### 2.3.7 获取界面上的信息节点

**WXML信息节点**
`wx.createSelectorQuery()` 可以用于获取节点属性、样式、在界面上的位置等信息。
最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

```js
const query = wx.createSelectorQuery();
query.select("#the-id").boundingClientRect(function(res) {
  res.top; // #the-id 节点的上边界坐标（相对于显示区域）
})
query.selectViewport().scrollOffSet(function(res) {
  res.scrollTop; // 显示区域的竖直滚动位置
})
// 执行所有的请求。请求结果按请求次序构成数组，在callback的第一个参数中返回
query.exec((e) => {
  console.log(e);
});
```

上述示例中，`#the-id` 是一个节点选择器，与 CSS 的选择器相近但略有区别，参见 [SelectorQuery.select](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.select.html) 的相关说明。

> 在 **自定义组件** 或包含 **自定义组件的页面** 中，推荐使用 `this.createSelectorQuery` 来代替 `wx.createSelectorQuery` ，这样可以确保在正确的范围内选择节点。

**WXML节点布局相交状态**
`wx.createIntersectionObserver(Object component, Object options)` API， 可用于监听两个或多个组件节点在布局位置上的相交状态。这一组API常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。

这一组API涉及的主要概念如下:

- 参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的 交集 作为参照区域。页面显示区域也可作为参照区域之一。
- 目标节点：监听的目标，默认只能是一个节点（使用 `selectAll` 选项时，可以同时监听多个节点）。
- 相交区域：目标节点的布局区域与参照区域的相交区域。
- 相交比例：相交区域占参照区域的比例。
- 阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。

以下示例代码可以在目标节点（用选择器 `.target-class` 指定）每次进入或离开页面显示区域时，触发回调函数。

```js
Page({
  onLoad: function(){
    wx.createIntersectionObserver().relativeToViewport().observe('.target-class', (res) => {
      res.id // 目标节点 id
      res.dataset // 目标节点 dataset
      res.intersectionRatio // 相交区域占目标节点的布局区域的比例
      res.intersectionRect // 相交区域
      res.intersectionRect.left // 相交区域的左边界坐标
      res.intersectionRect.top // 相交区域的上边界坐标
      res.intersectionRect.width // 相交区域的宽度
      res.intersectionRect.height // 相交区域的高度
    })
  }
})
```

以下示例代码可以在目标节点（用选择器 .target-class 指定）与参照节点（用选择器 .relative-class 指定）在页面显示区域内相交或相离，且相交或相离程度达到目标节点布局区域的20%和50%时，触发回调函数。

```js
Page({
  onLoad: function(){
    wx.createIntersectionObserver(this, {
      thresholds: [0.2, 0.5]
    }).relativeTo('.relative-class').relativeToViewport().observe('.target-class', (res) => {
      res.intersectionRatio // 相交区域占目标节点的布局区域的比例
      res.intersectionRect // 相交区域
      res.intersectionRect.left // 相交区域的左边界坐标
      res.intersectionRect.top // 相交区域的上边界坐标
      res.intersectionRect.width // 相交区域的宽度
      res.intersectionRect.height // 相交区域的高度
    })
  }
})
```

> 注意：
> 与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是 "布局区域"，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中 overflow 样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。
> 在 **自定义组件或包含自定义组件的页面中**，推荐使用 `this.createIntersectionObserver` 来代替 `wx.createIntersectionObserver` ，这样可以确保在正确的范围内选择节点。

#### 2.3.8 响应显示区域的变化

**显示区域尺寸**
显示区域指小程序界面中可以自由布局展示的区域。在默认情况下，小程序显示区域的尺寸自页面初始化起就不会发生变化。但以下两种方式都可以改变这一默认行为。

- **在手机上启用屏幕旋转支持**
  从小程序基础库版本 2.4.0 开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持屏幕旋转的方法是：在 **app.json** 的 **window** 段中设置 `"pageOrientation": "auto"` ，或在页面 json 文件中配置 `"pageOrientation": "auto"` 。

  如果页面添加声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。

  从小程序基础库版本 2.5.0 开始， `pageOrientation` 还可以被设置为 `landscape` ，表示固定为横屏显示。

- **在 iPad 上启用屏幕旋转支持**
从小程序基础库版本 2.3.0 开始，在 iPad 上运行的小程序可以支持屏幕旋转。使小程序支持 iPad 屏幕旋转的方法是：在 **app.json** 中添加 `"resizable": true` 。

> 注意：
> 如果小程序添加了声明，则在屏幕旋转时，小程序将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。
> 在 iPad 上不能单独配置某个页面是否支持屏幕旋转。

**Media Query**
有时，对于不同尺寸的显示区域，页面的布局会有所差异。此时可以使用 `media query` 来解决大多数问题。

```wxss
.my-class {
  width: 400px;
}
@media (max-width:480px) {
  /* 仅在 480px 或更窄的屏幕上生效的样式规则 */
  .my-class {
    width: 200px;
  }
}
```

在 WXML 中，可以使用 [match-media](https://developers.weixin.qq.com/miniprogram/dev/component/match-media.html) 组件来根据 media query 匹配状态展示、隐藏节点。

此外，可以在页面或者自定义组件 JS 中使用 `this.createMediaQueryObserver()` 方法来创建一个 `MediaQueryObserver` 对象，用于监听指定的 media query 的匹配状态。

**屏幕旋转事件**
有时，仅仅使用 media query 无法控制一些精细的布局变化。此时可以使用 js 作为辅助。

在 js 中读取页面的显示区域尺寸，可以使用 `selectorQuery.selectViewport` 。

页面尺寸发生改变的事件，可以使用页面的 `onResize` 来监听。对于自定义组件，可以使用 `resize` 生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库版本 2.4.0 开始支持。）

```js
Page({
  onResize: function(res) {
    res.size.windowWidth // 新的显示区域宽度
    res.size.windowHeight // 新的显示区域高度
  }
})
```

```js
Component({
  pageLifetimes: {
    resize(res) {
      res.size.windowWidth // 新的显示区域宽度
      res.size.windowHeight // 新的显示区域高度
    }
  }
})
```

#### 2.3.9 动画

**界面动画的常见方式**
在小程序中，通常可以使用 CSS 渐变 和 CSS 动画 来创建简易的界面动画。

动画过程中，可以使用 `bindtransitionend` `bindanimationstart` `bindanimationiteration` `bindanimationend` 来监听动画事件。

事件名 | 含义
------|------
transitionend | CSS 渐变结束或 wx.createAnimation 结束一个阶段
animationstart | CSS动画开始
animationiteration | CSS 动画结束一个阶段
animationend | CSS动画结束

> 注意：
> 这几个事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。
> 同时，还可以使用 `wx.createAnimation` 接口来动态创建简易的动画效果。（新版小程序基础库中推荐使用下面的关键帧动画接口代替。）

**关键帧动画**:

> 基础库 2.9.0 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

从小程序基础库 2.9.0 开始支持一种更友好的动画创建方式，用于代替旧的 `wx.createAnimation` 。它具有更好的性能和更可控的接口。
在页面或自定义组件中，当需要进行关键帧动画时，可以使用 `this.animate` 接口：

```js
this.animate(selector, keyframes, duration, callback)
```

参数说明

属性 | 类型 | 必填 | 说明
-----|-----|------|-----
selector | String | 是 | 选择器（同 SelectorQuery.select 的选择器格式）
keyframes | Array | 是 | 关键帧信息
duration | Number | 是 | 动画持续时长(单位：毫秒)
callback | function | 是 | 动画完成后的回调函数

keyframes 中对象的结构

属性 | 类型 | 默认值 | 必填 | 说明
-----|-----|--------|------|-----
offset | Number | - | 否 | 关键帧的偏移，范围[0-1]
ease | String | linear | 否 | 动画缓动函数
transformOrigin | String | - | 否 | 基点位置，即 CSS transform-origin
backgroundColor | String | - | 否 | 背景颜色，即 CSS background-color
bottom | Number/String | - | 否 | 底边位置，即 CSS bottom
height | Number/String | - | 否 | 高度，即 CSS height
left | Number/String | - | 否 | 左边位置，即 CSS left
width | Number/String | - | 否 | 宽度，即 CSS width
opacity | Number | - | 否 | 不透明度，即 CSS opacity
right | Number | - | 否 | 右边位置，即 CSS right
top | Number/String | - | 否 | 顶边位置，即 CSS top
matrix | Array | - | 否 | 变换矩阵，即 CSS transform matrix
matrix3d | Array | - | 否 | 三维变换矩阵，即 CSS transform matrix3d
rotate | Number | - | 否 | 旋转，即 CSS transform rotate
rotate3d | Array | - | 否 | 三维旋转，即 CSS transform rotate3d
rotateX | Number | - | 否 | X 方向旋转，即 CSS transform rotateX
rotateY | Number | - | 否 | Y 方向旋转，即 CSS transform rotateY
rotateZ | Number | - | 否 | Z 方向旋转，即 CSS transform rotateZ
scale | Array | - | 否 | 缩放，即 CSS transform scale
scale3d | Array | - | 否 | 三维缩放，即 CSS transform scale3d
scaleX | Number | - | 否 | X 方向缩放，即 CSS transform scaleX
scaleY | Number | - | 否 | Y 方向缩放，即 CSS transform scaleY
scaleZ | Number | - | 否 | Z 方向缩放，即 CSS transform scaleZ
skew | Array | - | 否 | 倾斜，即 CSS transform skew
skewX | Number | - | 否 | X 方向倾斜，即 CSS transform skewX
skewY | Number | - | 否 | Y 方向倾斜，即 CSS transform skewY
translate | Array | - | 否 | 位移，即 CSS transform translate
translate3d | Array | - | 否 | 三维位移，即 CSS transform translate3d
translateX | Number | - | 否 | X 方向位移，即 CSS transform translateX
translateY | Number | - | 否 | Y 方向位移，即 CSS transform translateY
translateZ | Number | - | 否 | Z 方向位移，即 CSS transform translateZ

```js
this.animate('#container', [
  { opacity: 1.0, rotate: 0, backgroundColor: '#FF0000' },
  { opacity: 0.5, rotate: 45, backgroundColor: '#00FF00'},
  { opacity: 0.0, rotate: 90, backgroundColor: '#FF0000' },
  ], 5000, function () {
    this.clearAnimation('#container', { opacity: true, rotate: true }, function () {
      console.log("清除了#container上的opacity和rotate属性")
    })
}.bind(this))

this.animate('.block', [
  { scale: [1, 1], rotate: 0, ease: 'ease-out'  },
  { scale: [1.5, 1.5], rotate: 45, ease: 'ease-in', offset: 0.9},
  { scale: [2, 2], rotate: 90 },
], 5000, function () {
  this.clearAnimation('.block', function () {
    console.log("清除了.block上的所有动画属性")
  })
}.bind(this))
```

调用 animate API 后会在节点上新增一些样式属性覆盖掉原有的对应样式。如果需要清除这些样式，可在该节点上的动画全部执行完毕后使用 `this.clearAnimation` 清除这些属性。

```js
this.clearAnimation(selector, options, callback)
```

参数说明

属性 | 类型 | 必填 | 说明
-----|-----|------|-----
selector| String | 是 | 选择器（同 SelectorQuery.select 的选择器格式）
options | Object | 否 | 需要清除的属性，不填写则全部清除
callback | Function | 否 | 清除完成后的回调函数

**滚动驱动的动画**
根据滚动位置而不断改变动画的进度是一种比较常见的场景，这类动画可以让人感觉到界面交互很连贯自然，体验更好。因此，从小程序基础库 2.9.0 开始支持一种由滚动驱动的动画机制。

基于上面关键帧动画接口，新增一个 `ScrollTimeline` 的参数，用来绑定滚动元素（目前只支持 `scroll-view`）。接口定义如下：

```js
this.animate(selector, keyframes, duration, ScrollTimeline)
```

ScrollTimeline 中对象的结构

属性 | 类型 | 默认值 | 必填 | 说明
-----|-----|--------|------|-----
scrollSource | String | - | 是 | 指定滚动元素的选择器（只支持 scroll-view），该元素滚动时会驱动动画的进度
orientation | String | vertical | 否 | 指定滚动的方向。有效值为 horizontal 或 vertical
startScrollOffset | Number | - | 是 | 指定开始驱动动画进度的滚动偏移量，单位 px
endScrollOffset | Number | - | 是 | 指定停止驱动动画进度的滚动偏移量，单位 px
timeRange | Number | - | 是 | 起始和结束的滚动范围映射的时间长度，该时间可用于与关键帧动画里的时间 (duration) 相匹配，单位 ms

```js
this.animate('.avatar', [{
  borderRadius: '0',
  borderColor: 'red',
  transform: 'scale(1) translateY(-20px)',
  offset: 0,
}, {
  borderRadius: '25%',
  borderColor: 'blue',
  transform: 'scale(.65) translateY(-20px)',
  offset: .5,
}, {
  borderRadius: '50%',
  borderColor: 'blue',
  transform: `scale(.3) translateY(-20px)`,
  offset: 1
}], 2000, {
  scrollSource: '#scroller',
  timeRange: 2000,
  startScrollOffset: 0,
  endScrollOffset: 85,
})

this.animate('.search_input', [{
  opacity: '0',
  width: '0%',
}, {
  opacity: '1',
  width: '100%',
}], 1000, {
  scrollSource: '#scroller',
  timeRange: 1000,
  startScrollOffset: 120,
  endScrollOffset: 252
})
```

**高级的动画方式**
在一些复杂场景下，上述的动画方法可能并不适用。

WXS 响应事件 的方式可以通过使用 WXS 来响应事件的方法来动态调整节点的 style 属性。通过不断改变 style 属性的值可以做到动画效果。同时，这种方式也可以根据用户的触摸事件来动态地生成动画。

连续使用 `setData` 来改变界面的方法也可以达到动画的效果。这样可以任意地改变界面，但通常会产生较大的延迟或卡顿，甚至导致小程序僵死。此时可以通过将页面的 `setData` 改为 自定义组件 中的 `setData` 来提升性能。

#### 2.3.10 初始渲染缓存

> 基础库 2.11.1 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

**初始渲染缓存工作原理**
小程序页面的初始化分为两个部分。

- 逻辑层初始化：载入必需的小程序代码、初始化页面 this 对象（也包括它涉及到的所有自定义组件的 this 对象）、将相关数据发送给视图层。
- 视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发送的数据，最后渲染页面。

在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。

启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 data 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：

- 在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；
- 在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；
- 如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。

利用初始渲染缓存，可以：

- 快速展示出页面中永远不会变的部分，如导航栏
- 预先展示一个骨架页，提升用户体验
- 展示自定义的加载提示
- 提前展示广告，等等

**支持的组件**
在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。

目前支持的内置组件：

- `<view />`
- `<text />`
- `<button />`
- `<image />`
- `<scroll-view />`
- `<rich-text />`

自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。

**静态初始渲染缓存**
若想启用初始渲染缓存，最简单的方法是在页面的 json 文件中添加配置项 `"initialRenderingCache": "static"` ，如果想要对所有页面启用，可以在 app.json 的 window 配置段中添加这个配置：

添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。

> 注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML 上的结果，不包含任何 setData 的结果。

例如，如果想要在页面中展示出"正在加载"几个字，这几个字受到 `loading` 数据字段控制：

```wxml
<view wx:if="{{loading}}">正在加载</view>
```

这种情况下， **loading** 应当在 data 中指定为 true ，如：

```js
// 正确的做法
Page({
  data: {
    loading: true
  }
})
```

**在初始渲染缓存中添加动态内容**
有些场景中，只是页面 data 的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片 URL 等。

这种情况下可以使用"动态"初始渲染缓存的方式。首先，配置 `"initialRenderingCache": "dynamic"` 。

此时，初始渲染缓存不会被自动启用，还需要在页面中调用 `this.setInitialRenderingCache(dynamicData)` 才能启用。其中， `dynamicData` 是一组数据，与 `data` 一起参与页面 WXML 渲染。

```js
Page({
  data: {
    loading: true
  },
  onReady: function() {
    this.setInitialRenderingCache({
      loadingHint: "正在加载" // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
    })
  }
})
```

```wxml
<view wx:if="{{loading}}">{{loadingHint}}</view>
```

> **注意**：
> 从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而 **开销相对较大**。因而要尽量避免频繁调用 `this.setInitialRenderingCache` ，如果在一个页面内多次调用，仅最后一次调用生效。
> `this.setInitialRenderingCache` 调用时机不能早于 Page 的 `onReady` 或 Component 的 `ready` 生命周期，否则可能对性能有负面影响。
> 如果想禁用初始渲染缓存，调用 `this.setInitialRenderingCache(null)` 。

### 2.4 框架接口

#### 2.4.1 小程序App

##### 2.4.1.1  App

**App(Object object)**
注册小程序。接受一个 `Object` 参数，其指定小程序的生命周期回调等。[详情查看](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html)

> App() 必须在 `app.js` 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。

##### 2.4.1.2 getApp

获取到小程序全局唯一的 `App` 实例。

参数 Object object

属性 | 类型 | 默认值 | 必填 | 说明 | 最低版本
-----|------|-------|-----|-------|--------
allowDefault | Boolean | false | 否 | 在 App 未定义时返回默认实现。当App被调用时，默认实现中定义的属性会被覆盖合并到App中。一般用于 [独立分包](#552-独立分包) | 2.2.4

> 注意:
> 不要在定义于 `App()` 内的函数中，或调用 `App` 前调用 `getApp()` ，使用 this 就可以拿到 app 实例。
> 通过 `getApp()` 获取实例之后，不要私自调用生命周期函数。

#### 2.4.2 页面

##### 2.4.2.1 Page

**Page(Object object)**
注册小程序中的一个页面。接受一个 `Object` 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。 [详情查看](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html)

**页面间通信**:

> 基础库 2.7.3 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

如果一个页面由另一个页面通过 [wx.navigateTo][wx.navigateTo] 打开，这两个页面间将建立一条数据通道：

- 被打开的页面可以通过 `this.getOpenerEventChannel()` 方法来获得一个 `EventChannel` 对象；
- `wx.navigateTo` 的 `success` 回调中也包含一个 `EventChannel` 对象。

这两个 `EventChannel` 对象间可以使用 `emit` 和 `on` 方法相互发送、监听事件。

##### 2.4.2.2 getCurrentPages

**PageObject[] getCurrentPages()**
获取当前页面栈。数组中第一个元素为首页，最后一个元素为当前页面。

> 注意：
> **不要尝试修改页面栈，会导致路由以及页面状态错误。**
> 不要在 `App.onLaunch` 的时候调用 `getCurrentPages()`，此时 page 还没有生成。

#### 2.4.3 自定义页面组件

##### 2.4.3.1 Component

**Component(Object object)**
创建自定义组件，接受一个 `Object` 类型的参数。 [详情查看](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)

> 注意：
> 使用 `this.data` 可以获取内部数据和属性值；但直接修改它不会将变更应用到界面上，应使用 `setData` 修改。
> 生命周期函数无法在组件方法中通过 `this` 访问到。
> 属性名应避免以 `data` 开头，即不要命名成 `dataXyz` 这样的形式，因为在 WXML 中， `data-xyz=""` 会被作为节点 `dataset` 来处理，而不是组件属性。
> 在一个组件的定义和使用时，组件的属性名和 data 字段相互间都不能冲突（尽管它们位于不同的定义段中）。
> 从基础库 2.0.9 开始，对象类型的属性和 data 字段中可以包含函数类型的子字段，即可以通过对象类型的属性字段来传递函数。低于这一版本的基础库不支持这一特性。
> bug : 位于 slot 中的自定义组件没有触发 pageLifetimes 中声明的页面生命周期，此问题在 2.5.2 中修复。
> bug : 对于 type 为 Object 或 Array 的属性，如果通过该组件自身的 `this.setData` 来改变属性值的一个子字段，则依旧会触发属性 observer ，且 observer 接收到的 `newVal` 是变化的那个子字段的值， `oldVal` 为空， `changedPath` 包含子字段的字段名相关信息；目前推荐使用 `observers` 定义段代替。

##### 2.4.3.2 Behavior

**Behavior(Object object)**
注册一个 behavior，接受一个 Object 类型的参数

**参数**:

定义段 | 类型 | 是否必填 | 描述
------|------|---------|------
properties | Object Map | 否 | 同组件的属性
data | Object | 否 | 同组件的数据
methods | Object | 否 | 同自定义组件的方法
behaviors | String Array | 否 | 引入其它的 behavior
created | Function | 否 | 生命周期函数
attached | Function | 否 | 生命周期函数
ready | Function | 否 | 生命周期函数
moved | Function | 否 | 生命周期函数
detached | Function | 否 | 生命周期函数

#### 2.4.4 基础功能

##### 2.4.4.1 wx

**Object wx**
小程序 API 全局对象，用于承载小程序能力相关 API。具体请参考小程序 [API 参考文档][api]。

##### 2.4.4.2 env

**Object wx.env**
小程序环境变量对象

**String wx.env.USER_DATA_PATH**
文件系统中的用户目录路径

##### 2.4.4.3 console

向调试面板中打印日志。console 是一个全局对象，可以直接访问。在微信客户端中，向 vConsole 中输出日志。

**方法**:

console.debug()
向调试面板中打印 debug 日志

console.log()
向调试面板中打印 log 日志

console.info()
向调试面板中打印 info 日志

console.warn()
向调试面板中打印 warn 日志

console.error()
向调试面板中打印 error 日志

console.group(string label)
在调试面板中创建一个新的分组。随后输出的内容都会被添加一个缩进，表示该内容属于当前分组。调用 console.groupEnd之后分组结束。

console.groupEnd()
结束由 console.group 创建的分组

> 注意:
> 由于 `vConsole` 功能有限，以及不同客户端对 `console` 方法的支持情况有差异，建议在小程序中只使用本文档中提供的方法。
> 部分内容展示的限制见 [调试](#九-调试)

#### 2.4.5 定时器

##### 2.4.5.1 一次性定时器

**number setTimeout(function callback, number delay, any rest)**
设定一个定时器。在定时到期以后执行注册的回调函数

参数 | 说明
-----|------
function callback | 回调函数
number delay | 延迟的时间，函数的调用会在该延迟之后发生，单位 ms。
any rest | param1, param2, ..., paramN 等附加参数，它们会作为参数传递给回调函数。

**返回值**
number
时器的编号。这个值可以传递给 `clearTimeout` 来取消该定时。

##### 2.4.5.2 循环定时器

**number setInterval(function callback, number delay, any rest)**
设定一个定时器。按照指定的周期（以毫秒计）来执行注册的回调函数

参数 | 说明
-----|-----
function callback | 回调函数
number delay | 执行回调函数之间的时间间隔，单位 ms。
any rest | param1, param2, ..., paramN 等附加参数，它们会作为参数传递给回调函数。

**返回值**
number
定时器的编号。这个值可以传递给 `clearInterval` 来取消该定时。

## 三. 小程序运行时

### 3.1 运行环境

微信小程序运行在多种平台上：iOS（iPhone/iPad）微信客户端、Android 微信客户端、PC 微信客户端、Mac 微信客户端和用于调试的微信开发者工具。

各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：

- 在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS 12、iOS 13 等；
- 在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 内核来渲染的；
- 在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的。
- 在 PC 上，小程序逻辑层 javascript 和视图层 javascript 都是用 Chrome 内核
- 在 Mac 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，与 iOS 一致

**平台差异**
尽管各运行环境是十分相似的，但是还是有些许区别：

- JavaScript 语法和 API 支持不一致：语法上可以通过开启 ES6 转 ES5 的功能来规避（[详情](https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#es6-%E8%BD%AC-es5)）；此外，小程序基础库内置了必要的Polyfill，来弥补API的差异。
- WXSS 渲染表现不一致：尽管可以通过开启样式补全来规避大部分的问题，但还是需要在 iOS 和 Android 上分别检查小程序的真实表现。

### 3.2 JavaScript 支持情况

**运行限制**
基于安全考虑，小程序中不支持动态执行 JS 代码，即：

- 不支持使用 `eval` 执行 JS 代码
- 不支持使用 `new Function` 创建函数

**客户端 ES6 API 支持情况**
微信小程序已经支持了绝大部分的 ES6 API，具体情况查询 [API支持情况](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/js-support.html)

### 3.3 运行机制

**前台后台状态**
小程序启动后，界面被展示给用户，此时小程序处于前台状态。

当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有完全终止运行，而是进入了后台状态，小程序还可以运行一小段时间。

当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。但如果用户很久没有再进入小程序，或者系统资源紧张，小程序可能被销毁，即完全终止运行。

**小程序启动**
小程序启动可以分为两种情况，一种是冷启动，一种是热启动。

- 冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。
- 热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。

**小程序销毁时机**
通常，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被销毁。具体而言包括以下几种情形：

- 当小程序进入后台，可以维持一小段时间的运行状态，如果这段时间内都未进入前台，小程序会被销毁。
- 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。
  - 在 iOS 上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户 「运行内存不足，请重新打开该小程序」。具体策略会持续进行调整优化。
  - 建议小程序在必要时使用 `wx.onMemoryWarning` 监听内存告警事件，进行必要的内存清理。

> 基础库 1.1.0 及以上，1.4.0 以下版本： 当用户从扫一扫、转发等入口（[场景值](#21-场景值)为1007, 1008, 1011, 1025）进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。

**启动场景分类**
用户打开小程序时，场景可分为以下 A、B 两类：

**A. 保留上次的浏览状态**。场景值有以下几项：

场景值ID | 说明
--------|------
1001 | 发现栏小程序主入口，「最近使用」列表（基础库2.2.4版本起包含「我的小程序」列表）
1003 | 星标小程序列表
1023 | 系统桌面小图标打开小程序
1038 | 从其他小程序返回小程序
1056 | 聊天顶部音乐播放器右上角菜单，打开小程序
1080 | 客服会话菜单小程序入口，打开小程序
1083 | 公众号会话菜单小程序入口 ，打开小程序（只有腾讯客服小程序有）
1089 | 聊天主界面下拉，打开小程序/微信聊天主界面下拉，「最近使用」栏（基础库2.2.4版本起包含「我的小程序」栏）
1090 | 长按小程序右上角菜单，打开小程序
1103 | 发现-小程序主入口我的小程序，打开小程序
1104 | 聊天主界面下拉，从我的小程序，打开小程序
1113 | 安卓手机负一屏，打开小程序
1114 | 安卓手机侧边栏，打开小程序
1117 | 后台运行小程序的管理页中，打开小程序

- 若进入的场景中带有 path，则每次打开小程序时都进入对应的 path 页面
- 若进入的场景中不带 path：
  - 若小程序是热启动，则保留原来状态
  - 若小程序是冷启动，则遵循下一节的重启策略，可能是首页或上次退出的页面

**B. relaunch 到指定页或首页**
包括除 A 类外的其他场景

- 若进入的场景中带有 path，则每次点击时都进入对应的 path 页面
- 若进入的场景中不带 path，则每次进入都打开首页

**A 类场景的重新启动策略**:

> 基础库 2.8.0 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

- 小程序被销毁后，下次冷启动如果属于 B 类场景，将会进入特定的页面。
- 下次冷启动如果属于 A 类场景，默认情况下将会进入小程序的首页。在页面对应的 json 文件中（也可以全局配置在 app.json 的 window 段中），指定 `restartStrategy` 配置项可以改变这个默认的行为，使得从某个页面退出后，下次 A 类场景的冷启动可以回到这个页面。

`restartStrategy` 可选值:

可选值 | 含义
------|------
homePage | （默认值）如果从这个页面退出小程序，下次将从首页冷启动
homePageAndLatestPage | 如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）

> 注意：
> 即使不配置为 **homePage** ，小程序如果退出过久（当前默认**一天**时间，可以使用退出状态来调整），下次冷启动时也将不再遵循 **restartStrategy** 的配置，而是直接从首页冷启动。
> 无论如何，页面中的状态并不会被保留，如输入框中的文本内容、 checkbox 的勾选状态等都不会还原。如果需要还原或部分还原，需要利用退出状态。

**退出状态**
每当小程序可能被销毁之前，页面回调函数 `onSaveExitState` 会被调用。如果想保留页面中的状态，可以在这个回调函数中"保存"一些数据，下次启动时可以通过 `exitState` 获得这些已保存数据。需要 `restartStrategy` 为 `homePageAndLatestPage`。

```js
Page({
  onLoad: function() {
    var prevExitState = this.exitState; // 尝试获得上一次退出前 onSaveExitState 保存的数据
    if(prevExitState !== undefined) {
      prevExitState.myDataField === "myData"; // 如果是根据 restartStrategy 配置进行的冷启动，就可以获取到
    }
  },
  onSaveExitState: function() {
    var exitState = { myDataField : "myData"} // 需要保存的数据
    return {
      data: exitState,
      expireTimeStamp: Date.now() + 24 * 60 * 60 * 1000 // 超时时刻
    }
  }
})
```

`onSaveExitState` 返回值可以包含两项:

字段名 | 类型 | 含义
------|-------|-----
data | Any | 需要保存的数据（只能是 JSON 兼容的数据）
expireTimeStamp | Number | 超时时刻，在这个时刻后，保存的数据保证一定被丢弃，默认为 (当前时刻 + 1 天)

> 注意：
>
> 1. 如果超过 `expireTimeStamp` ，保存的数据将被丢弃，且冷启动时不遵循 `restartStrategy` 的配置，而是直接从首页冷启动。
> 2. `expireTimeStamp` 有可能被自动提前，如微信客户端需要清理数据的时候。
> 3. 在小程序存活期间， `onSaveExitState` 可能会被多次调用，此时以最后一次的调用结果作为最终结果。
> 4. 在某些特殊情况下（如微信客户端直接被系统杀死），这个方法将不会被调用，下次冷启动也不遵循 `restartStrategy` 的配置，而是直接从首页冷启动。
> 5. 不能是 tabBar 的页面，否则不起作用

### 3.4 更新机制

**未启动时更新**
在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现有用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。

**启动时更新**
小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。

如果需要马上应用最新版本，可以使用 [wx.getUpdateManager](https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html) API 进行处理。

```js
const updateManager = wx.getUpdateManager();

updateManager.onCheckForUpdate(function() {
  // 请求完新版本信息的回调
  console.log(res.hasUpdate)
})

updateManager.onUpdateReady(function() {
  wx.showModel({
    title : "更新提示",
    content : '新版本已准备好，是否重启应用？'，
    success(res) {
      if(res.confirm) {
        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启
        updateManager.applyUpdate();
      }
    }
  })
})

updateManager.onUpdateFailed(function() {
  // 新版本下载失败
})
```

## 四. 自定义组件

从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。

可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

**创建自定义组件**
类似于页面，一个自定义组件由 **json** **wxml** **wxss** **js** 4个文件组成。要编写一个自定义组件，首先需要在 **json** 文件中进行自定义组件声明（将 `component` 字段设为 `true`）。

> 注意：在组件wxss中不应使用ID选择器、属性选择器 和 标签名选择器。

在自定义组件的 js 文件中，需要使用 `Component()` 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，属性值是可由组件外部传入的。

**使用自定义组件**
使用已注册的自定义组件前，首先要在页面的 **json** 文件或 **app.json** 中声明 `usingComponents` 字段，在 **app.json** 中声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。

```json
{
  "usingComponents" : {
     "component-tag-name": "path/to/the/custom/component"
  }
}
```

这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

> 注意事项:
>
> 1. 因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
> 2. 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 `usingComponents` 字段）。
> 3. 自定义组件和页面所在项目根目录名不能以 "wx-" 为前缀，否则会报错。
> 4. 是否在页面文件中使用 `usingComponents` 会使得页面的 `this` 对象的原型稍有差异
>     - 使用 usingComponents 页面的原型与不使用时不一致，即 Object.getPrototypeOf(this) 结果不同。
>     - 使用 usingComponents 时会多一些方法，如 selectComponent 。
>     - 出于性能考虑，使用 usingComponents 时， setData 内容不会被直接深复制，即 this.setData({ field: obj }) 后 this.data.field === obj 。（深复制会在这个值被组件间传递时发生。）

### 4.1 组件模板与样式

类似于页面，自定义组件拥有自己的 `wxml` 模板和 `wxss` 样式。

**组件模板**
组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

在组件模板中可以提供一个 `<slot>` 节点，用于承载组件引用时提供的子节点。

```wxml
<!-- 组件模板 -->
<view class="wrapper">
  <view>这里是组件的内部节点</view>
  <slot></slot>
</view>
```

```wxml
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```

> 注意 : 在模板中引用到的自定义组件及其对应的节点名需要在 json 文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为 [抽象节点](#49-抽象节点)。

**模板数据绑定**
与普通的 WXML 模板类似，可以使用数据绑定，向子组件的属性传递动态数据。

```wxml
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```

在以上例子中，组件的属性 **propA** 和 **propB** 将收到页面传递的数据。页面可以通过 **setData** 来改变绑定的数据字段。

> 注意：这样的数据绑定只能传递 JSON 兼容数据。自基础库版本 2.0.9 开始，还可以在数据中包含函数（但这些函数不能在 WXML 中直接调用，只能传递给子组件）。

**组件 wxml 的 slot**
在组件的 wxml 中可以包含 `slot` 节点，用于承载组件使用者提供的 wxml 结构。

默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。

```js
Component({
  options: {
    multipleSlots: true // 在组件定义时的选项中启用多slot支持
  },
  properties: { /* ... */ },
  methods: { /* ... */ }
})
```

此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 name 来区分。

```wxml
<!-- 组件模板 -->
<view class="wrapper">
  <slot name="before"></slot>
  <view>这里是组件的内部细节</view>
  <slot name="after"></slot>
</view>
```

使用时，用 `slot` 属性来将节点插入到不同的 slot 上。

```wxml
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
    <view slot="before">这里是插入到组件slot name="before"中的内容</view>
    <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
    <view slot="after">这里是插入到组件slot name="after"中的内容</view>
  </component-tag-name>
</view>
```

**组件样式**
组件对应 wxss 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点：

- 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。
- 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。
- 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。
- 继承样式，如 font 、 color ，会从组件外继承到组件内。
- 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。

除此以外，组件可以指定它所在节点的默认样式，使用 `:host` 选择器（需要包含基础库 1.7.2 或更高版本的开发者工具支持）。

例: [:host](./test/pages/component-show/component-show.wxss)

**组件样式隔离**
默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：

- `app.wxss` 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
- 指定特殊的样式隔离选项 `styleIsolation`(在Component构造器的 **options** 中定义) 。

`styleIsolation` 选项从基础库版本 2.6.5 开始支持。它支持以下取值：

- **isolated** : 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；
- **apply-shared** : 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；
- **shared** : 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 `apply-shared` 或 `shared` 的自定义组件。（这个选项在插件中不可用）

> 使用后两者时，请务必注意组件间样式的相互影响。

如果这个 Component 构造器用于构造页面 ，则默认值为 shared ，且还有以下几个额外的样式隔离选项可用：

- **page-isolated** : 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；
- **page-apply-shared** : 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；
- **page-shared** : 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 styleIsolation （这样就不需在 js 文件的 options 中再配置）。
小程序基础库版本 2.2.3 以上支持 `addGlobalClass` 选项，即在 Component 的 options 中设置 `addGlobalClass: true` 。 这个选项等价于设置 `styleIsolation: apply-shared` ，但设置了 styleIsolation 选项后这个选项会失效。

**外部样式类**:

> 基础库 1.9.90 开始支持，低版本需做 [兼容处理](compatibility) 。

有时，组件希望接受外部传入的样式类。此时可以在 `Component` 中用 `externalClasses` 定义段定义若干个外部样式类。

这个特性可以用于实现类似于 **view** 组件的 `hover-class` 属性：页面可以提供**一个**样式类，赋予 view 的 hover-class ，这个样式类本身写在页面中而非 view 组件的实现中。

> **注意**：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。

```js
/* 组件 custom-component.js */
Component({
  externalClasses: ['my-class']
})
```

```wxml
<!-- 组件 custom-component.wxml -->
<custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>
```

这样，组件的使用者可以指定这个样式类对应的 class ，就像使用普通属性一样。在 2.7.1 之后，可以指定多个对应的 class 。

**引用页面或父组件的样式**:

> 基础库 2.9.2 开始支持，低版本需做 [兼容处理](compatibility)。

即使启用了样式隔离 **isolated** ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。

例如，如果在页面 wxss 中定义了：

```wxss
.blue-text {
  color: blue;
}
```

在这个组件中可以使用 `~` 来引用这个类的样式：

```wxml
<view class="~blue-text"> 这段文本是蓝色的 </text>
```

如果在一个组件的父组件 wxss 中定义了：

```wxss
.red-text {
  color: red;
}
```

在这个组件中可以使用 `^` 来引用这个类的样式：

```wxml
<view class="^red-text"> 这段文本是红色的 </view>
```

也可以连续使用多个 `^` 来引用祖先组件中的样式。

> 注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。

**虚拟化组件节点**:

> 基础库 2.11.2 开始支持，低版本需做兼容处理。

默认情况下，自定义组件本身的那个节点是一个"普通"的节点，使用时可以在这个节点上设置 **class**、**style** 、**动画**、 **flex** 布局等，就如同普通的 view 组件节点一样。

但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex 布局等，而是希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定。

这种情况下，可以将这个自定义组件设置为"虚拟的"：

```js
Component({
  options: {
    virtualHost: true
  },
  properties: {
    style: { // 定义 style 属性可以拿到 style 属性上设置的值
      type: String
    }
  },
  externalClasses:['my-class']
})
```

这样，可以将 flex 放入自定义组件内：

```wxml
<!-- 页面的 WXML -->
<view style="display: flex">
  <!-- 如果设置了 virtualHost ，节点上的样式将失效 -->
  <custom-component class="my-class" style="color: blue">不是蓝色的</custom-component>
</view>
```

```wxml
<!-- custom-component.wxml -->
<view style="flex: 1">
  <text>满宽的</text>
  <slot></slot>
</view>
```

> 需要注意的是
>
> 1. 自定义组件节点上的 **class** **style** 和 **动画** 将不再生效
> 2. 将 style 定义成 `properties` 属性来获取 style 上设置的值
> 3. 将 class 定义成 `externalClasses` 外部样式类使得自定义组件 wxml 可以使用 class 值。

### 4.2 Component 构造器

`Component` 构造器可用于定义组件，调用 `Component` 构造器时可以指定组件的属性、数据、方法等。

```js
Component({

  behaviors: [],

  properties: {
    myProperty: { // 属性名
      type: String,
      value: ''
    },
    myProperty2: String // 简化的定义方式
  },

  data: {}, // 私有数据，可用于模板渲染

  lifetimes: {
    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
    attached: function () { },
    moved: function () { },
    detached: function () { },
  },

  pageLifetimes: {
    // 组件所在页面的生命周期函数
    show: function () { },
    hide: function () { },
    resize: function () { },
  },

  methods: {
    onMyButtonTap: function(){
      this.setData({
        // 更新属性和数据的方法与更新页面数据的方法类似
      })
    },
    // 内部方法建议以下划线开头
    _myPrivateMethod: function(){
      // 这里将 data.A[0].B 设为 'myPrivateData'
      this.setData({
        'A[0].B': 'myPrivateData'
      })
    }
  }

})
```

**使用 Component 构造器构造页面**
事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 `Component` 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 *json* 文件中包含 `usingComponents` 定义段。

此时，组件的属性可以用于接收页面的参数，如访问页面 **/pages/index/index?paramA=123&paramB=xyz** ，如果声明有属性 **paramA** 或 **paramB** ，则它们会被赋值为 123 或 xyz 。

页面的生命周期方法（即 `on` 开头的方法），应写在 `methods` 定义段中。

```js
Component({
  properties: {
    paramA: Number,
    paramB: String
  },

  methods: {
    onLoad: function() {
      this.data.paramA // 页面参数 paramA 的值
      this.data.paramB // 页面参数 paramB 的值
    }
  }
})
```

使用 Component 构造器来构造页面的一个好处是可以使用 `behaviors` 来提取所有页面中公用的代码段。

例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 `behaviors` 中。

```js
// page-common-behavior.js
module.exports = Behaviors({
  attached: function() {
    // 页面创建时执行
    console.info('Page loaded!')
  },
  detached: function() {
    // 页面销毁时执行
    console.info('Page unloaded!')
  }
})
```

```js
// 页面 A 或 B
var pageCommonBehavior = require("./page-common-behavior");
Component({
  behavior: [pageCommonBehavior],
  data: { ... },
  methods: { ... }
})
```

### 4.3 组件间通信与事件

**组件间通信**
组件间的基本通信方式有以下几种：

- **WXML 数据绑定** ：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 [组件模板和样式](#41-组件模板与样式)
- **事件** ：用于子组件向父组件传递数据，可以传递任意数据。
- 如果以上两种方式不足以满足需要，父组件还可以通过 `this.selectComponent` 方法获取子组件实例对象，这样就可以直接访问子组件的任意数据和方法。

**监听事件**
事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见 [事件系统](#234-事件系统)

监听自定义组件事件的方法与监听基础组件事件的方法完全一致。

**触发自定义事件**
自定义组件触发事件时，需要使用 `triggerEvent` 方法，指定 事件名、detail对象 和 事件选项：

```wxml
<!-- 在自定义组件中 -->
<button bindtap="onTap">点击这个按钮将触发"myEvent"事件</button>
```

```js
Component({
  properties: {},
  methods: {
    onTap: function() {
      var myEventDetail = {}; // detail对象，提供给事件监听函数
      var myEventOption = {}; // 触发事件的选项
      this.triggerEvent("myEvent", myEventDetail, myEventOption);
    }
  }
})
```

触发事件的选项包括：

选项名 | 类型 | 是否必填 |默认值 | 描述
------|------|---------|-------|------
bubbles | Boolean | 否 | false | 事件是否冒泡
composed | Boolean | 否 | false | 事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部
captruePhase | Boolean | 否 | false | 事件是否拥有捕获阶段

```wxml
// 页面 page.wxml
<another-component bindcustomevent="pageEventListener1">
  <my-component bindcustomevent="pageEventListener2"></my-component>
</another-component>
```

```wxml
// 组件 another-component.wxml
<view bindcustomevent="anotherEventListener">
  <slot />
</view>
```

```wxml
// 组件 my-component.wxml
<view bindcustomevent="myEventListener">
  <slot />
</view>
```

```js
// 组件 my-component.js
Component({
  methods: {
    onTap: function() {
      this.triggerEvent('customevent', {}) // 只会触发 pageEventListener2
      this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1
      this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
    }
  }
})
```

**获取组件实例**
可在父组件里调用 `this.selectComponent` ，获取子组件的实例对象。（插件的自定义组件将返回 null）

调用时需要传入一个匹配选择器 `selector`，如：this.selectComponent(".my-component")。

`selector` 类似于 CSS 的选择器，但仅支持下列语法。

- ID选择器：`#the-id`
- class选择器（可以连续指定多个）：`.a-class.another-class`
- 子元素选择器：`.the-parent > .the-child`
- 后代选择器：`.the-ancestor` `.the-descendant`
- 跨自定义组件的后代选择器：`.the-ancestor >>> .the-descendant`
- 多选择器的并集：`#a-node, .some-other-nodes`

```js
// 父组件
Page({
  data: {},
  getChildComponent: function() {
    const child = this.selectComponent(".my-component");
    console.log(child);
  }
})
```

在上例中，父组件将会获取 `class` 为 `my-component` 的子组件实例对象，即子组件的 `this` 。

若需要自定义 `selectComponent` 返回的数据，可使用内置 `behavior: wx://component-export`，从基础库版本 2.2.3 开始提供支持。

使自定义组件中支持 `export` 定义段，这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值。

```js
// 自定义组件 my-component 内部
Component({
  behavior: ['wx://component-export'],
  export: function() {
    return { myField: 'myValue' }
  }
})
```

```wxml
<!-- 使用自定义组件时 -->
<my-component id="the-id" />
```

```js
// 父组件调用
const child = this.selectComponent('#the-id') // 等于 { myField: 'myValue' }
```

### 4.4 组件生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

其中，最重要的生命周期是 `created` `attached` `detached` ，包含一个组件实例生命流程的最主要时间点。

- 组件实例刚刚被创建好时， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 `setData`** 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。
- 在组件完全初始化完毕、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
- 在组件离开页面节点树后， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发。

**定义生命周期方法**
生命周期方法可以直接定义在 `Component` 构造器的第一级参数中。
自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。

```js
Component({
  lifetimes: {
    created: function() {
      // 组件实例刚刚被创建好时执行
    },
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    }
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {},
  detached: function() {},
  // ...
})
```

在 `behaviors` 中也可以编写生命周期方法，同时不会与其他 `behaviors` 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。

可用的全部生命周期如下表所示。

生命周期 | 参数 | 描述 | 最低版本
--------|------|------|--------
created | 无 | 在组件实例刚刚被创建时执行 | 1.6.3
attached | 无 | 在组件实例进入页面节点树时执行 | 1.6.3
ready | 无 | 在组件在视图层布局完成后执行 | 1.6.3
moved | 无 |  在组件实例被移动到节点树另一个位置时执行 | 1.6.3
detached | 无 | 在组件实例被从页面节点树移除时执行 | 1.6.3
error | Object Error | 每当组件方法抛出错误时执行 | 2.4.1

**组件所在页面的声明周期**
还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为 "组件所在页面的生命周期"，在 `pageLifetimes` 定义段中定义。其中可用的生命周期包括：

生命周期 | 参数| 描述 | 最低版本
--------|-----|-----|---------
show | 无 | 组件所在的页面被展示时执行 | 2.2.3
hide | 无 | 组件所在的页面被隐藏时执行 | 2.2.3
resize | Object Size | 组件所在的页面尺寸变化时执行 | 2.4.0

```js
Component({
  pageLifetimes: {
    show: function() {
      //  页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
    resize: function() {
      // 页面尺寸变化
    }
  }
})
```

### 4.5 behaviors

`behaviors` 是用于组件间代码共享的特性，类似于一些编程语言中的 "mixins" 或 "traits"。

每个 `behavior` 可以包含一组 属性、数据、生命周期函数 和 方法。**组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。** 每个组件可以引用多个 behavior ，behavior 也可以引用其它 behavior 。

#### 4.5.1 参数与含义

定义段 | 类型 | 是否必填 | 描述
------|------|----------|-----
properties | Object Map | 否 | 同组件的属性
data | Object | 否 | 同组件的数据
methods | Object | 否 | 同自定义组件的方法
behaviors | String Array | 否 | 引入其它的 behavior
created | Function | 否 | 在组件实例刚刚被创建时执行
attached | Function | 否 | 进入页面节点树时执行
ready | Function | 否 | 在视图层布局完成后执行
moved | Function | 否  | 被移动到节点树另一个位置时执行
detached | Function | 否 | 被从页面节点树移除时执行

```js
// my-behavior.js
module.exports = Behaviors({
  behaviors: [],
  properties: {
    myBehaviorProperty: function() {
      type: String
    }
  },
  data: {
    myBehaviorData: {}
  },
  attached: function() {},
  created: function() {},
  ready: function() {},
  methods: {
    myBehaviorMethod: function(){}
  }
})
```

```js
// my-component.js
var myBehavior = require('my-behavior')
Component({
  behaviors: [myBehavior],
  properties: {
    myProperty: {
      type: String
    }
  },
  data: {
    myData: "my-component-data"
  },
  created: function() {
    console.log('[my-component] created')
  },
  attached: function () {
    console.log('[my-component] attached')
  },
  ready: function () {
    console.log('[my-component] ready')
  },
  methods: {
    myMethod: function() {
      console.log('[my-component] log by myMethod')
    }
  }
})
```

在上例中， my-component 组件定义中加入了 my-behavior，

而 my-behavior 结构为：

- 属性：myBehaviorProperty
- 数据字段：myBehaviorData
- 方法：myBehaviorMethod
- 生命周期函数：attached、created、ready

这将使 my-component 最终结构为：

- 属性：myBehaviorProperty、myProperty
- 数据字段：myBehaviorData、myData
- 方法：myBehaviorMethod、myMethod
- 生命周期函数：attached、created、ready

当组件触发生命周期时，上例生命周期函数执行顺序为：

- [my-behavior] created
- [my-component] created
- [my-behavior] attached
- [my-component] attached
- [my-behavior] ready
- [my-component] ready

详细规则参考下面的 同名字段的覆盖和组合规则。

**同名字段的覆盖和组合规则**
组件和它引用的 `behavior` 中可以包含同名的字段，对这些字段的处理方法如下：

- 如果有同名的属性 (properties) 或方法 (methods)：
  1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 behavior 中的同名属性或方法；
  2. 若组件本身无这个属性或方法，则在组件的 behaviors 字段中定义靠后的 behavior 的属性或方法会覆盖靠前的同名属性或方法；
  3. 在 2 的基础上，若存在嵌套引用 behavior 的情况，则规则为：父 behavior 覆盖 子 behavior 中的同名属性或方法。
- 如果有同名的数据字段 (data)：
  - 若同名的数据字段都是对象类型，会进行对象合并；
  - 其余情况会进行数据覆盖，覆盖规则为：组件 > 父 behavior > 子 behavior 、 靠后的 behavior > 靠前的 behavior。（优先级高的覆盖优先级低的，最大的为优先级最高）
- 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：
  - 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序
  - 对于同种生命周期函数，遵循如下规则：
    - behavior 优先于组件执行
    - 子 behavior 优先于 父 behavior 执行
    - 靠前的 behavior 优先于 靠后的 behavior 执行
  - 如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次

#### 4.5.2 内置 behaviors

自定义组件可以通过引用内置的 `behavior` 来获得内置组件的一些行为。

```js
Component({
  behaviors: ['wx://form-field']
})
```

在上例中， `wx://form-field` 代表一个内置 `behavior` ，它使得这个自定义组件有类似于表单控件的行为。

内置 `behavior` 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的 `type` 或添加 `observer` 。

- **wx://form-field**
  使自定义组件有类似于表单控件的行为。 form 组件可以识别这些自定义组件，并在 submit 事件中返回组件的字段名及其对应字段值。这将为它添加以下两个属性。

  属性名 | 类型 | 字段
  ------|------|------
  name | String | 在表单中的字段名
  value | Any | 在表单中的字段值

  ```js
  Component({
    behaviors: ['wx://form-field'],
    data: {
      value: ''
    },
    methods: {
      onChange: function(e) {
        this.setData({
          value: e.detail.value
        })
      }
    }
  })
  ```

- **wx://form-field-group**
  从基础库版本 2.10.2 开始提供支持。
  使 form 组件可以识别到这个自定义组件内部的所有表单控件。 例如，页面的结构如下：

  ```wxml
  <form bindsubmit="submit">
    <custom-comp></custom-comp>
    <button form-type="submit">submit</button>
  </form>
  ```

  组件 **custom-comp** 自身结构如下：

  ```wxml
  <input name="name">
  <switch name="student"></switch>
  ```

  如果组件 **custom-comp** 配置有：

  ```js
  Component({
    behaviors: ['wx://form-field-group']
  })
  ```

  此时，表单的 **submit** 事件的 value 中将包含 `name` 和 `student` 两个字段。

- **wx://form-field-button**
  从基础库版本 2.10.3 开始提供支持。
  使 form 组件可以识别到这个自定义组件内部的 button 。如果自定义组件内部有设置了 **form-type** 的 button ，它将被组件外的 form 接受。 例如，页面的结构如下：

  ```wxml
  <form>
    <input name="name" placeholder="请输入名字" />
    <custom-comp></custom-comp>
  </form>
  ```

  组件 **custom-comp** 自身结构如下：

  ```wxml
  <button form-type="submit">submit</button>
  ```

  如果组件 custom-comp 配置有：

  ```js
  Component({
    behaviors: ['wx://form-field-button']
  })
  ```

  此时点击组件内的 button ，将触发 form 的 submit 事件。

- **wx://component-export**
  从基础库版本 2.2.3 开始提供支持。
  使自定义组件支持 `export` 定义段。这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值。
  详细用法 [selectComponent](#43-组件间通信与事件)

### 4.6 组件间关系

#### 4.6.1 定义和使用组件间关系

有时需要实现这样的组件：

```wxml
<custom-ul>
  <custom-li> item 1 </custom-li>
  <custom-li> item 2 </custom-li>
</custom-ul>
```

这个例子中， custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入 `relations` 定义段，可以解决这样的问题。示例：

```js
// path/to/custom-ul.js
Component({
  relations: {
    './custom-li': {
      type: 'child', // 关联的目标节点应为子节点
      linked: function(target) {
        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
      },
      linkChanged: function(target) {
        // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
      },
      unlinked: function(target) {
        // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
      }
    }
  },
  methods: {
    _getAllLi: function() {
      // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
      var nodes = this.getRelationNodes('./custom-li-component');
    }
  },
  ready: function() {
    this._getAllLi();
  }
})
```

```js
// path/to/custom-li.js
Component({
  relations: {
    './custom-ul': {
      type: "parent",
      linked: function(target) {
        // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
      },
      linkChanged: function(target) {
        // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
      },
      unlinked: function(target) {
        // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
      }
    }
  }
})
```

> 注意：必须在两个组件定义中都加入relations定义，否则不会生效。

#### 4.6.2 关联一类组件

有时，需要关联的是一类组件，如：

```wxml
<custom-from>
  <view>
    <text>input</text>
    <custom-input></custom-input>
  </view>
  <custom-submit> submit </submit-submit>
</custom-from>
```

`custom-form` 组件想要关联 `custom-input` 和 `custom-submit` 两个组件。此时，如果这两个组件都有同一个 `behavior`：

```js
// path/to/custom-submit.js
var customFormControls = require('./custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    './custom-form': {
      type: 'ancestor' // 关联的目标节点应为祖先节点
    }
  }
})
```

则在 `relations` 关系定义中，可使用这个 `behavior` 来代替组件路径作为关联的目标节点：

```wxml
// path/to/custom-form.js
var customFormControls = require('./custom-form-controls')
Component({
  relations: {
    'customFormControls': {
      type: 'descendant', // 关联的目标节点应为子孙节点
      target: customFormControls // 替组件路径作为关联的目标节点
    }
  }
})
```

#### 4.6.3 relations 定义段

`relations` 定义段包含目标组件路径及其对应选项，可包含的选项见下表。

选项 | 类型 | 是否必填 | 描述
----|------|----------|-----
type | String | 是 | 目标组件的相对关系，可选的值为 `parent` 、 `child` 、 `ancestor` 、 `descendant`
linked | Function | 否 | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件attached生命周期之后
linkChanged | Function | 否 | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件moved生命周期之后
unlinked | Function | 否 | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件detached生命周期之后
target | String | 否 | 如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联

### 4.7 数据监听器

数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。

**使用数据监听器**
有时，在一些数据字段被 `setData` 设置时，需要执行一些操作。

例如， this.data.sum 永远是 this.data.numberA 与 this.data.numberB 的和。此时，可以使用数据监听器进行如下实现。

```js
Component({
  attached: function() {
    this.setData({
      numberA: 1,
      numberB: 2
    })
  },
  observers: {
    'numberA, numberB': function(numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    }
  }
})
```

**监听字段语法**
数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。

同时，监听器可以监听子数据字段，如下例所示。

```js
Component({
  observers: {
    'some.subfield': function(subfield) {
      // 使用 setData 设置 this.data.some.subfield 时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      console.log(subfield === this.data.some.subfield);
    },
    'arr[12]': function(arr12) {
      // 使用 setData 设置 this.data.arr[12] 时触发
      // （除此以外，使用 setData 设置 this.data.arr 也会触发）
      console.log(arr12 === this.data.arr[12]);
    }
  }
})
```

如果需要监听所有子数据字段的变化，可以使用通配符 `**` 。

```js
Component({
  observers: {
    'some.field.**': function(field) {
      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      console.log(field === this.data.some.field);
    }
  },
  attached: function() {
    // 这样会触发上面的 observer
    this.setData({
      'some.field': { /* ... */ }
    })
    // 这样也会触发上面的 observer
    this.setData({
      'some.field.xxx': { /* ... */ }
    })
    // 这样还是会触发上面的 observer
    this.setData({
      'some': { /* ... */ }
    })
  }
})
```

特别地，仅使用通配符 `**` 可以监听全部 `setData`

```js
Component({
  observers: {
    '**': function() {
      // 每次 setData 都触发
    },
  },
})
```

**Bugs & Tips**:

- 数据监听器监听的是 `setData` 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
- 如果在数据监听器函数中使用 `setData` 设置本身监听的数据字段，可能会导致死循环，需要特别留意。
- 数据监听器和属性的 `observer` 相比，数据监听器更强大且通常具有更好的性能。

### 4.8 纯数据字段

纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能。从小程序基础库版本 2.8.2 开始支持。

**组件数据中的纯数据字段**
有些情况下，某些 `data` 中的字段（包括 `setData` 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。

此时，可以指定这样的数据字段为 "纯数据字段"，它们将仅仅被记录在 `this.data` 中，而 **不参与任何界面渲染过程**，这样有助于提升页面更新性能。

指定 "纯数据字段" 的方法是在 `Component` 构造器的 `options` 定义段中指定 `pureDataPattern` 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

```js
Component({
  options: {
    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true,
    _b: true // 纯数据字段
  },
  methods: function() {
    myMethod: function() {
      this.data._b // 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, // 普通数据字段
        _d: true, // 纯数据字段
      })
    }
  }
})
```

**组件属性中的纯数据字段**
属性也可以被指定为纯数据字段（遵循 pureDataPattern 的正则表达式）。

属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的 WXML 中。

```js
Component({
  options: {
    pureDataPattern: /^_/
  },
  properties: {
    a: Boolean,
    _b: {
      type: Boolean,
      observer() {
        // 不要这样做！这个 observer 永远不会被触发
      }
    }
  }
})
```

> 注意：属性中的纯数据字段的属性 `observer` 永远不会触发！如果想要监听属性值变化，使用 数据监听器 代替。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 `pureDataPattern` （这样就不需在 js 文件的 options 中再配置）。此时，其值应当写成字符串形式：

```js
"pureDataPattern": "^_"
```

**使用数据监听器监听纯数据字段**
数据监听器 可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

下面的示例是一个将 JavaScript 时间戳转换为可读时间的自定义组件。

```js
Component({
  options: {
    pureDataPattern: /^timestamp$/
  },
  properties: {
    timestamp: Number
  },
  observers: {
    timestamp: function() {
      // timestamp 被设置时，将它展示为可读时间字符串
      var timeString = new Date(this.data.timestamp).toLocaleString();
      this.setData({
        timestamp: timeString
      })
    }
  }
})
```

### 4.9 抽象节点

> 这个特性自小程序基础库版本 1.9.6 开始支持。

**在组件中使用抽象节点**
有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为"抽象节点"。

例如，实现一个"选框组"（selectable-group）组件，它其中可以放置单选框（custom-radio）或者复选框（custom-checkbox）。这个组件的 wxml 可以这样编写：

```wxml
<!-- selectable-group.wxml -->
<view wx:for="{{labels}}">
  <label>
    <selectable disabled="{{false}}"></selectable>
  </label>
</view>
```

其中，"selectable" 不是任何在 json 文件的 `usingComponents` 字段中声明的组件，而是一个抽象节点。它需要在 `componentGenerics` 字段中声明：

```json
{
  "componentGenerics": {
    "selectable": true
  }
}
```

例: [selectable-group](./test/pages/selectable-group)

**使用包含抽象节点的组件**
在使用 selectable-group 组件时，必须指定"selectable"具体是哪个组件：

```wxml
<selectable-group generic:selectable="custom-radio" ></selectable-group>
```

这样，在生成这个 selectable-group 组件的实例时，"selectable"节点会生成"custom-radio"组件实例。类似地，如果这样使用

```wxml
<selectable-group generic:selectable="custom-checkbox" />
```

"selectable"节点则会生成"custom-checkbox"组件实例。

例：[tests](./test/pages/tests)

> 注意：上述的 custom-radio 和 custom-checkbox 需要包含在这个 wxml 对应 json 文件的 `usingComponents` 定义段中。**selectable** 是在抽象节点 json 文件的 `componentGenerics` 字段中声明的。

**抽象节点的默认组件**
抽象节点可以指定一个默认组件，当具体组件未被指定时，将创建默认组件的实例。默认组件可以在 `componentGenerics` 字段中指定：

```json
{
  "componentGenerics": {
    "selectable": {
      "default": "path/to/default/component"
    }
  }
}
```

> Tips: 节点的 `generic` 引用 `generic:xxx="yyy"` 中，值 yyy 只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。

### 4.10 自定义组件扩展

为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。从小程序基础库版本 2.2.3 开始支持。

**扩展后的效果**
自定义组件的扩展其实就是提供了修改自定义组件定义段的能力，下面的例子就是修改了自定义组件中的 `data` 定义段里的内容。

```js
// behavior.js
module.exports = Behaviors({
  definitionFilter(defFields) {
    defFields.data.from = "behavior"
  }
})

// component.js
Component({
  data: {
    from: "component"
  },
  behaviors: [require("./behavior.js"],
  ready() {
    console.log(this.data.from); // 此处会发现输出 behavior 而不是 component
  }
})
```

**使用扩展**
`Behavior()` 构造器提供了新的定义段 `definitionFilter` ，用于支持自定义组件扩展。 `definitionFilter` 是一个函数，在被调用时会注入两个参数，第一个参数是使用该 behavior 的 `component/behavior` 的定义对象，第二个参数是该 behavior 所使用的 `behavior` 的 `definitionFilter` 函数列表。

```js
// behavior3.js
module.exports = Behavior({
  definitionFilter(defFields, definitionFilter) {}
})

// behavior2.js
module.exports = Behavior2({
  behavior: [require(./behavior3.js)],
  definitionFilter(defFields, definitionFilter) {
    // definitionFilterArr[0](defFields)
  }
})

// behavior1.js
module.exports = Behavior({
  behaviors: [require('behavior2.js')],
  definitionFilter(defFields, definitionFilterArr) {}
})

// component.js
Component({
  behaviors: [require('behavior1.js')],
})
```

上述代码中声明了1个自定义组件和3个 behavior，每个 behavior 都使用了 `definitionFilter` 定义段。那么按照声明的顺序会有如下事情发生：

1. 当进行 behavior2 的声明时就会调用 behavior3 的 definitionFilter 函数，其中 defFields 参数是 behavior2 的定义段， definitionFilterArr 参数即为空数组，因为 behavior3 没有使用其他的 behavior 。
2. 当进行 behavior1 的声明时就会调用 behavior2 的 definitionFilter 函数，其中 defFields 参数是 behavior1 的定义段， definitionFilterArr 参数是一个长度为1的数组，definitionFilterArr[0] 即为 behavior3 的 definitionFilter 函数，因为 behavior2 使用了 behavior3。在此处可以自行决定在进行 behavior1 的声明时要不要调用 behavior3 的 definitionFilter 函数，如果需要调用，在此处补充代码 `definitionFilterArr[0](defFields)` 即可，definitionFilterArr 参数会由基础库补充传入。
3. 同理，在进行 component 的声明时就会调用 behavior1 的 definitionFilter 函数。

简单概括，definitionFilter 函数可以理解为当 A 使用了 B 时，A 声明就会调用 B 的 definitionFilter 函数并传入 A 的定义对象让 B 去过滤。此时如果 B 还使用了 C 和 D ，那么 B 可以自行决定要不要调用 C 和 D 的 definitionFilter 函数去过滤 A 的定义对象。

### 4.11 单元测试

在编写高质量的自定义组件过程中，单元测试是永远避不开的一个话题。完善的测试用例是提高自定义组件可用性的保证，同时测试代码覆盖率也是必不可少的一个环节。小程序从基础库版本 2.2.1 开始拥抱开源，支持使用 npm 安装自定义组件，那针对自定义组件的单元测试也是必须支持的。

**测试框架**
现在市面上流行的测试框架均可使用，只要它能兼顾 nodejs 端和 dom 环境。因为需要依赖到 nodejs 的一些库来完善测试环境，同时 dom 环境也是必须的，因为需要建成完整的 dom 树结构，才能更好的模拟自定义组件的运行。例如可以选用 mocha + jsdom 的组合，亦可选用 jest。

**自定义组件测试工具集**
小程序的运行环境比较特殊，不同于常见的浏览器环境，它采用的是双线程的架构。而在进行单元测试时，并不需要用到这样复杂的架构带来的利好，进行的是功能测试而无需苛求性能、安全等因素，因此小程序提供了一个测试工具集以支持自定义组件在 nodejs 单线程中也能运行起来。

我们先安装一下测试工具集—— [miniprogram-simulate](https://github.com/wechat-miniprogram/miniprogram-simulate)：

```npm
npm i --save-dev miniprogram-simulate
```

**编写测试用例**:

```js
// /test/components/index.test.js
const simulate = require('miniprogram-simulate')

test('components/index', () => {
    const id = simulate.load('/components/index') // 此处必须传入绝对路径
    const comp = simulate.render(id) // 渲染成自定义组件树实例

    const parent = document.createElement('parent-wrapper') // 创建父亲节点
    comp.attach(parent) // attach 到父亲节点上，此时会触发自定义组件的 attached 钩子

    const view = comp.querySelector('.index') // 获取子组件 view
    expect(view.dom.innerHTML).toBe('index.properties') // 测试渲染结果
    expect(window.getComputedStyle(view.dom).color).toBe('green') // 测试渲染结果
})
```

> 注意：
> 测试工具集中的 wx 对象和内置组件都不会实现真正的功能，如果需要测试一些特殊场景的话，可以自行覆盖掉测试工具集中的 api 接口和内置组件。
> 目前因为有部分自定义组件功能仍未支持（如抽象节点等），故测试工具暂无法全部覆盖自定义组件的特性。

测试工具集中提供了一些方便测试的接口，比如：

- 模拟 touch 事件、自定义事件触发
- 选取子节点
- 更新自定义组件数据
- 触发生命周期
- ...

更多详细的用法可以参阅 [github](https://github.com/wechat-miniprogram/miniprogram-simulate) 仓库上的文档。

### 4.12 获取更新性能统计信息

> 基础库 2.12.0 开始支持，低版本需做 [兼容处理](compatibility)。

如果想要知道 `setData` 引发界面更新的开销，可以使用更新性能统计信息接口(`setUpdatePerformanceListener`)。它将返回每次更新中主要更新步骤发生的时间戳，可以用来大体上估计自定义组件（或页面）更新性能。例如：

```js
Component({
  attached: function() { // 调用时机不能早于 attached
    this.setUpdatePerformanceListener({withDataPaths: true}, (res) => {
      console.log(res);
    })
  }
})
```

`setUpdatePerformanceListener` 方法接受一个 `options` 对象和回调函数 `listener` 作为参数。

其中， options 对象包含以下字段：

字段 | 类型 | 说明
-----|------|-----
withDataPaths | Boolean | 是否返回变更的 data 字段信息

`listeners` 返回携带一个 `res` 对象，表示一次由 `setData` 引发的 更新过程 。根据 `setData` 调用时机的不同，更新过程大体可以分为三类：

  1. **基本更新** : 它有一个唯一的 `updateProcessId`
  2. **子更新** : 它是另一个基本更新的一个子步骤，也有唯一的 `updateProcessId` ，但还有一个 `parentUpdateProcessId`
  3. **被合并更新** : 它被合并到了另一个基本更新或子更新过程中，无法被独立统计

每次成功的 `setData` 调用都会产生一个更新过程，使得 `listener` 回调一次。不过 `setData` 究竟触发了哪类更新过程很难判断，更新性能好坏与其具体是哪类更新也没有必然联系，只是它们的返回值参数有所不同。

`res` 中包含以下字段：

字段 | 类型 | 说明
-----|-----|------
updateProcessId | Number | 此次更新过程的 ID
parentUpdateProcessId | Number | 对于子更新，返回它所属的更新过程 ID
isMergedUpdate | Boolean | 是否是被合并更新，如果是，则 updateProcessId 表示被合并到的更新过程 ID
dataPaths | Array | 此次更新的 data 字段信息，只有 withDataPaths 设为 true 时才会返回
pendingStartTimestamp | Number | 此次更新进入等待队列时的时间戳
updateStartTimestamp | Number | 更新运算开始时的时间戳
updateEndTimestamp | Number | 更新运算结束时的时间戳

> 说明：
> `setUpdatePerformanceListener` 只会激活当前组件或页面的统计， `parentUpdateProcessId` 有可能是其他组件或者页面的更新过程 ID 而未被统计回调，如果想要知道页面内所有的更新过程，需要在所有组件中都调用 `setUpdatePerformanceListener` ；
> 统计本身有一点点开销，如果想要禁用统计，调用 `setUpdatePerformanceListener` 时传入第二个参数 `listener` 为 `null` 即可。

## 五. 基础能力

### 5.1 网络

#### 5.1.1 使用说明

在小程序/小游戏中使用网络相关的 API 时，需要注意下列问题。

- 服务器域名配置
  服务器域名请在 「小程序后台-开发-开发设置-服务器域名」 中进行配置，配置时需要注意：
  - **注意事项**
    1. 每个微信小程序需要事先设置通讯域名
    2. 小程序只可以跟指定的域名进行网络通信。包括普通 HTTPS 请求（[wx.request][wx.request]）、上传文件（[wx.uploadFile][wx.uploadFile]）、下载文件（[wx.downloadFile][wx.downloadFile]) 和 WebSocket 通信（[wx.connectSocket][wx.connectSocket]）。
    3. 从基础库 2.4.0 开始，网络接口允许与局域网 IP 通信，但要注意 **不允许与本机 IP 通信**。
    4. 从 2.7.0 开始，提供了 UDP 通信（[wx.createUDPSocket][wx.createUDPSocket])。
    5. 出于安全考虑，`api.weixin.qq.com` 不能被配置为服务器域名，相关API也不能在小程序内调用。 应将 `AppSecret` 保存到后台服务器中，通过服务器使用 `getAccessToken` 接口获取 `access_token`，并调用相关 API；
    6. 域名必须经过 ICP 备案；
    7. 域名不能使用 IP 地址（小程序的局域网 IP 除外）或 localhost；
    8. 不支持配置父域名，使用子域名。
    9. 可以配置端口，如 `https://myserver.com:8080`，但是配置后只能向 `https://myserver.com:8080` 发起请求。如果向 `https://myserver.com` 、`https://myserver.com:9091` 等 URL 请求则会失败。
    10. 如果不配置端口。如 `https://myserver.com`，那么请求的 URL 中也不能包含端口，甚至是默认的 443 端口也不可以。如果向 `https://myserver.com:443` 请求则会失败。

- 网络请求
  - **超时时间**
    - 默认超时时间和最大超时时间都是 60s；
    - 超时时间可以在 app.json 或 game.json 中通过 `networkTimeout` 配置。

  - **使用限制**
    - 网络请求的 `referer` header 不可设置。其格式固定为 `https://servicewechat.com/{appid}/{version}/page-frame.html`，其中 {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0 表示为开发版、体验版以及审核版本，版本号为 devtools 表示为开发者工具，其余为正式版本；
    - [wx.request][wx.request]、[wx.uploadFile][wx.uploadFile]、[wx.downloadFile][wx.downloadFile] 的最大并发限制是 **10** 个
    - [wx.connectSocket][wx.connectSocket] 的最大并发限制是 **5** 个。
    - 小程序进入后台运行后，如果 **5s** 内网络请求没有结束，会回调错误信息 `fail interrupted`；在回到前台之前，网络请求接口调用都会无法调用。

  - **返回值编码**
    - 建议服务器返回值使用 `UTF-8` 编码。对于非 UTF-8 编码，小程序会尝试进行转换，但是会有转换失败的可能。
    - 小程序会自动对 BOM 头进行过滤（只过滤一个BOM头）。

  - **回调函数**
    - 只要成功接收到服务器返回，无论 `statusCode` 是多少，都会进入 `success` 回调。根据业务逻辑对返回值进行判断。

- 常见问题
  - **HTTPS 证书**
    小程序必须使用 `HTTPS/WSS` 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。由于系统限制，不同平台对于证书要求的严格程度不同。为了保证小程序的兼容性，建议按照最高标准进行证书配置，并使用相关工具检查现有证书是否符合要求。对证书要求如下：
    - HTTPS 证书必须有效
      - 证书必须被系统信任，即根证书被已系统内置
      - 部署 SSL 证书的网站域名必须与证书颁发的域名一致
      - 证书必须在有效期内
      - 证书的信任链必需完整（需要服务器配置）
    - `iOS` 不支持自签名证书
    - `iOS` 下证书必须满足苹果 [App Transport Security (ATS)](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33) 的要求;
    - TLS 必须支持 1.2 及以上版本。部分旧 Android 机型还未支持 TLS 1.2，请确保 HTTPS 服务器的 TLS 版本支持 1.2 及以下版本;
    - 部分 CA 可能不被操作系统信任，请在选择证书时注意小程序和各系统的相关通告
      - [Chrome 56/57 内核对 WoSign、StartCom 证书限制周知](https://developers.weixin.qq.com/community/develop/doc/800026caeb042e45681583652b70910a)
    > 证书有效性可以使用 `openssl s_client -connect example.com:443` 命令验证，也可以使用其他[在线工具](https://myssl.com/ssl.html)。
    > 除了网络请求 API 外，小程序中其他 HTTPS 请求如果出现异常，也请按上述流程进行检查。如 https 的图片无法加载、音视频无法播放等。

  - 跳过域名校验
    在微信开发者工具中，可以临时开启 开发环境不校验请求域名、TLS版本及HTTPS证书 选项，跳过服务器域名的校验。此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。
    在服务器域名配置成功后，建议开发者关闭此选项进行开发，并在各平台下进行测试，以确认服务器域名配置正确。
    > 如果手机上出现 "打开调试模式可以发出请求，关闭调试模式无法发出请求" 的现象，请确认是否跳过了域名校验，并确认服务器域名和证书配置是否正确。

#### 5.1.2 局域网通信

基础库 2.4.0 提供了 [wx.startLocalServiceDiscovery][wx.startLocalServiceDiscovery] 等一系列 mDNS API，可以用来获取局域网内提供 mDNS 服务的设备的 IP。 [wx.request][wx.request]/[wx.connectSocket][wx.connectSocket]/[wx.uploadFile][wx.uploadFile]/[wx.downloadFile][wx.downloadFile] 的 url 参数允许为 `${IP}:${PORT}/${PATH}` 的格式，当且仅当 IP 与手机 IP 处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个 wifi 下）时，请求/连接才会成功。

在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用 http/ws。

```js
wx.request({
  url: 'http://10.9.176.40:828'
   // 省略其他参数
})

wx.connectSocket({
  url: 'ws://10.9.176.42:828'
  // 省略其他参数
})
```

基础库 2.7.0 开始，提供了 [wx.createUDPSocket][wx.createUDPSocket] 接口用于进行 UDP 通信。通信规则同上，仅允许同一局域网下的非本机 IP。

**mDNS**
目前小程序只支持通过 mDNS 协议获取局域网内其他设备的 IP。iOS 上 mDNS API 的实现基于 [Bonjour](https://developer.apple.com/bonjour/)，Android 上则是基于 [Android 系统接口](https://developer.android.com/training/connect-devices-wirelessly/nsd)。

**serviceType**
发起 mDNS 服务搜索 [wx.startLocalServiceDiscovery][wx.startLocalServiceDiscovery] 的接口有 `serviceType` 参数，指定要搜索的服务类型。

serviceType 的格式和规范，iOS Bonjour Overview 在 Bonjour Names for Existing Service Types 有提及。

### 5.2 存储

每个微信小程序都可以有自己的本地缓存，可以通过 一下 API 对本地缓存进行读写和清理。

- 将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB
  - [wx.setStorage][wx.setStorage] / [wx.setStorageSync][wx.setStorageSync]
  - **参数 Object object**

    属性 | 类型 | 必填 | 说明
    -----|------|-----|-----
    key |  string |  是 |  本地缓存中指定的 key
    data |  any |  是 |  需要存储的内容。只支持原生类型、Date、及能够通过JSON.stringify序列化的对象。
    success |  function |  否 |  接口调用成功的回调函数
    fail |  function |  否 |  接口调用失败的回调函数
    complete |  function |  否 |  接口调用结束的回调函数（调用成功、失败都会执行）

    ```js
    wx.setStorage({
      key: 'key',
      data: 'value'
    })

    try {
      wx.setStorageSync('key', 'value');
    } catch(e) {}
    ```

- **从本地缓存中异步获取指定 `key` 的内容**
  - [wx.getStorage][wx.getStorage] / [wx.getStorageSync][wx.getStorageSync]
  - **参数 Object object**

    属性 | 类型 | 必填 | 说明
    -----|------|-----|-----
    key |  string |  是 |  本地缓存中指定的 key
    success |  function |  否 |  接口调用成功的回调函数
    fail |  function |  否 |  接口调用失败的回调函数
    complete |  function |  否 |  接口调用结束的回调函数（调用成功、失败都会执行）

  - object.success 回调函数参数 Object res

    属性 | 类型 | 说明
    ----|------|------
    data | any | key对应的内容

    ```js
    wx.getStorage({
      key: 'key',
      success (res) {
        console.log(res.data)
      }
    })

    try {
      var value = wx.getStorageSync("key");
      if(value) {
        // ...
      }
    } catch(e) {
        // ...
    }
    ```

- **清理本地数据缓存**
  - [wx.clearStorage][wx.clearStorage] / [wx.clearStorageSync][wx.clearStorageSync]
  - **参数 Object object**

    属性 | 类型 | 必填 | 说明
    -----|------|-----|-----
    success |  function |  否 |  接口调用成功的回调函数
    fail |  function |  否 |  接口调用失败的回调函数
    complete |  function |  否 |  接口调用结束的回调函数（调用成功、失败都会执行）

    ```js
    wx.clearStorage();

    try {
      wx.clearStorageSync()
    } catch(e) {
      // Do something when catch error
    }
    ```

- **从本地缓存中移除指定 key**
  - [wx.removeStorage][wx.removeStorage] / [wx.removeStorageSync][wx.removeStorageSync]
  - **参数 Object object**

    属性 | 类型 | 必填 | 说明
    -----|------|-----|-----
    key |  string |  是 |  本地缓存中指定的 key
    success |  function |  否 |  接口调用成功的回调函数
    fail |  function |  否 |  接口调用失败的回调函数
    complete |  function |  否 |  接口调用结束的回调函数（调用成功、失败都会执行）

    ```js
    wx.removeStorage({
      key: 'key',
      success (res) {
        console.log(res)
      }
    })

    try {
      wx.removeStorageSync('key')
    } catch(e) {
      // Do something when catch error
    }
    ```

**隔离策略**
同一个微信用户，同一个小程序 storage 上限为 10MB。storage 以用户维度隔离，同一台设备上，A 用户无法读取到 B 用户的数据；不同小程序之间也无法互相读写数据。

**插件隔离策略**:

1. 同一小程序使用不同插件：不同插件之间，插件与小程序之间 storage 不互通。
2. 不同小程序使用同一插件：同一插件 storage 不互通。

**清理策略**
本地缓存的清理时机跟代码包一样，只有在代码包被清理的时候本地缓存才会被清理。

### 5.3 文件系统

文件系统是小程序提供的一套以小程序和用户维度隔离的存储以及一套相应的管理接口。通过 [wx.getFileSystemManager()][wx.getFileSystemManager] 可以获取到全局唯一的文件系统管理器，所有文件系统的管理操作通过 [FileSystemManager][FileSystemManager] 来调用。

文件主要分为两大类：

- 代码包文件：代码包文件指的是在项目目录中添加的文件。
- 本地文件：通过调用接口本地产生，或通过网络下载下来，存储到本地的文件。
  1. 本地临时文件：临时产生，随时会被回收的文件。不限制存储大小。
  2. 本地缓存文件：小程序通过接口把本地临时文件缓存后产生的文件，不能自定义目录和文件名。跟本地用户文件共计，小程序（含小游戏）最多可存储 200MB。
  3. 本地用户文件：小程序通过接口把本地临时文件缓存后产生的文件，允许自定义目录和文件名。跟本地缓存文件共计，小程序（含小游戏）最多可存储 200MB。

**代码包文件**
由于代码包文件大小限制，代码包文件适用于放置首次加载时需要的文件，对于内容较大或需要动态替换的文件，不推荐用添加到代码包中，推荐在小游戏启动之后再用下载接口下载到本地。

**访问代码包文件**
代码包文件的访问方式是从项目根目录开始写文件路径，不支持相对路径的写法。如：`/a/b/c`、`a/b/c` 都是合法的，`./a/b/c` `../a/b/c` 则不合法。

**修改代码包文件**
代码包内的文件无法在运行后动态修改或删除，修改代码包文件需要重新发布版本。

**本地文件**
本地文件指的是小程序被用户添加到手机后，会有一块独立的文件存储区域，以用户维度隔离。即同一台手机，每个微信用户不能访问到其他登录用户的文件，同一个用户不同 appId 之间的文件也不能互相访问。

本地文件的文件路径均为 `{{协议名}}://文件路径` 格式。

> 其中，协议名在 iOS/Android 客户端为 "wxfile"，在开发者工具上为 "http"，无需关注这个差异，也不应在代码中去硬编码完整文件路径。

**本地临时文件**
本地临时文件只能通过调用特定接口产生，不能直接写入内容。本地临时文件产生后，仅在当前生命周期内有效，重启之后即不可用。因此，不可把本地临时文件路径存储起来下次使用。如果需要下次在使用，可通过 [FileSystemManager.saveFile()][FileSystemManager.saveFile] 或 [FileSystemManager.copyFile()][FileSystemManager.copyFile] 接口把本地临时文件转换成本地缓存文件或本地用户文件。

```js
wx.chooseImage({
  success: function(res) {
    var tempFilePaths = res.tempFilePaths; // tempFilePaths 的每一项是一个本地临时文件路径
  }
})
```

**本地缓存文件**
本地缓存文件只能通过调用特定接口产生，不能直接写入内容。本地缓存文件产生后，重启之后仍可用。本地缓存文件只能通过 [FileSystemManager.saveFile()][FileSystemManager.saveFile] 接口将本地临时文件保存获得。

```js
fs.saveFile({
  tempFilePath: '', // 传入一个本地临时文件路径
  success(res) {
    console.log(res.savedFilePath); // res.savedFilePath 为一个本地缓存文件路径
  }
})
```

> **注意：本地缓存文件是最初的设计，1.7.0 版本开始，提供了功能更完整的本地用户文件，可以完全覆盖本地缓存文件的功能，如果不需要兼容低于 1.7.0 版本，可以不使用本地缓存文件。**

**本地用户文件**
本地用户文件是从 1.7.0 版本开始新增的概念。提供了一个用户文件目录给开发者，开发者对这个目录有完全自由的读写权限。通过 `wx.env.USER_DATA_PATH` 可以获取到这个目录的路径。

```js
// 在本地用户文件目录下创建一个文件 hello.txt，写入内容 "hello, world"
const fs = wx.getFileSystemManager();
fs.writeFileSync(`${wx.env.USER_DATA_PATH}/hello.txt`, 'hello', 'utf8')
```

**读写权限**:

接口、组件 | 读 | 写
----------|----|---
代码包文件 |  有 |  无
本地临时文件 |  有 |  无
本地缓存文件 |  有 |  无
本地用户文件 |  有 |  有

**清理策略**:

- 本地临时文件只保证在小程序当前生命周期内，一旦小程序被关闭就可能被清理，即下次冷启动不保证可用。
- 本地缓存文件和本地用户文件的清理时机跟代码包一样，只有在代码包被清理的时会被清理。

### 5.4 画布

所有在 [canvas][canvas] 中的画图必须用 JavaScript 完成：

WXML：（接下来的例子中如无特殊声明都会用这个 WXML 为模板，不再重复）

```wxml
<canvas canvas-id="myCanvas" style="border: 1px solid;"></canvas>
```

JS：（接下来的例子中会将 JS 放在 onLoad 中）

```js
// 1. 创建一个 Canvas 绘图上下文 [CanvasContext][CanvasContext]。CanvasContext 是小程序内建的一个对象，有一些绘图的方法
const ctx = wx.createCanvasContext('myCanvas')
// 2. 使用 Canvas 绘图上下文进行绘图描述
ctx.setFillStyle('red')
// 用 fillRect(x, y, width, height) 方法画一个矩形，填充为刚刚设置的红色
ctx.fillRect(10, 10, 150, 75)
// 3. 画图，告诉 canvas 组件要将刚刚的描述绘制上去
ctx.draw()
```

#### 5.4.1 坐标系

canvas 是在一个二维的网格当中。左上角的坐标为(0, 0)。

可以在 [canvas][canvas] 中加上一些事件，来观测它的坐标系

```wxml
<canvas canvas-id="myCanvas"
  style="margin: 5px; border:1px solid #d3d3d3;"
  bindtouchstart="start"
  bindtouchmove="move"
  bindtouchend="end"/>

<view hidden="{{hidden}}">
  Coordinates: {{x}}，{{y}}
</view>
```

```js
Page({
  data: {
    x: 0,
    y: 0,
    hidden: true
  },
  start: function(e) {
    this.setData({
      hidden: false,
      x: e.touches[0].x,
      y: e.touches[0].y
    })
  },
  move: function(e) {
    this.setData({
      x: e.touches[0].x,
      y: e.touches[0].y
    })
  },
  end: function(e) {
    this.setData({
      hidden: true
    })
  }
})
```

#### 5.4.2 渐变

渐变能用于填充一个矩形，圆，线，文字等。填充色可以不固定为固定的一种颜色。

小程序提供了两种颜色渐变的方式：

- [createLinearGradient(x, y, x1, y1)][CanvasContext.createCircularGradient] 创建一个线性的渐变
- [createCircularGradient(x, y, r)][CanvasContext.createLinearGradient] 创建一个从圆心开始的渐变

一旦创建了一个渐变对象，必须添加两个颜色渐变点。

[addColorStop(position, color)][CanvasGradient.addColorStop] 方法用于指定颜色渐变点的位置和颜色，位置必须位于0到1之间。

可以用 fillStyle 和 setStrokeStyle 方法设置渐变，然后进行画图描述。

使用 `createLinearGradient()`

```js
const ctx = wx.createLinearGradient('myCanvas');

// Create linear gradient
const grd = ctx.createLinearGradient(0, 0, 200, 0)
grd.addColorStop(0, 'red')
  .addColorStop(1, 'white')

// fill with gradient
ctx.setFillStyle(grd);
  .fillRect(10, 10, 150, 80)
  .draw();
```

使用 `createCircularGradient()`

```js
const ctx = wx.createCanvasContext('myCanvas')

// Create circular gradient
ctx.createCircularGradient(75, 50, 50)
grd.addColorStop(0, 'red')
  .addColorStop(1, 'white')

// Fill with gradient
ctx.setFillStyle(grd)
  .fillRect(10, 10, 150, 80)
  .draw()
```

### 5.5 分包加载

某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。

在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个 **主包**。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而分包则是根据开发者的配置进行划分。

在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。

目前小程序分包大小有以下限制：

- 整个小程序所有分包大小不超过 20M
- 单个分包/主包大小不能超过 2M

对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。

#### 5.5.1 使用分包

**配置方法**
假设支持分包的小程序目录结构如下：

```txt
├── app.js
├── app.json
├── app.wxss
├── packageA
│   └── pages
│       ├── cat
│       └── dog
├── packageB
│   └── pages
│       ├── apple
│       └── banana
├── pages
│   ├── index
│   └── logs
└── utils
```

可以通过在 **app.json** `subpackages` 字段声明项目分包结构：

```json
{
  "pages":[
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat",
        "pages/dog"
      ]
    }, {
      "root": "packageB",
      "name": "pack2",
      "pages": [
        "pages/apple",
        "pages/banana"
      ]
    }
  ]
}
```

`subpackages` 中，每个分包的配置有以下几项：

字段 | 类型 | 说明
----|------|-----
root | String | 分包根目录
name | String | 分包别名，分包预下载时可以使用
pages | StringArray | 分包页面路径，相对与分包根目录
independent | Boolean | 分包是否是独立分包

**打包原则**:

- 声明 `subpackages` 后，将按 `subpackages` 配置路径进行打包，`subpackages` 配置路径外的目录将被打包到 app（主包） 中
- app（主包）也可以有自己的 pages（即最外层的 pages 字段）
- `subpackage` 的根目录不能是另外一个 `subpackage` 内的子目录
- `tabBar` 页面必须在 app（主包）内

**引用原则**:

- packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件
- packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 template
- packageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源

**低版本兼容**
由微信后台编译来处理旧版本客户端的兼容，后台会编译两份代码包，一份是分包后代码，另外一份是整包的兼容代码。 新客户端用分包，老客户端还是用的整包，完整包会把各个 `subpackage` 里面的路径放到 pages 中。

#### 5.5.2 独立分包

> 基础库 2.3.0 及以上版本开始支持。

独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。

开发者可以按需将某些具有一定功能独立性的页面配置到独立分包中。当小程序从普通的分包页面启动时，需要首先下载主包；而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度。

一个小程序中可以有多个独立分包。

**配置方法**
假设小程序目录结构如下：

```txt
├── app.js
├── app.json
├── app.wxss
├── moduleA
│   └── pages
│       ├── rabbit
│       └── squirrel
├── moduleB
│   └── pages
│       ├── pear
│       └── pineapple
├── pages
│   ├── index
│   └── logs
└── utils
```

通过在 `app.json` 的 `subpackages` 字段中对应的分包配置项中定义 `independent` 字段声明对应分包为独立分包。

```json
{
  "pages": [
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "moduleA",
      "pages": [
        "pages/rabbit",
        "pages/squirrel"
      ]
    }, {
      "root": "moduleB",
      "pages": [
        "pages/pear",
        "pages/pineapple"
      ],
      "independent": true
    }
  ]
}
```

**限制**
独立分包属于分包的一种。普通分包的所有限制都对独立分包有效。独立分包中插件、自定义组件的处理方式同普通分包。

此外，使用独立分包时要注意：

- **独立分包中不能依赖主包和其他分包中的内容**，包括js文件、template、wxss、自定义组件、插件等。主包中的 `app.wxss` 对独立分包无效，应避免在独立分包页面中使用 `app.wxss` 中的样式；
- `App` 只能在主包内定义，独立分包中不能定义 `App`，会造成无法预期的行为；
- 独立分包中暂时不支持使用插件。

**注意事项**:

- 关于 getApp()
  与普通分包不同，独立分包运行时，`App` 并不一定被注册，因此 `getApp()` 也不一定可以获得 `App` 对象：
  - 当用户从独立分包页面启动小程序时，主包不存在，`App` 也不存在，此时调用 `getApp()` 获取到的是 `undefined`。 当用户进入普通分包或主包内页面时，主包才会被下载，`App` 才会被注册。
  由于这一限制，无法通过 `App` 对象实现独立分包和小程序其他部分的全局变量共享。
  为了在独立分包中满足这一需求，基础库 2.2.4 版本开始 `getApp` 支持 [`allowDefault`] 参数，在 App 未定义时返回一个默认实现。当主包加载，App 被注册时，默认实现中定义的属性会被覆盖合并到真正的 App 中。

  ```js
  // 独立分包中
  const app = wx.getApp({allowDefault: true});
  app.data = 456
  app.global = {}

  App({
    data: 123,
    other: 'hello'
  })
  console.log(getApp()) // {global: {}, data: 456, other: 'hello'}
  ```

- 关于 App 生命周期
  当从独立分包启动小程序时，主包中 App 的 `onLaunch` 和首次 `onShow` 会在从独立分包页面首次进入主包或其他普通分包页面时调用。
  由于独立分包中无法定义 App，小程序生命周期的监听可以使用 [wx.onAppShow][wx.onAppShow]，[wx.onAppHide][wx.onAppHide] 完成。App 上的其他事件可以使用 [wx.onError][wx.onError]，[wx.onPageNotFound][wx.onPageNotFound] 监听。

**低版本兼容**
在低于6.7.2版本的微信中运行时，独立分包视为普通分包处理，不具备独立运行的特性。

> 注意：在兼容模式下，主包中的 `app.wxss` 可能会对独立分包中的页面产生影响，因此应避免在独立分包页面中使用 `app.wxss` 中的样式。

#### 5.5.3 分包预下载

> 基础库 2.3.0 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

开发者可以通过配置，在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度。对于独立分包，也可以预下载主包。

**分包预下载目前只支持通过配置方式使用，暂不支持通过调用API完成。**

> vConsole 里有 `preloadSubpackages` 开头的日志信息，可以用来验证预下载的情况。

**配置方法**
预下载分包行为在进入某个页面时触发，通过在 `app.json` 增加 `preloadRule` 配置来控制。

```json
{
  "pages": ["pages/index"],
  "subpackages": [
    {
      "root": "important",
      "pages": ["index"],
    },
    {
      "root": "sub1",
      "pages": ["index"],
    },
    {
      "name": "hello",
      "root": "path/to",
      "pages": ["index"]
    },
    {
      "root": "sub3",
      "pages": ["index"]
    },
    {
      "root": "indep",
      "pages": ["index"],
      "independent": true
    }
  ],
  "preloadRule": {
    "pages/index": {
      "network": "all",
      "packages": ["important"]
    },
    "sub1/index": {
      "packages": ["hello", "sub3"]
    },
    "sub3/index": {
      "packages": ["path/to"]
    },
    "indep/index": {
      "packages": ["__APP__"]
    }
  }
}
```

`preloadRule` 中，`key` 是页面路径，`value` 是进入此页面的预下载配置，每个配置有以下几项：

字段 | 类型 | 必填 | 默认值 | 说明
-----|-----|------|-------|-----
package | StringArray | 是 | 无 | 进入页面后预下载分包的 `root` 或 `name`。`__APP__` 表示主包。
network | String | 否 | wifi | 在指定网络下预下载，可选值为： `all`: 不限网络，`wifi`: 仅wifi下预下载

**限制**
同一个分包中的页面享有共同的预下载大小限额 **2M**，限额会在工具中打包时校验。
如，页面 A 和 B 都在同一个分包中，A 中预下载总大小 0.5M 的分包，B中最多只能预下载总大小 1.5M 的分包。

### 5.6 多线程Worker

一些异步处理的任务，可以放置于 Worker 中运行，待运行结束后，再把结果返回到小程序主线程。Worker 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法。

Worker 与主线程之间的数据传输，双方使用 [Worker.postMessage()][Worker.postMessage] 来发送数据，[Worker.onMessage()][Worker.onMessage] 来接收数据，传输的数据并不是直接共享，而是**被复制**的。

**使用流程**:

1. 配置Worker 信息
  在 `app.json` 中可配置 `Worker` 代码放置的目录，目录下的代码将被打包成一个文件：

    ```json
    {
      "workers": "workers"
    }
    ```

2. 添加 Worker 代码文件
  根据步骤 1 中的配置，在代码目录下新建以下两个入口文件：

    ```txt
    workers/request/index.js
    workers/request/utils.js
    workers/response/index.js
    ```

    添加后，目录结构如下：

    ```txt
    ├── app.js
    ├── app.json
    ├── project.config.json
    └── workers
        ├── request
        │   ├── index.js
        │   └── utils.js
        └── response
            └── index.js
    ```

3. 编写 Worker 代码
  在 `workers/request/index.js` 编写 Worker 响应代码

    ```js
    const utils = require("./utils")
    // 在 Worker 线程执行上下文会全局暴露一个 worker 对象，直接调用 worker.onMessage/postMessage 即可
    worker.onMessage(function (res) {
      console.log(res)
    })
    ```

4. 在主线程中初始化 Worker
  在主线程的代码 app.js 中初始化 Worker

    ```js
    // 文件名指定 worker 的入口文件路径，绝对路径
    const worker = wx.createWorker('/workers/request/index.js')
    ```

5. 主线程向 Worker 发送消息

  ```js
  worker.postMessage({
    msg: 'hello worker'
  })
  ```

worker 对象的其它接口看 [worker接口指南][https://developers.weixin.qq.com/miniprogram/dev/api/worker/wx.createWorker.html]

> 注意:
>
> 1. Worker 最大并发数量限制为 1 个，创建下一个前请用 `Worker.terminate()` 结束当前 Worker
> 2. Worker 内代码只能 `require` 指定 `Worker` 路径内的文件，无法引用其它路径
> 3. Worker 的入口文件由 `wx.createWorker()` 时指定，开发者可动态指定 Worker 入口文件
> 4. Worker 内不支持 `wx` 系列的 API
> 5. Workers 之间不支持发送消息

### 5.7 服务端能力

#### 5.7.1 服务端API

小程序还提供了一系列在后端服务器使用 HTTPS 请求调用的 API，帮助开发者在后台完成各类数据分析、管理和查询等操作。如 getAccessToken，code2Session 等。详细介绍参考 [服务端文档][服务端]。

**access_token**
`access_token` 是小程序全局唯一后台接口调用凭据，调用绝大多数后台接口时都需使用。开发者可以通过 `getAccessToken` 接口获取并进行妥善保存。
为了 access_token 的安全性，后端 API 不能直接在小程序内通过 [wx.request][wx.request] 调用，即 `api.weixin.qq.com` 不能被配置为服务器域名。开发者应在后端服务器使用 `getAccessToken` 获取 `access_token`，并调用相关 API；

**请求参数说明**:

- 对于 GET 请求，请求参数应以 `QueryString` 的形式写在 URL 中。
- 对于 POST 请求，部分参数需以 `QueryString` 的形式写在 URL 中（一般只有 `access_token`，如有额外参数会在文档里的 URL 中体现），其他参数如无特殊说明均以 JSON 字符串格式写在 POST 请求的 body 中。

**返回参数说明**:

> 注意：当API调用成功时，部分接口不会返回 `errcode` 和 `errmsg`，只有调用失败时才会返回。

#### 5.7.2 消息推送

接入微信小程序消息推送服务，可以两种方式选择其一：

1. 开发者服务器接收消息推送
2. 云函数接收消息推送

##### 5.7.2.1 开发者服务器接收消息推送

**第一步：填写服务器配置**
登录小程序后台后，在「开发」-「开发设置」-「消息推送」中，管理员扫码启用消息服务，填写服务器地址（URL）、令牌（Token） 和 消息加密密钥（EncodingAESKey）等信息。

- URL: 用来接收微信消息和事件的接口 URL。所填写的URL 必须以 `http://` 或 `https://` 开头，分别支持 80 端口和 443 端口。
- Token: 可以任意填写，用作生成签名（该 Token 会和接口 URL 中包含的 Token 进行比对，从而验证安全性）。
- EncodingAESKey: 手动填写或随机生成，将用作消息体加解密密钥。

同时，可选择消息加解密方式：明文模式（默认）、兼容模式和安全模式。可以选择消息数据格式：XML 格式（默认）或 JSON 格式。

模式的选择与服务器配置在提交后都会立即生效，请谨慎填写及选择。切换加密方式和数据格式需要提前配置好相关代码，详情参考 [消息加解密说明][消息加解密说明]。

**第二步：验证消息的确来自微信服务器**
提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带参数如下表所示：

参数 | 描述
-----|-----
signature | 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。
timestamp | 时间戳
nonce | 随机数
echostr | 随机字符串

通过检验 `signature` 对请求进行校验（下面有校验方式）。若确认此次 GET 请求来自微信服务器，原样返回 `echostr` 参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：

1. 将token、timestamp、nonce三个参数进行字典序排序
2. 将三个参数字符串拼接成一个字符串进行sha1加密
3. 获得加密后的字符串可与signature对比，标识该请求来源于微信

验证URL有效性成功后即接入生效

**第三步：接收消息和事件**
当某些特定的用户操作引发事件推送时（如用户向小程序客服发送消息、或者进入会话等情况），微信服务器会将消息（或事件）的数据包以 POST 请求发送到开发者配置的 URL，开发者可以依据自身业务逻辑进行响应。

微信服务器在将用户的消息发给开发者服务器地址后，微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。如果在调试中，发现用户无法收到响应的消息，可以检查是否消息处理超时。关于重试的消息排重，有 msgid 的消息推荐使用 msgid 排重。事件类型消息推荐使用 `FromUserName + CreateTime` 排重。

服务器收到请求必须做出下述回复，这样微信服务器才不会对此作任何处理，并且不会发起重试，否则，将出现严重的错误提示。详细说明：

1. 直接回复success（推荐方式）
2. 直接回复空串（指字节长度为0的空字符串，而不是结构体中content字段的内容为空）
3. 若接口文档有指定返回内容，应按文档说明返回

对于客服消息，一旦遇到以下情况，微信会在小程序会话中向用户下发系统提示"该小程序客服暂时无法提供服务，请稍后再试"：

1. 在5秒内未回复任何内容
2. 回复了异常数据

如果希望增强安全性，可以在开发者中心处开启消息加密，这样，用户发给小程序的消息以及小程序被动回复用户消息都会继续加密，详见 [消息加解密说明][消息加解密说明]。

##### 5.7.2.2 云函数接收消息推送

开通了 [云开发][云开发] 的小程序可以使用云函数接收消息推送，目前仅支持客服消息推送。

**第一步：开发者工具云开发控制台中增加配置**
打开云开发控制台，到设置 tab 中选择全局设置 - 添加消息推送配置。消息类型对应收包的 `MsgType`，事件类型对应收包的 `Event`，同一个 <消息类型, 事件类型> 二元组只能推到一个环境的一个云函数。例如客服消息文本消息对应的就是消息类型为 `text`，事件类型为空。具体值查看各个消息的消息格式。

**第二步：云函数中处理消息**
云函数被触发时，其 `event` 参数即是接口所定义的 JSON 结构的对象（统一 JSON 格式，不支持 XML 格式）。

以客服消息为例，接收到客服消息推送时，`event` 结构如下：

```json
{
  "FromUserName": "ohl4L07T_DaNQa4ePaz0",
  "ToUserName": "wx3d289323f5900f8e",
  "Content": "测试",
  "CreateTime": 1555684067,
  "MsgId": "49d72d67b16d115e7935ac386f2f0fa41535298877_1555684067",
  "MsgType": "text"
}
```

此时可调用 [发送客服消息][customerServiceMessage.send] 接口回复消息，一个简单的接收到消息后统一回复 "收到" 的示例如下：

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()

  await cloud.openapi.customerServiceMessage.send({
    touser: wxContext.OPENID,
    msgtype: 'text',
    text: {
      content: '收到',
    },
  })

  return 'success'
}
```

### 5.8 自定义 tabBar

> 基础库 2.5.0 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。

自定义 tabBar 可以让开发者更加灵活地设置 tabBar 样式，以满足更多个性化的场景。

**在自定义 tabBar 模式下**:

- 为了保证低版本兼容以及区分哪些页面是 tab 页，tabBar 的相关配置项需完整声明，但这些字段不会作用于自定义 tabBar 的渲染。
- 此时需要提供一个自定义组件来渲染 tabBar，所有 tabBar 的样式都由该自定义组件渲染。推荐用 fixed 在底部的 cover-view + cover-image 组件渲染样式，以保证 tabBar 层级相对较高。
- 与 tabBar 样式相关的接口，如 wx.setTabBarItem 等将失效
- 每个 tab 页下的自定义 tabBar 组件实例是不同的，可通过自定义组件下的 `getTabBar` 接口，获取当前页面的自定义 tabBar 组件实例。

> 注意：如需实现 tab 选中态，要在当前页面下，通过 `getTabBar` 接口获取组件实例，并调用 `setData` 更新选中态。

**使用流程**:

1. 配置信息
    - 在 app.json 中的 tabBar 项指定 `custom` 字段，同时其余 tabBar 相关配置也补充完整。
    - 所有 tab 页的 json 里需声明 `usingComponents` 项，也可以在 app.json 全局开启。

      ```json
      {
        "tabBar": {
          "custom": true,
          "color": "#000000",
          "selectedColor": "#000000",
          "backgroundColor": "#000000",
          "list": [{
            "pagePath": "page/component/index",
            "text": "组件"
          }, {
            "pagePath": "page/API/index",
            "text": "接口"
          }]
        },
        "usingComponents": {}
      }
      ```

2. 添加 tabBar 代码文件
  在代码根目录下添加入口文件:

    ```txt
    custom-tab-bar/index.js
    custom-tab-bar/index.json
    custom-tab-bar/index.wxml
    custom-tab-bar/index.wxss
    ```

3. 编写 tabBar 代码
  用自定义组件的方式编写即可，该自定义组件完全接管 `tabBar` 的渲染。另外，自定义组件新增 `getTabBar` 接口，可获取当前页面下的自定义 `tabBar` 组件实例。

### 5.9 周期性更新

> 基础库 2.8.0 开始支持，低版本需做 [兼容处理](#111-低版本兼容)。
> 生效条件：用户七天内使用过小程序

周期性更新能够在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间，增强在弱网条件下的可用性。

**使用流程**:

1. 配置数据下载地址
  登录小程序管理后台，进入设置 -> 开发设置 -> 数据周期性更新，点击开启，填写数据下载地址。

2. 设置 TOKEN
  第一次启动小程序时，调用 [wx.setBackgroundFetchToken()][wx.setBackgroundFetchToken] 设置一个 TOKEN 字符串，可以跟用户态相关，会在后续微信客户端向开发者服务器请求时带上，便于给后者校验请求合法性。

    ```js
    APP({
      onLaunch: function() {
        wx.setBackgroundFetchToken({
          token: 'xxx'
        })
      }
    })
    ```

3. 微信客户端定期拉取数据
  微信客户端会在一定的网络条件下，每隔 12 小时（以上一次成功更新的时间为准）向配置的数据下载地址发起一个 HTTP GET 请求，其中包含的 `query` 参数如下，数据获取到后会将整个 `HTTP body` 缓存到本地。

    参数 | 类型 | 说明
    -----|-----|------
    appid | String | 小程序标识
    token | String | 前面设置的 TOKEN
    timestamp | Number | 时间戳，微信客户端发起请求的时间

    > query 参数会使用 urlencode 处理
    > 服务器接口返回的数据类型应为字符串，且大小应不超过 256KB，否则将无法缓存数据

4. 读取数据
  用户启动小程序时，调用 [wx.getBackgroundFetchData()][wx.getBackgroundFetchData] 获取已缓存到本地的数据。

    ```js
    App({
      onLaunch: function() {
        wx.getBackgroundFetchData({
          fetch: 'periodic',
          success(res) {
            console.log(res.fetchedData) // 缓存数据
            console.log(res.timeStamp) // 客户端拿到缓存数据的时间戳
          }
        })
      }
    })
    ```

**调试方法**
为了方便调试周期性数据，工具提供了调试能力，具体查看 [周期性数据调试](https://developers.weixin.qq.com/miniprogram/dev/devtools/periodic-data.html)。

### 5.10 数据预拉取

预拉取能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度 。

**使用流程**:

1. 配置数据下载地址
  登录小程序 MP 管理后台，进入设置 -> 开发设置 -> 数据预加载，点击开启，填写数据下载地址，只支持 HTTPS 。

2. 设置 TOKEN
  第一次启动小程序时，调用 [wx.setBackgroundFetchToken()][wx.setBackgroundFetchToken] 设置一个 TOKEN 字符串，可以跟用户态相关，会在后续微信客户端向开发者服务器请求时带上，便于给后者校验请求合法性。

    ```js
    App({
      onLaunch() {
        wx.setBackgroundFetchToken({
          token: 'xxx'
        })
      }
    })
    ```

3. 微信客户端提前拉取数据
  当用户打开小程序时，微信服务器将向开发者服务器（上面配置的数据下载地址）发起一个 HTTP GET 请求，其中包含的 `query` 参数如下，数据获取到后会将整个 HTTP body 缓存到本地。

    参数 | 类型 | 必填 | 说明
    ----|------|------|-----
    appid | String | 是 | 小程序标识。
    token | String | 否 | 前面设置的 TOKEN。
    code | String | 否 | 用户登录凭证，未设置TOKEN时由微信侧预生成，可在开发者后台调用 [auth.code2Session][auth.code2Session]，换取 openid 等信息。
    timestamp | Number | 是 | 时间戳，微信客户端发起请求的时间
    path | String | 否 | 打开小程序的路径。
    query | String | 否 | 打开小程序的query。
    scene | Number | 否 | 打开小程序的场景值。

    > query 参数会使用 urlencode 处理
    > token和code只会存在一个，用于标识用户身份。
    > 服务器接口返回的数据类型应为字符串，且大小应不超过 256KB，否则将无法缓存数据

4. 读取数据
  用户启动小程序时，调用 wx.getBackgroundFetchData() 获取已缓存到本地的数据。

    ```js
    App({
      onLaunch() {
        wx.getBackgroundFetchData({
          fetchType: 'pre',
          success(res) {
            console.log(res.fetchedData) // 缓存数据
            console.log(res.timeStamp) // 客户端拿到缓存数据的时间戳
            console.log(res.path) // 页面路径
            console.log(res.query) // query 参数
            console.log(res.scene) // 场景值
          }
        })
      }
    })
    ```

**调试方法**
工具提供了调试能力，具体查看 [预拉取数据调试](https://developers.weixin.qq.com/miniprogram/dev/devtools/prefetch-data.html)。

### 5.11 DarkModel 适配指南

> 基础库 v2.11.0 开始支持

**开启 DarkMode**
在 app.json 中配置 `darkmode` 为true，即表示当前小程序已适配 DarkMode，所有基础组件均会根据系统主题展示不同的默认样式，navigation bar 和 tab bar 也会根据下面的配置自动切换。

**相关配置**
当 app.json 中配置 `darkmode` 为true时，小程序部分配置项可通过变量的形式配置，在变量配置文件中定义不同主题下的颜色或图标，方法如下：

1. 在 app.json 中配置 `themeLocation`，指定变量配置文件 theme.json 路径，例如：在根目录下新增 theme.json，需要配置 `"themeLocation":"theme.json"`
2. 在 theme.json 中定义相关变量；
3. 在 app.json 中以 `@` 开头引用变量。

支持通过变量配置的属性：

- 全局配置的 window 属性与页面配置下的属性
  - navigationBarBackgroundColor
  - navigationBarTextStyle
  - backgroundColor
  - backgroundTextStyle
  - backgroundColorTop
  - backgroundColorBottom
- 全局配置 window.tabBar 的属性
  - color
  - selectedColor
  - backgroundColor
  - borderStyle
  - list
    - iconPath
    - selectedIconPath

**变量配置文件 theme.json**
`theme.json` 用于颜色主题相关的变量定义，需要先在 `themeLocation` 中配置 `theme.json` 的路径，否则无法读取变量配置。

配置文件须包含以下属性：

属性 | 类型 | 必填 | 描述
-----|-----|------|-----
light | object | 是 | 浅色模式下的变量定义
dark | object | 是 | 深色模式下的变量定义

light和dark下均可以key: value的方式定义变量名和值，例如：

```json
{
  "light": {
    "navBgColor": "#f6f6f6",
    "navTxtStyle": "black"
  },
  "dark": {
    "navBgColor": "#191919",
    "navTxtStyle": "white"
  }
}
```

完成定义后，可在全局配置或页面配置的相关属性中以 `@` 开头引用，例如：

```json
// 全局配置
{
  "window": {
    "navigationBarBackgroundColor": "@navBgColor",
    "navigationBarTextStyle": "@navTxtStyle"
  }
}
// 页面配置
{
  "navigationBarBackgroundColor": "@navBgColor",
  "navigationBarTextStyle": "@navTxtStyle"
}
```

配置完成后，小程序框架会自动根据系统主题，为小程序展示对应主题下的颜色。

**获取当前系统主题**
如果app.json中声明了 "darkmode": true，`wx.getSystemInfo` 或 `wx.getSystemInfoSync` 的返回结果中会包含 `theme` 属性，值为light或dark。

如果 app.json 未声明 "darkmode": true，则无法获取到 theme 属性（即theme为undefined）。

**监听主题切换事件**
支持2种方式：

1. 在 `App()` 中传入 onThemeChange 回调方法，主题切换时会触发此回调
2. 通过 [wx.onThemeChange][wx.onThemeChange] 监听主题变化，[wx.offThemeChange][wx.offThemeChange] 取消监听

**WXSS 适配**
WXSS中，支持通过媒体查询 `prefers-color-scheme` 适配不同主题，与 Web 中适配方式一致，例如：

```wxss
/* 一般情况下的样式 begin */
.some-background {
  background: white;
}
.some-text {
  color: black;
}
/* 一般情况下的样式 end */

@media (prefers-color-scheme: dark) {
  /* DarkMode 下的样式 start */
  .some-background {
      background: #1b1b1b;
  }
  .some-text {
      color: #ffffff;
  }
  /* DarkMode 下的样式 end */
}
```

> 注意:
>
> 1. WXSS 中的媒体查询不受 `app.json` 中的 `darkmode` 开关配置影响，只要微信客户端（iOS 7.0.12、Android 7.0.13）支持 `DarkMode`，无论是否配置"darkmode": true，在系统切换到 DarkMode 时，媒体查询都将生效。
> 2. 主题切换事件需要在配置 `"darkmode": true` 时，才会触发。

### 5.12 大屏适配指南

目前市面上的用户设备大致可分为小屏的手机端、中屏的平板、大屏的 PC 端三类，而在这三类设备中又会有细小的尺寸差别，也称作屏幕碎片化。

随着小程序能够在越来越多的设备终端上运行，应该针对不同的屏幕尺寸进行相应的适配。

按照一般的适配原则，结合小程序特点，通常在以下三种情况中需要进行适配：

1. 同一类设备下，尺寸有细微差别
  使用小程序提供的 [rpx](#232-wxss) 单位，在尺寸差别不大的情况下对页面布局进行等比缩放。

2. 在允许屏幕旋转的情况下，可分为横屏与竖屏
  手机端设置 `"pageOrientation": "auto"` 或 iPad 上设置 `"resizable": true` 时会允许屏幕旋转，此时使用 Page 的 `onResize` 事件或者 `wx.onWindowResize` 方法可对该操作进行监听，进而判断是使用横屏还是竖屏布局。

3. 不同类设备或者能够自由拖拽窗口的 PC 小程序
  小程序目前是基于 Webview 实现，利用 CSS 媒体查询 可实时监听屏幕尺寸大小，在不同的屏幕下展现不同的 UI 布局，结合 Flex 弹性布局、Grid 网格布局便能实现更加响应式的适配方案。
  matchMedia - 抽象式媒体查询，小程序基础库基于 `window.matchMedia` API 新增了一组过程式与定义式接口 `match-media` 。可以通过 `<match-media></match-media>` 和 `wx.createMediaQueryObserver` 来显式地使用媒体查询能力，对于多端适配来说，它有以下优势：

    1. 能够更方便、显式地使用 Media Query 能力，而不是耦合在 CSS 文件中，难以复用。
    2. 能够在 WXML 中结合数据绑定动态地使用，不仅能做到组件的显示或隐藏，在过程式 API 中可塑性更高，例如能够根据尺寸变化动态地添加 class 类名，改变样式。
    3. 能够嵌套式地使用 Media Query 组件，即能够满足局部组件布局样式的改变。
    4. 组件化之后，封装性更强，能够隔离样式、模版以及绑定在模版上的交互事件，还能够提供更高的可复用性。
    5. 浏览器内置 API ，能够在所有基于 Webview 的小程序上使用，兼容性良好。 match-media 具体使用方法可参考相关 [文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia)

4. 自适应布局
  为了更好的自适应大屏，小程序提供了 [row/col 组件][grid] 供开发者使用。自适应的主要特性是：
    - 整行最多只有 24 份，多余的排列会自动向下换行
    - 每个尺寸设置并不会影响到其它尺寸的布局

    设计指引与代码示例
      关于如何在设计、用户体验上实现更好的多端适配小程序，可参考[小程序适配设计指南](https://developers.weixin.qq.com/miniprogram/design/adapt.html#_1-%E5%9F%BA%E6%9C%AC%E9%80%82%E9%85%8D%E5%8E%9F%E5%88%99)。

## 六. 硬件能力

### 6.1 蓝牙

蓝牙适配器模块生效周期为调用 [wx.openBluetoothAdapter][wx.openBluetoothAdapter] 至调用 [wx.closeBluetoothAdapter][wx.closeBluetoothAdapter] 或小程序被销毁为止。

在小程序蓝牙适配器模块生效期间，才能够正常调用蓝牙相关的小程序 API，并收到蓝牙模块相关的事件回调。

> 注意:
> 由于系统限制，Android 上获取到的 deviceId 为设备 MAC 地址，iOS 上则为设备 uuid。因此 deviceId 不能硬编码到代码中。
> 目前不支持在开发者工具上进行蓝牙功能的调试，需要使用真机才能正常调用小程序蓝牙接口。

**低功耗蓝牙（BLE）注意事项**
wx.getBLEDeviceServices
iOS 上对特征值的 read、write、notify操作，由于系统需要获取特征值实例，传入的 `serviceId` 与 `characteristicId` 必须由 [wx.getBLEDeviceServices][wx.getBLEDeviceServices] 与 [wx.getBLEDeviceCharacteristics][wx.getBLEDeviceCharacteristics] 中获取到后才能使用。建议双平台统一在建立连接后先执行 [wx.getBLEDeviceServices][wx.getBLEDeviceServices] 与 [wx.getBLEDeviceCharacteristics][wx.getBLEDeviceCharacteristics] 后再进行与蓝牙设备的数据交互。

### 6.2 NFC

支持 HCE（基于主机的卡模拟）模式，即将安卓手机模拟成实体智能卡。 支持 NFC 读写，即手机作为读卡器使用。

- 适用机型：支持 NFC 功能，且系统版本为 Android 5.0 及以上的手机
- 适用卡范围：符合ISO 14443-4 标准的 CPU 卡
- 支持 Reader/Writer（读取器/写入器）模式，即支持 NFC 设备读取和/或写入被动 NFC 标签和贴纸。
- 适用机型：支持 NFC 功能，且系统版本为 Android 5.0 及以上的手机
- 适用范围：
  - 支持NFC-A (ISO 14443-3A)/NFC-B (ISO 14443-3B)/NFC-F (JIS 6319-4)/NFC-V (ISO 15693)/ISO-DEP (ISO 14443-4)标准的读写
（部分Android手机）支持MIFARE Classic/MIFARE Ultralight标签的读写
  - 支持对NDEF格式的NFC标签上的NDEF数据的读写

**基本流程**
以往NFC-A卡片写入 apdu指令 为例

- 调用 wx.getNFCAdapter() 获取NFC适配器实例
- 调用 NFCAdapter.onDiscovered(function callback) 注册贴卡监听回调
- 调用 NFCAdapter.startDiscovery(Object object) 开始监听贴卡
- 贴卡，onDiscovered 回调
  - 根据 onDiscovered 回调res对象的techs字段匹配到卡片支持NFC-A标准
  - 通过 NFCAdapter.getNfcA() 获取NfcA实例
- 使用NfcA实例进行读写
  - 调用 NfcA.connect() 和 NFC卡片 建立连接
  - 调用 NfcA.transceive(Object object) 往NFC卡片写入apdu指令并接收卡片返回数据
  - 读写完毕，调用NfcA.close()断开连接
- 调用 NFCAdapter.stopDiscovery(Object object) 结束监听贴卡

### 6.3 WI-FI

在小程序中支持搜索周边的 Wi-Fi，同时可以针对指定 Wi-Fi，传入密码发起连接。

该系列接口为系统原生能力，如需查看「微信连Wi-Fi」能力及配置跳转小程序，参考 [文档](https://developers.weixin.qq.com/doc/offiaccount/WiFi_via_WeChat/WiFi_mini_programs.html)。

连接指定 Wi-Fi 接口调用时序：

- Android：startWifi —> connectWifi —> onWifiConnected
- iOS（仅iOS 11及以上版本支持）：startWifi —> connectWifi —> onWifiConnected

连周边 Wi-Fi 接口调用时序：

- Android：startWifi —> getWifiList —> onGetWifiList —> connectWifi —> onWifiConnected
- iOS（iOS 11.0及11.1版本因系统原因暂不支持）：startWifi —> getWifiList —> onGetWifiList —> setWifiList —> onWifiConnected

> 注意：
> Wi-Fi 相关接口暂不可用 [wx.canIUse][wx.canIUse] 接口判断。
> Android 6.0 以上版本，在没有打开定位开关的时候会导致设备不能正常获取周边的 Wi-Fi 信息。

## 七. 开放能力

### 7.1 用户信息

#### 7.1.1 小程序登录

小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。

登录流程时序
![登录流程时序](./image/登录流程时序.jpg)

说明：

1. 调用 [wx.login()][wx.login] 获取 **临时登录凭证code** ，并回传到开发者服务器。
2. 调用 [auth.code2Session][auth.code2Session] 接口，换取 **用户唯一标识 OpenID** 和 **会话密钥 session_key**。

之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。

> 注意：
> 会话密钥 `session_key` 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。
> 临时登录凭证 code 只能使用一次

#### 7.1.2 UnionID 机制说明

如果拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。

**UnionID获取途径**
绑定了开发者帐号的小程序，可以通过以下途径获取 UnionID。

1. 调用接口 [wx.getUserInfo][wx.getUserInfo] ，从解密数据中获取 UnionID。注意本接口需要用户授权，请妥善处理用户拒绝授权后的情况。

2. 如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过 [wx.login][wx.login] + `code2Session` 获取到该用户 UnionID，无须用户再次授权。

3. 如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过 [wx.login][wx.login] + `code2Session` 获取到该用户 UnionID ，无须用户再次授权。

4. 用户在小程序（暂不支持小游戏）中支付完成后，开发者可以直接通过 `getPaidUnionId` 接口获取该用户的 UnionID，无需用户授权。注意：本接口仅在用户支付完成后的5分钟内有效，请妥善处理。

5. 小程序端调用云函数时，如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号，可在云函数中通过 [cloud.getWXContext][cloud.getWXContext] 获取 UnionID。

6. 小程序端调用云函数时，如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用，也可在云函数中通过 [cloud.getWXContext][cloud.getWXContext] 获取 UnionID。

**微信开放平台绑定小程序流程**
登录微信开放平台 — 管理中心 — 小程序 — 绑定小程序

#### 7.1.3 授权

部分接口需要经过用户授权同意才能调用。小程序把这些接口按使用范围分成多个 `scope` ，用户选择对 `scope` 来进行授权，当授权给一个 `scope` 之后，其对应的所有接口都可以直接使用。

此类接口调用时：

- 如果用户未接受或拒绝过此权限，会弹窗询问用户，用户点击同意后方可调用接口；
- 如果用户已授权，可以直接调用接口；
- 如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调。请兼容用户拒绝授权的场景。

**获取用户授权设置**
可以使用 [wx.getSetting][wx.getSetting] 获取用户当前的授权状态。

**打开设置界面**
用户可以在小程序设置界面（「右上角」 - 「关于」 - 「右上角」 - 「设置」）中控制对该小程序的授权状态。

可以调用 [wx.openSetting][wx.openSetting] 打开设置界面，引导用户开启授权。

**提前发起授权请求**
可以使用 [wx.authorize][wx.authorize] 在调用需授权 API 之前，提前向用户发起授权请求。

**scope 列表**:

scope | 对应接口 | 描述
------|----------|-----
scope.userInfo | [wx.getUserInfo][wx.getUserInfo] | 用户信息
scope.userLocation | [wx.getLocation][wx.getLocation], [wx.chooseLocation][wx.chooseLocation] | 地理位置
scope.userLocationBackground | [wx.startLocationUpdateBackground][wx.startLocationUpdateBackground] | 后台定位
scope.address | [wx.chooseAddress][wx.chooseAddress] | 通讯地址（已取消授权，可以直接调用对应接口）
scope.invoiceTitle | [wx.chooseInvoiceTitle][wx.chooseInvoiceTitle] | 发票抬头（已取消授权，可以直接调用对应接口）
scope.invoice | [wx.chooseInvoice][wx.chooseInvoice] | 获取发票（已取消授权，可以直接调用对应接口）
scope.werun | [wx.getWeRunData][wx.getWeRunData] | 微信运动步数
scope.record | [wx.startRecord][wx.startRecord] | 录音功能
scope.writePhotosAlbum | [wx.saveImageToPhotosAlbum][wx.saveImageToPhotosAlbum], [wx.saveVideoToPhotosAlbum][wx.saveVideoToPhotosAlbum] | 保存到相册
scope.camera | [camera][camera] 组件 | 摄像头

**授权有效期**
一旦用户明确同意或拒绝过授权，其授权关系会记录在后台，直到用户主动删除小程序。

**最佳实践**
在真正需要使用授权接口时，才向用户发起授权申请，并在授权申请中说明清楚要使用该功能的理由。

> 注意:
> `wx.authorize({scope: "scope.userInfo"})`，不会弹出授权窗口，请使用 `<button open-type="getUserInfo"/>`
> 需要授权 `scope.userLocation`、`scope.userLocationBackground` 时必须 [配置地理位置用途说明](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#permission)。

**后台定位**
与其它类型授权不同的是，`scope.userLocationBackground` 不会弹窗提醒用户。需要用户在设置页中，主动将"位置信息"选项设置为"使用小程序期间和离开小程序后"。开发者可以通过调用 [wx.openSetting][wx.openSetting]，打开设置页。

#### 7.1.4 开放数据校验与解密

小程序可以通过各种前端接口获取微信提供的开放数据。考虑到开发者服务端也需要获取这些开放数据，微信提供了两种获取方式：

##### 7.1.4.1 开发者后台校验与解密开放数据

微信会对这些开放数据做签名和加密处理。后台拿到开放数据后可以对数据进行校验签名和解密，来保证数据不被篡改。

![开放数据加密解密过程](./image/开放数据加密解密过程.jpg)

签名校验以及数据加解密涉及用户的会话密钥 `session_key`。 开发者应该事先通过 [wx.login][wx.login] 登录流程获取会话密钥 session_key 并保存在服务器。为了数据不被篡改，开发者不应该把 session_key 传到小程序客户端等服务器外的环境。

**数据签名校验**
为了确保开放接口返回用户数据的安全性，微信会对明文数据进行签名。可以根据业务需要对数据包进行签名校验，确保数据的完整性。

1. 通过调用接口（如 [wx.getUserInfo][wx.getUserInfo]）获取数据时，接口会同时返回 rawData、signature，其中 signature = sha1( rawData + session_key )
2. 将 signature、rawData 发送到开发者服务器进行校验。服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的完整性。

如 wx.getUserInfo的数据校验：

接口返回的rawData：

```json
{
  "nickName": "Band",
  "gender": 1,
  "language": "zh_CN",
  "city": "Guangzhou",
  "province": "Guangdong",
  "country": "CN",
  "avatarUrl": "http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"
}
```

用户的 session-key：

```string
HyVFkGl5F5OQWJZZaNzBBg==
```

用于签名的字符串为：

```string
{"nickName":"Band","gender":1,"language":"zh_CN","city":"Guangzhou","province":"Guangdong","country":"CN","avatarUrl":"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0"}HyVFkGl5F5OQWJZZaNzBBg==
```

使用sha1得到的结果为

```string
75e81ceda165f4ffa64f4068af58c64b8f54b88c
```

**加密数据解密算法**
接口如果涉及敏感数据（如 [wx.getUserInfo][wx.getUserInfo] 当中的 openId 和 unionId），接口的明文内容将不包含这些敏感数据。如需要获取敏感数据，需要对接口返回的 **加密数据(encryptedData)** 进行对称解密。 解密算法如下：

1. 对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。
2. 对称解密的目标密文为 Base64_Decode(encryptedData)。
3. 对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。
4. 对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。

微信官方提供了多种编程语言的示例代码（[点击下载](https://res.wx.qq.com/wxdoc/dist/assets/media/aes-sample.eae1f364.zip)）。每种语言类型的接口名字均一致。调用方式可以参照示例。

另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印( watermark )

**watermark参数说明**：

参数 | 类型 | 说明
-----|-----|-----
appid | String | 敏感数据归属 appId，开发者可校验此参数与自身 appId 是否一致
timestamp | Int | 敏感数据获取的时间戳, 开发者可以用于数据时效性校验

> 注意：解密后得到的json数据根据需求可能会增加新的字段，旧字段不会改变和删减，需要预留足够的空间

**session_key的注意事项**:

1. [wx.login][wx.login] 调用时，用户的 session_key 可能会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 wx.login，并非每次调用都导致 session_key 刷新）。应该在明确需要重新登录时才调用 wx.login，及时通过 [auth.code2Session][auth.code2Session] 接口更新服务器存储的 session_key。
2. 微信不会把 session_key 的有效期告知开发者。微信会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。
3. 开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 [wx.checkSession][wx.checkSession] 可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。
4. 当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。

##### 7.1.4.2 云调用直接获取开放数据

接口如果涉及敏感数据（如[wx.getWeRunData][wx.getWeRunData]），接口的明文内容将不包含这些敏感数据，而是在返回的接口中包含对应敏感数据的 cloudID 字段，数据可以通过云函数获取。完整流程如下：

1. 获取 cloudID
  使用 2.7.0 或以上版本的基础库，如果小程序已开通云开发，在开放数据接口的返回值中可以通过 cloudID 字段获取（与 encryptedData 同级），cloudID 有效期五分钟。

2. 调用云函数
  调用云函数时，对传入的 data 参数，如果有顶层字段的值为通过 `wx.cloud.CloudID` 构造的 CloudID，则调用云函数时，这些字段的值会被替换为 cloudID 对应的开放数据，一次调用最多可替换 5 个 CloudID。
  示例：在小程序获取到 cloudID 之后发起调用

    ```js
    wx.cloud.CloudID({
      name: 'myFunction',
      data: {
        weRunData: wx.cloud.CloudID('xxx'), // 这个 CloudID 值到云函数端会被替换
        obj: {
          shareInfo:  wx.cloud.CloudID('yyy'), // 非顶层字段的 CloudID 不会被替换，会原样字符串展示
        }
      }
    })
    ```

    在云函数收到的 event 示例：

    ```json
    // event
    {
      // weRunData 的值已被替换为开放数据
      "weRunData": {
        "cloudID": "xxx",
        "data": {
          "stepInfoList": [
            {
              "step": 5000,
              "timestamp": 1554814312,
            }
          ],
          "watermark": {
            "appid": "wx1111111111",
            "timestamp": 1554815786
          }
        }
      },
      "obj": {
        // 非顶层字段维持原样
        "shareInfo": "yyy",
      }
    }
    ```

    如果 `cloudID` 非法或过期，则在 `event` 中获取得到的将是一个有包含错误码、错误信息和原始 `cloudID` 的对象。过期 `cloudID` 换取结果示例：

    ```json
    // event
    {
      "weRunData": {
        "cloudID": "xxx",
        "errCode": -601006,
        "errMsg": "cloudID expired."
      },
      // ...
    }
    ```

#### 7.1.5 获取手机号

获取微信用户绑定的手机号，需先调用 [wx.login][wx.login] 接口。

因为需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 button 组件的点击来触发。

> **注意：目前该接口针对非个人开发者，且完成了认证的小程序开放（不包含海外主体）。需谨慎使用，若用户举报较多或被发现在不必要场景下使用，微信有权永久回收该小程序的该接口权限。**

**使用方法**
需要将 button 组件 `open-type` 的值设置为 `getPhoneNumber`，当用户点击并同意之后，可以通过 `bindgetphonenumber` 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。

> 注意
> 在回调中调用 [wx.login][wx.login] 登录，可能会刷新登录态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议提前进行 `login`；或者在回调中先使用 `checkSession` 进行登录态检查，避免 `login` 刷新登录态。

**代码示例**:

```wxml
<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"></button>
```

```js
Page({
  getPhoneNumber (e) {
    console.log(e.detail.errMsg)
    console.log(e.detail.iv)
    console.log(e.detail.encryptedData)
  }
})
```

**返回参数说明**:

参数 | 类型 | 说明
-----|-----|------
encryptedData | String | 包括敏感数据在内的完整用户信息的加密数据，详细见[加密数据解密算法](#714-开放数据校验与解密)
iv | String | 加密算法的初始向量，详细见加密数据解密算法
cloudID | string | 敏感数据对应的云 ID，开通云开发的小程序才会返回，可通过云调用直接获取开放数据，详细见[云调用直接获取开放数据](#7142-云调用直接获取开放数据)

获取得到的开放数据为以下 json 结构：

```json
{
  "phoneNumber": "13580006666",
  "purePhoneNumber": "13580006666",
  "countryCode": "86",
  "watermark":
  {
      "appid":"APPID",
      "timestamp": TIMESTAMP
  }
}
```

参数 | 类型 | 说明
-----|------|-----
phoneNumber | String | 用户绑定的手机号（国外手机号会有区号）
purePhoneNumber | String | 没有区号的手机号
countryCode | String | 区号

#### 7.1.7 生物认证

小程序通过 SOTER 提供以下生物认证方式。

目前暂时只支持指纹识别认证。设备支持的生物认证方式可使用 [wx.checkIsSupportSoterAuthentication][wx.checkIsSupportSoterAuthentication] 查询

调用流程

![生物认证调用流程](./image/生物认证调用流程.png)

**流程步骤说明**:

1. 调用 [wx.startSoterAuthentication][wx.startSoterAuthentication]，获取 `resultJSON` 和 `resultJSONSignature`

2. （可选）签名校验。此处 `resultJSONSignature` 使用 SHA256withRSA/PSS 作为签名算法进行验签。此公式数学定义如下: `bool` 验签结果=verify(用于签名的原串，签名串，验证签名的公钥)

3. 微信提供后台接口用于可信的密钥验签服务，微信将保证该接口返回的验签结果的正确性与可靠性，并且对于 Android root 情况下该接口具有上述特征（将返回是否保证root情况安全性）。

接口地址：

```txt
POST http://api.weixin.qq.com/cgi-bin/soter/verify_signature?access_token=%access_token
```

post 数据内容（JSON 编码）:

```json
{"openid":"$openid", "json_string" : "$resultJSON", "json_signature" : "$resultJSONSignature" }
```

请求返回数据内容（JSON 编码）:

```txt
// 验证成功返回
{"is_ok":true}
// 验证失败返回
{"is_ok":false}
// 接口调用失败
{"errcode":"xxx,"errmsg":"xxxxx"}
```

### 7.2 转发

#### 7.2.1 转发

**获取更多转发信息**
通常希望转发出去的小程序被二次打开的时候能够获取到一些信息，例如群的标识。现在通过调用 [wx.showShareMenu][wx.showShareMenu] 并且设置 `withShareTicket` 为 `true` ，当用户将小程序转发到任一群聊之后，此转发卡片在群聊中被其他用户打开时，可以在 App.onLaunch 或 App.onShow 获取到一个 `shareTicket`。通过调用 [wx.getShareInfo][wx.getShareInfo] 接口传入此 `shareTicket` 可以获取到转发信息。

**页面内发起转发**
通过给 button 组件设置属性 `open-type="share"`，可以在用户点击按钮后触发 [Page.onShareAppMessage](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShareAppMessage-Object-object) 事件。

**使用指引**
转发按钮，旨在帮助用户更流畅地与好友分享内容和服务。转发，应是用户自发的行为，且在需要时触手可及。在使用时若遵从以下指引，会得到更佳的用户体验。

1. **含义清晰** : 明确、一目了然的图形按钮，将为用户减少理解的时间。在资源下载中心，可以找到这样的按钮素材并直接使用。或者可以根据业务的设计风格，灵活设计含义清晰的按钮的样式。当然，也可以直接使用带文案的按钮，"转发给好友"。
2. **方便点击** : 按钮点击热区不宜过小，亦不宜过大。同时，转发按钮与其他按钮一样，热区也不宜过密，以免用户误操作。
3. **按需出现** : 并非所有页面都适合放置转发按钮，涉及用户隐私的非公开内容，或可能打断用户完成当前操作体验的场景，该功能并不推荐使用。同时，由于转发过程中，将截取用户屏幕图像作为配图，因此，需要注意帮助用户屏蔽个人信息。
4. **尊重意愿** : 它不应该成为一个诱导或强制行为，如转发后才能解锁某项功能等。注意，这类做法不仅不被推荐，还可能违反《运营规范》。

> 提示：
>
> 1. 不自定义转发图片的情况下，默认会取当前页面，从顶部开始，高度为 80% 屏幕宽度的图像作为转发图片。
> 2. 转发的调试支持请查看 [普通转发的调试支持](https://developers.weixin.qq.com/miniprogram/dev/devtools/different.html#%E6%99%AE%E9%80%9A%E7%9A%84%E8%BD%AC%E5%8F%91) 和 [带 shareTicket 的转发](https://developers.weixin.qq.com/miniprogram/dev/devtools/different.html#%E5%B8%A6-shareticket-%E7%9A%84%E8%BD%AC%E5%8F%91)
> 3. 只有转发到群聊中打开才可以获取到 `shareTickets` 返回值，单聊没有 `shareTickets`
> 4. `shareTicket` 仅在当前小程序生命周期内有效
> 5. 由于策略变动，小程序群相关能力进行调整，可先使用 [wx.getShareInfo][wx.getShareInfo] 接口中的群 ID 进行功能开发。
> 6. 微信7.0.12开始，支持群主转发小程序时同时把消息设为该群的群待办消息，群待办消息会以气泡形式出现在聊天窗口底部。默认每次转发一个群待办消息，都会生成一个待办消息气泡。通过 [wx.updateShareMenu][wx.updateShareMenu] 接口修改 `toDoActivityId` 属性可以把多个待办消息聚合为同一个，即转发相同 `toDoActivityId` 的群待办消息，只会出现一个待办消息气泡。`toDoActivityId` 需要在转发前通过 [updatableMessage.createActivityId][updatableMessage.createActivityId] 接口创建。

#### 7.2.2 动态消息

从基础库 2.4.0 开始，支持转发动态消息。动态消息对比普通消息，有以下特点：

1. 消息发出去之后，可以通过后台接口修改部分消息内容。
2. 消息有对应的提醒按钮，用户点击提醒按钮可以订阅提醒，开发者可以通过后台修改消息状态并推送一次提醒消息给订阅了提醒的用户

**消息状态**
消息有两个状态，分别有其对应的文字内容和颜色。其中状态 0 可以转移到状态 0 和 1，状态 1 无法再转移。

状态 | 文字内容 | 颜色 | 允许转移的状态
-----|---------|------|--------------
0 | "成员正在加入，当前 {member_count}/{room_limit} 人" | #FA9D39 | 0, 1
1 | "已开始" | #CCCCCC | 无

**状态参数**
每个状态转移的时候可以携带参数，具体参数说明如下。

参数 | 类型 | 说明
-----|-----|------
member_count | string | 状态 0 时有效，文字内容模板中 member_count 的值
room_limit | string | 状态 0 时有效，文字内容模板中 room_limit 的值
path | string | 状态 1 时有效，点击「进入」启动小程序时使用的路径。对于小游戏，没有页面的概念，可以用于传递查询字符串（query），如 "?foo=bar"
version_type | string | 状态 1 时有效，点击「进入」启动小程序时使用的版本。有效参数值为：develop（开发版），trial（体验版），release（正式版）

**使用方法**:

1. 创建 activity_id
  每条动态消息可以理解为一个活动，活动发起前需要通过 [updatableMessage.createActivityId][updatableMessage.createActivityId] 接口创建 `activity_id`。后续转发动态消息以及更新动态消息都需要传入这个 `activity_id`。
  活动的默认有效期是 24 小时。活动结束后，消息内容会变成统一的样式：
    - 文字内容："已结束"
    - 文字颜色：#00ff00

2. 在转发之前声明消息类型为动态消息
  通过调用 [wx.updateShareMenu][wx.updateShareMenu] 接口，传入 `isUpdatableMessage: true`，以及 `templateInfo`、`activityId` 参数。其中 `activityId` 从上一步中获得。

    ```js
    wx.updateShareMenu({
      withShareTicket: true,
      isUpdatableMessage: true,
      activityId: '', // 活动ID
      templateInfo: {
        parameterList: [{
          name: 'member_count',
          value: '1'
        }, {
          name: 'room_limit',
          value: '3'
        }]
      }
    })
    ```

3. 修改动态消息内容
  动态消息发出去之后，可以通过 [updatableMessage.setUpdatableMsg][updatableMessage.setUpdatableMsg] 修改消息内容。

> 注意 : 对于不支持动态消息的客户端版本，收到动态消息后会展示成普通消息

#### 7.2.3 小程序私密消息

小程序私密消息功能是这样一种能力：当分享者分享小程序卡片给其他用户或者微信群后，其他用户点击此小程序卡片时，开发者可以鉴别出点击卡片的用户是否被分享者分享过小程序卡片。

**使用说明**:

1. 分享
    1. 创建业务活动后、分享小程序消息前，需要通过后台接口 [updatableMessage.createActivityId][updatableMessage.createActivityId] 创建 `activityId`，建议一个 activityId 与一个业务活动id唯一关联。
    2. 然后通过 [wx.updateShareMenu][wx.updateShareMenu] 接口声明本次分享的消息为私密消息，私密消息具有不可二次转发性。
    3. 声明完成后，可以通过右上角菜单、分享按钮组件、wx.shareAppMessage（仅小游戏）分享私密消息给个人、群聊。

    场景一： 个人分享给个人 (A -> B)
    场景二： 个人分享给群 (A --> [B, C, D, E])

      ```js
      wx.updateShareMenu({
        withShareTicket: true,
        isPrivateMessage: true,
        activityId: 'xxx',
      })
      ```

2. 验证
  从群聊、单聊消息卡片进入小程序时，通过 [wx.authPrivateMessage][wx.authPrivateMessage] 接口可以验证当前用户是否是私密消息的接收者，即验证这条消息是否是**A直接转发给B**或者**A转发给B所在的群**

    ```js
    wx.authPrivateMessage({
      shareTicket: 'xxx',
      success(res) {
        console.log('authPrivateMessage success', res)
        // res
        // {
        //   errMsg: 'authPrivateMessage:ok'
        //   valid: true
        //   iv: 'xxxx',
        //   encryptedData: 'xxxxxx'
        // }
      },
      fail(res) {
        console.log('authPrivateMessage fail', res)
      }
    })
    ```

    > 注意:
    >
    > 1. 若返回的valid字段为false，表示此次验证不通过。
    > 2. 若返回的valid字段为true，表示验证通过。但是为了安全起见，预防valid字段被篡改的可能，可以把encryptedData和iv传到开发者后台去解密。若解密后得到的activityId就是当前活动所对应的activityId 则验证通过，否则表示验证不通过。
    > 3. 当私密消息分享给群时，是按鉴别时刻用户是否在群里作为判断。
    > 4. activityId创建后7天内分享有效，120天内验证有效。

### 7.3 收藏

> 安卓 7.0.15 版本起支持，iOS 暂不支持

小程序菜单增加收藏功能，可收藏某个页面至收藏夹。点开小程序右上角胶囊，点击收藏按钮会触发 [Page.onAddToFavorites](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onaddtofavoritesobject-object) 事件。

### 7.4 多人音视频通话

用于实现小程序内多人音视频对话的功能。

**申请开通**
小程序管理后台，「开发」-「接口设置」中自助开通该组件权限。相关接口 [wx.joinVoIPChat][wx.joinVoIPChat] 和组件 [voip-room][voip-room]。

**调用流程**
仅需提供房间唯一标识，即可加入到指定的房间。传入相同唯一标识的用户，会进到相同的房间。为了保证前端传入的 `groupId` 可信，[wx.joinVoIPChat][wx.joinVoIPChat] 接口要求传入签名。详见 签名算法。当加入视频房间时，可结合 [voip-room][voip-room] 组件显示成员画面。

**前端接口**:

- 创建/加入房间：[wx.joinVoIPChat][wx.joinVoIPChat]
- 离开房间：[wx.exitVoIPChat][wx.exitVoIPChat]
- 更新房间麦克风/耳机静音设置：[wx.updateVoIPChatMuteConfig][]
- 监听房间成员变化：[wx.onVoIPChatMembersChanged][wx.onVoIPChatMembersChanged]
- 监听房间成员通话状态变化：[wx.onVoIPChatSpeakersChanged][wx.onVoIPChatMembersChanged]
- 监听通话中断：[wx.onVoIPChatInterrupted][wx.onVoIPChatInterrupted]
- 监听实时语音通话成员视频状态变化：[wx.onVoIPVideoMembersChanged][wx.onVoIPVideoMembersChanged]
- 订阅视频画面成员 [wx.subscribeVoIPVideoMembers][wx.subscribeVoIPVideoMembers]

**签名算法**
生成签名需要传入四个参数：

参数名 | 说明
------|-----
appId | 小程序的 appId
groupId | 游戏房间的唯一标识，由游戏自己保证唯一
nonceStr | 随机字符串，长度应小于 128
timeStamp | 生成这个随机字符串的 UNIX 时间戳（精确到秒）

签名算法为：

```txt
// hmac_sha256需要开发者自行引入
signature = hmac_sha256([appId, groupId, nonceStr, timeStamp].sort().join(''), sessionKey)
```

具体来说，这个算法分为几个步骤：

1. 对 `appId` `groupId` `nonceStr` `timeStamp` 四个值表示成字符串形式，按照字典序排序；
2. 将排好序的四个字符串拼接在一起；
3. 使用 `session_key` 作为 `key`，使用 `hmac_sha256` 算法对 2 中的结果字符串做计算，所得结果即为 `signature`

```js
appId = 'wx20afc706a711eefc'
groupId = '1559129713_672975982'
nonceStr = '8AP6DT9ybtniUJfb'
timeStamp = '1559129714'
session_key = 'gDyVgzwa0mFz9uUP7M6GQQ=='

str = [appId, groupId, nonceStr, timeStamp].sort().join('') = '1559129713_67297598215591297148AP6DT9ybtniUJfbwx20afc706a711eefc'
signature = hmac_sha256('1559129713_67297598215591297148AP6DT9ybtniUJfbwx20afc706a711eefc', sessionKey) = 'b002b824688dd8593a6079e11d8c5e8734fbcb39a6d5906eb347bfbcad79c617'
```

**使用云开发完成签名**
在云开发中，无法获取 session_key，但提供了单独的函数 [cloud.getVoIPSign][cloud.getVoIPSign] 来计算签名。

```js
const cloud = require('wx-server-sdk')
cloud.init()

exports.main = async (event, context) => {
  const signature = cloud.getVoIPSign({
    groupId: 'xxx',
    timestamp: 123,
    nonce: 'yyy'
  })
  return signature
}
```

> 注意：
> 人数限制 : 每个房间最多同时加入 10 个人。
> 频率限制 : 对于每个小程序，每天最多允许创建 100000 个房间。当所有人退出房间时，房间即被销毁。此时如果传入之前用过的 groupId 重新加入房间，会被计算为新开一个房间。

### 7.5 打开APP

此功能需要用户主动触发才能打开 APP，所以不由 API 来调用，需要用 `open-type` 的值设置为 `launchApp` 的 `button` 组件的点击来触发。

当小程序从 APP 分享消息卡片的场景打开（场景值 1036，APP 分享小程序文档 iOS / Android） 或从 APP 打开的场景打开时（场景值 1069），小程序会获得打开 APP 的能力，此时用户点击按钮可以打开分享该小程序卡片/拉起该小程序的 APP。即小程序不能打开任意 APP，只能 **跳回** APP。

具体查看 [打开APP文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html)

### 7.6 消息

#### 7.6.1 订阅消息

消息能力是小程序能力中的重要组成，小程序提供了订阅消息能力，以便实现服务的闭环和更优的体验。

- 订阅消息推送位置：服务通知
- 订阅消息下发条件：用户自主订阅
- 订阅消息卡片跳转能力：点击查看详情可跳转至该小程序的页面

订阅消息包括两种：

1. **一次性订阅消息** : 一次性订阅消息用于解决用户使用小程序后，后续服务环节的通知问题。用户自主订阅后，可不限时间地下发一条对应的服务消息；每条消息可单独订阅或退订。

2. **长期订阅消息** : 一次性订阅消息可满足小程序的大部分服务场景需求，但线下公共服务领域存在一次性订阅无法满足的场景，如航班延误，需根据航班实时动态来多次发送消息提醒。为便于服务，小程序提供了长期性订阅消息，用户订阅一次后，开发者可长期下发多条消息。

> 目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放，后期将逐步支持到其他线下公共服务业务

**使用说明**:

1. 获取模板 ID
  在微信公众平台手动配置获取模板 ID：
  登录 [微信公众平台][微信公众平台] 获取模板，如果没有合适的模板，可以申请添加新模板，审核通过后可使用。
2. 获取下发权限
  详见小程序端消息订阅接口 [wx.requestSubscribeMessage][wx.requestSubscribeMessage]
3. 调用接口下发订阅消息
  详见服务端消息发送接口 [subscribeMessage.send][subscribeMessage.send]

> 注意 : 用户勾选 "总是保持以上选择，不再询问" 之后，下次订阅调用 [wx.requestSubscribeMessage][wx.requestSubscribeMessage] 不会弹窗，保持之前的选择，修改选择需要打开小程序设置进行修改。

#### 7.6.2 统一服务消息

为便于开发者对用户进行服务消息触达，简化小程序和公众号模板消息下发流程，小程序提供统一的服务消息下发接口。

**相关接口**
[下发统一服务消息](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/uniform-message/uniformMessage.send.html)

#### 7.6.3 客服消息

##### 7.6.3.1 概述

**在页面使用客服消息**
需要将 button 组件 `open-type` 的值设置为 `contact`，当用户点击后就会进入客服会话，如果用户在会话中点击了小程序消息，则会返回到小程序，可以通过 `bindcontact` 事件回调获取到用户所点消息的页面路径 `path` 和对应的参数 `query`。

```wxml
<button open-type="contact" bindcontact="handleContact">客服</button>
```

```js
Page({
  handleContact: function(e) {
    console.log(e.detail.path)
    console.log(e.detail.query)
  }
})
```

**返回参数说明**:

参数 | 类型 | 说明
-----|-----|------
path | String | 小程序消息指定的路径
query | Object | 小程序消息指定的查询参数

**后台接入消息服务**
用户向小程序客服发送消息、或者进入会话等情况时，开发者填写的服务器配置 URL （如果使用的是云开发，则是配置的云函数）将得到微信服务器推送过来的消息和事件，可以依据自身业务逻辑进行响应。接入和使用方式参考 [消息推送](#572-消息推送)。

##### 7.6.3.2 接收消息和事件

在页面中使用 `<button open-type="contact" />` 可以显示进入客服会话按钮。

当用户在客服会话发送消息、或由某些特定的用户操作引发事件推送时，微信服务器会将消息或事件的数据包发送到开发者填写的 URL，如果使用的是云开发，则可以推送到指定的云函数（详情参考 [消息推送](#572-消息推送) ）。开发者收到请求后可以使用 [发送客服消息][customerServiceMessage.send] 接口进行异步回复。

各消息类型的推送JSON、XML数据包结构如下。

###### 7.6.3.2.1 文本消息

用户在客服会话中发送文本消息时将产生如下数据包：

```xml
<!-- XML格式 -->
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1482048670</CreateTime>
  <MsgType><![CDATA[text]]></MsgType>
  <Content><![CDATA[this is a test]]></Content>
  <MsgId>1234567890123456</MsgId>
</xml>
```

```json
// JSON 格式
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "text",
  "Content": "this is a test",
  "MsgId": 1234567890123456
}
```

**参数说明**:

参数 | 说明
----|------
ToUserName | 小程序的原始ID
FromUserName | 发送者的openid
CreateTime | 消息创建时间(整型）
MsgType | text
Content | 文本消息内容
MsgId | 消息id，64位整型

###### 7.6.3.2.2 图片消息

用户在客服会话中发送图片消息时将产生如下数据包：

```xml
<!-- XML格式 -->
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1482048670</CreateTime>
  <MsgType><![CDATA[image]]></MsgType>
  <PicUrl><![CDATA[this is a url]]></PicUrl>
  <MediaId><![CDATA[media_id]]></MediaId>
  <MsgId>1234567890123456</MsgId>
</xml>
```

```json
// JSON 格式
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "image",
  "PicUrl": "this is a url",
  "MediaId": "media_id",
  "MsgId": 1234567890123456
}
```

**参数说明**:

参数 | 说明
-----|-----
ToUserName | 小程序的原始ID
FromUserName | 发送者的openid
CreateTime | 消息创建时间(整型）
MsgType | image
PicUrl | 图片链接（由系统生成）
MediaId | 图片消息媒体id，可以调用[获取临时素材]((getTempMedia)接口拉取数据。
MsgId | 消息id，64位整型

###### 7.6.3.2.3 小程序卡片消息

用户在客服会话中发送小程序卡片消息时将产生如下数据包：

```xml
<!-- XML 格式 -->
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1482048670</CreateTime>
  <MsgType><![CDATA[miniprogrampage]]></MsgType>
  <MsgId>1234567890123456</MsgId>
  <Title><![CDATA[Title]]></Title>
  <AppId><![CDATA[AppId]]></AppId>
  <PagePath><![CDATA[PagePath]]></PagePath>
  <ThumbUrl><![CDATA[ThumbUrl]]></ThumbUrl>
  <ThumbMediaId><![CDATA[ThumbMediaId]]></ThumbMediaId>
</xml>
```

```json
// JSON 格式
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "miniprogrampage",
  "MsgId": 1234567890123456,
  "Title":"title",
  "AppId":"appid",
  "PagePath":"path",
  "ThumbUrl":"",
  "ThumbMediaId":""
}
```

**参数说明**:

参数 | 说明
-----|-----
ToUserName | 小程序的原始ID
FromUserName | 发送者的openid
CreateTime | 消息创建时间(整型）
MsgType | miniprogrampage
MsgId | 消息id，64位整型
Title | 标题
AppId | 小程序appid
PagePath | 小程序页面路径
ThumbUrl | 封面图片的临时cdn链接
ThumbMediaId | 封面图片的临时素材id

###### 7.6.3.2.4 进入会话事件

用户在小程序"客服会话按钮"进入客服会话时将产生如下数据包：

```xml
<!-- XML格式 -->
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>1482048670</CreateTime>
  <MsgType><![CDATA[event]]></MsgType>
  <Event><![CDATA[user_enter_tempsession]]></Event>
  <SessionFrom><![CDATA[sessionFrom]]></SessionFrom>
</xml>
```

```json
{
  "ToUserName": "toUser",
  "FromUserName": "fromUser",
  "CreateTime": 1482048670,
  "MsgType": "event",
  "Event": "user_enter_tempsession",
  "SessionFrom": "sessionFrom"
}
```

**参数说明**:

参数 | 说明
-----|-----
ToUserName | 小程序的原始ID
FromUserName | 发送者的openid
CreateTime | 事件创建时间(整型）
MsgType | event
Event | 事件类型，user_enter_tempsession
SessionFrom | 开发者在客服会话按钮设置的 session-from 属性

##### 7.6.3.3 发送消息

当用户和小程序客服产生特定动作的交互时，微信将会把消息数据推送给开发者，可以在一段时间内（目前为 48 小时）调用客服接口，通过调用 [发送客服消息接口][customerServiceMessage.send] 来发送消息给普通用户。此接口主要用于客服等有人工消息处理环节的功能，方便开发者为用户提供更加优质的服务。

目前允许的动作列表如下，不同动作触发后，允许的客服接口下发消息条数和下发时限不同。

用户动作 | 允许下发条数限制 | 下发时限
--------|-----------------|--------
用户发送消息 | 5 条 | 48 小时

##### 7.6.3.4 转发消息

如果小程序设置了消息推送，普通微信用户向小程序客服发消息时，微信服务器会先将消息 POST 到开发者填写的 URL 上，如果希望将消息转发到网页版客服工具，则需要开发者在响应包中返回 `MsgType` 为 `transfer_customer_service` 的消息，微信服务器收到响应后会把当次发送的消息转发至客服系统。

用户被客服接入以后，客服关闭会话以前，处于会话过程中时，用户发送的消息均会被直接转发至客服系统。当会话超过 30 分钟客服没有关闭时，微信服务器会自动停止转发至客服，而将消息恢复发送至开发者填写的 URL 上。

用户在等待队列中时，用户发送的消息仍然会被推送至开发者填写的 URL 上。

> 特别注意 : 只针对微信用户发来的消息才进行转发，而对于其他事件（比如用户从小程序唤起客服会话）都不应该转发，否则客服在客服系统上会看到一些无意义的消息。

**消息转发到网页版客服工具**
只要在响应包中返回 `MsgType` 为 `transfer_customer_service` 的消息，微信服务器收到响应后就会把当次发送的消息转发至客服系统。

如果是使用自有服务器接收的消息推送，则需返回如下格式的 XML 数据：

```xml
<xml>
  <ToUserName><![CDATA[touser]]></ToUserName>
  <FromUserName><![CDATA[fromuser]]></FromUserName>
  <CreateTime>1399197672</CreateTime>
  <MsgType><![CDATA[transfer_customer_service]]></MsgType>
</xml>
```

**参数说明**:

参数 | 是否必须 | 描述
-----|---------|------
ToUserName | 是 | 接收方帐号（收到的OpenID）
FromUserName | 是 | 开发者微信号
CreateTime | 是 | 消息创建时间 （整型）
MsgType | 是 | transfer_customer_service

如果是使用 [云函数接收的消息推送](#5722-云函数接收消息推送)，则需在云函数被客服消息触发后返回同样格式的 `JSON` 数据：

```js
// ...
exports.main = async (event, context) => {
  // 判断处理客服消息 ...
  // 最后返回 JSON
  return {
    MsgType: 'transfer_customer_service',
    ToUserName: 'touser',
    FromUserName: 'fromuser',
    CreateTime: parseInt(+new Date / 1000),
  }
}
```

##### 7.6.3.5 下发客服输入状态

可通过调用 [客服输入状态接口][customerServiceMessage.setTyping]，返回客服当前输入状态给用户。

1. 此接口需要客服消息接口权限。
2. 如果不满足发送客服消息的触发条件，则无法下发输入状态。
3. 下发输入状态，需要客服之前 30 秒内跟用户有过消息交互。
4. 在输入状态中（持续 15 秒），不可重复下发输入态。
5. 在输入状态中，如果向用户下发消息，会同时取消输入状态。

##### 7.6.3.6 临时素材

可在接收和发送客服消息的过程中获取或上传临时素材。

**获取临时素材**
接收到用户消息之后，可通过 [获取临时素材接口][customerServiceMessage.getTempMedia] 获取消息中的临时素材

**上传临时素材**
通过 [上传临时素材接口][customerServiceMessage.uploadTempMedia] 可以上传临时素材，并在 [发送消息接口][customerServiceMessage.send] 中使用。

#### 7.6.4 位置消息

> 微信客户端 7.0.9 及以上版本支持，iOS 暂不支持

为了让用户更便捷地使用小程序的打车服务，小程序在位置消息详情页的菜单中，新增了打车小程序入口。

1. 打开聊天中的位置消息，点击详情页右下角绿色按钮，菜单中会展示符合条件的打车小程序，用户可以直接发起目的地为该位置的打车服务。
2. 小程序的注册类目为"打车（网约车）"，且有用户最近使用的记录，才可以出现在该菜单中。
3. 在此处点击打开小程序后，需要直接进入到发起打车页面。

[详情查看](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/location-message.html)

### 7.7 获取小程序码

通过后台接口可以获取小程序任意页面的小程序码，扫描该小程序码可以直接进入小程序对应的页面，所有生成的小程序码永久有效，可放心使用。 推荐生成并使用小程序码，它具有更好的辨识度，且拥有展示"[公众号关注组件][official-account]"等高级能力。

**获取小程序码**
为满足不同需求和场景，小程序提供了两个接口，可挑选适合自己的接口。

- [接口 A: 适用于需要的码数量较少的业务场景](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html)
  - 生成小程序码，可接受 path 参数较长，生成个数受限，数量限制见下面的 注意事项，请谨慎使用。
- [接口 B：适用于需要的码数量极多的业务场景](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html)
  - 生成小程序码，可接受页面参数较短，生成个数不受限。

**获取小程序码（一物一码）**
[微信一物一码](https://developers.weixin.qq.com/doc/offiaccount/Unique_Item_Code/Unique_Item_Code_Op_Guide.html) 支持生成小程序码。微信通过“一物一码”接口发放的二维码相比较普通链接二维码更安全、支持更小的印刷面积，支持跳转到指定小程序页面，且无数量限制。

- [接口 D：适用于“一物一码”的业务场景](https://developers.weixin.qq.com/doc/offiaccount/Unique_Item_Code/Unique_Item_Code_API_Documentation.html)

> 注意：
>
> 1. 接口只能生成已发布的小程序的二维码
> 2. 接口 A 加上接口 C，总共生成的码数量限制为 100,000，请谨慎调用。
> 3. 接口 B 调用分钟频率受限(5000次/分钟)，如需大量小程序码，建议预生成。

### 7.8 获取URL scheme

通过服务端接口可以获取打开小程序任意页面的URL Scheme，支持生成的到期失效和永久有效的URL Scheme。适用于从短信、邮件、微信外网页等场景打开小程序。通过URL Scheme打开小程序的场景值为 1065。 生成的URL scheme如下所示：

```txt
weixin://dl/business/?ticket= *TICKET*`
```

部分操作系统不支持直接识别 URL Scheme，因此直接将 Scheme 发送给用户会导致用户无法正常打开小程序。为此，需要预先准备一个H5页面，再从H5页面跳转到Scheme实现打开小程序，跳转代码示例如下：

```txt
location.href = 'weixin://dl/business/?ticket= *TICKET*'
```

该跳转方法可以在用户打开H5时立即调用，也可以在用户触发事件后调用。

> 注意：
>
> 1. 生成的URL Scheme仅支持从微信外打开小程序。
> 2. 微信内的网页如需打开小程序使用 [微信开放标签-小程序跳转按钮](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html)，无公众号也可以直接使用小程序身份开发网页并免鉴权跳转小程序，见 [云开发静态网站跳转小程序][jump-miniprogram]。符合开放范围的小程序可以 [下发支持打开小程序的短信][msg-miniprogram]。
> 3. 只能生成已发布的小程序的URL Scheme。
> 4. 通过URL Scheme跳转到微信时，会触发系统弹框询问，若用户选择不跳转，则无法打开小程序。请妥善处理用户选择不跳转的场景。
> 5. 开放范围: 国内非个人主体小程序开放。

**示例**
示例使用了云开发静态网站托管搭建网页，无需公众号，只需准备好小程序和开通云开发。网页会判断所在的环境来觉得采用哪种跳转方式，如检测到微信客户端内，则免鉴权使用开放标签跳转，如检测到在外部浏览器或 App，则使用 URL Scheme 跳转小程序。

[示例网页地址](https://postpay-2g5hm2oxbbb721a4-1258211818.tcloudbaseapp.com/jump-mp.html)

详细代码示例和说明：[云开发静态网站跳转小程序][jump-miniprogram]。

### 7.9 数据分析

开发者通过数据分析接口，可获取到小程序的各项数据指标，便于进行数据存储和整理。数据分析详细功能介绍及指标解释参见数据分析文档。

- [概况](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/analysis.getDailySummary.html)
- 访问趋势
  - [日趋势](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/visit-trend/analysis.getDailyVisitTrend.html)
  - [周趋势](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/visit-trend/analysis.getWeeklyVisitTrend.html)
  - [月趋势](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/visit-trend/analysis.getMonthlyVisitTrend.html)
- [访问分布](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/analysis.getVisitDistribution.html)
- 访问留存
  - [日留存](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/visit-retain/analysis.getDailyRetain.html)
  - [周留存](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/visit-retain/analysis.getWeeklyRetain.html)
  - [月留存](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/visit-retain/analysis.getMonthlyRetain.html)
- [访问页面](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/analysis.getVisitPage.html)
- [用户画像](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/data-analysis/analysis.getUserPortrait.html)
- [自定义数据上报](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/data-analysis/wx.reportAnalytics.html)

## 八. 安全指引

### 8.1 开发原则与注意事项

本文档整理了部分小程序开发中常见的安全风险和漏洞，用于在开发环节中发现和修复相关漏洞，避免在上线后对业务和数据造成损失。在开发环节中必须基于以下原则：

1. 互不信任原则，不要信任用户提交的数据，包括第三方系统提供的数据，必要的数据校验必须放在后台校验。
2. 最小权限原则，代码、模块等只拥有可以完成任务的最小权限，不赋予不必要的权限。
3. 禁止明文保存用户敏感数据。
4. 小程序代码（不包括云函数代码）跟传统 Web 应用的前端代码类似，可被外部获取及进行反混淆，重要业务逻辑应放在后台代码或云函数中进行。
5. 后台接口调用以及云函数调用，必须进行有效的身份鉴权。

### 8.2 通用

#### 8.2.1 接口鉴权

接口鉴权是指后台接口（包括自建后台接口与云函数）在被调用时需要对本次接口调用进行权限校验，否则容易发生越权行为。如商品删除接口，后台在收到请求时应当校验调用者的身份信息（如 openid、 ip 地址、开发者自定义的登录态信息等），只有指定用户才可以通过校验进行删除。

越权通常分为平行越权和垂直越权：

- 平行越权
  平行越权是指相同角色之间的越权。 A1、 A2 都是普通用户， A1 通过请求后台接口 userInfo.php?id=A1 来获取用户 A1 自己的信息，如果 userInfo.php 没有进行权限校验，用户 A1 把请求改为 userInfo.php?id=A2 便可以获取到 A2 用户的信息，造成 A2 用户信息的泄露。

- 垂直越权
  垂直越权是指不同角色之间的越权。 B1 是管理员， B2 是普通用户，管理员 B1 通过请求后台接口 getAllUserInfo.php 可以获取所有注册用户的信息，如果 getAllUserInfo.php 没有进行权限校验， B2 用户也可以请求 getAllUserInfo.php 来获取所有注册用户的信息，出现越权行为。

**开发建议**：

1. 敏感数据、能力相关接口需要在后台进行鉴权。通常可校验 openid、 IP 地址、自定义登陆态等信息。
2. 鉴权逻辑应放在后台进行，不应在小程序前端以隐藏页面、隐藏按钮等方式来代替。参照原则4。

#### 8.2.2 代码管理与泄漏

1. 当使用 git、 svn 等版本管理工具时，会产生 .git 等目录。某些编辑器或软件也会在运行过程中生成临时文件。若这些目录或文件被带到生产环境，则可能发生源码泄漏。
2. 使用 [小程序代码管理平台](https://git.weixin.qq.com/users/authorize#wechat_redirect) 或 github 等第三方平台时需要注意项目权限，不要公开敏感、内部项目。

**开发建议**：

1. 备份文件和版本管理工具产生的文件不要同步到 Web 目录下。
2. 禁止外部访问 .git 等目录与文件。
3. 在 [小程序代码管理平台](https://git.weixin.qq.com/users/authorize#wechat_redirect) 等管理平台内配置适当的访问权限。

#### 8.2.3 信息泄露

敏感信息是指一旦泄露可能会对开发者的业务、合作伙伴和用户带来利益损害的数据，包括但不限于帐号 Appsecret、特权帐号信息、后台加密密钥、登录账户密码、用户身份证号、手机号、银行卡号等。

**开发建议**：

1. 敏感信息不应以明文、注释、可逆的编码方式（如 base64）、不安全散列函数（如 MD5、 SHA1）等形式出现在小程序文件内。

2. 部分敏感信息如用户的银行卡号、手机号等需要用于展示的，需要进行脱敏处理。常用脱敏规范如下：

    敏感信息类型 | 展示样例
    ------------|---------
    姓名 | 名字只有两个字，对第一个字打码，如：`*三。 多于两个字，只保留第一个和最后一个，其余都打码，如：王*四、欧**五`
    身份证 | 只显示第一位和最后一位，如：3****************1
    手机号 | 除去手机国际码后，手机号位数不少于10位时，只显示前三位和最后两位，如：`156******77`。手机号位数少于10位时，只显示前两位和后两位，如：12*****89。国家码可以完全显示。
    银行卡 | 只显示最后4位，如：************1234

3. 如果小程序存在敏感信息泄露的问题，微信开放平台将有可能下架该小程序，并暂停该小程序的相关服务。

### 8.3 后台

#### 8.3.1 注入漏洞

注入漏洞（SQL、 命令等）通常指用户绕过后台代码限制，直接在数据库、 shell 内执行自定义代码。

常见的注入漏洞有：

**SQL 注入**
SQL 注入是指 Web 程序代码中对于用户提交的参数未做有效过滤就直接拼接到 SQL 语句中执行，导致参数中的特殊字符打破了 SQL 语句原有逻辑，黑客可以利用该漏洞执行任意 SQL 语句。

**开发建议**：

1. 使用数据库提供的参数化查询来进行数据库操作，不允许直接通过拼接字符串的方式来合成 SQL 语句。
2. 如果存在部分情况需要通过拼接的方式来合成 SQL ，拼接的变量必须要经过处理：
    1. 对于整数，需要判断变量是否为整数类型。
    2. 对于字符串，需要对单引号、双引号等做转义处理。
3. 避免 Web 应用显示 SQL 的报错信息。
4. 保证 Web 应用里每一数据层的编码统一。

**命令注入**
命令注入漏洞是指 Web 应用未对用户可控参数进行有效过滤，攻击者可以构造恶意参数拼接到命令上来执行任意命令。

**开发建议**：

- 对用户输入的数据（如 ;、|、&等）进行过滤或转义

#### 8.3.2 弱口令

弱口令指管理后台的用户名密码设置得较为简单或者使用默认帐号。攻击者可以通过登录这些帐号修改后台数据或进行下一步的入侵操作。

**开发建议**：

1. 后台服务禁用默认帐号，修改后台弱口令。
2. 敏感服务增加二次验证机制，如短信验证码、邮箱验证码等。

#### 8.3.3 文件上传漏洞

文件上传漏洞是指 Web 应用允许用户上传指定文件，但未对文件类型、格式等做合法性校验，导致可以上传非预期格式的文件。

**开发建议**：

- 正确解析上传文件的文件类型，通过白名单的方式限制可上传的文件类型。

#### 8.3.4 文件下载

文件下载漏洞是指 Web 应用允许用户通过指定路径和文件名的方式来下载对应的文件，但未正确限制可下载文件所在的目录范围，导致预期范围外的文件被下载泄露。

**开发建议**：

1. 正确限制可下载文件所在的目录范围
2. 通过指定文件 id 的方式来查找下载对应的文件

#### 8.3.5 目录遍历

目录遍历是指由后台服务对用户输入验证不足或配置不严谨导致的服务器目录内容泄漏。外部可能通过目录遍历获取系统文件、后台代码等敏感文件。

**开发建议**：

1. web 服务配置
    1. 服务端禁止展示目录
    2. 设置目录访问权限
    3. 在每个目录下放置一个空的 index.html 页面
2. web 应用代码
    1. 严格检查文件路径参数，限定文件的范围

#### 8.3.6 条件竞争

条件竞争比较常见的例子是攻击者通过并发 https 请求而达到多次获奖、多次收获、多次获赠等非正常逻辑所能触发的效果。

```java
// 漏洞代码示例
// 从DB里查询该用户剩余获奖次数，初始值为1
int remain_times = SelectRemainTimes();

if(remain_times > 0){
  EarnRewards();          // 用户获得奖励
  ClearRemainTimes();     // 在DB里把该用户的剩余获奖次数清零
}
```

设计本意是只允许用户获得一次奖励，但当出现并发请求时，有可能出现请求 A 和请求 B 都刚好执行完第2行代码的情况，此时两个请求的 remain_times 都为1，也就是可以通过第4行代码的判断，获得两次奖励。

**开发建议**：

- 对关键（完整）逻辑加锁操作或把关键逻辑以队列任务的形式去进行处理。

### 8.4 安全风控

为提高微信开放平台生态安全性，针对小程序各应用场景中可能存在的恶意注册、营销作弊等黑产风险和安全问题，平台开放API方式向开发者提供安全风控接口协助开发者应对刷单、虚假交易、恶意骗取补贴等营销作弊风险和批量注册、伪造身份等注册黑产风险，以便开发者维护小程序运营秩序和安全。

**安全风控接口提供能力和应用场景**:

- 营销作弊场景：在首单优惠和特价优惠等营销活动中有效识别刷单、虚假交易、恶意骗保骗补贴等破坏运营秩序和安全的行为。
- 恶意注册：识别并拦截机器批量注册、垃圾小号、伪造身份等恶意注册行为。

**能力申请流程**
登录小程序，在【开发→开发管理→安全中心→风险用户扫描】申请开通即可。

**风险等级说明和使用建议**
可根据接口返回的风险等级数判别用户的风险程度，风险等级代表的意义及对应业务的使用，可参考下方的说明及建议，具体的使用可根据业务实际情况动态调整，以达到准确的拦截，保护业务健康有序的开展。

风险等级 | 建议处置方案
--------|-------------
风险等级0 | 无风险，不做任何阻拦
风险等级1 | 低微可疑的风险，建议进行简单的验证（如验证码、短信等）
风险等级2 | 轻度可疑的风险，建议进行简单的验证（如验证码、短信等）
风险等级3 | 中度可疑的风险，建议根据业务场景采取一定措施避免伤害。例如，营销活动可降低高等级奖励的概率；打榜类活动对此类投票降低权重；登录注册要求二次验证等
风险等级4 | 高度可疑的风险，建议根据业务逻辑直接拦截。例如，红包类活动返回不中奖或最小额红包；打榜类活动不计算票数；登录/注册操作要求二次验证；高危业务可选择限制本次操作

**开发接入指引**
[调用API](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/safety-control-capability/riskControl.getUserRiskRank.html)

## 九. 调试

**vConsole**
在真机上，如果想要查看 console API 输出的日志内容和额外的调试信息，需要在点击屏幕右上角的按钮打开的菜单里选择「打开调试」。此时小程序/小游戏会退出，重新打开后会右下角会出现一个 `vConsole` 按钮。点击 `vConsole` 按钮可以打开日志面板。小程序和小游戏的 vConsole 展示内容会有一定差别。

**vConsole 使用说明**
由于实现机制的限制，开发者调用 `console` API 打印的日志内容，是转换成 `JSON` 字符串后传输给 vConsole 的，导致 vConsole 中展示的内容会有一些限制：

- 除了 Number、String、Boolean、null 外，其他类型都会被作为 Object 处理展示，打印对象及原型链中的 `Enumerable` 属性。
- Infinity 和 NaN 会显示为 null。
- undefined、ArrayBuffer、Function 类型无法显示
- 无法打印存在循环引用的对象

```js
let a = {}
a.b = a
console.log(a) // 2.3.2 以下版本，会打印 `An object width circular reference can't be logged`
```

针对上述问题，小程序/小游戏在使用 vConsole 时做了一些处理

- 2.3.2 及以上版本，支持打印循环引用对象。循环引用的对象属性会显示引用路径，`@` 表示对象本身。

  ```js
  const circular = { x: {}, c: {} }
  circular.x = [{ promise: Promise.resolve() }]
  circular.a = circular
  circular.c.x0 = circular.x[0]

  console.log(circular)
  // "{a: '<Circular: @>', c: {x0: '<Circular: @.x[0]>'}, x: [{promise: '<Promise>'}]}"
  ```

- 2.3.1 及以上版本，支持展示所有类型的数据。基础库会对日志内容进行一次转换，经过转换的内容会使用 `<>` 包裹。如:
  - `<Function: func>`
  - `<Undefined>`
  - `<Infinity>`
  - `<Map: size=0>`
  - `<ArrayBuffer: byteLength=10>`
  - ...

- 2.2.3 ~ 2.3.0 版本中，可以展示 `ArrayBuffer` 和 `Function` 类型，undefined 会被打印为字符串 'undefined'

> 注意：尽量避免在非调试情景下打印结构过于复杂或内容过长的日志内容（如游戏引擎中的精灵或材质对象等），可能会带来额外耗时。为了防止异常发生，日志内容超过一定长度会被替换为<LOG_EXCEED_MAX_LENGTH>，此时需要裁剪日志内容。

**Source Map**:

> 目前只在 iOS 6.7.2 及以上版本支持

小程序/小游戏在打包时，会将所有 js 代码打包成一个文件，为了便于在手机上调试时定位错误位置，小程序/小游戏提供了 `Source Map` 支持。

在开发者工具中开启 ES6 转 ES5、代码压缩时，会生成 `Source Map` 的 `.map` 文件。开发版小程序中，基础库会使用代码包中的 `.map` 文件，对 vConsole 中展示的错误信息堆栈进行重新映射（只对开发者代码文件进行）。

如果使用外部的编译脚本对源文件进行处理，只需将对应生成的 Source Map 文件放置在源文件的相同目录下

如：

```map
pages/index.js

pages/index.js.map

app.js

app.js.map
```

开发者工具会读取、解析 `Source Map` 文件，并进行将其上传

后续可以在小程序后台的运营中心可以利用上传的 Source Map 文件进行错误分析

1. Source Map 文件不计入代码包大小计算。
2. 开发版代码包中由于包含了 `.map` 文件，实际代码包大小会比体验版和正式版大。

**真机调试**
真机远程调试功能可以实现直接利用开发者工具，通过网络连接，对手机上运行的小程序进行调试，更好的定位和查找在手机上出现的问题。详见开发工具文档 [真机调试](https://developers.weixin.qq.com/miniprogram/dev/devtools/remote-debug.html)

## 十. 性能与体验

### 10.1 启动性能

小程序启动是小程序用户体验中极为重要的一环，启动耗时过长会造成小程序用户流失。

> 启动只包括小程序冷启动，不包括小程序后台切前台的热启动。

#### 10.1.1 启动流程

在小程序启动过程中，主要包括以下几个方面：

1. 小程序启动的这些部分不是串行完成的，会尽可能的并行进行。
2. 小程序启动各部分不是每次启动都完整进行的，会尽可能的利用缓存。

##### 10.1.1.1 资源准备

1. 小程序相关信息准备
  在用户访问小程序时，微信客户端需要从微信后台获取小程序的配置、版本、权限等相关信息，以对小程序进行必要的版本管理、权限控制和校验等。

    - **对启动耗时的影响**
      - 信息的获取和更新会影响小程序的启动耗时，尤其体现在用户首次访问小程序时。
      - 为了在尽量降低影响启动耗时的情况下保证信息的实时性，这些信息会在本地缓存，并通过一定的机制定期进行更新。

2. 小程序运行环境准备
  在执行小程序代码之前，微信客户端需要准备小程序运行的基础环境。小程序的运行环境包括小程序进程、原生部分的 UI 元素（如 导航栏、tabBar等）、渲染页面使用的 WebView 容器、运行开发者 JS 代码的 JS 引擎、小程序基础库等等。

    - **对启动耗时的影响**
      - 运行环境的准备耗时较长，对小程序的启动耗时有明显影响。
      - 为了尽可能的降低运行环境准备对启动耗时的影响，微信客户端会根据用户的使用场景和设备资源的使用情况，提前对运行环境进行部分地预加载。但由于受到设备资源和操作系统调度的影响，目前很难保证每次小程序启动时都有预加载的环境。

3. 小程序代码包准备
  小程序启动时需要从服务器获取代码包地址、下载小程序代码包，并对代码包进行校验。根据小程序页面所在分包和使用的插件不同，一次启动可能需要下载多个代码包或插件包。
  当小程序版本发生更新时，微信客户端还需要对代码包进行增量更新。

    - **对启动耗时的影响**
      - 下载耗时是启动耗时中的重要瓶颈，与代码包或增量包的体积正相关。微信采用 ZSTD 算法对小程序代码包进行压缩，以尽可能降低下载过程中传输的数据量。
      - 考虑到包大小对用户体验的影响，平台限制单个代码包的大小上限为 2M。代码包上限的增加对于开发者来说，能够实现更丰富的功能，但对于用户来说，也增加了下载流量和本地空间的占用。为了保证启动速度，开发者应该尽可能的控制代码包大小。

##### 10.1.1.2 开发者代码注入（逻辑层）

小程序启动时需要从代码包内读取小程序的配置和代码，并注入到 JS 引擎中。在主包代码注入过程中，会触发小程序的 `App.onLaunch` 和首次 `App.onShow` 生命周期。在开发者代码注入完成后，框架侧会根据用户访问的页面进行一些页面数据初始化工作，触发首页的 `Page.onLoad`, `Page.onShow` 事件。

- **对启动耗时的影响**
  - 开发者代码的注入耗时直接影响小程序的启动耗时。在主流的 JS 引擎中，代码注入耗时包括编译和执行等环节，代码量、同步接口调用和一些复杂的计算，都会影响注入耗时。
  - 由于首页渲染需要使用逻辑层发送的数据，如果开发者代码注入耗时过长，也会延迟首页渲染开始的时间。
  - 在部分平台上，微信客户端会使用 V8 引擎的 Code Caching 技术对代码编译结果进行缓存，降低二次注入时的编译耗时。

##### 10.1.1.3 开发者代码注入（渲染层）

开发者的 wxss 和 wxml 会经过编译注入到渲染层，包含页面渲染需要的页面结构和样式信息。渲染层的注入耗时主要和页面结构复杂度和使用的自定义组件数量有关。

渲染层和逻辑层的开发者代码注入是并行进行的。

- **对启动耗时的影响**
  - 由于首页渲染需要使用渲染层的页面结构和样式信息，如果开发者代码注入耗时过长，会延迟首页渲染开始的时间。

##### 10.1.1.4  首页（初次）渲染

在开发者代码注入完成后，结合逻辑层得到的数据和渲染层得到的页面结构和样式信息，小程序框架会进行小程序首页的渲染，展示小程序首屏，并触发首页的 `Page.onReady` 事件。`Page.onReady` 事件触发标志小程序启动过程完成。

- **对启动耗时的影响**
  - 首页渲染耗时主要受页面结构和参与渲染的数据量影响。

#### 10.1.2 关键概念

在讨论小程序启动耗时时，需要明确几个概念：

1. **小程序首屏渲染完成**
  从开发者角度看，小程序首屏渲染完成的标志是首页 `Page.onReady` 事件触发。
  从框架的角度来说，小程序的首屏的内容是基于小程序的初始数据，以及在渲染开始前到达的 `setData` 数据渲染的。
  首屏渲染完成不表示小程序页面一定有完整内容，开发者触发的 `setData`（例如通过 wx.request 异步请求数据）不一定能参与到首屏渲染中。
  由于框架和启动流程的差异，小程序定义的首屏渲染完成不等同于浏览器的 load 事件。

2. **小程序启动阶段**
  从用户点击访问小程序到小程序首屏渲染完成（首页 `Page.onReady` 事件触发）。

3. **打开率/到达率**
  小程序首屏渲染完成 PV 与 用户点击访问小程序 PV 的比值。流失率 = 1 - 打开率

#### 10.1.3 启动性能优化

在启动流程中，小程序代码包准备、开发者代码注入和首页渲染是与开发者相关的，开发者可以进行一定的优化工作。其他部分目前开发者暂时无法干预，框架侧负责进行持续的优化。

**小程序代码包优化**
代码包优化的核心手段是降低代码包大小，代码包大小直接影响了下载耗时，影响用户启动小程序时的体验。
开发者可以采取以下手段优化代码包大小：

1. 分包加载
  使用 [分包加载](#55-分包加载) 是优化小程序启动耗时效果最明显的手段。建议按照功能划分，将小程序的功能按使用频率和场景拆分成分包，实现代码包的按需加载。
  分包加载具有以下优势：
    - 承载更多功能：小程序单个代码包的体积上限为 2M，使用分包可以提升小程序代码包总体积上限，承载更多的功能与服务。
    - 降低代码包下载耗时：使用分包后可以显著启动时需要下载的代码包大小，在不影响功能正常使用的前提下明显提升启动耗时。
    - 降低开发者代码注入耗时：小程序启动时会一次性注入全部的开发者代码，使用分包后可以降低注入的代码量，从而降低注入耗时。
    - 降低页面渲染耗时
  此外，结合分包加载的几个扩展功能，可以进一步优化启动耗时：
    - [分包预下载](#553-分包预下载)
      在使用「分包加载」后，虽然能够显著提升小程序的启动速度，但是当用户在使用小程序过程中跳转到分包内页面时，需要等待分包下载完成后才能进入页面，造成页面切换的延迟，影响小程序的使用体验。分包预下载便是为了解决首次进入分包页面时的延迟问题而设计的。
    - [独立分包](#552-独立分包)
      小程序中的某些场景（如广告页、活动页、支付页等），通常功能不是很复杂且相对独立，对启动性能有很高的要求。独立分包可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。建议将部分对启动性能要求很高的页面放到特殊的独立分包中。
    - 独立分包和分包预下载可以配合使用，获得更好的效果，详情参考 [独立分包与分包预下载教程](https://developers.weixin.qq.com/community/develop/doc/000e44abb2c7e89c2287f84b956c09)

2. 代码重构和优化
  通过代码重构，降低代码冗余。在使用如 Webpack 等打包工具时，要尽量利用 tree-shaking 等特性去除冗余代码，也要注意防止打包时引入不需要的库和依赖。

3. 控制代码包内图片等资源
  避免在代码包中包含或在 WXSS 中使用 base64 内联过多、过大的图片，应尽量采用网络图片。代码包内的图片一般应只包含一些体积较小的图标。声音、视频等其他类型的资源应尽量避免放到代码包中。
  小程序代码包在下载时会使用 ZSTD 算法进行压缩，降低下载时传输的数据量。这些资源文件会占用大量代码包体积，并且通常难以进一步被压缩，对于下载耗时的影响比代码文件大得多。

4. 及时清理没有使用到的代码和资源
  在日常开发的时候，可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，常常会忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。

**开发者代码注入优化**
开发者代码注入的优化可以从优化执行耗时和优化代码量两部分着手。

1. 减少启动过程的同步调用
  在小程序启动流程中，会注入开发者代码并顺序同步执行 `App.onLaunch`, `App.onShow`, `Page.onLoad`, `Page.onShow`。在小程序初始化代码（Page，App 定义之外的内容）和启动相关的几个生命周期中，应避免执行复杂的计算逻辑或过度使用Sync结尾的同步API，如 `wx.getStorageSync`，`wx.getSystemInfoSync` 等。对于 `getSystemInfo`, `getSystemInfoSync` 的结果应进行缓存，避免重复调用。

2. 使用[懒注入](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#lazyCodeLoading)
  通常情况下，在小程序启动时，启动页面所在分包和主包（独立分包除外）的所有JS代码会全部合并注入，包括其他未访问的页面以及未用到自定义组件，造成很多没有使用的代码注入到小程序运行环境中，影响注入耗时和内存占用。
  自基础库版本 2.11.1 起，小程序支持仅注入当前页面需要的自定义组件和当前页面代码，以降低小程序的启动时间和运行时内存。可以在 `app.json` 中配置：

    ```json
    {
      "lazyCodeLoading": "requiredComponents"
    }
    ```

    > 注意：添加这项配置后，未使用到的代码文件将不被执行。

**页面渲染优化**:

1. 提前首屏数据请求
  大部分小程序在渲染首页时，需要依赖服务端的接口数据，小程序为开发者提供了提前发起数据请求的能力：

    - [数据预拉取](#510-数据预拉取) ：能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度。
    - [周期性更新](#59-周期性更新) ：在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间。

2. 骨架屏
  在页面数据未准备好时（如需要通过网络获取），尽量避免展示空白页面，应先通过骨架屏展示页面的大致结构，请求数据返回后在进行页面更新。以提升用户的等待意愿。

3. 缓存请求数据
  小程序提供了 [wx.setStorage][wx.setStorage]、[wx.getStorage][wx.getStorage] 等读写本地缓存的能力，数据存储在本地，返回的会比网络请求快。如果基于某些原因无法采用数据预拉取与周期性更新，推荐优先从缓存中获取数据来渲染视图，等待网络请求返回后进行更新。

4. 精简首屏数据
  推荐延迟请求非关键渲染数据，与视图层渲染无关的数据尽量不要放在 data 中，加快页面渲染完成时间。

#### 10.1.4 启动性能分析

**性能数据获取**:

1. 小程序助手「性能分析」板块
  建议使用 [小程序助手][mydev] 中「性能分析」板块，持续关注小程序性能。性能分析从 **启动性能、运行性能和网络性能** 三个维度提供性能数据，根据平台、机型、网络环境和访问来源等条件做精细化分析。

    > 目前，小程序助手中只包括微信客户端 >= 7.0.3 版本的正式版小程序数据。
    > `启动总耗时 ≠ 下载耗时 + js 注入耗时 + 初次渲染耗时`。在启动过程中，下载不一定发生，也不一定只下载一个代码包。js 注入耗时和渲染耗时也会受缓存更新而发生波动。
    > 各阶段耗时的下降不一定反应在总耗时的下降。例如小程序新版本发布后，即使各阶段耗时都下降，下载比例的升高反而可能导致总耗时的上升。

2. 通过 API 在小程序内获取
  可以在小程序中根据自身业务需求进行性能打点，也可以使用 [wx.getPerformance][wx.getPerformance] ，获取当前小程序性能相关的信息。
  在获取信息后，可以自行上报或使用 [wx.reportPerformance][wx.reportPerformance] 进行测速。

3. 体验评分
  小程序工具中提供了 [体验评分工具](https://developers.weixin.qq.com/miniprogram/dev/framework/audits/audits.html)，方便能够及时发现小程序的体验问题。

**影响启动性能的因素**
根据启动流程来看，影响小程序启动耗时的因素众多，分析小程序启动性能是一个比较复杂的过程。

对于同一个小程序，以下因素会直接影响平均启动耗时：

- 平台: 不同平台下（安卓、iOS、PC等）设备性能、操作系统、框架实现、优化方案存在较大差异，启动耗时也存在较大的差异。只有分平台比较启动耗时（包括各阶段的耗时）才有意义。
- 下载比例: 代码包下载和更新都会显著影响小程序启动耗时，在其他流程耗时稳定的情况下，下载比例升高会影响大盘启动耗时。
- 入口页面：不同页面启动时，根据所在分包的不同，需要下载的代码包数量和大小和代码注入量都存在差异。不同页面渲染耗时也存在差异。
- 机型分布：启动耗时和设备性能有较强关联，不同小程序或使用场景用户群体的差异可能导致机型分布的差异，进而影响大盘启动耗时。
- 网络环境：网络环境主要影响网络请求的耗时，如小程序信息获取、代码包下载等。

下列情况也会间接影响启动耗时：

- 场景/访问来源：不同场景用户访问的页面不同，访问的目的性和自身的等待意愿也有差异，对启动耗时和打开率都有一定影响。
- 首次访问用户比例：用户首次访问小程序时，需要完整的进行小程序信息准备、代码包下载的流程、代码缓存也需要重新生成，启动耗时会比非首次访问高。
- 小程序版本更新：小程序版本更新时，用户需要更新小程序信息和代码包，代码缓存也需要重新生成，启动耗时会出现上涨。

### 10.2 运行时性能

**setData**
: setData 是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。

**工作原理**
: 小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 `evaluateJavascript` 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。
而 `evaluateJavascript` 的执行会受很多方面的影响，数据到达视图层并不是实时的。

**常见的 setData 操作错误**:

1. 频繁的 `setData`
    - Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层
    - 渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时

2. 每次 `setData` 都传递大量新数据
  由setData的底层实现可知，我们的数据传输实际是一次 `evaluateJavascript` 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程，

3. 后台态页面进行 `setData`
  当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。

**图片资源**
目前图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面。

**图片对内存的影响**
在 iOS 上，小程序的页面是由多个 WKWebView 组成的，在系统内存紧张时，会回收掉一部分 WKWebView。大图片和长列表图片的使用会引起 WKWebView 的回收。

**图片对页面切换的影响**
除了内存问题外，大图片也会造成页面切换的卡顿。小程序在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。

> 建议 : 尽量减少使用大图片资源。

### 10.3 性能分析工具

微信 Android 6.5.10 开始，提供了 Trace 导出工具，可以在开发者工具 Trace Panel 中使用该功能。

**使用方法**:

1. PC 上需要先安装 `adb` 工具，可以参考一些主流教程进行安装，Mac 上可使用 `brew` 直接安装。
2. 确定 `adb` 工具已成功安装后，在开发者工具上打开 Trace Panel，将 Android 手机通过 USB 连接上 PC，点击「Choose Devices」，此时手机上可能弹出连接授权框，请点击「允许」。
3. 选择设备后，在手机上打开你需要调试的开发版小程序，通过右上角菜单，打开性能监控面板，重启小程序；
4. 重启后，在小程序上进行操作，完成操作后，通过右上角菜单，导出 Trace 数据；
5. 此时开发者工具 Trace Panel 上会自动拉取 Trace 文件，选择你要分析的 Trace 文件即可；

> 可以通过 adb devices 命令确定设备是否已和 PC 建立起连接

**性能面板**
从微信 6.5.8 开始，提供了性能面板了解小程序的性能。可以在开发版小程序下打开性能面板，打开方法：进入开发版小程序，进入右上角更多按钮，点击「显示性能窗口」。

**性能面板指标说明**:

指标 | 说明
-----|-----
CPU | 小程序进程的 CPU 占用率，仅 Android 下提供
内存 | 小程序进程的内存占用（Total Pss)，仅 Android 下提供
启动耗时 | 小程序启动总耗时
下载耗时 | 小程序包下载耗时，首次打开或资源包需更新时会进行下载
页面切换耗时 | 小程序页面切换的耗时
帧率/FPS | -
首次渲染耗时 | 页面首次渲染的耗时
再次渲染耗时 | 页面再次渲染的耗时（通常由开发者的 setData 操作触发）
数据缓存 | 小程序通过 Storage 接口储存的缓存大小

### 10.4 体验评分

#### 10.4.1 简介

体验评分是一项给小程序的体验好坏打分的功能，它会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。

**运行环境要求**：

- 基础库需要切到 2.2.0 或以上版本。

**使用流程**:

1. 打开开发者工具，在详情里切换基础库到 2.2.0 或以上版本。
2. 在调试器区域切换到 Audits 面板。
3. 点击”开始“按钮，然后自行操作小程序界面，运行过的页面就会被“体验评分”检测到。
4. 点击 “停止" 则结束检测，在当前面板显示相应的检测报告，可根据报告中的建议对相应功能进行优化。
5. 如需再次运行体验评分，可点击报告上方的“清空体验评分”恢复初始状态。请注意，目前系统不提供报告存储服务，一旦清空体验评分，将无法再查看本次评分结果。

**自动运行**
为了方便能够及时发现小程序的体验问题，从开发者工具 1.02.1811150 版本起支持体验评分的 “自动运行” 功能。

该功能会在开发调试小程序时，实时检查，一旦发现体验分数低于 70 分时，系统会在 console 面板打印一个 warning 信息提示开发者，此时可以切到 Audits 面板查看详情。

开发者在工具的右上角 “详情” 面板的 本地设置 中勾选 “自动运行体验评分” 选项即可开启。

#### 10.4.2 评分方法与规则

目前体验评分共有27条规则，共分为三类：**性能、体验、最佳实践**，满足规则要求得分（100分），否则不得分（0分），最后根据各规则权重和公式计算出总得分。

![性能体验评分计算](./image/性能体验评分计算.png)

> 权重为0的规则，表示该规则不参与评分，仅作为提示项。开发者可在开发者工具中可以点击“忽略”。
> 各规则的得分条件也可能会随小程序的版本更新有一定的调整。

**权重表**:

分类 | 规则 | 权重
-----|-----|------
性能 | 脚本执行时间 | 7
 _ | 首屏时间 | 6
 _ | 渲染时间 | 6
 _ | setData调用频率 | 6
 _ | setData数据大小 | 6
 _ | WXML节点数 | 6
 _ | 请求耗时 | 5
 _ | 网络请求数 | 5
 _ | 图片请求数 | 5
 _ | 图片缓存 | 4
 _ | 图片大小 | 4
 _ | 网络请求缓存 | 2
体验 | 开启惯性滚动 | 8
 _ | 避免使用 `:active` 伪类来实现点击态 | 8
 _ | 保持图片大小比例 | 4
 _ | 可点击元素的响应区域 | 3
 _ | iPhone X兼容 | 3
 _ | 窗口变化适配 | 3
 _ | 合理的颜色搭配 | 0
最佳实践 | 避免JS异常 | 3
 _ | 避免网络请求异常 | 3
 _ | 废弃接口 | 2
 _ | 使用HTTPS | 1
 _ | 避免setData数据冗余 | 1
 _ | 最低基础库版本 | 0
 _ | 移除不可访问到的页面 | 0
 _ | WXSS使用率 | 0
 _ | 及时回收定时器 | 0

#### 10.4.3 性能

1. 首屏时间
  首屏时间是指用户从打开小程序看到第一屏主要内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，影响使用体验。
  优化首屏时间，可以分为以下几种情况：
    1. 首屏渲染的内容较多，需要集合多份数据进行渲染。这种情况需要把内容分优先级，把优先级高的内容做优先展示，缩短白屏时间；
    2. 首屏内容依赖的数据从服务端请求的时间太长。需要从服务端侧具体分析服务端数据返回的时间长的原因；
    3. 一次性渲染数据太大或依赖的计算过于复杂。减少渲染的数据量、优化渲染相关数据的算法可以解决这类问题。
  **得分条件：首屏时间不超过 5 秒**

2. 渲染时间
  渲染时间指的是首次渲染或因数据变化带来的页面结构变化的渲染花费的时间。
  渲染界面的耗时过长会让用户觉得卡顿，体验较差，出现这一情况时，需要校验下是否同时渲染的区域太大（例如列表过长），或渲染依赖的计算是否过于复杂。
  **得分条件：渲染时间不超过 500ms**

3. 脚本执行时间
  脚本执行时间是指JS脚本在一次同步执行中消耗的时间，比如生命周期回调、事件处理函数的同步执行时间。
  执行脚本的耗时过长会让用户觉得卡顿，体验较差，出现这一情况时，需要确认并优化脚本的逻辑
  **得分条件：一个执行周期内脚本运行时间不超过 1 秒**

4. setData调用频率
  setData接口的调用涉及逻辑层与渲染层间的线程通信，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用。
  **得分条件：每秒调用setData的次数不超过 20 次**

5. setData数据大小
  由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间。
  **得分条件：setData的数据在JSON.stringify后不超过 256KB**

6. WXML节点数
  建议一个页面使用少于 1000 个 WXML 节点，节点树深度少于 30 层，子节点数不大于 60 个。一个太大的 WXML 节点树会增加内存的使用，样式重排时间也会更长，影响体验。
  **得分条件：页面WXML节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个**

7. 图片缓存
  开启 HTTP 缓存控制后，下一次加载同样的图片，会直接从缓存读取，大大提升加载速度。
  **得分条件：所有图片均开启 HTTP 缓存**

8. 图片大小
  图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。
  **得分条件：图片宽高乘积 <= 实际显示宽高乘积 * (设备像素比 ^ 2)**

9. 请求耗时
  请求的耗时太长会让用户一直等待甚至离开，应当优化好服务器处理时间、减小回包大小，让请求快速响应。
  **得分条件：所有网络请求都在 1 秒内返回结果**

10. 网络请求数
  短时间内发起太多请求会触发小程序并行请求数量的限制，同时太多请求也可能导致加载慢等问题，应合理控制请求数量，甚至做请求的合并等。
  **得分条件：通过 wx.request 发起的耗时超过 300ms 的请求并发数不超过 10 个**

11. 图片请求数
  短时间内发起太多图片请求会触发浏览器并行加载的限制，可能导致图片加载慢，用户一直处理等待。应该合理控制数量，可考虑使用雪碧图技术或在屏幕外的图片使用懒加载。
  **得分条件：同域名耗时超过 100ms 的图片请求并发数不超过 6 个**

12. 网络请求缓存
  发起网络请求总会让用户等待，可能造成不好的体验，应尽量避免多余的请求，比如对同样的请求进行缓存
  **得分条件：3 分钟以内同一个url请求不出现两次回包大于 128KB 且一模一样的内容**

#### 10.4.4 体验

1. 开启惯性滚动
  惯性滚动会使滚动比较顺畅，在安卓下默认有惯性滚动，而在 iOS 下需要额外设置 `-webkit-overflow-scrolling: touch` 的样式；
  **得分条件：wxss中带有overflow: scroll的元素，在 iOS 下需要设置-webkit-overflow-scrolling: touch样式**

2. 避免使用 `:active` 伪类来实现点击态
  使用 css `:active` 伪类来实现点击态，很容易触发，并且滚动或滑动时点击态不会消失，体验较差。建议使用小程序内置组件的 'hover-class' 属性来实现
  **得分条件：不使用:active伪类，并使用hover-class替换:active**

3. 保持图片大小比例
  图片若没有按原图宽高比例显示，可能导致图片歪曲，不美观，甚至导致用户识别困难。可根据情况设置 image 组件的 mode 属性，以保持原图宽高比。
  **得分条件：显示的高/宽与原图的高/宽不超过 15%**

4. 可点击元素的响应区域
  应该合理地设置好可点击元素的响应区域大小，如果过小会导致用户很难点中，体验很差。
  **得分条件：可点击元素的宽高都不小于 20px**

5. iPhone X 兼容
  对于 `position: fixed` 的可交互组件，如果渲染在iPhone X的安全区域外，容易误触 Home Indicator，应当把可交互的部分都渲染到安全区域内。
  建议使用以下wxss进行兼容

    ```wxss
    padding-bottom: constant(safe-area-inset-bottom);
    padding-bottom: env(safe-area-inset-bottom);
    ```

    **得分条件：`position: fixed` 且高度小于 68px 的可交互组件渲染在安全区域内**

6. 窗口变化适配
  对于支持调整大小的页面，需要对不同窗口尺寸进行UI适配，已达到良好体验。
  可以使用 `match-media` 组件、`MatchMediaObserver` 或者 `@media` 媒体查询对页面补充适配逻辑。
  **得分条件：支持调整大小的页面有相关适配逻辑**

7. 合理的颜色搭配
  文字颜色与背景色需要搭配得当，适宜的颜色对比度可以让用户更好地阅读，提升小程序的用户体验。
  由于颜色搭配的计算方法较为复杂，目前算法还在不断优化中。因此该指标仅作为评分的提醒项，不计入总分中。
  **判断标准**：
    1. 对于较大字体（font-size >= 24px，或同时满足font-size >= 19px与font-weight >= 700），文字颜色和背景颜色的对比度不小于3
    2. 其他字体，文字颜色和背景颜色的对比度不小于4.5

#### 10.4.5 最佳实践

1. 避免JS异常
  出现 JavaScript 异常可能导致程序的交互无法进行下去，我们应当追求零异常，保证程序的高鲁棒性和高可用性。
  **得分条件：不出现任何JS异常**

2. 避免网络请求异常
  请求失败可能导致程序的交互无法进行下去，应当保证所有请求都能成功。
  **得分条件：所有已授权网络请求都正常返回，未授权网络请求需要给出 401 或 403 这两种状态码**

3. 不使用废弃接口
  使用即将废弃或已废弃接口，可能导致小程序运行不正常。一般而言，接口不会立即去掉，但保险起见，建议不要使用，避免后续小程序突然运行异常。
  **得分条件：不使用任何文档中提示废弃的接口**

4. 使用HTTPS
  使用HTTPS，可以让你的小程序更加安全，而HTTP是明文传输的，存在可能被篡改内容的风险
  **得分条件：所有网络请求都使用HTTPS**

5. 避免setData数据冗余
  setData操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入setData会造成不必要的性能消耗。
  **得分条件：setData传入的所有数据都在模板渲染中有相关依赖**

6. 最低基础库版本
  当使用的组件/API 的支持版本大于配置的线上最低基础库版本时，可能导致相应功能不可用。可通过调整最低基础库版本或在代码上兼容的方式解决该问题。
  由于用户可以通过代码兼容的方式解决该问题，因此该指标仅作为评分的提醒项，不计入总分中。
  **判断标准：不存在使用的组件/API 的支持版本大于配置的线上最低基础库版本**

7. 移除不可访问到的页面
  小程序的包大小会影响加载时间，应该尽量控制包体积大小，避免将不会被使用的文件打包进去。
  由于该项指标依赖开发者的操作路径，因此仅作为评分的提醒项，不计入总分中。
  **判断标准：不存在访问不到的页面被打包到小程序中**

8. WXSS使用率
  应该按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度。
  由于该项指标依赖开发者的操作路径，因此仅作为评分的提醒项，不计入总分中。
  **判断标准：每个 wxss 资源的未使用部分不超过 2KB**

9. 及时回收定时器
  定时器是全局的，并不是跟页面绑定的，当小程序从一个页面路由到另一个页面之后，前一个页面定时器应注意手动回收。
  由于该项指标依赖开发者的操作路径，因此仅作为评分的提醒项，不计入总分中。
  **判断标准：所有定时器的回调执行时所在的页面都与设置定时器的页面一致**

## 十一. 基础库

[版本分布查看](https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html)

### 11.1 低版本兼容

小程序的功能不断的增加，但是旧版本的微信客户端并不支持新功能，所以在使用这些新能力的时候需要做兼容。

可以通过以下方式进行低版本的兼容：

1. 版本号比较
  微信客户端和小程序基础库的版本号风格为 Major.Minor.Patch（主版本号.次版本号.修订版本号）。文档中会在组件，API等页面描述中带上各个功能所要求的最低基础库版本号。
  可以在小程序中通过调用 [wx.getSystemInfo][wx.getSystemInfo] 或者 [wx.getSystemInfoSync][wx.getSystemInfoSync] 获取到当前小程序运行的基础库的版本号。通过版本号比较的方式进行运行低版本兼容逻辑。
  版本号比较适用于所有情况。部分场景下也可以使用后面提到的方法完成。
  **注意：不要直接使用字符串比较的方法进行版本号比较。**
  版本号比较可以参考以下代码：

    ```js
    function compareVersion(v1, v2) {
      v1 = v1.split('.')
      v2 = v2.split('.')
      const len = Math.max(v1.length, v2.length)

      while (v1.length < len) {
        v1.push('0')
      }
      while (v2.length < len) {
        v2.push('0')
      }

      for (let i = 0; i < len; i++) {
        const num1 = parseInt(v1[i])
        const num2 = parseInt(v2[i])

        if (num1 > num2) {
          return 1
        } else if (num1 < num2) {
          return -1
        }
      }

      return 0
    }

    compareVersion('1.11.0', '1.9.9') // 1
    ```

    ```js
    const version = wx.getSystemInfoSync().SDKVersion

    if (compareVersion(version, '1.1.0') >= 0) {
      wx.openBluetoothAdapter()
    } else {
      // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示
      wx.showModal({
        title: '提示',
        content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'
      })
    }
    ```

2. API 存在判断
  对于新增的 API，可以通过判断该API是否存在来判断是否支持用户使用的基础库版本。例如：

    ```js
    if (wx.openBluetoothAdapter) {
      wx.openBluetoothAdapter()
    } else {
      // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示
      wx.showModal({
        title: '提示',
        content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'
      })
    }
    ```

3. wx.canIUse
  除了直接通过版本号判断，也可以通过 [wx.canIUse][wx.canIUse] 来判断是否可以在该基础库版本下直接使用。例如：
  **API 参数或返回值**
  对于 API 的参数或者返回值有新增的参数，可以判断用以下代码判断。

  ```js
  wx.showModal({
  success: function(res) {
    if (wx.canIUse('showModal.success.cancel')) {
      console.log(res.cancel)
    }
  }
  })
  ```

  **组件**
  对于组件，新增的组件或属性在旧版本上不会被处理，不过也不会报错。如果特殊场景需要对旧版本做一些降级处理，可以这样子做。

    ```js
    Page({
      data: {
        canIUse: wx.canIUse('cover-view')
      }
    })
    ```

    ```wxml
    <video controls="{{!canIUse}}">
      <cover-view wx:if="{{canIUse}}">play</cover-view>
    </video>
    ```

**设置最低基础库版本**:

> 需要 iOS 6.5.8 / 安卓 6.5.7 及以上版本微信客户端支持

为便于解决低版本基础库无法兼容小程序的新功能的问题，可设置小程序最低基础库版本要求。
可以登录小程序管理后台，进入「设置 - 基本设置 - 基础库最低版本设置」进行配置。在配置前，可查看近 30 天内访问当前小程序的用户所使用的基础库版本占比，了解当前用户使用的情况。
设置后，若用户基础库版本低于设置值，则无法正常打开小程序，并提示用户更新客户端版本。

## 十二. 实时日志

**背景**
为快捷地排查小程序漏洞、定位问题，小程序推出了实时日志功能。从基础库2.7.1开始，可通过提供的接口打印日志，日志汇聚并实时上报到小程序后台。可从小程序管理后台“开发->运维中心->实时日志”进入日志查询页面，查看打印的日志信息。

**如何使用**:

1. 调用相关接口。打日志的接口是 [wx.getRealtimeLogManager][wx.getRealtimeLogManager]
  为了兼容旧的版本，建议使用如下代码封装一下，例如封装在log.js文件里面：

    ```js
    var log = wx.getRealtimeLogManager ? wx.getRealtimeLogManager() : null

    module.exports = {
      info() {
        if (!log) return
        log.info.apply(log, arguments)
      },
      warn() {
        if (!log) return
        log.warn.apply(log, arguments)
      },
      error() {
        if (!log) return
        log.error.apply(log, arguments)
      },
      setFilterMsg(msg) { // 从基础库2.7.3开始支持
        if (!log || !log.setFilterMsg) return
        if (typeof msg !== 'string') return
        log.setFilterMsg(msg)
      },
      addFilterMsg(msg) { // 从基础库2.8.1开始支持
        if (!log || !log.addFilterMsg) return
        if (typeof msg !== 'string') return
        log.addFilterMsg(msg)
      }
    }
    ```

2. 在页面的具体位置打印日志

    ```js
    var log = require('./log.js') // 引用上面的log.js文件
    log.info('hello test hahaha') // 日志会和当前打开的页面关联，建议在页面的onHide、onShow等生命周期里面打
    log.warn('warn')
    log.error('error')
    log.setFilterMsg('filterkeyword')
    log.addFilterMsg('addfilterkeyword')
    ```

  完整的例子可以参考 [代码片段](https://developers.weixin.qq.com/s/i42NbKmp76bJ)

**如何查看日志**
登录小程序管理后台，从 “开发->运维中心->实时日志” 进入日志查询页面。可通过设置时间、微信号/OpenID、页面链接、FilterMsg内容（基础库2.7.3及以上支持setFilterMsg）等筛选条件查询指定用户的日志信息。

**注意事项**
由于后台资源限制，“实时日志”使用规则如下：

1. 为了定位问题方便，日志是按页面划分的，某一个页面，在onShow到onHide（切换到其它页面、右上角圆点退到后台）之间打的日志，会聚合成一条日志上报，并且在小程序管理后台上可以根据页面路径搜索出该条日志。
2. 每个小程序账号每天限制500万条日志，日志会保留7天，建议遇到问题及时定位。
3. 一条日志的上限是5KB，最多包含200次打印日志函数调用（info、warn、error调用都算），所以要谨慎打日志，避免在循环里面调用打日志接口，避免直接重写console.log的方式打日志。
4. 意见反馈里面的日志，可根据OpenID搜索日志。
5. setFilterMsg可以设置过滤的Msg。这个接口的目的是提供某个场景的过滤能力，例如setFilterMsg('scene1')，则在MP上可输入scene1查询得到该条日志。比如上线过程中，某个监控有问题，可以根据FilterMsg过滤这个场景下的具体的用户日志。FilterMsg仅支持大小写字母。如果需要添加多个关键字，建议使用addFilterMsg替代setFilterMsg。

## 十三. 小程序测速

为优化小程序性能，小程序推出了"小程序测速"功能。"小程序测速"可以简单方便地统计小程序内某一事件的实时耗时情况，并可根据地域、运营商、操作系统、网络类型、机型等关键维度进行实时交叉分析。从基础库2.9.2开始，可以通过“测速上报”接口上报某一指标的耗时情况后，可在小程序管理后台"开发 -运维中心 -小程序测速" 查看各指标耗时趋势，并支持分钟级数据实时查看。

**新建监控 ID**
为了实现对某一指标的耗时监控，需要先定义监控指标。在小程序管理后台（mp.weixin.qq.com）的 ："开发 -运维中心 -小程序测速"中新建监控 ID，并填写监控指标的名称和解释。
点击"新建"可以新建 ID ，需要选择指标类型，并填写指标名称和指标对应的解释。 监控指标分为两类：

- **网络请求类** : 此类耗时主要受网络环境影响，包含操作系统、运营商、网络环境、地区等统计维度。如：网络 api 耗时、云调用耗时、网络数据读写耗时等。注意此类指标最多可创建20个。
- **加载/渲染类** : 此类耗时主要受设备性能影响，包含操作系统、机型类别等统计维度。可以用来测量页面切换耗时、组件渲染耗时等。 注意此类指标最多可创建20个。

**测速上报**
定义监控ID后，需要在小程序代码中调用 [wx.reportPerformance][wx.reportPerformance] 接口上报耗时数值，才可实现耗时监控：

1. 使用 canIUse 进行判断

    ```js
    // 需要使用 canIUse 判断接口是否可用
    if (wx.canIUse('reportPerformance')) {
      wx.reportPerformance(id, val)
    }
    ```

2. 使用 compareVersion 进行判断

    ```js
    // 需要先使用 compareVersion 判断接口是否可用
    const sdkVersion = wx.getSystemInfoSync().SDKVersion
    if (compareVersion(sdkVersion, '2.9.2') >= 0) {
      wx.reportPerformance(id, val)
    }
    ```

    ​id 和 val 均为 uint32 类型，其中 id 为小程序管理后台定义的监控 ID，val 为本次要上报的耗时数值（由开发者自行计算）。接口调用需要基础库的版本号高于 2.9.2，否则在一些低版本基础库可能报错。

**数据观察**
完成代码上报后，可在小程序管理后台 "开发 -运维中心 -小程序测速" 查看各指标耗时趋势。目前线上数据约有15分钟数据时延，上报数据保留 7 天，可按照 1 分钟 - 1 小时等不同的时间粒度进行聚合。

每个指标可以观察到两条曲线，分别为平均值曲线和上报次数曲线。

​同时对于不同维度的数据，提供了交叉对比功能，快速便捷的完成分析，注意交叉对比的曲线数最多不能超过10条。

​对于网络请求类指标，提供了区域地图，快速的定位区域资源问题。

**自定义维度(可选功能)**
对于更复杂的用户场景，用户可能需要将测速数据根据url、页面等维度进行细分，所以提供了自定义维度，用户可以将一些业务层面的维度字符串填入至自定义维度中，以方便业务分析。 目前每个指标的自定义纬度值的数量需要限制在50以内（超限制的数据会被丢弃），自定义维度值的长度需要限制在256字节内（超限制的值会被截断）。
想要使用自定义维度，只需要给 [wx.reportPerformance][wx.reportPerformance] 加上第三个参数dimensions，即可上报自定义维度：

```js
wx.reportPerformance(id, value, dimensions)
```

## 十四. 小程序搜索

### 14.1 小程序搜索优化指南

爬虫访问小程序内页面时，会携带特定的 user-agent "mpcrawler" 及场景值：1129

判断请求是否来源于官方搜索爬虫的方法：

签名算法与小程序消息推送接口的签名算法一致。

参数在请求的header里设置，分别是： X-WXApp-Crawler-Timestamp X-WXApp-Crawler-Nonce X-WXApp-Crawler-Signature

签名流程如下： 1.将token、X-WXApp-Crawler-Timestamp、X-WXApp-Crawler-Nonce三个参数进行字典序排序 2.将三个参数字符串拼接成一个字符串进行sha1加密 3.开发者获得加密后的字符串可与X-WXApp-Crawler-Signature对比，标识该请求来源于微信

1. 小程序里跳转的页面 (url) 可被直接打开。
  小程序页面内的跳转url是爬虫发现页面的重要来源，且搜索引擎召回的结果页面 (url) 是必须能直接打开，不依赖上下文状态的。 特别的：建议页面所需的参数都包含在url

2. 页面跳转优先采用 [navigator][navigator] 组件
  小程序提供了两种页面路由方式：
    1. [navigator][navigator] 组件
    2. 路由 API，包括 navigateTo / redirectTo / switchTab / navigateBack / reLaunch
    建议使用 [navigator][navigator] 组件，若不得不使用API，可在爬虫访问时屏蔽针对点击设置的时间锁或变量锁。

3. 清晰简洁的页面参数
  结构清晰、简洁、参数有含义的 queryString 对抓取以及后续的分析都有很大帮助，但是将 JSON 数据作为参数的方式是比较糟糕的实现。

4. 必要的时候才请求用户进行授权、登录、绑定手机号等
  建议在必须的时候才要求用户授权（比如阅读文章可以匿名，而发表评论需要留名）。

5. 不收录 web-view 中的任何内容。
  暂时做不到这一点，长期来看，可能也做不到。

6. 利用 sitemap 配置引导爬虫抓取，同时屏蔽无搜索价值的路径。
  [网站地图配置](#1214-网站地图配置-sitemapjson)

7. 设置一个清晰的标题和页面缩略图
  页面标题和缩略图对于理解页面和提高曝光转化有重要的作用。 通过 [wx.setNavigationBarTitle][wx.setNavigationBarTitle] 或 自定义转发内容 [Page.onShareAppMessage](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShareAppMessage-Object-object) 对页面的标题和缩略图设置，另外也为 video、audio 组件补齐 poster / poster-for-crawler 属性。

8. 使用页面路径推送能力
  可极大丰富微信可以收录的内容，进而提高小程序内容的曝光机会。可以通过 [search.submitPages](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/search/search.submitPages.html) 提交小程序页面url及参数信息(不要推送webview页面)，让微信可以更及时的收录到小程序的页面信息，交的页面信息将可能被用于小程序搜索结果展示。

## 十五. 设计

[微信小程序设计指南](https://developers.weixin.qq.com/miniprogram/design/)
