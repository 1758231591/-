# 图解 GoogleV8

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [图解 GoogleV8](#图解-googlev8)
  - [一. 宏观视角](#一-宏观视角)
    - [1.1 什么是 V8](#11-什么是-v8)
    - [1.2 高级代码需要先编译再执行](#12-高级代码需要先编译再执行)
    - [1.3 V8 执行 JS 代码](#13-v8-执行-js-代码)
    - [1.4 构建和使用 V8 的调试工具 d8](#14-构建和使用-v8-的调试工具-d8)
  - [二. JS 设计思想](#二-js-设计思想)
    - [2.1 函数即对象](#21-函数即对象)
      - [2.1.1 JS 中的对象](#211-js-中的对象)
      - [2.1.2 函数的本质](#212-函数的本质)
      - [2.1.3 函数是一等公民](#213-函数是一等公民)
    - [2.2 V8 如何提升对象属性访问速度](#22-v8-如何提升对象属性访问速度)
      - [2.2.1 常规属性（properties）和排序属性（elements）](#221-常规属性properties和排序属性elements)
      - [2.2.2 快属性和慢属性](#222-快属性和慢属性)
      - [2.2.3 在 Chrome 中查看对象布局](#223-在-chrome-中查看对象布局)
    - [2.3 函数表达式](#23-函数表达式)
      - [2.3.1 函数声明与函数表达式的差异](#231-函数声明与函数表达式的差异)
      - [2.3.2 V8 处理函数声明](#232-v8-处理函数声明)
      - [2.3.3 V8 处理函数表达式](#233-v8-处理函数表达式)
    - [2.4 原型链](#24-原型链)
      - [2.4.1 原型继承的实现](#241-原型继承的实现)
      - [2.4.2 利用 `__proto__` 实现继承](#242-利用-__proto__-实现继承)
    - [2.5 作用域链](#25-作用域链)
      - [2.5.1 全局作用域和函数作用域](#251-全局作用域和函数作用域)
      - [2.5.2 作用域链的工作方式](#252-作用域链的工作方式)
    - [2.6 类型转换](#26-类型转换)
      - [2.6.1 类型系统](#261-类型系统)
      - [2.6.2 v8 执行加法操作](#262-v8-执行加法操作)
  - [三. V8 编译流水线](#三-v8-编译流水线)
    - [3.1 运行 JS 代码的基石：运行时环境](#31-运行-js-代码的基石运行时环境)
      - [3.1.1 构造数据存储空间：堆空间和栈空间](#311-构造数据存储空间堆空间和栈空间)
      - [3.1.2 全局执行上下文和全局作用域](#312-全局执行上下文和全局作用域)
      - [3.1.3 构造事件循环系统](#313-构造事件循环系统)
    - [3.2 机器码](#32-机器码)
      - [3.2.1 将源码编译成机器码](#321-将源码编译成机器码)
      - [3.2.2 CPU 执行程序](#322-cpu-执行程序)
    - [3.3 堆和栈](#33-堆和栈)
      - [3.3.1 为何使用栈结构来管理函数调用](#331-为何使用栈结构来管理函数调用)
      - [3.3.2 栈如何管理函数调用](#332-栈如何管理函数调用)
      - [3.3.3 堆的优势](#333-堆的优势)
    - [3.4 惰性解析](#34-惰性解析)
      - [3.4.1 惰性解析的过程](#341-惰性解析的过程)
      - [3.4.2 闭包的三个基础特性](#342-闭包的三个基础特性)
      - [3.4.3 闭包给惰性解析带来的问题和解决方案](#343-闭包给惰性解析带来的问题和解决方案)
    - [3.5 字节码](#35-字节码)
      - [3.5.1 机器码的问题](#351-机器码的问题)
      - [3.5.2 字节码的优势](#352-字节码的优势)
      - [3.5.3 生成字节码](#353-生成字节码)

<!-- /code_chunk_output -->

## 一. 宏观视角

V8 是 JS 虚拟机的一种。可以简单地把 JS 虚拟机理解成是一个翻译程序，将人类能够理解的编程语言 JS，翻译成机器能够理解的机器语言。如下图所示：

![V8JS引擎](./image/V8JS引擎.webp)

上图中，中间的 “黑盒” 就是 JS 引擎 V8。目前市面上有很多种 JS 引擎，诸如 SpiderMonkey、V8、JavaScriptCore 等。而由谷歌开发的开源项目 V8 是当下使用最广泛的 JS 虚拟机。

V8 之所以拥有如此庞大的生态圈，也和它许多革命性的设计是分不开的。在 V8 出现之前，所有的 JS 虚拟机所采用的都是解释执行的方式，这是 JS 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JS 的执行速度带来了极大的提升。

V8 出现之后，各大厂商也都在自己的 JS 虚拟机中引入了 JIT 机制，所以可以看到目前市面上 JS 虚拟机都有着类似的架构。另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JS 代码的编译执行效率。

**V8 的主要职责是用来执行 JS 代码**的，那首先需要先了解 JS 这门语言的基本特性和设计思想。JS 借鉴了很多语言的特性，比如 C 语言的基本语法、Java 的类型系统和内存管理、Scheme 的函数作为一等公民，还有 Self 基于原型（prototype）的继承机制。毫无疑问，JS 是一门非常优秀的语言，特别是 “原型继承机制” 和 “函数是一等公民” 这两个设计。

![JS的设计思想](./image/JS的设计思想.webp)

不过 JS 也是一门处处是坑的语言，由于历史原因，很多错误的或者不合理的设计都被延续至今，比如使用 new 加构造函数来创建对象，这种方式的背后隐藏了太多的细节，非常容易增加代码出错概率，而且也大大增加了新手的学习成本；再比如初期的 JS 没有块级作用域机制，使得 JS 需要采取变量提升的策略，而变量提升又是非常反人性的设计。

V8 是 JS 的实现，在学习 V8 工作原理时，就要格外关注 JS 这些独特的设计思想和特性背后的实现。比如，为了实现函数是一等公民的特性，JS 采取了基于对象的策略；再比如为了实现原型继承，V8 为每个对象引入了 [`__proto__`](/front_end/JavaScript/JavaScript权威指南/JavaScript权威指南.md#143-prototype-特性) 属性。

V8 执行 JS 代码的完整流程被称之为 V8 的编译流水线，其完整流程如下图所示：

![V8编译流水线](./image/V8编译流水线.webp)

编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内联缓存等等。这些技术决定着一段 JS 代码能否正常执行，以及代码的执行效率。比如 V8 中使用的隐藏类（Hide Class），这是将 JS 中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行速度过慢的问题，如果熟悉 V8 的工作机制，在编写 JS 时，就能充分利用好隐藏类这种强大的优化特性，写出更加高效的代码。

再比如，V8 实现了 JS 代码的惰性解析，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，可以优化代码更加适应这个机制，从而提高程序性能。要想充分了解 V8 是怎么工作的，除了要分析编译流水线，还需要了解另外两个非常重要的特性：

- **事件循环系统**
  事件循环系统和 JS 中的难点与异步编程特性紧密相关。JS 是单线程的，代码都是在一个线程上执行，如果同一时间发送了多个 JS 执行的请求，就需要排队，也就是进行异步编程。V8 的事件循环系统会调度这些排队任务，保证 JS 代码被 V8 有序地执行。因此也可以说，事件循环系统就是 V8 的心脏，它驱动了 V8 的持续工作。

- **垃圾回收机制**
  JS 是一种自动垃圾回收的语言，V8 在执行垃圾回收时，会占用主线程的资源，如果编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，这也是经常会遇到的一个问题。需要知道 V8 是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完整的系统，当下次遇到内存问题时，就知道如何去排查了。

![V8知识图谱](./image/V8知识图谱.jpg)

### 1.1 什么是 V8

V8 是一个由 Google 开发的开源 JS 引擎，目前用在 Chrome 浏览器和 Node.js 中，其核心功能是执行易于人类理解的 JS 代码。

其主要核心流程分为编译和执行两步。首先需要将 JS 代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果。

![转换为中间代码](./image/%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81.webp)

可以把 V8 看成是一个虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的 CPU、堆栈、寄存器等，虚拟机还具有它自己的一套指令系统。

所以对于 JS 代码来说，V8 就是它的整个世界，当 V8 执行 JS 代码时，并不需要担心现实中不同操作系统的差异，也不需要担心不同体系结构计算机的差异，只需要按照虚拟机的规范写好代码就可以了。

### 1.2 高级代码需要先编译再执行

可以把 CPU 看成是一个非常小的运算机器，可以通过二进制的指令和 CPU 进行沟通，比如给 CPU 发出 “1000100111011000” 的二进制指令，这条指令的意思是将一个寄存器中的数据移动到另外一个寄存器中，当处理器执行到这条指令的时候，便会按照指令的意思去实现相关的操作。

为了能够完成复杂的任务，工程师们为 CPU 提供了一大堆指令，来实现各种功能，这一大堆指令被称为**指令集**（Instructions），也就是机器语言。

> **注意**：CPU 只能识别二进制的指令，但是对程序员来说，二进制代码难以阅读和记忆，于是又将二进制指令集转换为人类可以识别和记忆的符号，这就是汇编指令集。

CPU 不能直接识别汇编语言，所以还需要一个汇编编译器，其作用是将汇编代码编程成机器代码：

![汇编编译器](./image/%E6%B1%87%E7%BC%96%E7%BC%96%E8%AF%91%E5%99%A8.webp)

虽然汇编语言对机器语言做了一层抽象，减少了程序员理解机器语言的复杂度，但是汇编语言依然是复杂且繁琐的，即便写一个非常简单的功能，也需要实现大量的汇编代码，这主要表现在以下两点。

1. **不同的 CPU 有着不同的指令集**，如果要使用机器语言或者汇编语言来实现一个功能，那么需要为每种架构的 CPU 编写特定的汇编代码，这会带来巨大的、枯燥繁琐的操作。

2. 在编写汇编代码时，还需要**了解和处理器架构相关的硬件知识**，比如寄存器、内存、操作 CPU 等。

因此需要一种屏蔽了计算机架构细节的语言，能适应多种不同 CPU 架构的语言，能专心处理业务逻辑的语言，诸如 C、C++、Java、C#、Python、JS 等，这些 “高级语言” 就应运而生了。

和汇编语言一样，处理器也不能直接识别由高级语言所编写的代码，通常，有两种方式来执行这些代码：

1. **解释执行**

   需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。具体流程如下图所示：

   ![解释执行流程图](./image/%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.webp)

2. **编译执行**

   采用这种方式时，也需要先将源代码转换为中间代码，然后编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

   ![编译执行流程图](./image/%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.webp)

但是针对不同的高级语言，实现方式还是有很大差异的，比如要执行 C 语言编写的代码，需要将其编译为二进制代码的文件，然后再直接执行二进制代码。而对于像 Java 语言、JS 语言等，则需要不同虚拟机，模拟计算机的这个编译执行流程。执行 Java 语言，需要经过 Java 虚拟机的转换，执行 JS 需要经过 JS 虚拟机的转换。

即便是 JS 一门语言，也有好几种流行的虚拟机，它们之间的实现方式也存在着一部分差异，比如苹果公司在 Safari 中就是用 JSCore 虚拟机，Firefox 使用了 TraceMonkey 虚拟机，而 Chrome 则使用了 V8 虚拟机。

### 1.3 V8 执行 JS 代码

V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，把这种混合使用编译器和解释器的技术称为 **JIT**（Just In Time）技术。

这是一种权衡策略，因为这两种方法都各自有各自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。可以参考下面完整的 V8 执行 JS 的流程图：

![8执行一段JS流程图](./image/8%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5JS%E6%B5%81%E7%A8%8B%E5%9B%BE.webp)

上图中的最左边的部分，在 V8 启动执行 JS 之前，它还需要准备执行 JS 时所需要的一些基础环境，这些基础环境包括了 “堆空间” “栈空间” “全局执行上下文” “全局作用域” “消息循环系统” “内置函数” 等，这些内容都是在执行 JS 过程中需要使用到的。

1. 首先 V8 会接收到要执行的 JS 源代码，V8 并不能直接理解源代码的含义，它需要**结构化**[^1]这段字符串。

   [^1]: 结构化，是指信息经过分析后可分解成多个互相关联的组成部分，各组成部分间有明确的层次结构，方便使用和维护，并有一定的操作规范。

   V8 源代码的结构化之后，就生成了抽象语法树（AST）。在生成 AST 的同时，V8 还会生成相关的作用域，作用域中存放相关变量。

2. 有了 AST 和作用域之后，就可以生成**字节码**[^2]了。

   [^2]: 字节码，是介于 AST 和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。

3. 之后，解释器会按照顺序解释执行字节码，并输出执行结果。

在解释器有个监控，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。

当某段代码被标记为热点代码后，V8 就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么 V8 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。

不过，和静态语言不同的是，JS 是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行**反优化操作**，经过反优化的代码，下次执行时就会回退到解释器解释执行。

### 1.4 构建和使用 V8 的调试工具 d8

[文档](https://time.geekbang.org/column/article/219418)

[编译好的 d8](https://storage.googleapis.com/chromium-v8/official/canary/v8-win64-dbg-8.4.109.zip)

## 二. JS 设计思想

### 2.1 函数即对象

JS 中的函数非常灵活，其根本原因在于 **JS 中的函数就是一种特殊的对象**，JS 中的函数被称为**一等公民**（First Class Function）。

基于函数是一等公民的设计，使得 JS 非常容易实现一些特性，比如闭包，还有函数式编程等，而其他语言要实现这些特性就显得比较困难，比如要在 C++ 中实现闭包需要实现大量复杂的代码，而且使用起来也异常复杂。

#### 2.1.1 JS 中的对象

JS 是一门**基于对象**（Object-Based）的语言，可以说 JS 中大部分的内容都是由对象构成的，诸如函数、数组，也可以说 JS 是建立在对象之上的语言。

![基于对象的设计](./image/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1.webp)

而这些对象在运行时可以动态修改其内容，这造就了 JS 的超级灵活特性。不过，因为 JS 太灵活了，也加大了理解和使用这门语言的难度。

虽然 JS 是基于对象设计的，但是它却不是一门面向对象的语言（Object—Oriented Programming Language），因为**面向对象语言天生支持封装、继承、多态**，但是 JS 并没有直接提供多态的支持，因此要在 JS 中使用多态并不是一件容易的事。

除了对多态支持的不好，JS 实现继承的方式和面向对象的语言实现继承的方式同样存在很大的差异。

面向对象语言是由语言本身对继承做了充分的支持，并提供了大量的关键字，如 public、protected、friend、interface 等，众多的关键字使得面向对象语言的继承变得异常繁琐和复杂，而 JS 中实现继承的方式却非常简单清爽，只是在对象中添加了一个称为**原型**的属性，把继承的对象通过原型链接起来，就实现了继承，这种继承方式被称为**基于原型链继承**。关于 V8 是如何支持原型的，我们会在《05 | 原型链：V8 是如何实现对象继承的？》这节课做具体介绍。<!-- TODO -->

JS 中的对象非常简单，每个对象就是由一组组属性和值构成的集合，比如：

```js
let person = new Object();
person.firstname = 'John';
person.lastname = 'Doe';
person.age = 50;
person.eyecolor = 'blue';
```

这个对象里面有四个属性：

![对象的构成](./image/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E6%88%90.webp)

上图展示了对象 person 的结构，可以看到蓝色的属性在左边，黄色的值在右边，有多组属性和值组成，这就是 JS 中的对象，虽然 JS 对象用途非常广泛，使用的方式也非常之多，但是万变不离其宗，其核心本质都就是由一组组属性和值组成的集合。

之所以 JS 中对象的用途这么广，是因为对象的值可以是任意类型的数据，可以改造下上面的那段代码：

```js
let person = new Object();
person.firstname = 'John';
person.lastname = 'Doe';
person.info = new Object();
person.info.age = 50;
person.info.eyecolor = 'blue';
person.showinfo = function () {
  console.log(/*...*/);
};
```

这段代码的内存布局，如下图所示：

![属性值类型](./image/%E5%B1%9E%E6%80%A7%E5%80%BC%E7%B1%BB%E5%9E%8B.webp)

观察上图，可以看出来，对象的属性值有三种类型：

1. **原始类型**（primitive）

   所谓的原始类型的数据，是指值本身无法被改变，比如 JS 中的字符串就是原始类型，如果修改了 JS 中字符串的值，那么 V8 会返回一个新的字符串，原始字符串并没有被改变，称这些类型的值为 “原始值”。

   JS 中的原始值主要包括 null、undefined、boolean、number、string、bigint、symbol 这七种。

2. **对象类型**（Object）：对象的属性值也可以是另外一个对象。

3. **函数类型**（Function）：如果对象中的属性值是函数，那么可以把这个属性称为**方法**，所以又说对象具备属性和方法。

#### 2.1.2 函数的本质

在 JS 中，函数是一种特殊的对象，它和对象一样可以拥有属性和值，函数和普通对象不同的是，函数可以被调用。V8 内部为了实现函数可调用特性，会为函数对象添加了两个隐藏属性：

![函数对象具有隐藏属性](./image/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%85%B7%E6%9C%89%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7.webp)

也就是说，函数除了可以拥有常用类型的属性值之外，还拥有两个隐藏属性：

- `name`：隐藏 name 属性的值就是函数名称，如果某个函数没有设置函数名，默认是 `''`，表示该函数对象没有被设置名称。

- `code`：其值表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8 便会从函数对象中取出 code 属性值，也就是函数代码，然后再解释执行这段函数代码。

#### 2.1.3 函数是一等公民

因为函数是一种特殊的对象，所以在 JS 中，函数可以赋值给一个变量，也可以作为函数的参数，还可以作为函数的返回值。**如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，就把这个语言中的函数称为一等公民**。支持函数是一等公民的语言可以使得代码逻辑更加清晰，代码更加简洁。

但是由于函数的 “可被调用” 的特性，使得实现函数的可赋值、可传参和可作为返回值等特性变得有一点麻烦。

在执行 JS 函数的过程中，为了实现变量的查找，V8 会为其维护一个作用域链，如果函数中使用了某个变量，但是在函数内部又没有定义该变量，那么函数就会沿着作用域链去外部的作用域中查找该变量：

![查找变量](./image/%E6%9F%A5%E6%89%BE%E5%8F%98%E9%87%8F.webp)

从图中可以看出，当函数内部引用了外部的变量时，使用这个函数进行赋值、传参或作为返回值，还需要保证这些被引用的外部变量是确定存在的，这就是让函数作为一等公民麻烦的地方，因为虚拟机还需要处理函数引用的外部变量。来看一段简单的代码：

```js
function foo() {
  let number = 1;
  function bar() {
    number++;
    console.log(number);
  }
  return bar;
}
let myBar = foo();
myBar();
```

在 foo 函数中定义了一个新的 bar 函数，并且 bar 函数引用了 foo 函数中的变量 number，当调用 foo 函数的时候，它会返回 bar 函数。

“函数是一等公民” 就体现在，如果要返回函数 bar 给外部，那么即便 foo 函数执行结束了，其内部定义的 number 变量也不能被销毁，因为 bar 函数依然引用了该变量。也把这种**将外部变量和和函数绑定起来的技术称为闭包**。V8 在实现闭包的特性时也做了大量的额外的工作，关于闭包的详细实现，会在《12 | 延迟解析：V8 是如何实现闭包的？》这节课再介绍。<!-- TODO -->

### 2.2 V8 如何提升对象属性访问速度

JS 中的对象是由一组组属性和值的集合，从 JS 语言的角度来看，JS 对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。

然而在 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8 为了提升存储和查找效率，采用了一套复杂的存储策略。

![线性结构和非线性结构](./image/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.webp)

#### 2.2.1 常规属性（properties）和排序属性（elements）

```js
function Foo() {
  this[100] = 'test-100';
  this[1] = 'test-1';
  this['B'] = 'bar-B';
  this[50] = 'test-50';
  this[9] = 'test-9';
  this[8] = 'test-8';
  this[3] = 'test-3';
  this[5] = 'test-5';
  this['A'] = 'bar-A';
  this['C'] = 'bar-C';
}
let bar = new Foo();

for (let key in bar) {
  console.log(`index:${key}  value:${bar[key]}`);
}
```

上面这段代码，利用构造函数 Foo 创建了一个 bar 对象，在构造函数中，给 bar 对象设置了很多属性，包括了数字属性和字符串属性，然后枚举出来了 bar 对象中所有的属性，并将其一一打印出来：

```txt
index:1  value:test-1
index:3  value:test-3
index:5  value:test-5
index:8  value:test-8
index:9  value:test-9
index:50  value:test-50
index:100  value:test-100
index:B  value:bar-B
index:A  value:bar-A
index:C  value:bar-C
```

发现打印出来的属性顺序并不是设置的顺序，设置属性的时候是乱序设置的，但是输出的内容却非常规律，总的来说体现在以下两点：

- 设置的数字属性被最先打印出来了，并且是按照数字大小的顺序打印的。
- 设置的字符串属性依然是按照之前的设置顺序打印的，比如是按照 B、A、C 的顺序设置的，打印出来依然是这个顺序。

之所以出现这样的结果，是因为在 ECMAScript 规范中定义了**数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列**。

在这里把**对象中的数字属性称为排序属性**，在 V8 中被称为 elements，**字符串属性就被称为常规属性**，在 V8 中被称为 properties。

在 V8 内部，为了有效地提升存储和访问这两种属性的性能，*分别使用了两个线性数据结构*来分别保存排序属性和常规属性：

![V8内部的对象构造](./image/V8%E5%86%85%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0.webp)

通过上图发现，bar 对象包含了两个隐藏属性：elements 属性和 properties 属性，elements 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性，properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存了常规属性。

分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。

#### 2.2.2 快属性和慢属性

将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如执行 bar.B 这个语句来查找 B 的属性值，那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。

基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，这被称为**对象内属性**（in-object properties）：

![对象内属性](./image/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%B1%9E%E6%80%A7.webp)

采用对象内属性之后，常规属性就被保存到 bar 对象本身了，这样当再次使用 bar.B 来查找 B 的属性值时，V8 就可以直接从 bar 对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。

不过**对象内属性的数量是固定的，默认是 10 个**，如果添加的属性超出了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自由地扩容。

通常，**将保存在线性数据结构中的属性称之为 “快属性”**，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。

因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是 “慢属性” 策略，但慢属性的对象内部会有独立的非线性数据结构（词典）作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。

![慢属性是如何存储的](./image/%E6%85%A2%E5%B1%9E%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84.webp)

#### 2.2.3 在 Chrome 中查看对象布局

打开 Chrome 开发者工具，先选择控制台标签，然后在控制台中执行以下代码查看内存快照：

```js
function Foo(property_num, element_num) {
  // 添加可索引属性
  for (let i = 0; i < element_num; i++) {
    this[i] = `element${i}`;
  }
  // 添加常规属性
  for (let i = 0; i < property_num; i++) {
    let ppt = `property${i}`;
    this[ppt] = ppt;
  }
}
let bar = new Foo(12, 10);
```

创建了函数对象，接下来就来看看构造函数和对象在内存中的状态。将 Chrome 开发者工具切换到 Memory 标签，然后点击左侧的小圆圈（拍摄堆快照）就可以捕获当前的内存快照，然后在类过滤器中输入构造函数名称：

![从内存快照搜索构造函数](./image/%E4%BB%8E%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%E6%90%9C%E7%B4%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png)

可以看到其中有 10 个对象内属性，另外的常用属性就被保存到 properties 中，10 个排序属性存放在 elements 中。

**其他属性**
观察上图，除了 elements 和 properties 属性，V8 还为每个对象实现了 `map` 属性和 `__proto__` 属性。`__proto__` 属性就是原型，是用来实现 JS 继承的。而 map 则是隐藏类，我们会在《15 | 隐藏类：如何在内存中快速查找对象属性？》这一节中介绍其工作机制。<!-- TODO -->

### 2.3 函数表达式

函数表达式在 JS 中非常基础也非常重要，使用函数表达式可以用来实现代码隐藏，还可以实现变量隔离，所以函数表达式被广泛地应用在各个项目中。

```js
// 函数声明
function foo() {
  // ...
}

// 函数表达式
let foo = function () {
  // ...
};
```

#### 2.3.1 函数声明与函数表达式的差异

```js
foo();
function foo() {
  console.log('foo');
}
```

在这段代码中，声明了一个 foo 函数，然后在 foo 函数之前调用了 foo 函数，执行这段代码，可以看到 foo 函数被正确执行了。

```js
foo();
var foo = function () {
  console.log('foo');
};
```

在下面的代码中，定义了一个变量 foo，然后将一个函数赋值给了变量 foo，也是在 foo 函数的前面调用 foo，执行这段代码，发现报错了，提示的错误信息如下所示：

```sh
VM130:1 Uncaught TypeError: foo is not a function
    at <anonymous>:1:1
```

第二段代码报错的主要原因是这两种定义函数的方式具有不同语义，不同的语义触发了不同的行为。

![不同的语义触发不同的行为](./image/%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AF%AD%E4%B9%89%E8%A7%A6%E5%8F%91%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%8C%E4%B8%BA.webp)

因为语义不同，所以给这两种定义函数的方式使用了不同的名称，第一种称之为**函数声明**，第二种称之为**函数表达式**。

#### 2.3.2 V8 处理函数声明

函数声明定义了一个具有指定参数的函数，其声明语法如下所示：

```js
function name([param,[, param,[..., param]]]) {
   [statements]
}
```

V8 在执行 JS 的过程中，会先对其进行编译，然后再执行：

```js
var x = 5;
function foo() {
  console.log('Foo');
}
```

V8 执行这段代码的流程大致如下图所示：

![V8执行代码流程](./image/V8%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B.webp)

在编译阶段，如果解析到函数声明，那么 V8 会将这个函数声明转换为内存中的函数对象，并将其放到作用域中。同样，如果解析到了某个变量声明，也会将其放到作用域中，但是会将其值设置为 undefined，表示该变量还未被使用。

然后在 V8 执行阶段，如果使用了某个变量，或者调用了某个函数，那么 V8 便会去作用域查找相关内容。

#### 2.3.3 V8 处理函数表达式

在一个表达式中使用 function 来定义一个函数，那么就把该函数称为函数表达式。

```js
let foo = function () {
  console.log('foo');
};
```

函数表达式与函数声明的最主要区别有以下三点：

- 函数表达式是在表达式语句中使用 function 的，最典型的表达式是 “a=b” 这种形式，因为函数也是一个对象，把 “a = function (){}” 这种方式称为函数表达式。

- 在函数表达式中，可以省略函数名称，从而创建匿名函数（anonymous functions）。

- 一个函数表达式可以被用作一个即时调用的函数表达式——IIFE（Immediately Invoked Function Expression）。

### 2.4 原型链

**继承就是一个对象可以访问另外一个对象中的属性和方法**，比如有一个 B 对象，该对象继承了 A 对象，那么 B 对象便可以直接访问 A 对象中的属性和方法：

![继承](./image/%E7%BB%A7%E6%89%BF.webp)

不同的语言实现继承的方式是不同的，其中最典型的两种方式：

- **基于类的设计**

  C++、Java、C# 这些语言都是基于经典的类继承的设计模式，这种模式最大的特点就是提供了非常复杂的规则，并提供了非常多的关键字，诸如 class、friend、protected、private、interface 等，通过组合使用这些关键字，就可以实现继承。

  使用基于类的继承时，如果业务复杂，那么需要创建大量的对象，然后需要维护非常复杂的继承关系，这会导致代码过度复杂和臃肿，另外引入了这么多关键字也给设计带来了更大的复杂度。

- **基于原型继承的设计**

  而 JS 的继承方式和其他面向对象的继承方式有着很大差别，JS 本身不提供一个 class 实现。虽然标准委员会在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JS 的继承依然和基于类的继承没有一点关系。

  JS 仅仅在对象中引入了一个原型的属性，就实现了语言的继承机制，基于原型的继承省去了很多基于类继承时的繁文缛节，简洁而优美。

#### 2.4.1 原型继承的实现

**在 JS 中，通过原型和原型链的方式来实现了继承特性**。

![原型继承的实现-1](./image/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0-1.webp)

有一个对象 C，它包含了一个属性 “type”，那么对象 C 可以直接访问它自己的属性 type。

上面从 V8 的内存快照看到，JS 的每个对象都包含了一个隐藏属性**原型** `__proto__`（prototype），`__proto__` 指向了内存中的另外一个对象，就把 `__proto__` 指向的对象称为该对象的**原型对象**，那么该对象就可以直接访问其原型对象的方法或者属性。

比如让 C 对象的原型指向 B 对象，那么便可以利用 C 对象来直接访问 B 对象中的属性或者方法：

![原型继承的实现-2](./image/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0-2.webp)

当 C 对象将它的 `__proto__` 属性指向了 B 对象后，那么通过对象 C 来访问对象 B 中的 name 属性时，V8 会先从对象 C 中查找，但是并没有查找到，接下来 V8 继续在其原型对象 B 中查找，因为对象 B 中包含了 name 属性，那么 V8 就直接返回对象 B 中的 name 属性值，虽然 C 和 B 是两个不同的对象，但是使用的时候，B 的属性看上去就像是 C 的属性一样。

同样的方式，B 也是一个对象，它也有自己的 `__proto__` 属性，比如它的属性指向了内存中另外一块对象 A：

对象 A 有个属性是 color，那么通过 C.color 访问 color 属性时，V8 会先在 C 对象内部查找，但是没有查找到，接着继续在 C 对象的原型对象 B 中查找，但是依然没有查找到，那么继续去对象 B 的原型对象 A 中查找，因为 color 在对象 A 中，那么 V8 就返回该属性值。

使用 C.name 和 C.color 时，给人的感觉属性 name 和 color 都是对象 C 本身的属性，但实际上这些属性都是位于原型对象上，把这个查找属性的路径称为**原型链**，它像一个链条一样，将几个原型链接起来。查找属性的时候，JS 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。

> **注意**：不要将原型链接和作用域链搞混淆了，作用域链是沿着函数的作用域一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的，关于作用域链，我会在《06 | 作用域链：V8 是如何查找变量的？》这节课来介绍。<!-- TODO -->

#### 2.4.2 利用 `__proto__` 实现继承

```js
let animal = {
  type: 'Default',
  color: 'Default',
  getInfo: function () {
    return `Type is: ${this.type}，color is ${this.color}.`;
  }
};
let dog = {
  type: 'Dog',
  color: 'Black'
};
```

在这段代码中，创建了两个对象 animal 和 dog，想让 dog 对象继承于 animal 对象，那么最直观的方式就是将 dog 的原型指向对象 animal：

```js
dog.__proto__ = animal;
```

通常隐藏属性是不能使用 JS 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JS 可以访问隐藏属性 `__proto__`，但是在实际项目中，不应该直接通过 `__proto__` 来[访问或者修改该属性](/front_end/JavaScript/JavaScript.md#232-js-的原形)，其主要原因有两个：

- 这是隐藏属性，并不是标准定义的。
- 使用该属性会造成严重的性能问题。

### 2.5 作用域链

**作用域链就是将一个个作用域串起来，实现变量查找的路径**。作用域就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。

当在函数内部使用一个变量的时候，V8 便会去作用域中去查找：

```js
let name = '极客时间';
let type = 'global';

function foo() {
  let name = 'foo';
  console.log(`name: ${name}`);
  console.log(`type: ${type}`);
}

function bar() {
  let name = 'bar';
  let type = 'function';
  foo();
}

bar();
// name: foo
// type: global
```

#### 2.5.1 全局作用域和函数作用域

每个函数在执行时都需要查找自己的作用域，称为**函数作用域**，在执行阶段，在执行一个函数时，当该函数需要使用某个变量或者调用了某个函数时，便会优先在该函数作用域中查找相关内容。

```js
var x = 4;
var test;
function test_scope() {
  var name = 'foo';
  console.log(name);
  console.log(type);
  console.log(test);
  var type = 'function';
  test = 1;
  console.log(x);
}
test_scope();
```

在上面的代码中，定义了一个 test_scope 函数，在 V8 执行 test_scope 函数的时候，在编译阶段会为 test_scope 函数创建一个作用域，在 test_scope 函数中定义的变量和声明的函数都会丢到该作用域中，因为在 test_scope 函数中定了三个变量，那么常见的作用域就包含有这三个变量。

可以通过 Chrome 的控制台来直观感受下 test_scope 函数的作用域，先打开包含这段代码的页面，然后打开开发者工具，接着在 test_scope 函数中的第二段代码加上断点，然后刷新该页面。当执行到该断点时，V8 会暂停整个执行流程，这时候就可以通过右边的区域面板来查看当前函数的执行状态。

![观察作用域](./image/%E8%A7%82%E5%AF%9F%E4%BD%9C%E7%94%A8%E5%9F%9F.webp)

可以参考图中右侧的 Scope 项，然后点击展开该项，这个 Local 就是当前函数 test_scope 的作用域。在 test_scope 函数中定义的变量都包含到了 Local 中，如变量 name、type，另外系统还添加了另外一个隐藏变量 this，V8 会默认将隐藏变量 this 存放到作用域中。

在 test_scope 函数使用了变量 x，但是在 test_scope 函数的作用域中，并没有定义变量 x，V8 如果在当前函数作用域中没有查找到变量，那么 V8 会去全局作用域中去查找，这个查找的线路就称为作用域链。

全局作用域和函数作用域类似，也是存放变量和函数的地方，但是它们有点不一样：**全局作用域是在 V8 启动过程中就创建了，且一直保存在内存中不会被销毁的，直至 V8 退出。而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉**。

全局作用域中包含了很多全局变量，比如全局的 this 值，如果是浏览器，全局作用域中还有 window、document、opener 等非常多的方法和对象，如果是 node 环境，那么会有 Global、File 等内容。

V8 启动之后就进入正常的消息循环状态，这时候就可以执行代码了，比如执行到上面那段时，V8 会先解析顶层（Top Level）代码，可以看到，在顶层代码中定义了变量 x，这时候 V8 就会将变量 x 添加到全局作用域中。

#### 2.5.2 作用域链的工作方式

1. 当 V8 启动时，会创建全局作用域，全局作用域中包括了 this、window 等变量，还有一些全局的 Web API 接口：

   ![全局作用域-初始化](./image/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%88%9D%E5%A7%8B%E5%8C%96.webp)

2. V8 启动之后，消息循环系统便开始工作，这时候，输入代码让其执行。V8 会先编译顶层代码，在编译过程中会将顶层定义的变量和声明的函数都添加到全局作用域中：

   ![全局作用域-编译](./image/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F-%E7%BC%96%E8%AF%91.webp)

3. 全局作用域创建完成之后，V8 便进入了执行状态。

   当 V8 执行 bar 函数的时候，同样需要经历两个阶段：编译和执行。在编译阶段，V8 会为 bar 函数创建函数作用域，最终效果如下所示：

   ![bar函数作用域](./image/bar%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F.webp)

   然后进入了 bar 函数的执行阶段。在 bar 函数中，只是简单地调用 foo 函数，因此 V8 又开始执行 foo 函数。同样，在编译 foo 函数的过程中，会创建 foo 函数的作用域：

   ![foo函数作用域](./image/foo%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F.webp)

   **因为 JS 是基于词法作用域的，词法作用域就是指，查找作用域的顺序是按照函数定义时的位置来决定的**。bar 和 foo 函数的外部代码都是全局代码，所以无论是在 bar 函数中查找变量，还是在 foo 函数中查找变量，其查找顺序都是按照*当前函数作用域–> 全局作用域*这个路径来的。所以在 foo 函数中使用 type，最终打印出来的值就是全局作用域中的 type。

   ![词法作用域](./image/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F.webp)

   因为词法作用域是根据函数在代码中的位置来确定的，作用域是在声明函数时就确定好了，所以也将词法作用域称为**静态作用域**。和静态作用域相对的是动态作用域，**动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用**。换句话说，作用域链是基于调用栈的，而不是基于函数定义的位置的。

### 2.6 类型转换

如果尝试在 Python 中使用数字和字符串进行相加操作，那么 Python 虚拟机会直接返回一个执行错误，错误提示是这样的：

```python
>>> 1+'2'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

这段错误代码提示了这是个类型错误，表明 Python 并不支持数字类型和字符串类型相加的操作。

不过在 JS 中执行这段表达式，是可以返回一个结果的，最终返回的结果是字符串 “12”。

#### 2.6.1 类型系统

对机器语言来说，所有的数据都是一堆二进制代码，CPU 处理这些数据的时候，并没有类型的概念，CPU 所做的仅仅是移动数据，比如对其进行移位，相加或相乘。

而在高级语言中，都会为操作的数据赋予指定的类型，**类型可以确认一个值或者一组值具有特定的意义和目的**。所以，类型是高级语言中的概念。

![类型是高级语言的概念](./image/%E7%B1%BB%E5%9E%8B%E6%98%AF%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5.webp)

比如在 C/C++ 中，需要为要处理的每条数据指定类型：

```c++
int counter = 100 // 赋值整型变量
float miles = 1000.0 // 浮点型
char* name = "John" // 字符串
```

C/C++ 编译器负责将这些数据片段转换为供 CPU 处理的正确命令，通常是二进制的机器代码。

在某些更高级的语言中，还可以根据数据推断出类型，比如在 Python 或 JS 中，就不必为数据指定专门的数据类型，在 Python 中定义变量：

```python
counter = 100 # 赋值整型变量
miles = 1000.0 # 浮点型
name = "John" # 字符串
```

在 JS 中定义变量：

```js
var counter = 100; // 赋值整型变量
let miles = 1000.0; // 浮点型
const name = 'John'; // 字符串
```

虽然 Python 和 JS 定义变量的方式不同，但是它们都不需要直接指定变量的类型，因为虚拟机会根据数据自动推导出类型。

通用的类型有数字类型、字符串、Boolean 类型等等，引入了这些类型之后，编译器或者解释器就可以根据类型来限制一些有害的或者没有意义的操作。比如在 Python 语言中，如果使用字符串和数字相加就会报错，因为 Python 觉得这是没有意义的。而在 JS 中，字符串和数字相加是有意义的，可以使用字符串和数字进行相加的。

每种语言都**定义了自己的类型，还定义了如何操作这些类型，另外还定义了这些类型应该如何相互作用，就把这称为类型系统**。一个语言的类型系统越强大，那编译器能帮程序员检查的东西就越多，程序员定义 “检查规则” 的方式就越灵活。

#### 2.6.2 v8 执行加法操作

当有两个值相加的时候，比如：

```js
a + b;
```

V8 会严格根据 ECMAScript 规范来执行操作。ECMAScript 是一个语言标准，JS 就是 ECMAScript 的一个实现，比如在 ECMAScript 就定义了怎么执行加法操作，如下所示：

![ECMAScript定义加法语义](./image/ECMAScript%E5%AE%9A%E4%B9%89%E5%8A%A0%E6%B3%95%E8%AF%AD%E4%B9%89.webp)

具体细节也可以[参考规范](https://262.ecma-international.org/6.0/#sec-addition-operator-plus-runtime-semantics-evaluation)，标准定义的内容翻译如下：

1. 把第一个表达式（AdditiveExpression）的值赋值给左引用（lref）。
2. 使用 GetValue（lref）获取左引用（lref）的计算结果，并赋值给左值。
3. 使用 ReturnIfAbrupt（lval）如果报错就返回错误。
4. 把第二个表达式（MultiplicativeExpression）的值赋值给右引用（rref）。
5. 使用 GetValue（rref）获取右引用（rref）的计算结果，并赋值给 rval。
6. 使用 ReturnIfAbrupt（rval）如果报错就返回错误。
7. 使用 ToPrimitive（lval）获取左值（lval）的计算结果，并将其赋值给左原生值（lprim）。
8. 使用 ToPrimitive（rval）获取右值（rval）的计算结果，并将其赋值给右原生值（rprim）。
9. 如果 Type（lprim）和 Type（rprim）中有一个是 String，则：
   a. 把 ToString（lprim）的结果赋给左字符串（lstr）；
   b. 把 ToString（rprim）的结果赋给右字符串（rstr）；
   c. 返回左字符串（lstr）和右字符串（rstr）拼接的字符串。
10. 把 ToNumber（lprim）的结果赋给左数字（lnum）。
11. 把 ToNumber（rprim）的结果赋给右数字（rnum）。
12. 返回左数字（lnum）和右数字（rnum）相加的数值。

通俗地理解，V8 会提供了一个 ToPrimitive 方法，其作用是将 a 和 b 转换为原生数据类型，其转换流程如下：

1. 先检测该对象中是否存在 valueOf 方法，如果有并返回了原始类型，那么就使用该值进行强制类型转换。
2. 如果 valueOf 没有返回原始类型，那么就使用 toString 方法的返回值。
3. 如果 valueOf 和 toString 两个方法都不返回基本类型值，便会触发一个 TypeError 的错误。

将对象转换为原生类型的流程图如下所示：

![将对象转换为原生类型](./image/%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B.webp)

当 V8 执行 `1 + "2"` 时，因为这是两个原始值相加，原始值相加的时候，如果其中一项是字符串，那么 V8 会默认将另外一个值也转换为字符串，相当于执行了下面的操作：

```js
Number(1).toString() + '2';
```

这里，把数字 1 偷偷转换为字符串 “1” 的过程也称为强制类型转换，因为这种转换是隐式的，所以如果不熟悉语义，那么就很容易判断错误。

## 三. V8 编译流水线

### 3.1 运行 JS 代码的基石：运行时环境

其实在执行 JS 代码之前，V8 就已经准备好了代码的运行时环境，这个环境包括了堆空间和栈空间、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，还有消息循环系统。准备好运行时环境之后，V8 才可以执行 JS 代码，这包括解析源码、生成字节码、解释执行或者编译执行这一系列操作。

![运行时环境](./image/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83.webp)

**宿主环境**
可以把 V8 和浏览器的渲染进程的关系看成病毒和细胞的关系，浏览器为 V8 提供基础的消息循环系统、全局变量、Web API，而 V8 的核心是实现了 ECMAScript 标准，这相当于病毒自己的 DNA 或者 RNA，V8 只提供了 ECMAScript 定义的一些对象和一些核心的函数，这包括了 Object、Function、String。除此之外，V8 还提供了垃圾回收器、协程等基础内容，不过这些功能依然需要宿主环境的配合才能完整执行。

如果 V8 使用不当，比如不规范的代码触发了频繁的垃圾回收，或者某个函数执行时间过久，这些都会占用宿主环境的主线程，从而影响到程序的执行效率，甚至导致宿主环境的卡死。

除了浏览器可以作为 V8 的宿主环境，Node.js 也是 V8 的另外一种宿主环境，它提供了不同的宿主对象和宿主的 API，但是整个流程依然是相同的，比如 Node.js 也会提供一套消息循环系统，也会提供一个运行时的主线程。

![宿主环境和V8的关系](./image/%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83%E5%92%8CV8%E7%9A%84%E5%85%B3%E7%B3%BB.webp)

#### 3.1.1 构造数据存储空间：堆空间和栈空间

由于 V8 是寄生在浏览器或者 Node.js 这些宿主中的，因此，V8 也是被这些宿主启动的。比如，在 Chrome 中，只要打开一个渲染进程，渲染进程便会初始化 V8，同时初始化堆空间和栈空间。

**栈空间主要是用来管理 JS 函数调用的**，栈是内存中连续的一块空间，同时栈结构是 “先进后出” 的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。

栈空间的最大的特点是**空间连续**，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8 对栈空间的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误。可以在控制台执行下面这样一段代码：

```js
function factorial(n) {
  if (n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
console.log(factorial(50000));
```

执行这段代码，便会报出这样的错误：

```js
VM68:1 Uncaught RangeError: Maximum call stack size exceeded
```

这段提示是说，调用栈超出了最大范围，因为这里求阶乘的函数需要嵌套调用 5 万层，而栈提供不了这么大的空间，所以就抛出了栈溢出的错误。

如果有一些占用内存比较大的数据，或者不需要存储在连续空间中的数据，使用栈空间就显得不是太合适了，所以 V8 又使用了堆空间。

**堆空间是一种树形的存储结构，用来存储对象类型的离散的数据**，JS 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览器中还有 window 对象、document 对象等，这些都是存在堆空间的。宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中。

#### 3.1.2 全局执行上下文和全局作用域

V8 初始化了基础的存储空间之后，接下来就需要**初始化全局执行上下文和全局作用域**了，这两个内容是 V8 执行后续流程的基础。

当 V8 开始执行一段可执行代码时，会生成一个执行上下文。V8 用执行上下文来维护执行当前代码所需要的变量声明、this 指向等。执行上下文中主要包含三部分：

- 变量环境
- 词法环境
- this 关键字

比如在浏览器的环境中，全局执行上下文中就包括了 window 对象，还有默认指向 window 的 this 关键字，另外还有一些 Web API 函数，诸如 setTimeout、XMLHttpRequest 等内容。而词法环境中，则包含了使用 let、const 等变量的内容。执行上下文所包含的具体内容，可以参考下图：

![执行上下文](./image/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.webp)

全局执行上下文在 V8 的生存周期内是不会被销毁的，它会一直保存在堆中，这样当下次在需要使用函数或者全局变量时，就不需要重新创建了。另外，当执行了一段全局代码时，如果全局代码中有声明的函数或者定义的变量，那么函数对象和声明的变量都会被添加到全局执行上下文中。

在 ES6 中，同一个全局执行上下文中，能存在多个作用域：

```js
var x = 5;
{
  let y = 2;
  const z = 3;
}
```

这段代码在执行时，就会有两个对应的作用域，一个是全局作用域，另外一个是括号内部的作用域，但是这些内容都会保存到全局执行上下文中。具体可以参考下图：

![全局作用域和子作用域关系](./image/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%AD%90%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%85%B3%E7%B3%BB.webp)

当 V8 调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函数执行上下文就形成了一个栈结构。比如执行下面这段代码：

```js
var x = 1;
function show_x() {
  console.log(x);
}
function bar() {
  show_x();
}
bar();
```

当执行到 show_x 的时候，其栈状态如下图所示：

![函数调用栈](./image/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.webp)

#### 3.1.3 构造事件循环系统

有了堆空间和栈空间，生成了全局执行上下文和全局作用域之后，V8 还需要有一个主线程，用来执行 JS 和执行垃圾回收等工作。V8 是寄生在宿主环境中的，它并没有自己的主线程，而是使用宿主所提供的主线程，V8 所执行的代码都是在宿主的主线程上执行的。

只有一个主线程依然不行，因为如果开启一个线程，在该线程执行一段代码，那么当该线程执行完这段代码之后，就会自动退出了，执行过程中的一些栈上的数据也随之被销毁，下次再执行另外一个段代码时，还需要重新启动一个线程，重新初始化栈数据，这会严重影响到程序执行时的性能。

为了在执行完代码之后，让线程继续运行，线程实际上是事件驱动的，也就是说，如果没有任务，那么该线程将被挂起，一旦有新的任务到达了消息队列，那么系统会将这个挂起的线程激活，激活之后线程继续向下执行。

> **注意**：因为所有的任务都是运行在主线程的，在浏览器的页面中，V8 会和页面共用主线程，共用消息队列，所以如果 V8 执行一个函数过久，会影响到浏览器页面的交互性能。

### 3.2 机器码

准备好了运行时环境，V8 就可以执行 JS 代码了。在执行代码时，V8 需要先将 JS 编译成字节码，然后再解释执行字节码，或者将需要优化的字节码编译成二进制，并直接执行二进制代码。也就是说，V8 首先需要将 JS 编译成字节码或者二进制代码，然后再执行。

因为字节码的执行模式和 CPU 直接执行二进制代码的模式是类似的，所以先了解 CPU 执行二进制代码的过程，有利于分析字节码的执行流程。

#### 3.2.1 将源码编译成机器码

以一段 C 代码为例，来看一下代码被编译成二进制可执行程序之后，是如何被 CPU 执行的：

```c
int main()
{
  int x = 1;
  int y = 2;
  int z = x + y;
  return z;
}
```

CPU 并不能直接执行这段 C 代码，而是需要对其进行编译，将其转换为二进制的机器码，然后 CPU 才能按照顺序执行编译后的机器码。先通过 GCC 编译器将这段 C 代码编译成二进制文件，可以输入以下命令让其编译成目的文件：

```sh
gcc -O0 -o code_prog code.c
```

输入上面的命令之后回车，就可以在文件夹中生成名为 code_prog 的可执行程序，接下来再将编译出来的 code_prog 程序进行反汇编，这样就可以看到二进制代码和对应的汇编代码。可以使用 objdump 完成该任务，命令如下所示：

```js
objdump -d code_prog
```

最后编译出来的机器码如下图所示：

![反汇编的机器码](./image/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81.webp)

观察上图，左边就是编译生成的机器码，在这里它是使用十六进制来展示的，这主要是因为十六进制比较容易阅读，所以通常使用十六进制来展示二进制代码。可以观察到上图是由很多行组成的，每一行其实都是一个指令，该指令可以让 CPU 执行指定的任务。

中间的部分是汇编代码，汇编代码采用**助记符**（memonic）来编写程序，例如原本是二进制表示的指令，在汇编代码中可以使用单词来表示，比如 mov、add 就分别表示数据的存储和相加。汇编语言和机器语言是一一对应的，这一点和高级语言有很大的不同。

**通常将汇编语言编写的程序转换为机器语言的过程称为 “汇编”**；反之，**机器语言转化为汇编语言的过程称为 “反汇编”**，比如上图就是对 code_prog 进程进行了反汇编操作。

这一大堆指令按照顺序集合在一起就组成了程序，所以程序的执行，本质上就是 CPU 按照顺序执行这一大堆指令的过程。

#### 3.2.2 CPU 执行程序

![计算机系统的硬件组织结构](./image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.webp)

这张图是比较通用的系统硬件组织模型图，从图中可以看出，它主要是由 CPU、主存储器、各种 IO 总线，还有一些外部设备，诸如硬盘、显示器、USB 等设备组成的。

1. 在程序执行之前，程序需要被装进内存。

   比如在 Windows 下面，可以通过鼠标点击一个可执行文件，当点击该文件的时候，系统中的程序加载器会将该文件加载到内存中。

2. 一旦二进制代码被装载进内存，CPU 便可以从内存中取出一条指令，然后分析该指令，最后执行该指令。

   **把取出指令、分析指令、执行指令这三个过程称为一个 CPU 时钟周期**。当它执行完成一条指令之后，会立即从内存中取出下一条指令，接着分析该指令，执行该指令，CPU 一直重复执行该过程，直至所有的指令执行完成。

### 3.3 堆和栈

#### 3.3.1 为何使用栈结构来管理函数调用

大部分高级语言都不约而同地采用栈这种结构来管理函数调用，这与函数的特性有关。通常函数有两个主要的特性：

- **函数可以被调用**

  可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制权将从父函数转移到子函数，子函数执行结束之后，又会将代码执行控制权返还给父函数。

- **函数具有作用域机制**

  作用域机制，是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量也称为临时变量，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁。

可以看下面这段 C 代码：

```c
int getZ()
{
  return 4;
}
int add(int x, int y)
{
  int z = getZ();
  return x + y + z;
}
int main()
{
  int x = 5;
  int y = 6;
  int ret = add(x, y);
}
```

上面这段代码其中包含了多层函数嵌套调用，执行流程是这样的：

1. 当 main 函数调用 add 函数时，需要将代码执行控制权交给 add 函数。
2. 然后 add 函数又调用了 getZ 函数，于是又将代码控制权转交给 getZ 函数。
3. 接下来 getZ 函数执行完成，需要将控制权返回给 add 函数。
4. 同样当 add 函数执行结束之后，需要将控制权返还给 main 函数
5. 然后 main 函数继续向下执行。

![函数调用示意图](./image/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.webp)

通过上述分析，可以得出，**函数调用者的生命周期总是长于被调用者（后进），并且被调用者的生命周期总是先于调用者的生命周期结束（先出）**。

因为函数是有作用域机制的，作用域机制通常表现在函数执行时，会在内存中分配函数内部的变量、上下文等数据，在函数执行完成之后，这些内部数据会被销毁掉。**所以站在函数资源分配和回收角度来看，被调用函数的资源分配总是晚于调用函数（后进），而函数资源的释放则总是先于调用函数（先出）**。

通过观察函数的生命周期和函数的资源分配情况发现，它们都符合后进先出（LIFO）的策略，而栈结构正好满足这种后进先出（LIFO）的需求，所以选择栈来管理函数调用关系是一种很自然的选择。

#### 3.3.2 栈如何管理函数调用

首先来分析最简单的场景：当执行一个函数的时候，栈怎么变化？

当一个函数被执行时，函数的参数、函数内部定义变量都会依次压入到栈中，结合实际的代码来分析下这个过程，可以参考下图：

![函数内部变量压栈状态](./image/%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E7%8A%B6%E6%80%81.webp)

上图展示的是一段简单的 C 代码的执行过程，可以看到：

1. 当执行到函数的第一段代码的时候，变量 x 第一次被赋值，且值为 5，这时 5 会被压入到栈中。
2. 然后，执行第二段代码，变量 y 第一次被赋值，且值为 6，这时 6 会被压入到栈中。
3. 接着，执行到第三段代码，注意这里变量 x 是第二次被赋值，且新的值为 100，那么这时并不是将 100 压入到栈中，而是替换之前压入栈的内容，也就是将栈中的 5 替换成 100。
4. 最后，执行第四段代码，这段代码是 int z = x + y，会先计算出来 x+y 的值，然后再将 x+y 的值赋值给 z，由于 z 是第一次被赋值，所以 z 的值也会被压入到栈中。

**函数在执行过程中，其内部的临时变量会按照执行顺序被压入到栈中**。

分析更加复杂的场景：当一个函数调用另外一个函数时，栈的变化情况是怎样的？

```c
int add(num1, num2){
  int x = num1;
  int y = num2;
  int ret = x + y;
  return ret;
}

int main()
{
  int x = 5;
  int y = 6;
  x = 100;
  int z = add(x, y);
  return z;
}
```

1. 当执行到 int z = add(x, y) 时，当前栈的状态如下所示：

   ![执行add(x+y)时的栈状态](<./image/执行add(x+y)时的栈状态.webp>)

2. 接下来，就要调用 add 函数了，理想状态下，执行 add 函数的过程是下面这样的：

   ![执行 add 函数的过程](./image/%E6%89%A7%E8%A1%8C%20add%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B.webp)

   当执行到 add 函数时，会先把参数 num1 和 num2 压栈，接着再把变量 x、y、ret 的值依次压栈，不过执行这里，会遇到一个问题，那就是当 add 函数执行完成之后，需要将执行代码的控制权转交给 main 函数，这意味着需要将栈的状态恢复到 main 函数上次执行时的状态，这个过程被称为**恢复现场**。

   恢复现场的方法很简单，只要在寄存器中保存一个永远指向当前栈顶的指针，栈顶指针的作用就是告诉应该往哪个位置添加新元素，这个指针通常存放在 esp 寄存器中。如果想往栈中添加一个元素，那么需要先根据 esp 寄存器找到当前栈顶的位置，然后在栈顶上方添加新元素，新元素添加之后，还需要将新元素的地址更新到 esp 寄存器中。

   有了栈顶指针，就很容易恢复 main 函数的执行现场了，当 add 函数执行结束时，只需要将栈顶指针向下移动就可以了，具体可以参看下图：

   ![add函数即将执行结束的状态](./image/add%E5%87%BD%E6%95%B0%E5%8D%B3%E5%B0%86%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F%E7%9A%84%E7%8A%B6%E6%80%81.webp)

   ![恢复main函数执行现场](./image/%E6%81%A2%E5%A4%8Dmain%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%8E%B0%E5%9C%BA.webp)

   观察上图，将 esp 的指针向下移动到之前 main 函数执行时的地方就可以，不过新的问题又来了，CPU 是怎么知道要移动到这个地址呢？

   CPU 的解决方法是增加了另外一个 ebp 寄存器，用来保存当前函数的起始位置，把**一个函数的起始位置也称为栈帧指针**，ebp 寄存器中保存的就是当前函数的栈帧指针，如下图所示：

   ![ebp寄存器保存了栈帧指针](./image/ebp%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%9D%E5%AD%98%E4%BA%86%E6%A0%88%E5%B8%A7%E6%8C%87%E9%92%88.webp)

   在 main 函数调用 add 函数的时候，main 函数的栈顶指针就变成了 add 函数的栈帧指针，所以需要将 main 函数的栈顶指针保存到 ebp 中，当 add 函数执行结束之后，需要销毁 add 函数的栈帧，并恢复 main 函数的栈帧，那么只需要取出 main 函数的栈顶指针写到 esp 中即可（main 函数的栈顶指针是保存在 ebp 中的），这就相当于将栈顶指针移动到 main 函数的区域。

   因为 main 函数也有它自己的栈帧指针，所以在继续执行 main 函数之前，还需恢复它的栈帧指针。如何恢复 main 函数的栈帧指针呢？

   通常的方法是在 main 函数中调用 add 函数时，CPU 会将当前 main 函数的栈帧指针保存在栈中，如下图所示：

   ![保存函数的栈帧指针](./image/%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E5%B8%A7%E6%8C%87%E9%92%88.webp)

   当函数调用结束之后，就需要恢复 main 函数的执行现场了，首先取出 ebp 中的指针，写入 esp 中，然后从栈中取出之前保留的 main 的栈帧地址，将其写入 ebp 中，到了这里 ebp 和 esp 就都恢复了，可以继续执行 main 函数了。

#### 3.3.3 堆的优势

使用栈有非常多的优势：

1. 栈的结构和非常适合函数调用过程。
2. 在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。

虽然操作速度非常快，但是栈也是有缺点的，其中最大的缺点也是它的优点所造成的，那就是栈是连续的，所以要想在内存中分配一块连续的大空间是非常难的，因此栈空间是有限的。

因为栈空间是有限的，这就导致在编写程序的时候，经常一不小心就会导致栈溢出，比如函数循环嵌套层次太多，或者在栈上分配的数据过大，都会导致栈溢出，基于栈不方便存放大的数据，因此使用了另外一种数据结构用来保存一些大数据，这就是堆。

和栈空间不同，存放在堆空间中的数据是不要求连续存放的，从堆上分配内存块没有固定模式的，可以在任何时候分配和释放它，看下面这段代码是怎么执行的：

```c++
struct Point
{
  int x;
  int y;
};

int main()
{
  int x = 5;
  int y = 6;
  int *z = new int;
  *z = 20;


  Point p;
  p.x = 100;
  p.y = 200;


  Point *pp = new Point();
  pp->y = 400;
  pp->x = 500;
  delete z;
  delete pp;
  return 0;
}
```

可以看到代码中有 new int、new Point 这种语句，当执行这些语句时，表示要在堆中分配一块数据，然后返回指针，通常返回的指针会被保存到栈中，下面来看看当 main 函数快执行结束时，堆和栈的状态：

![堆和栈的状态](./image/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E7%8A%B6%E6%80%81.webp)

当使用 new 时，会在堆中分配一块空间，在堆中分配空间之后，会返回分配后的地址，会把该地址保存在栈中，如上图中 p 和 pp 都是地址，它们保存在栈中，指向了在堆中分配的空间。通常，当堆中的数据不再需要的时候，需要对其进行销毁，在 C 语言中可以使用 free，在 C++ 语言中可以使用 delete 来进行操作。

像 C/C++ 这种手动管理内存的语言，如果没有手动销毁堆中的数据，那么就会造成内存泄漏。不过 JS，Java 使用了自动垃圾回收策略，可以实现垃圾自动回收，但是事情总有两面性，垃圾自动回收也会给带来一些性能问题。所以不管是自动垃圾回收策略，还是手动垃圾回收策略，要想写出高效的代码，都需要了解内存的底层工作机制。

### 3.4 惰性解析

V8 执行 JS 代码，需要经过编译和执行两个阶段，其中编译过程是指 V8 将 JS 代码转换为字节码或者二进制机器代码的阶段，而执行阶段则是指解释器解释执行字节码，或者是 CPU 直接执行二进制机器代码的阶段。

在编译 JS 代码的过程中，V8 并不会一次性将所有的 JS 解析为中间代码，这主要是基于以下两点：

- 如果一次解析和编译所有的 JS 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JS 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JS 代码都有 10 多兆，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间。

- 解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JS 代码，那么这些中间代码和机器代码将会一直占用内存，特别是在手机普及的年代，内存是非常宝贵的资源。

基于以上的原因，所有主流的 JS 虚拟机都实现了**惰性解析**。所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。

#### 3.4.1 惰性解析的过程

```js
function foo(a, b) {
  var d = 100;
  var f = 10;
  return d + f + a + b;
}
var a = 1;
var c = 4;
foo(1, 5);
```

当把这段代码交给 V8 处理时，V8 会至上而下解析这段代码，在解析过程中首先会遇到 foo 函数，由于这只是一个函数声明语句，V8 在这个阶段只需要将该函数转换为函数对象，如下图所示：

![惰性解析函数声明](./image/%E6%83%B0%E6%80%A7%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E.webp)

> **注意**：这里只是将该函数声明转换为函数对象，但是并没有解析和编译函数内部的代码，所以也不会为 foo 函数的内部代码生成抽象语法树。

然后继续往下解析，由于后续的代码都是顶层代码，所以 V8 会为它们生成抽象语法树，最终生成的结果如下所示：

![生成顶层代码的抽象语法树](./image/%E7%94%9F%E6%88%90%E9%A1%B6%E5%B1%82%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.webp)

代码解析完成之后，V8 便会按照顺序自上而下执行代码，首先会先执行 “a=1” 和 “c=4” 这两个赋值表达式，接下来执行 foo 函数的调用，过程是从 foo 函数对象中取出函数代码，然后和编译顶层代码一样，V8 会先编译 foo 函数的代码，编译时同样需要先将其编译为抽象语法树和字节码，然后再解释执行。

上面就是惰性解析的一个大致过程，不过在 V8 实现惰性解析的过程中，需要支持 JS 中的闭包特性，这会使得 V8 的解析过程变得异常复杂。

#### 3.4.2 闭包的三个基础特性

JS 中的闭包有三个基础特性：

1. **允许在函数内部定义新的函数**

   ```js
   function foo() {
     function inner() {}
     inner();
   }
   ```

2. **可以在内部函数中访问父函数中定义的变量**

   ```js
   var d = 20;
   // inner 函数的父函数，词法作用域
   function foo() {
     var d = 55;
     // foo 的内部函数
     function inner() {
       return d + 2;
     }
     inner();
   }
   ```

   由于可以在函数中定义新的函数，所以很自然的，内部的函数可以使用外部函数中定义的变量。

   > **注意**：上面代码中的 inner 函数是在 foo 函数内部定义的，就称 inner 函数是 foo 函数的子函数，foo 函数是 inner 函数的父函数。这里的父子关系是针对词法作用域而言的，因为词法作用域在函数声明时就决定了。

3. **因为函数是一等公民，所以函数可以作为返回值**

   ```js
   function foo() {
     return function inner(a, b) {
       const c = a + b;
       return c;
     };
   }
   const f = foo();
   ```

#### 3.4.3 闭包给惰性解析带来的问题和解决方案

**问题**
下面是使用闭包的三个特性组装的一段经典的闭包代码：

```js
function foo() {
  let d = 20;
  return function inner(a, b) {
    const c = a + b + d;
    return c;
  };
}
const f = foo();
```

上面这段代码的执行过程是：

1. 当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f。
2. 然后 foo 函数执行结束，执行上下文被 V8 销毁。
3. 虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d。

按照通用的做法，d 已经被 v8 销毁了，但是由于存活的函数 inner 依然引用了 foo 函数中的变量 d，这样就会带来两个问题：

- 当 foo 执行结束时，变量 d 该不该被销毁？如果不应该被销毁，那么应该采用什么策略？
- 如果采用了惰性解析，那么当执行到 foo 函数时，V8 只会解析 foo 函数，并不会解析内部的 inner 函数，那么这时候 V8 就不知道 inner 函数中是否引用了 foo 函数的变量 d。

下面就来看一下上面这段代码执行 foo 函数的时候堆栈的变化：

![闭包的堆栈变化](./image/%E9%97%AD%E5%8C%85%E7%9A%84%E5%A0%86%E6%A0%88%E5%8F%98%E5%8C%96.webp)

从上图可以看出来，在执行全局代码时，V8 会将全局执行上下文压入到调用栈中，然后进入执行 foo 函数的调用过程，这时候 V8 会为 foo 函数创建执行上下文，执行上下文中包括了变量 d，然后将 foo 函数的执行上下文压入栈中，foo 函数执行结束之后，foo 函数执行上下文从栈中弹出，这时候 foo 执行上下文中的变量 d 也随之被销毁。

但是这时候，由于 inner 函数被保存到全局变量中了，所以 inner 函数依然存在，最关键的地方在于 inner 函数使用了 foo 函数中的变量 d，按照正常执行流程，变量 d 在 foo 函数执行结束之后就被销毁了。

所以正常的处理方式应该是 foo 函数的执行上下文虽然被销毁了，但是 inner 函数引用的 foo 函数中的变量却不能被销毁，那么 V8 就需要为这种情况做特殊处理，需要保证即便 foo 函数执行结束，但是 foo 函数中的 d 变量依然保持在内存中，不能随着 foo 函数的执行上下文被销毁掉。

于是 V8 在执行 foo 函数的阶段，虽然采取了惰性解析，不会解析和执行 foo 函数中的 inner 函数，但是 V8 判断了 inner 函数是否引用了 foo 函数中的变量，负责处理这个任务的模块叫做**预解析器**。

**解决方案**
V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个：

1. **判断当前函数是不是存在一些语法上的错误**

   ```js
   function foo(a, b) {
     {/} //语法错误
   }
   var a = 1
   var c = 4
   foo(1, 5)
   ```

   在预解析过程中，预解析器发现了语法错误，那么就会向 V8 抛出语法错误，比如上面这段代码的语法错误是这样的：

   ```js
   Uncaught SyntaxError: Invalid regular expression: missing /
   ```

2. 检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。

### 3.5 字节码

V8 在执行一段 JS 代码之前，需要将其编译为字节码，然后再解释执行字节码或者将字节码编译为二进制代码然后再执行。

所谓字节码，是指编译过程中的中间代码，可以把字节码看成是机器代码的抽象，在 V8 中，字节码有两个作用：

- 解释器可以直接解释执行字节码。
- 优化编译器可以将字节码编译为二进制代码，然后再执行二进制机器代码。

#### 3.5.1 机器码的问题

虽然目前的架构使用了字节码，不过早期的 V8 并不是这样设计的，那时候 V8 团队认为这种 “先生成字节码再执行字节码” 的方式，多了个中间环节，多出来的中间环节会牺牲代码的执行速度。于是在早期，V8 团队采取了非常激进的策略，直接将 JS 代码编译成机器代码。

当 JS 代码在浏览器中被执行的时候，需要先被 V8 编译，早期的 V8 会将 JS 编译成未经优化的二进制机器代码，然后再执行这些未优化的二进制代码，通常情况下，编译占用了很大一部分时间。

![早期V8执行一段JS代码花费的时间](./image/%E6%97%A9%E6%9C%9FV8%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5JS%E4%BB%A3%E7%A0%81%E8%8A%B1%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4.webp)

从图中可以看出，编译所消耗的时间和执行所消耗的时间是差不多的，如果在浏览器中再次打开相同的页面，当页面中的 JS 文件没有被修改，那么再次编译之后的二进制代码也会保持不变，这意味着编译这一步白白浪费了 CPU 资源，因为之前已经编译过一次了。

这就是 Chrome 浏览器引入二进制代码缓存的原因，通过把二进制代码保存在内存中来消除冗余的编译，重用它们完成后续的调用，这样就省去了再次编译的时间。

V8 使用两种代码缓存策略来缓存生成的代码：

- V8 第一次执行一段代码时，会编译源 JS 代码，并将编译后的二进制代码缓存在内存中，把这种方式称为**内存缓存**（in-memory cache）。然后通过 JS 源文件的字符串在内存中查找对应的编译后的二进制代码。这样当再次执行到这段代码时，V8 就可以直接去内存中查找是否编译过这段代码。如果内存缓存中存在这段代码所对应的二进制代码，那么就直接执行编译好的二进制代码。

- V8 除了采用将代码缓存在内存中策略之外，还会将代码缓存到硬盘上，这样即便关闭了浏览器，下次重新打开浏览器再次执行相同代码时，也可以直接重复使用编译好的二进制代码。

实践表明，在浏览器中采用了二进制代码缓存的方式，初始加载时分析和编译的时间缩短了 20%～ 40%。

不过随着移动设备的普及，V8 团队逐渐发现将 JS 源码直接编译成二进制代码存在两个致命的问题：

- 时间问题：编译时间过久，影响代码启动速度。
- 空间问题：缓存编译后的二进制代码占用更多的内存。

#### 3.5.2 字节码的优势

于是 V8 团队大规模重构代码，引入了中间的字节码。字节码的优势有如下三点：

- **解决启动问题**：生成字节码的时间很短。

  ![字节码编译时间](./image/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4.webp)

  从图中可以看出，生成机器代码比生成字节码需要花费更久的时间，但是直接执行机器代码却比解释执行字节码要更高效，所以在快速启动 JS 代码与花费更多时间获得最优运行性能的代码之间，需要找到一个平衡点。

  解释器可以快速生成字节码，但字节码通常效率不高。相比之下，优化编译器虽然需要更长的时间进行处理，但最终会产生更高效的机器码，这正是 V8 在使用的模型。它的解释器叫 Ignition，（就原始字节码执行速度而言）是所有引擎中最快的解释器。V8 的优化编译器名为 TurboFan，最终由它生成高度优化的机器码。

- **解决空间问题**：字节码占用内存不多，缓存字节码会大大降低内存的使用。

  在早期，Chrome 做了两件事来提升 JS 代码的执行速度：

  - 运行时将二进制机器代码缓存在内存中。
  - 当浏览器退出时，缓存编译之后二进制代码到磁盘上。

  很明显，采用缓存是一种典型的以空间换时间的策略，以牺牲存储空间来换取执行速度，Chrome 的多进程架构已经非常吃内存了，而 Chrome 中每个页面进程都运行了一份 V8 实例，V8 在执行 JS 代码的过程中，会将 JS 代码转换为未经优化的二进制代码，可以对照下图中的 JS 代码和二进制代码的：

  ![JS代码与字节码和二进制代码大小对比](./image/JS%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%AF%B9%E6%AF%94.webp)

  可以看到，二进制代码所占用的内存空间是 JS 代码的几千倍，在移动设备流行起来之后，V8 过度占用内存的问题就充分暴露出来了。因为通常一部手机的内存不会太大，如果过度占用内存，那么会导致 Web 应用的速度大大降低。

  也可以看到，字节码虽然占用的空间比原始的 JS 多，但是相较于机器代码，字节码还是小了太多。有了字节码，无论是解释器的解释执行，还是优化编译器的编译执行，都可以直接针对字节来进行操作。由于字节码占用的空间远小于二进制代码，所以浏览器就可以实现缓存所有的字节码，而不是仅仅缓存顶层的字节码。

- **代码架构清晰**：采用字节码，可以简化程序的复杂度，使得 V8 移植到不同的 CPU 架构平台更加容易。

  早期的 V8 代码，无论是基线编译器还是优化编译器，它们都是基于 AST 抽象语法树来将代码转换为机器码的，不同架构的机器码是不一样的，而市面上存在不同架构的处理器又是非常之多。

  这意味着基线编译器和优化编译器要针对不同的体系的 CPU 编写不同的代码，这会大大增加代码量。引入了字节码，就可以统一将字节码转换为不同平台的二进制代码：

  ![将源码转换为二进制代码](./image/%E5%B0%86%E6%BA%90%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81.webp)

  因为字节码的执行过程和 CPU 执行二进制代码的过程类似，相似的执行流程，那么将字节码转换为不同架构的二进制代码的工作量也会大大降低，这就降低了转换底层代码的工作量。

#### 3.5.3 生成字节码

当 V8 执行一段 JS 代码时，会先对 JS 代码进行解析（Parser），并生成为 AST 和作用域信息，之后 AST 和作用域信息被输入到一个称为 Ignition 的解释器中，并将其转化为字节码，之后字节码再由 Ignition 解释器来解释执行。

```js
function add(x, y) {
  var z = x + y;
  return z;
}
console.log(add(1, 2));
```

V8 首先会将函数的源码解析为 AST，这一步由解析器（Parser）完成，可以在 d8 中通过 `–print-ast` 命令来查看 V8 内部生成的 AST。

```sh
[generating bytecode for function: add]
--- AST ---
FUNC at 12
. KIND 0
. LITERAL ID 1
. SUSPEND COUNT 0
. NAME "add"
. PARAMS
. . VAR (0x7fa7bf8048e8) (mode = VAR, assigned = false) "x"
. . VAR (0x7fa7bf804990) (mode = VAR, assigned = false) "y"
. DECLS
. . VARIABLE (0x7fa7bf8048e8) (mode = VAR, assigned = false) "x"
. . VARIABLE (0x7fa7bf804990) (mode = VAR, assigned = false) "y"
. . VARIABLE (0x7fa7bf804a38) (mode = VAR, assigned = false) "z"
. BLOCK NOCOMPLETIONS at -1
. . EXPRESSION STATEMENT at 31
. . . INIT at 31
. . . . VAR PROXY local[0] (0x7fa7bf804a38) (mode = VAR, assigned = false) "z"
. . . . ADD at 32
. . . . . VAR PROXY parameter[0] (0x7fa7bf8048e8) (mode = VAR, assigned = false) "x"
. . . . . VAR PROXY parameter[1] (0x7fa7bf804990) (mode = VAR, assigned = false) "y"
. RETURN at 37
. . VAR PROXY local[0] (0x7fa7bf804a38) (mode = VAR, assigned = false) "z"
```

可以将其图形化：

![V8生成的AST图形化](./image/V8%E7%94%9F%E6%88%90%E7%9A%84AST%E5%9B%BE%E5%BD%A2%E5%8C%96.webp)

从图中可以看出，函数的字面量被解析为 AST 树的形态，这个函数主要拆分成四部分：

- **参数的声明**（PARAMS）：参数声明中包括了所有的参数，在这里主要是参数 x 和参数 y，可以在函数体中使用 arguments 来使用对应的参数。

- **变量声明节点**（DECLS）：参数部分可以使用 arguments 来调用，同样，也可以将这些参数作为变量来直接使用，这体现在 DECLS 节点下面也出现了变量 x 和变量 y，除了可以直接使用 x 和 y 之外，还有一个 z 变量也在 DECLS 节点下。在上面生成的 AST 数据中，参数声明节点中的 x 和变量声明节点中的 x 的地址是相同的，都是 0x7fa7bf8048e8，同样 y 也是相同的，都是 0x7fa7bf804990，这说明它们指向的是同一块数据。

- **x+y 的表达式节点**：可以看到，节点 add 下面使用了 var proxy x 和 var proxy x 的语法，它们指向了实际 x 和 y 的值。

- **RETURN 节点**：它指向了 z 的值，在这里是 `local[0]`。

V8 在生成 AST 的同时，还生成了 add 函数的作用域，可以使用 `–print-scopes` 命令来查看：

```js
Global scope:
function add (x, y) { // (0x7f9ed7849468) (12, 47)
  // will be compiled
  // 1 stack slots
  // local vars:
  VAR y;  // (0x7f9ed7849790) parameter[1], never assigned
  VAR z;  // (0x7f9ed7849838) local[0], never assigned
  VAR x;  // (0x7f9ed78496e8) parameter[0], never assigned
}
```

作用域中的变量都是未使用的，默认值都是 undefined，在执行阶段，作用域中的变量会指向堆和栈中相应的数据，作用域和实际数据的关系如下图所示：

![作用域和实际数据的关系](./image/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%AE%9E%E9%99%85%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B3%E7%B3%BB.webp)

在解析期间，所有函数体中声明的变量和函数参数，都被放进作用域中，如果是普通变量，那么默认值是 undefined，如果是函数声明，那么将指向实际的函数对象。

一旦生成了作用域和 AST，V8 就可以依据它们来生成字节码了。AST 之后会被作为输入传到字节码生成器（BytecodeGenerator），这是 Ignition 解释器中的一部分，用于生成以函数为单位的字节码。可以通过 `–print-bytecode` 命令查看生成的字节码。

```byte
[generated bytecode for function: add (0x079e0824fdc1 <SharedFunctionInfo add>)]
Parameter count 3
Register count 2
Frame size 16
         0x79e0824ff7a @    0 : a7                StackCheck
         0x79e0824ff7b @    1 : 25 02             Ldar a1
         0x79e0824ff7d @    3 : 34 03 00          Add a0, [0]
         0x79e0824ff80 @    6 : 26 fb             Star r0
         0x79e0824ff82 @    8 : 0c 02             LdaSmi [2]
         0x79e0824ff84 @   10 : 26 fa             Star r1
         0x79e0824ff86 @   12 : 25 fb             Ldar r0
         0x79e0824ff88 @   14 : ab                Return
Constant pool (size = 0)
Handler Table (size = 0)
Source Position Table (size = 0)
```

可以看到，生成的字节码第一行提示了 “Parameter count 3”，这是告诉这里有三个参数，包括了显式地传入了 x 和 y，还有一个隐式地传入了 this。将 JS 函数转换为字节码之后，只有 8 行：

```txt
StackCheck
Ldar a1
Add a0, [0]
Star r0
LdaSmi [2]
Star r1
Ldar r0
Return
```

#### 3.5.4 解释器的架构设计

字节码似乎和汇编代码有点像，这些字节码看起来似乎难以理解，但实际上它们非常简单，每一行表示一个特定的功能，把这些功能拼凑在一起就构成完整的程序。

下图是一些常用的字节码的指令集：

![V8中定义的部分字节码指令集](./image/V8%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E9%83%A8%E5%88%86%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86.webp)

也可以去 [V8 的源码](https://github.com/v8/v8/blob/master/src/interpreter/bytecodes.h)中查看这些字节码。

阅读汇编代码，需要先理解 CPU 的体系架构，然后再分析特定汇编指令的具体含义，同样，要了解怎么阅读字节码，就需要理解 V8 解释器的整体设计架构，然后再来分析特定的字节码指令的含义。

因为解释器就是模拟物理机器来执行字节码的，比如可以实现如取指令、解析指令、执行指令、存储数据等，所以解释器的执行架构和 CPU 处理机器代码的架构类似（关于 CPU 是如何执行机器代码的，你可以参看《10｜机器代码：二进制机器码究竟是如何被 CPU 执行的？》这节课）。<!-- TODO -->

通常有两种类型的解释器：

- **基于栈（Stack-based）**：基于栈的解释器使用栈来保存函数参数、中间运算结果、变量等。
- **基于寄存器（Register-based）**：基于寄存器的虚拟机则支持寄存器的指令操作，使用寄存器来保存参数、中间计算结果。

通常，基于栈的虚拟机也定义了少量的寄存器，基于寄存器的虚拟机也有堆栈，其区别体现在它们提供的指令集体系。

大多数解释器都是基于栈的，比如 Java 虚拟机，.Net 虚拟机，还有早期的 V8 虚拟机。基于堆栈的虚拟机在处理函数调用、解决递归问题和切换上下文时简单明快。

而现在的 V8 虚拟机则采用了基于寄存器的设计，它将一些中间数据保存到寄存器中，了解这点对于分析字节码的执行过程非常重要。

基于寄存器的解释器架构，具体可以参考下图：

![基于寄存器的解释器架构](./image/%E5%9F%BA%E4%BA%8E%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9E%B6%E6%9E%84.webp)

解释器执行时主要有四个模块，内存中的字节码、寄存器、栈、堆。这和 CPU 执行二进制机器代码的模式是类似的。但是需要重点注意这里的累加器，它是一个非常特殊的寄存器，用来保存中间的结果，这体现在很多 V8 字节码的语义上面，比如下面这个字节码的指令：

```sh
Ldar a1
```

Ldar 表示将寄存器中的值加载到累加器中，可以把它理解为 LoaD Accumulator from Register，就是把某个寄存器中的值，加载到累加器中。那么上面这个指令的意思就是把 a1 寄存器中的值，加载到累加器中，可以参看下图：

![Ldar a1](./image/Ldar%20a1.webp)

再来看另外一个段字节码指令：

```sh
Star r0
```

Star 表示 Store Accumulator Register， 可以把它理解为 Store Accumulator to Register，就是把累加器中的值保存到某个寄存器中，上面这段代码的意思就是将累加器中的数值保存到 r0 寄存器中，具体流程可以参看下图：

![Star r0](./image/Star%20r0.webp)

再来看一个执行加法的字节码：

```sh
Add a0, [0]
```

`Add a0, [0]` 是从 a0 寄存器加载值并将其与累加器中的值相加，然后将结果再次放入累加器，最终操作如下图所示：

![Add a0, [0]](./image/Add%20a0,%20[0].webp)

add a0 后面还跟了一个[0]，这个符号是被称之为 feedback vector slot，可以称为**反馈向量槽**，它是一个数组，解释器将解释执行过程中的一些数据类型的分析信息都保存在这个反馈向量槽中了，目的是为了给 TurboFan 优化编译器提供优化信息，很多字节码都会为反馈向量槽提供运行时信息。

在上面的字节码中，还有一个：

```sh
LdaSmi [2]
```

这是将小整数（Smi）2 加载到累加器寄存器中，操作流程可以参看下图：

![LdaSmi [2]](./image/LdaSmi%20[2].webp)

最后一个字节码是：

```sh
Return
```

Return 结束当前函数的执行，并将控制权传回给调用方。返回的值是累加器中的值。

**完整分析一段字节码**：

```sh
StackCheck
Ldar a1
Add a0, [0]
Star r0
LdaSmi [2]
Star r1
Ldar r0
Return
```

执行这段代码时，整体的状态如下图所示：

![执行字节码时的状态](./image/%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81.webp)

1. StackCheck

    - 参数对象 parameter 保存在栈中，包含了 a0 和 a1 两个值，在上面的代码中，这两个值分别是 1 和 2。

    - PC 寄存器指向了第一个字节码 StackCheck，V8 在执行一个函数之前，会判断栈是否会溢出，这里的 StackCheck 字节码指令就是检查栈是否达到了溢出的上限，如果栈增长超过某个阈值，将中止该函数的执行并抛出一个 RangeError，表示栈已溢出。

2. 然后继续执行下一条字节码，Ldar a1，这是将 a1 寄存器中的参数值加载到累加器中，这时候第一个参数就保存到累加器中了。

3. 接下来执行加法操作，Add a0, [0]，因为 a0 是第一个寄存器，存放了第一个参数，Add a0 就是将第一个寄存器中的值和累加器中的值相加，也就是将累加器中的 2 和通用寄存器中 a0 中的 1 进行相加，同时将相加后的结果 3 保存到累加器中。

4. 然后执行第四段字节码，Star r0，这是将累加器中的值，也就是 1+2 的结果 3 保存到寄存器 r0 中，那么现在寄存器 r0 中的值就是 3 了。

5. 然后将常数 2 加载到累加器中，又将累加器中的 2 加载到寄存器 r1 中，发现这里两段代码可能没实际的用途，不过 V8 生成的字节码就是这样。

6. 接下来 V8 将寄存器 r0 中的值加载到累加器中。

7. 然后执行最后一句 Return 指令，Return 指令会中断当前函数的执行，并将累加器中的值作为返回值。

### 3.6 在内存中快速查找对象属性

JS 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JS 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。

**静态语言的效率更高**
通过下面两段代码，来对比一下动态语言和静态语言在运行时的一些特征，一段是动态语言的 JS，另外一段静态语言的 C++ 的源码：

![动态语言和静态语言在运行时的一些特征](./image/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E5%BE%81.webp)

JS 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 start.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也可以说 V8 并不知道该对象的具体的形状。那么，当在 JS 中要查询对象 start 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时（具体查找过程你可以参考《03｜快属性和慢属性：V8 是怎样提升对象属性访问速度的？》这节课程中的内容）。<!-- TODO -->

这种动态查询对象属性的方式和 C++ 这种静态语言不同，C++ 在声明一个对象之前需要定义该对象的结构，也可以称为形状，比如 Point 结构体就是一种形状，可以使用这个形状来定义具体的对象。C++ 代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中，Point 的形状是无法被改变的。

那么在 C++ 中访问一个对象的属性时，自然就知道该属性相对于该对象地址的偏移值了，比如在 C++ 中使用 start.x 的时候，编译器会直接将 x 相对于 start 的地址写进汇编指令中，那么当使用了对象 start 中的 x 属性时，CPU 就可以直接去内存地址中取出该内容即可，没有任何中间的查找环节。

因此静态语言中，可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。

#### 3.6.1 隐藏类

V8 将静态的特性引入的思路是将 JS 中的对象静态化，也就是 V8 在运行 JS 的过程中，会假设 JS 中的对象是静态的，具体地讲，V8 对每个对象做如下两点假设：

- 对象创建好了之后就不会添加新的属性。
- 对象创建好了之后也不会删除属性。

符合这两个假设之后，V8 就可以对 JS 中的对象做深度优化了。具体地讲，V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：

- 对象中所包含的所有的属性。
- 每个属性相对于对象的偏移量。

有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对于的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。
