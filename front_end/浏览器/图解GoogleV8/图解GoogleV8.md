# 图解 GoogleV8

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [图解 GoogleV8](#图解-googlev8)
  - [一. 宏观视角](#一-宏观视角)
    - [1.1 什么是 V8](#11-什么是-v8)
    - [1.2 高级代码需要先编译再执行](#12-高级代码需要先编译再执行)
    - [1.3 V8 执行 JS 代码](#13-v8-执行-js-代码)
  - [二. JS 设计思想](#二-js-设计思想)
    - [2.1 函数即对象](#21-函数即对象)
      - [2.1.1 JS 中的对象](#211-js-中的对象)
      - [2.1.2 函数的本质](#212-函数的本质)
      - [2.1.3 函数是一等公民](#213-函数是一等公民)
    - [2.2 V8 如何提升对象属性访问速度](#22-v8-如何提升对象属性访问速度)
      - [2.2.1 常规属性（properties）和排序属性（elements）](#221-常规属性properties和排序属性elements)
      - [2.2.2 快属性和慢属性](#222-快属性和慢属性)
      - [2.2.3 在 Chrome 中查看对象布局](#223-在-chrome-中查看对象布局)
    - [2.3 函数表达式](#23-函数表达式)
      - [2.3.1 函数声明与函数表达式的差异](#231-函数声明与函数表达式的差异)
      - [2.3.2 V8 处理函数声明](#232-v8-处理函数声明)
      - [2.3.3 V8 处理函数表达式](#233-v8-处理函数表达式)
    - [2.4 原型链](#24-原型链)
      - [2.4.1 原型继承的实现](#241-原型继承的实现)

<!-- /code_chunk_output -->

## 一. 宏观视角

V8 是 JS 虚拟机的一种。可以简单地把 JS 虚拟机理解成是一个翻译程序，将人类能够理解的编程语言 JS，翻译成机器能够理解的机器语言。如下图所示：

![V8JS引擎](./image/V8JS引擎.webp)

上图中，中间的 “黑盒” 就是 JS 引擎 V8。目前市面上有很多种 JS 引擎，诸如 SpiderMonkey、V8、JavaScriptCore 等。而由谷歌开发的开源项目 V8 是当下使用最广泛的 JS 虚拟机。

V8 之所以拥有如此庞大的生态圈，也和它许多革命性的设计是分不开的。在 V8 出现之前，所有的 JS 虚拟机所采用的都是解释执行的方式，这是 JS 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JS 的执行速度带来了极大的提升。

V8 出现之后，各大厂商也都在自己的 JS 虚拟机中引入了 JIT 机制，所以可以看到目前市面上 JS 虚拟机都有着类似的架构。另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JS 代码的编译执行效率。

**V8 的主要职责是用来执行 JS 代码**的，那首先需要先了解 JS 这门语言的基本特性和设计思想。JS 借鉴了很多语言的特性，比如 C 语言的基本语法、Java 的类型系统和内存管理、Scheme 的函数作为一等公民，还有 Self 基于原型（prototype）的继承机制。毫无疑问，JS 是一门非常优秀的语言，特别是 “原型继承机制” 和 “函数是一等公民” 这两个设计。

![JS的设计思想](./image/JS的设计思想.webp)

不过 JS 也是一门处处是坑的语言，由于历史原因，很多错误的或者不合理的设计都被延续至今，比如使用 new 加构造函数来创建对象，这种方式的背后隐藏了太多的细节，非常容易增加代码出错概率，而且也大大增加了新手的学习成本；再比如初期的 JS 没有块级作用域机制，使得 JS 需要采取变量提升的策略，而变量提升又是非常反人性的设计。

V8 是 JS 的实现，在学习 V8 工作原理时，就要格外关注 JS 这些独特的设计思想和特性背后的实现。比如，为了实现函数是一等公民的特性，JS 采取了基于对象的策略；再比如为了实现原型继承，V8 为每个对象引入了 [`__proto__`](/front_end/JavaScript/JavaScript权威指南/JavaScript权威指南.md#143-prototype-特性) 属性。

V8 执行 JS 代码的完整流程被称之为 V8 的编译流水线，其完整流程如下图所示：

![V8编译流水线](./image/V8编译流水线.webp)

编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内联缓存等等。这些技术决定着一段 JS 代码能否正常执行，以及代码的执行效率。比如 V8 中使用的隐藏类（Hide Class），这是将 JS 中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行速度过慢的问题，如果熟悉 V8 的工作机制，在编写 JS 时，就能充分利用好隐藏类这种强大的优化特性，写出更加高效的代码。

再比如，V8 实现了 JS 代码的惰性解析，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，可以优化代码更加适应这个机制，从而提高程序性能。要想充分了解 V8 是怎么工作的，除了要分析编译流水线，还需要了解另外两个非常重要的特性：

- **事件循环系统**
  事件循环系统和 JS 中的难点与异步编程特性紧密相关。JS 是单线程的，代码都是在一个线程上执行，如果同一时间发送了多个 JS 执行的请求，就需要排队，也就是进行异步编程。V8 的事件循环系统会调度这些排队任务，保证 JS 代码被 V8 有序地执行。因此也可以说，事件循环系统就是 V8 的心脏，它驱动了 V8 的持续工作。

- **垃圾回收机制**
  JS 是一种自动垃圾回收的语言，V8 在执行垃圾回收时，会占用主线程的资源，如果编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，这也是经常会遇到的一个问题。需要知道 V8 是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完整的系统，当下次遇到内存问题时，就知道如何去排查了。

![V8知识图谱](./image/V8知识图谱.jpg)

### 1.1 什么是 V8

V8 是一个由 Google 开发的开源 JS 引擎，目前用在 Chrome 浏览器和 Node.js 中，其核心功能是执行易于人类理解的 JS 代码。

其主要核心流程分为编译和执行两步。首先需要将 JS 代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果。

![转换为中间代码](./image/%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81.webp)

可以把 V8 看成是一个虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的 CPU、堆栈、寄存器等，虚拟机还具有它自己的一套指令系统。

所以对于 JS 代码来说，V8 就是它的整个世界，当 V8 执行 JS 代码时，并不需要担心现实中不同操作系统的差异，也不需要担心不同体系结构计算机的差异，只需要按照虚拟机的规范写好代码就可以了。

### 1.2 高级代码需要先编译再执行

可以把 CPU 看成是一个非常小的运算机器，可以通过二进制的指令和 CPU 进行沟通，比如给 CPU 发出 “1000100111011000” 的二进制指令，这条指令的意思是将一个寄存器中的数据移动到另外一个寄存器中，当处理器执行到这条指令的时候，便会按照指令的意思去实现相关的操作。

为了能够完成复杂的任务，工程师们为 CPU 提供了一大堆指令，来实现各种功能，这一大堆指令被称为**指令集**（Instructions），也就是机器语言。

> **注意**：CPU 只能识别二进制的指令，但是对程序员来说，二进制代码难以阅读和记忆，于是又将二进制指令集转换为人类可以识别和记忆的符号，这就是汇编指令集。

CPU 不能直接识别汇编语言，所以还需要一个汇编编译器，其作用是将汇编代码编程成机器代码：

![汇编编译器](./image/%E6%B1%87%E7%BC%96%E7%BC%96%E8%AF%91%E5%99%A8.webp)

虽然汇编语言对机器语言做了一层抽象，减少了程序员理解机器语言的复杂度，但是汇编语言依然是复杂且繁琐的，即便写一个非常简单的功能，也需要实现大量的汇编代码，这主要表现在以下两点。

1. **不同的 CPU 有着不同的指令集**，如果要使用机器语言或者汇编语言来实现一个功能，那么需要为每种架构的 CPU 编写特定的汇编代码，这会带来巨大的、枯燥繁琐的操作。

2. 在编写汇编代码时，还需要**了解和处理器架构相关的硬件知识**，比如寄存器、内存、操作 CPU 等。

因此需要一种屏蔽了计算机架构细节的语言，能适应多种不同 CPU 架构的语言，能专心处理业务逻辑的语言，诸如 C、C++、Java、C#、Python、JS 等，这些 “高级语言” 就应运而生了。

和汇编语言一样，处理器也不能直接识别由高级语言所编写的代码，通常，有两种方式来执行这些代码：

1. **解释执行**

   需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。具体流程如下图所示：

   ![解释执行流程图](./image/%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.webp)

2. **编译执行**

   采用这种方式时，也需要先将源代码转换为中间代码，然后编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

   ![编译执行流程图](./image/%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.webp)

但是针对不同的高级语言，实现方式还是有很大差异的，比如要执行 C 语言编写的代码，需要将其编译为二进制代码的文件，然后再直接执行二进制代码。而对于像 Java 语言、JS 语言等，则需要不同虚拟机，模拟计算机的这个编译执行流程。执行 Java 语言，需要经过 Java 虚拟机的转换，执行 JS 需要经过 JS 虚拟机的转换。

即便是 JS 一门语言，也有好几种流行的虚拟机，它们之间的实现方式也存在着一部分差异，比如苹果公司在 Safari 中就是用 JSCore 虚拟机，Firefox 使用了 TraceMonkey 虚拟机，而 Chrome 则使用了 V8 虚拟机。

### 1.3 V8 执行 JS 代码

V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，把这种混合使用编译器和解释器的技术称为 **JIT**（Just In Time）技术。

这是一种权衡策略，因为这两种方法都各自有各自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。可以参考下面完整的 V8 执行 JS 的流程图：

![8执行一段JS流程图](./image/8%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5JS%E6%B5%81%E7%A8%8B%E5%9B%BE.webp)

上图中的最左边的部分，在 V8 启动执行 JS 之前，它还需要准备执行 JS 时所需要的一些基础环境，这些基础环境包括了 “堆空间” “栈空间” “全局执行上下文” “全局作用域” “消息循环系统” “内置函数” 等，这些内容都是在执行 JS 过程中需要使用到的。

1. 首先 V8 会接收到要执行的 JS 源代码，V8 并不能直接理解源代码的含义，它需要**结构化**[^1]这段字符串。

   [^1]: 结构化，是指信息经过分析后可分解成多个互相关联的组成部分，各组成部分间有明确的层次结构，方便使用和维护，并有一定的操作规范。

   V8 源代码的结构化之后，就生成了抽象语法树（AST）。在生成 AST 的同时，V8 还会生成相关的作用域，作用域中存放相关变量。

2. 有了 AST 和作用域之后，就可以生成**字节码**[^2]了。

   [^2]: 字节码，是介于 AST 和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。

3. 之后，解释器会按照顺序解释执行字节码，并输出执行结果。

在解释器有个监控，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。

当某段代码被标记为热点代码后，V8 就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么 V8 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。

不过，和静态语言不同的是，JS 是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行**反优化操作**，经过反优化的代码，下次执行时就会回退到解释器解释执行。

### 1.4 构建和使用 V8 的调试工具 d8

[文档](https://time.geekbang.org/column/article/219418)

[编译好的 d8](https://storage.googleapis.com/chromium-v8/official/canary/v8-win64-dbg-8.4.109.zip)

## 二. JS 设计思想

### 2.1 函数即对象

JS 中的函数非常灵活，其根本原因在于 **JS 中的函数就是一种特殊的对象**，JS 中的函数被称为**一等公民**（First Class Function）。

基于函数是一等公民的设计，使得 JS 非常容易实现一些特性，比如闭包，还有函数式编程等，而其他语言要实现这些特性就显得比较困难，比如要在 C++ 中实现闭包需要实现大量复杂的代码，而且使用起来也异常复杂。

#### 2.1.1 JS 中的对象

JS 是一门**基于对象**（Object-Based）的语言，可以说 JS 中大部分的内容都是由对象构成的，诸如函数、数组，也可以说 JS 是建立在对象之上的语言。

![基于对象的设计](./image/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1.webp)

而这些对象在运行时可以动态修改其内容，这造就了 JS 的超级灵活特性。不过，因为 JS 太灵活了，也加大了理解和使用这门语言的难度。

虽然 JS 是基于对象设计的，但是它却不是一门面向对象的语言（Object—Oriented Programming Language），因为**面向对象语言天生支持封装、继承、多态**，但是 JS 并没有直接提供多态的支持，因此要在 JS 中使用多态并不是一件容易的事。

除了对多态支持的不好，JS 实现继承的方式和面向对象的语言实现继承的方式同样存在很大的差异。

面向对象语言是由语言本身对继承做了充分的支持，并提供了大量的关键字，如 public、protected、friend、interface 等，众多的关键字使得面向对象语言的继承变得异常繁琐和复杂，而 JS 中实现继承的方式却非常简单清爽，只是在对象中添加了一个称为**原型**的属性，把继承的对象通过原型链接起来，就实现了继承，这种继承方式被称为**基于原型链继承**。关于 V8 是如何支持原型的，我们会在《05 | 原型链：V8 是如何实现对象继承的？》这节课做具体介绍。<!-- TODO -->

JS 中的对象非常简单，每个对象就是由一组组属性和值构成的集合，比如：

```js
let person = new Object();
person.firstname = 'John';
person.lastname = 'Doe';
person.age = 50;
person.eyecolor = 'blue';
```

这个对象里面有四个属性：

![对象的构成](./image/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E6%88%90.webp)

上图展示了对象 person 的结构，可以看到蓝色的属性在左边，黄色的值在右边，有多组属性和值组成，这就是 JS 中的对象，虽然 JS 对象用途非常广泛，使用的方式也非常之多，但是万变不离其宗，其核心本质都就是由一组组属性和值组成的集合。

之所以 JS 中对象的用途这么广，是因为对象的值可以是任意类型的数据，可以改造下上面的那段代码：

```js
let person = new Object();
person.firstname = 'John';
person.lastname = 'Doe';
person.info = new Object();
person.info.age = 50;
person.info.eyecolor = 'blue';
person.showinfo = function () {
  console.log(/*...*/);
};
```

这段代码的内存布局，如下图所示：

![属性值类型](./image/%E5%B1%9E%E6%80%A7%E5%80%BC%E7%B1%BB%E5%9E%8B.webp)

观察上图，可以看出来，对象的属性值有三种类型：

1. **原始类型**（primitive）

   所谓的原始类型的数据，是指值本身无法被改变，比如 JS 中的字符串就是原始类型，如果修改了 JS 中字符串的值，那么 V8 会返回一个新的字符串，原始字符串并没有被改变，称这些类型的值为 “原始值”。

   JS 中的原始值主要包括 null、undefined、boolean、number、string、bigint、symbol 这七种。

2. **对象类型**（Object）：对象的属性值也可以是另外一个对象。

3. **函数类型**（Function）：如果对象中的属性值是函数，那么可以把这个属性称为**方法**，所以又说对象具备属性和方法。

#### 2.1.2 函数的本质

在 JS 中，函数是一种特殊的对象，它和对象一样可以拥有属性和值，函数和普通对象不同的是，函数可以被调用。V8 内部为了实现函数可调用特性，会为函数对象添加了两个隐藏属性：

![函数对象具有隐藏属性](./image/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%85%B7%E6%9C%89%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7.webp)

也就是说，函数除了可以拥有常用类型的属性值之外，还拥有两个隐藏属性：

- `name`：隐藏 name 属性的值就是函数名称，如果某个函数没有设置函数名，默认是 `''`，表示该函数对象没有被设置名称。

- `code`：其值表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8 便会从函数对象中取出 code 属性值，也就是函数代码，然后再解释执行这段函数代码。

#### 2.1.3 函数是一等公民

因为函数是一种特殊的对象，所以在 JS 中，函数可以赋值给一个变量，也可以作为函数的参数，还可以作为函数的返回值。**如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，就把这个语言中的函数称为一等公民**。支持函数是一等公民的语言可以使得代码逻辑更加清晰，代码更加简洁。

但是由于函数的 “可被调用” 的特性，使得实现函数的可赋值、可传参和可作为返回值等特性变得有一点麻烦。

在执行 JS 函数的过程中，为了实现变量的查找，V8 会为其维护一个作用域链，如果函数中使用了某个变量，但是在函数内部又没有定义该变量，那么函数就会沿着作用域链去外部的作用域中查找该变量：

![查找变量](./image/%E6%9F%A5%E6%89%BE%E5%8F%98%E9%87%8F.webp)

从图中可以看出，当函数内部引用了外部的变量时，使用这个函数进行赋值、传参或作为返回值，还需要保证这些被引用的外部变量是确定存在的，这就是让函数作为一等公民麻烦的地方，因为虚拟机还需要处理函数引用的外部变量。来看一段简单的代码：

```js
function foo() {
  let number = 1;
  function bar() {
    number++;
    console.log(number);
  }
  return bar;
}
let myBar = foo();
myBar();
```

在 foo 函数中定义了一个新的 bar 函数，并且 bar 函数引用了 foo 函数中的变量 number，当调用 foo 函数的时候，它会返回 bar 函数。

“函数是一等公民” 就体现在，如果要返回函数 bar 给外部，那么即便 foo 函数执行结束了，其内部定义的 number 变量也不能被销毁，因为 bar 函数依然引用了该变量。也把这种**将外部变量和和函数绑定起来的技术称为闭包**。V8 在实现闭包的特性时也做了大量的额外的工作，关于闭包的详细实现，会在《12 | 延迟解析：V8 是如何实现闭包的？》这节课再介绍。<!-- TODO -->

### 2.2 V8 如何提升对象属性访问速度

JS 中的对象是由一组组属性和值的集合，从 JS 语言的角度来看，JS 对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。

然而在 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8 为了提升存储和查找效率，采用了一套复杂的存储策略。

![线性结构和非线性结构](./image/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.webp)

#### 2.2.1 常规属性（properties）和排序属性（elements）

```js
function Foo() {
  this[100] = 'test-100';
  this[1] = 'test-1';
  this['B'] = 'bar-B';
  this[50] = 'test-50';
  this[9] = 'test-9';
  this[8] = 'test-8';
  this[3] = 'test-3';
  this[5] = 'test-5';
  this['A'] = 'bar-A';
  this['C'] = 'bar-C';
}
let bar = new Foo();

for (let key in bar) {
  console.log(`index:${key}  value:${bar[key]}`);
}
```

上面这段代码，利用构造函数 Foo 创建了一个 bar 对象，在构造函数中，给 bar 对象设置了很多属性，包括了数字属性和字符串属性，然后枚举出来了 bar 对象中所有的属性，并将其一一打印出来：

```txt
index:1  value:test-1
index:3  value:test-3
index:5  value:test-5
index:8  value:test-8
index:9  value:test-9
index:50  value:test-50
index:100  value:test-100
index:B  value:bar-B
index:A  value:bar-A
index:C  value:bar-C
```

发现打印出来的属性顺序并不是设置的顺序，设置属性的时候是乱序设置的，但是输出的内容却非常规律，总的来说体现在以下两点：

- 设置的数字属性被最先打印出来了，并且是按照数字大小的顺序打印的。
- 设置的字符串属性依然是按照之前的设置顺序打印的，比如是按照 B、A、C 的顺序设置的，打印出来依然是这个顺序。

之所以出现这样的结果，是因为在 ECMAScript 规范中定义了**数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列**。

在这里把**对象中的数字属性称为排序属性**，在 V8 中被称为 elements，**字符串属性就被称为常规属性**，在 V8 中被称为 properties。

在 V8 内部，为了有效地提升存储和访问这两种属性的性能，*分别使用了两个线性数据结构*来分别保存排序属性和常规属性：

![V8内部的对象构造](./image/V8%E5%86%85%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0.webp)

通过上图发现，bar 对象包含了两个隐藏属性：elements 属性和 properties 属性，elements 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性，properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存了常规属性。

分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。

#### 2.2.2 快属性和慢属性

将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如执行 bar.B 这个语句来查找 B 的属性值，那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。

基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，这被称为**对象内属性**（in-object properties）：

![对象内属性](./image/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%B1%9E%E6%80%A7.webp)

采用对象内属性之后，常规属性就被保存到 bar 对象本身了，这样当再次使用 bar.B 来查找 B 的属性值时，V8 就可以直接从 bar 对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。

不过**对象内属性的数量是固定的，默认是 10 个**，如果添加的属性超出了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自由地扩容。

通常，**将保存在线性数据结构中的属性称之为 “快属性”**，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。

因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是 “慢属性” 策略，但慢属性的对象内部会有独立的非线性数据结构（词典）作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。

![慢属性是如何存储的](./image/%E6%85%A2%E5%B1%9E%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84.webp)

#### 2.2.3 在 Chrome 中查看对象布局

打开 Chrome 开发者工具，先选择控制台标签，然后在控制台中执行以下代码查看内存快照：

```js
function Foo(property_num, element_num) {
  // 添加可索引属性
  for (let i = 0; i < element_num; i++) {
    this[i] = `element${i}`;
  }
  // 添加常规属性
  for (let i = 0; i < property_num; i++) {
    let ppt = `property${i}`;
    this[ppt] = ppt;
  }
}
let bar = new Foo(12, 10);
```

创建了函数对象，接下来就来看看构造函数和对象在内存中的状态。将 Chrome 开发者工具切换到 Memory 标签，然后点击左侧的小圆圈（拍摄堆快照）就可以捕获当前的内存快照，然后在类过滤器中输入构造函数名称：

![从内存快照搜索构造函数](./image/%E4%BB%8E%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%E6%90%9C%E7%B4%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png)

可以看到其中有 10 个对象内属性，另外的常用属性就被保存到 properties 中，10 个排序属性存放在 elements 中。

**其他属性**
观察上图，除了 elements 和 properties 属性，V8 还为每个对象实现了 `map` 属性和 `__proto__` 属性。`__proto__` 属性就是原型，是用来实现 JS 继承的。而 map 则是隐藏类，我们会在《15 | 隐藏类：如何在内存中快速查找对象属性？》这一节中介绍其工作机制。<!-- TODO -->

### 2.3 函数表达式

函数表达式在 JS 中非常基础也非常重要，使用函数表达式可以用来实现代码隐藏，还可以实现变量隔离，所以函数表达式被广泛地应用在各个项目中。

```js
// 函数声明
function foo() {
  // ...
}

// 函数表达式
let foo = function () {
  // ...
};
```

#### 2.3.1 函数声明与函数表达式的差异

```js
foo();
function foo() {
  console.log('foo');
}
```

在这段代码中，声明了一个 foo 函数，然后在 foo 函数之前调用了 foo 函数，执行这段代码，可以看到 foo 函数被正确执行了。

```js
foo();
var foo = function () {
  console.log('foo');
};
```

在下面的代码中，定义了一个变量 foo，然后将一个函数赋值给了变量 foo，也是在 foo 函数的前面调用 foo，执行这段代码，发现报错了，提示的错误信息如下所示：

```sh
VM130:1 Uncaught TypeError: foo is not a function
    at <anonymous>:1:1
```

第二段代码报错的主要原因是这两种定义函数的方式具有不同语义，不同的语义触发了不同的行为。

![不同的语义触发不同的行为](./image/%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AF%AD%E4%B9%89%E8%A7%A6%E5%8F%91%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%8C%E4%B8%BA.webp)

因为语义不同，所以给这两种定义函数的方式使用了不同的名称，第一种称之为**函数声明**，第二种称之为**函数表达式**。

#### 2.3.2 V8 处理函数声明

函数声明定义了一个具有指定参数的函数，其声明语法如下所示：

```js
function name([param,[, param,[..., param]]]) {
   [statements]
}
```

V8 在执行 JS 的过程中，会先对其进行编译，然后再执行：

```js
var x = 5;
function foo() {
  console.log('Foo');
}
```

V8 执行这段代码的流程大致如下图所示：

![V8执行代码流程](./image/V8%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B.webp)

在编译阶段，如果解析到函数声明，那么 V8 会将这个函数声明转换为内存中的函数对象，并将其放到作用域中。同样，如果解析到了某个变量声明，也会将其放到作用域中，但是会将其值设置为 undefined，表示该变量还未被使用。

然后在 V8 执行阶段，如果使用了某个变量，或者调用了某个函数，那么 V8 便会去作用域查找相关内容。

#### 2.3.3 V8 处理函数表达式

在一个表达式中使用 function 来定义一个函数，那么就把该函数称为函数表达式。

```js
let foo = function () {
  console.log('foo');
};
```

函数表达式与函数声明的最主要区别有以下三点：

- 函数表达式是在表达式语句中使用 function 的，最典型的表达式是 “a=b” 这种形式，因为函数也是一个对象，把 “a = function (){}” 这种方式称为函数表达式。

- 在函数表达式中，可以省略函数名称，从而创建匿名函数（anonymous functions）。

- 一个函数表达式可以被用作一个即时调用的函数表达式——IIFE（Immediately Invoked Function Expression）。

### 2.4 原型链

**继承就是一个对象可以访问另外一个对象中的属性和方法**，比如有一个 B 对象，该对象继承了 A 对象，那么 B 对象便可以直接访问 A 对象中的属性和方法：

![继承](./image/%E7%BB%A7%E6%89%BF.webp)

不同的语言实现继承的方式是不同的，其中最典型的两种方式：

- **基于类的设计**

  C++、Java、C# 这些语言都是基于经典的类继承的设计模式，这种模式最大的特点就是提供了非常复杂的规则，并提供了非常多的关键字，诸如 class、friend、protected、private、interface 等，通过组合使用这些关键字，就可以实现继承。

  使用基于类的继承时，如果业务复杂，那么需要创建大量的对象，然后需要维护非常复杂的继承关系，这会导致代码过度复杂和臃肿，另外引入了这么多关键字也给设计带来了更大的复杂度。

- **基于原型继承的设计**

  而 JS 的继承方式和其他面向对象的继承方式有着很大差别，JS 本身不提供一个 class 实现。虽然标准委员会在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JS 的继承依然和基于类的继承没有一点关系。

  JS 仅仅在对象中引入了一个原型的属性，就实现了语言的继承机制，基于原型的继承省去了很多基于类继承时的繁文缛节，简洁而优美。

#### 2.4.1 原型继承的实现

**在 JS 中，通过原型和原型链的方式来实现了继承特性**。

![原型继承的实现-1](./image/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0-1.webp)

有一个对象 C，它包含了一个属性 “type”，那么对象 C 可以直接访问它自己的属性 type。

上面从 V8 的内存快照看到，JS 的每个对象都包含了一个隐藏属性**原型** `__proto__`（prototype），`__proto__` 指向了内存中的另外一个对象，就把 `__proto__` 指向的对象称为该对象的**原型对象**，那么该对象就可以直接访问其原型对象的方法或者属性。

比如让 C 对象的原型指向 B 对象，那么便可以利用 C 对象来直接访问 B 对象中的属性或者方法：

![原型继承的实现-2](./image/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0-2.webp)

当 C 对象将它的 `__proto__` 属性指向了 B 对象后，那么通过对象 C 来访问对象 B 中的 name 属性时，V8 会先从对象 C 中查找，但是并没有查找到，接下来 V8 继续在其原型对象 B 中查找，因为对象 B 中包含了 name 属性，那么 V8 就直接返回对象 B 中的 name 属性值，虽然 C 和 B 是两个不同的对象，但是使用的时候，B 的属性看上去就像是 C 的属性一样。

同样的方式，B 也是一个对象，它也有自己的 `__proto__` 属性，比如它的属性指向了内存中另外一块对象 A：

对象 A 有个属性是 color，那么通过 C.color 访问 color 属性时，V8 会先在 C 对象内部查找，但是没有查找到，接着继续在 C 对象的原型对象 B 中查找，但是依然没有查找到，那么继续去对象 B 的原型对象 A 中查找，因为 color 在对象 A 中，那么 V8 就返回该属性值。

使用 C.name 和 C.color 时，给人的感觉属性 name 和 color 都是对象 C 本身的属性，但实际上这些属性都是位于原型对象上，把这个查找属性的路径称为**原型链**，它像一个链条一样，将几个原型链接起来。查找属性的时候，JS 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。

> **注意**：不要将原型链接和作用域链搞混淆了，作用域链是沿着函数的作用域一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的，关于作用域链，我会在《06 | 作用域链：V8 是如何查找变量的？》这节课来介绍。<!-- TODO -->

#### 2.4.2 利用 `__proto__` 实现继承

```js
let animal = {
  type: 'Default',
  color: 'Default',
  getInfo: function () {
    return `Type is: ${this.type}，color is ${this.color}.`;
  }
};
let dog = {
  type: 'Dog',
  color: 'Black'
};
```

在这段代码中，创建了两个对象 animal 和 dog，想让 dog 对象继承于 animal 对象，那么最直观的方式就是将 dog 的原型指向对象 animal：

```js
dog.__proto__ = animal;
```

通常隐藏属性是不能使用 JS 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JS 可以访问隐藏属性 `__proto__`，但是在实际项目中，不应该直接通过 `__proto__` 来[访问或者修改该属性](/front_end/JavaScript/JavaScript.md#232-js-的原形)，其主要原因有两个：

- 这是隐藏属性，并不是标准定义的。
- 使用该属性会造成严重的性能问题。

### 2.5 作用域链

**作用域链就是将一个个作用域串起来，实现变量查找的路径**。作用域就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。

当在函数内部使用一个变量的时候，V8 便会去作用域中去查找：

```js
let name = '极客时间';
let type = 'global';

function foo() {
  let name = 'foo';
  console.log(`name: ${name}`);
  console.log(`type: ${type}`);
}

function bar() {
  let name = 'bar';
  let type = 'function';
  foo();
}

bar();
// name: foo
// type: global
```

#### 2.5.1 全局作用域和函数作用域

每个函数在执行时都需要查找自己的作用域，称为**函数作用域**，在执行阶段，在执行一个函数时，当该函数需要使用某个变量或者调用了某个函数时，便会优先在该函数作用域中查找相关内容。

```js
var x = 4;
var test;
function test_scope() {
  var name = 'foo';
  console.log(name);
  console.log(type);
  console.log(test);
  var type = 'function';
  test = 1;
  console.log(x);
}
test_scope();
```

在上面的代码中，定义了一个 test_scope 函数，在 V8 执行 test_scope 函数的时候，在编译阶段会为 test_scope 函数创建一个作用域，在 test_scope 函数中定义的变量和声明的函数都会丢到该作用域中，因为在 test_scope 函数中定了三个变量，那么常见的作用域就包含有这三个变量。

可以通过 Chrome 的控制台来直观感受下 test_scope 函数的作用域，先打开包含这段代码的页面，然后打开开发者工具，接着在 test_scope 函数中的第二段代码加上断点，然后刷新该页面。当执行到该断点时，V8 会暂停整个执行流程，这时候就可以通过右边的区域面板来查看当前函数的执行状态。

![观察作用域](./image/%E8%A7%82%E5%AF%9F%E4%BD%9C%E7%94%A8%E5%9F%9F.webp)

可以参考图中右侧的 Scope 项，然后点击展开该项，这个 Local 就是当前函数 test_scope 的作用域。在 test_scope 函数中定义的变量都包含到了 Local 中，如变量 name、type，另外系统还添加了另外一个隐藏变量 this，V8 会默认将隐藏变量 this 存放到作用域中。

在 test_scope 函数使用了变量 x，但是在 test_scope 函数的作用域中，并没有定义变量 x，V8 如果在当前函数作用域中没有查找到变量，那么 V8 会去全局作用域中去查找，这个查找的线路就称为作用域链。

全局作用域和函数作用域类似，也是存放变量和函数的地方，但是它们有点不一样：**全局作用域是在 V8 启动过程中就创建了，且一直保存在内存中不会被销毁的，直至 V8 退出。而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉**。

全局作用域中包含了很多全局变量，比如全局的 this 值，如果是浏览器，全局作用域中还有 window、document、opener 等非常多的方法和对象，如果是 node 环境，那么会有 Global、File 等内容。

V8 启动之后就进入正常的消息循环状态，这时候就可以执行代码了，比如执行到上面那段时，V8 会先解析顶层（Top Level）代码，可以看到，在顶层代码中定义了变量 x，这时候 V8 就会将变量 x 添加到全局作用域中。

#### 2.5.2 作用域链的工作方式

1. 当 V8 启动时，会创建全局作用域，全局作用域中包括了 this、window 等变量，还有一些全局的 Web API 接口：

   ![全局作用域-初始化](./image/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%88%9D%E5%A7%8B%E5%8C%96.webp)

2. V8 启动之后，消息循环系统便开始工作，这时候，输入代码让其执行。V8 会先编译顶层代码，在编译过程中会将顶层定义的变量和声明的函数都添加到全局作用域中：

   ![全局作用域-编译](./image/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F-%E7%BC%96%E8%AF%91.webp)

3. 全局作用域创建完成之后，V8 便进入了执行状态。

   当 V8 执行 bar 函数的时候，同样需要经历两个阶段：编译和执行。在编译阶段，V8 会为 bar 函数创建函数作用域，最终效果如下所示：

   ![bar函数作用域](./image/bar%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F.webp)

   然后进入了 bar 函数的执行阶段。在 bar 函数中，只是简单地调用 foo 函数，因此 V8 又开始执行 foo 函数。同样，在编译 foo 函数的过程中，会创建 foo 函数的作用域：

   ![foo函数作用域](./image/foo%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F.webp)

   **因为 JS 是基于词法作用域的，词法作用域就是指，查找作用域的顺序是按照函数定义时的位置来决定的**。bar 和 foo 函数的外部代码都是全局代码，所以无论是在 bar 函数中查找变量，还是在 foo 函数中查找变量，其查找顺序都是按照*当前函数作用域–> 全局作用域*这个路径来的。所以在 foo 函数中使用 type，最终打印出来的值就是全局作用域中的 type。

   ![词法作用域](./image/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F.webp)

   因为词法作用域是根据函数在代码中的位置来确定的，作用域是在声明函数时就确定好了，所以也将词法作用域称为**静态作用域**。和静态作用域相对的是动态作用域，**动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用**。换句话说，作用域链是基于调用栈的，而不是基于函数定义的位置的。

### 2.6 类型转换

如果尝试在 Python 中使用数字和字符串进行相加操作，那么 Python 虚拟机会直接返回一个执行错误，错误提示是这样的：

```python
>>> 1+'2'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

这段错误代码提示了这是个类型错误，表明 Python 并不支持数字类型和字符串类型相加的操作。

不过在 JS 中执行这段表达式，是可以返回一个结果的，最终返回的结果是字符串 “12”。

#### 2.6.1 类型系统

对机器语言来说，所有的数据都是一堆二进制代码，CPU 处理这些数据的时候，并没有类型的概念，CPU 所做的仅仅是移动数据，比如对其进行移位，相加或相乘。

而在高级语言中，都会为操作的数据赋予指定的类型，**类型可以确认一个值或者一组值具有特定的意义和目的**。所以，类型是高级语言中的概念。

![类型是高级语言的概念](./image/%E7%B1%BB%E5%9E%8B%E6%98%AF%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5.webp)

比如在 C/C++ 中，需要为要处理的每条数据指定类型，这样定义变量：

```c++
int counter = 100 # 赋值整型变量
float miles = 1000.0 # 浮点型
char* name = "John" # 字符串
```

C/C++ 编译器负责将这些数据片段转换为供 CPU 处理的正确命令，通常是二进制的机器代码。

在某些更高级的语言中，还可以根据数据推断出类型，比如在 Python 或 JS 中，就不必为数据指定专门的数据类型，在 Python 中，可以这样定义变量：

```python
counter = 100 # 赋值整型变量
miles = 1000.0 # 浮点型
name = "John" # 字符串
```
