浏览器
  一.浏览器工作过程
    1.基本过程
      对浏览器的实现者来说，他们做的事，就是把一个URL变成屏幕上显示的网页，过程是这样的：
        ① 浏览器首先使用HTTP协议或HTTPS协议，向服务端请求页面。
        ② 把请求回来的HTML代码经过解析，构建成DOM树。
        ③ 计算DOM树上的CSS属性。
        ④ 最后根据CSS属性逐个进行进行渲染，得到内存中的位图。
        ⑤ 一个可选的步骤：对位图进行合成，这会极大的增加后续绘制的速度。
        ⑥ 合成后，再绘制到页面上。
        图片：front_end\浏览器的实现原理与API\示例文件\image\浏览器工作基本过程.jpg
      这里的步骤，从HTTP请求回来开始，不是一步做完再做下一步，而是一条流水线。
      从HTTP请求回来，就产生了流式数据，后续的DOM树构建、CSS计算、渲染、合成、绘制，都是尽可能流式处理前一步的产出：即不需要等上一步骤完全结束，就开始处理上一步的输出。
    2.HTTP协议
      浏览器首先要做的事就是根据URL把数据取回来，取回数据使用的是HTTP协议，HTTP标准是由 IETF 组织制定的，跟它相关的标准主要有两份：
        · HTTP1.1 https://tools.ietf.org/html/rfc2616
        · HTTP1.1 https://tools.ietf.org/html/rfc7234
      HTTP协议是基于TCP协议出现的，对TCP协议来说，TCP是一条双向的通讯通道，HTTP在TCP的基础上，规定了 Request-Response 模式。这个模式决定了通讯一定是由浏览器端先发起的。
      大部分情况下，浏览器的实现者只需要一个TCP库，甚至一个现成的HTTP库就可以搞定浏览器的网络通讯部分。HTTP是纯粹的文本协议，它是规定了使用TCP协议来传输文本格式的应用层协议。
      (1)请求过程
        TCP通道中传输的完全是文本：
          例：front_end\浏览器的实现原理与API\示例文件\HTTP请求过程.txt
      (2)HTTP协议格式
        HTTP协议，大概可以分成以下部分：
          图片：front_end\浏览器的实现原理与API\示例文件\image\HTTP协议格式.jpg
        在这些部分中，path是请求的路径完全由服务端来定义，而version几乎都是固定字符串，response body是HTML。
        ① HTTP Method(方法)
          这是 request line 里面的方法部分。这里的方法跟编程中的方法意义类似，表示此次HTTP请求希望执行的操作类型。方法有以下八种定义：
            · GET: 浏览器通过地址栏访问的都是GET方法
            · POST: 表单提交产生POST方法
            · HEAD: 跟GET类似，只返回响应头，多数由JS发起
            · PUT: 表示添加资源，这只是语义上的约定，并没有强约束力
            · DELETE: 表示删除资源，这只是语义上的约定，并没有强约束力
            · CONNECT: 多用于HTTPS和WebSocket
            · OPTIONS: 表明请求想得到请求/响应链上关于此请求里的URI（Request-URI）指定资源的通信选项信息，一般用于调试，多数线上服务不支持。
            · TRACE: 被用于激发一个远程的，应用层的请求消息回路（注：TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路），一般用于调试，多数线上服务不支持。
        ② HTTP Status Code(状态码) 和 Status text(状态文本)
          常见的状态码有以下几种：
            · 1xx: 临时回应，表示客户端请继续。这个1xx状态，前端一般看不见，因为它会被浏览器HTTP库直接处理掉，不会让上层应用知晓。
            · 2xx: 请求成功
              200: 请求成功
            · 3xx: 表示请求的目标有变化，希望客户端进一步处理
              301: 当前资源永久性转移，这更接近于一种报错，提示客户端下次别来了
              302: 当前资源临时性转移
              304: 客户端本地已经有了缓存的版本，并且在 request 中告诉了服务端，当服务端通过时间或tag，发现没有更新时，就会返回一个不含body的304状态
            · 4xx: 客户端请求错误
              403: 无权限
              404: 表示请求的页面不存在
            · 5xx: 服务端请求错误
              500: 服务端错误
              503: 服务端暂时性错误，可以一会再试
        ③ HTTP Head(HTTP头)
          HTTP头可以看做一个键值对。原则上，HTTP头也是一种数据，可以自由定义HTTP头和值。在HTTP标准中，有完整的请求/响应头规定，下面是几个重点的：
            Request Header：
              · Accept: 浏览器端接收的格式
              · Accept-Encoding: 浏览器端接收的编码方式
              · Accept-Language: 浏览器端接收的语言，用于服务端判断多语言
              · Cache-Control: 控制缓存的时效性
              · Connection: 连接方式，如果是keep-alive，且服务端支持，则会复用连接
              · Host: http访问使用的域名
              · if-Modified-Since: 上次访问时的更改时间，如果服务端认为此时间后没有更新，则会给出304响应
              · if-None-Match: 上次访问时使用的E-Tag，通常是页面的信息摘要，这个比更改时间更准确一些
              · User-Agent: 客户端标识
              · Cookie: 客户端储存的cookie字符串
            Response Header：
              · Cache-Control: 缓存控制，用于通知各级缓存保存的时间，例：max-age=0，表示不要缓存
              · Connection: 连接类型，Keep-Alive表示复用连接
              · Content-Length: 内容的长度，有利于浏览器判断内容是否已经结束
              · Content-Encoding: 内容编码方式，通常是gzip
              · Content-Type: 内容类型，所有请求网页都是text/html
              · Date: 当前服务器的日期
              · ETag: 页面的摘要信息，用于判断是否需要重新到服务端取回页面
              · Expires: 过期时间，用于下次请求是否需要到服务端请求页面
              · Keep-Alive: 保持连接不断时需要的一些信息，例：timeout=5，max=100
              · Last-Modified: 页面上次修改的时间
              · Server: 服务端软件的类型
              · Set-Cookie: 设置cookie，可以存在多个
              · Via: 服务端的请求链路，对一些调试场景至关重要的一个头
        ④ HTTP Response Body
          HTTP请求的body主要用于提交表单场景。实际上，HTTP请求的 body 是比较自由的，只要浏览器端发送的body服务端认可就行。一些常见的body格式：
            · application-json
            · application/x-www-form-urlencoded
            · multipart/form-data
            · text/html
          使用HTML的form标签提交产生的HTML请求，默认产生 application/x-www-form-urlencoded 的格式数据，当有文件上传时，则会使用 multipart/form-data
      (3)HTTPS
        在HTTP的基础上，HTTPS和HTTP2规定了更复杂的内容，但是它基本保持了HTTP的设计思想，即：Request-Response模式
        HTTPS有两个作用：
          · 确定定请求的目标端身份
          · 确保传输的数据不会被网络中间节点窃听或篡改
        HTTPS标准也是由RFS规定的，详情链接：https://tools.ietf.org/html/rfc2818
        HTTPS是使用加密通道来传输HTTP的内容。HTTPS首先与服务端建立一条TLS加密通道。TLS建构在TCP协议上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS跟HTTP没有任何区别。
      (4)HTTP2
        HTTP2是HTTP1的升级版本，详情链接：https://tools.ietf.org/html/rfc7540
        HTTP2最大的改进有两点：
          · 支持服务端推送: 服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端放入缓存中，可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。
          · 支持TCP连接复用: 使用同一个TCP连接来传输多个HTTP请求，避免了TCP连接建立时的三次握手开销，和初建TCP连接窗口小的问题。
        其实很多优化涉及更下层的协议。IP层的分包情况，和物理层的建连时间都是需要被考虑的。
    3.构建DOM树
      字符流 -> 状态机 -> token 词 -> 栈 -> DOM树
      (1)解析代码
        HTTP的Response的body是需要去解析的，HTML的结构不算复杂，日常开发需要的90%的词(指编译原理中的token，表示最小的有意义的单元)，种类大约只有标签开始、属性、标签结束、注释、CDATA节点几种。
        ① 词(token)是被如何拆分的
          <p class="a">text</p>
          如果从最小有意义单元的定义来拆分，第一个词是什么呢？显然，作为一个词，整个 p 标签肯定是过大了（它甚至可以嵌套）。考虑到起始标签也是会包含属性的，最小的意义单元其实是“<p” ，所以“ <p” 就是我们的第一个词。
          继续拆分，可以把这段代码依次拆成词:
            · <p 标签的开始
            · class="a" 属性
            · > "标签开始"的结束
            · text 文本
            · </p>标签结束 
          词可以被拆分成7种：front_end\浏览器的实现原理与API\示例文件\image\解析代码-词拆分示例.png
        ② 状态机
          为什么要使用状态机？
            设想，代码开始从HTTP协议收到字符流读取字符。在接收第一个字符前，完全无法判断这是哪一个词，不过，随着接收的字符越来越多，拼出其他的内容可能性就越来越少。
              比如：接受了一个字符"<"，就知道这不是一个文本节点。之后再读取一个字符，比如"x"，那么就知道这不是注释和 CDATA 了，接下来一直读，直到遇到“>”或者空格，这样就得到了一个完整的词了。实际上，每读入一个字符，其实都要做一次决定，而且这些决定是跟"当前状态"有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词，最常见的方案就是使用状态机。
          绝大多数的语言的词法部分都是用状态机来是实现的，下面是一个部分词的简易状态机示意图：
            例：front_end\浏览器的实现原理与API\示例文件\image\部分词的简易状态机示意图.png
          真正完整的HTML词法状态机，比这张图要复杂的多。更详细的内容，可以参考：https://html.spec.whatwg.org/multipage/parsing.html#tokenization，HTML官方文档规定了80个状态。
          如果仅仅是为了理解原理，这个简单的状态机就足够了：
            状态机的初始状态，仅仅区分"<"和"非<":
              · 如果获得的是一个"非<"字符，那么可以认为进入了一个文本节点
              · 如果获得的是一个"<"，那么进入一个标签状态
            在标签状态时，会有以下几种可能：
              · 下一个字符是"!"，那么可能是进入了注释节点或CDATA节点
              · 如果下一个字符是"/"，那么可以确定进入了一个结束标签
              · 如果下一个是字符，那么可以确定进入了一个开始标签
              · 如果要完整处理各种HTML标准中规定的东西，那么还要考虑"?"、"%"等内容
            可以看到，用状态机做词法分析，其实正是把每个词的"特征字符"逐个拆开成独立状态，然后把所有词的特征字符链合并起来，形成一个连通图结构。
          代码实现
            在 C/C++ 和 JavaScript 中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。（注意：状态机真的是一种没有办法封装的东西，所以永远不要试图封装状态机。）
              例：front_end\浏览器的实现原理与API\示例文件\简易状态机实现.js