浏览器
  一.浏览器工作过程
    1.基本过程
      对浏览器的实现者来说，他们做的事，就是把一个URL变成屏幕上显示的网页，过程是这样的：
        ① 浏览器首先使用HTTP协议或HTTPS协议，向服务端请求页面。
        ② 把请求回来的HTML代码经过解析，构建成DOM树。
        ③ 计算DOM树上的CSS属性。
        ④ 确定每一个元素的位置，进行排版。
        ⑤ 最后根据CSS属性逐个进行进行渲染，得到内存中的位图。
        ⑥ 一个可选的步骤：对位图进行合成，这会极大的增加后续绘制的速度。
        ⑦ 合成后，再绘制到页面上。
        图片：front_end\浏览器的实现原理与API\示例文件\image\浏览器工作基本过程.jpg
      这里的步骤，从HTTP请求回来开始，不是一步做完再做下一步，而是一条流水线。
      从HTTP请求回来，就产生了流式数据，后续的DOM树构建、CSS计算、渲染、合成、绘制，都是尽可能流式处理前一步的产出：即不需要等上一步骤完全结束，就开始处理上一步的输出。
    2.HTTP协议
      浏览器首先要做的事就是根据URL把数据取回来，取回数据使用的是HTTP协议，HTTP标准是由 IETF 组织制定的，跟它相关的标准主要有两份：
        · HTTP1.1 https://tools.ietf.org/html/rfc2616
        · HTTP1.1 https://tools.ietf.org/html/rfc7234
      HTTP协议是基于TCP协议出现的，对TCP协议来说，TCP是一条双向的通讯通道，HTTP在TCP的基础上，规定了 Request-Response 模式。这个模式决定了通讯一定是由浏览器端先发起的。
      大部分情况下，浏览器的实现者只需要一个TCP库，甚至一个现成的HTTP库就可以搞定浏览器的网络通讯部分。HTTP是纯粹的文本协议，它是规定了使用TCP协议来传输文本格式的应用层协议。
      (1)请求过程
        TCP通道中传输的完全是文本：
          例：front_end\浏览器的实现原理与API\示例文件\HTTP请求过程.txt
      (2)HTTP协议格式
        HTTP协议，大概可以分成以下部分：
          图片：front_end\浏览器的实现原理与API\示例文件\image\HTTP协议格式.jpg
        在这些部分中，path是请求的路径完全由服务端来定义，而version几乎都是固定字符串，response body是HTML。
        ① HTTP Method(方法)
          这是 request line 里面的方法部分。这里的方法跟编程中的方法意义类似，表示此次HTTP请求希望执行的操作类型。方法有以下八种定义：
            · GET: 浏览器通过地址栏访问的都是GET方法
            · POST: 表单提交产生POST方法
            · HEAD: 跟GET类似，只返回响应头，多数由JS发起
            · PUT: 表示添加资源，这只是语义上的约定，并没有强约束力
            · DELETE: 表示删除资源，这只是语义上的约定，并没有强约束力
            · CONNECT: 多用于HTTPS和WebSocket
            · OPTIONS: 表明请求想得到请求/响应链上关于此请求里的URI（Request-URI）指定资源的通信选项信息，一般用于调试，多数线上服务不支持。
            · TRACE: 被用于激发一个远程的，应用层的请求消息回路（注：TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路），一般用于调试，多数线上服务不支持。
        ② HTTP Status Code(状态码) 和 Status text(状态文本)
          常见的状态码有以下几种：
            · 1xx: 临时回应，表示客户端请继续。这个1xx状态，前端一般看不见，因为它会被浏览器HTTP库直接处理掉，不会让上层应用知晓。
            · 2xx: 请求成功
              200: 请求成功
            · 3xx: 表示请求的目标有变化，希望客户端进一步处理
              301: 当前资源永久性转移，这更接近于一种报错，提示客户端下次别来了
              302: 当前资源临时性转移
              304: 客户端本地已经有了缓存的版本，并且在 request 中告诉了服务端，当服务端通过时间或tag，发现没有更新时，就会返回一个不含body的304状态
            · 4xx: 客户端请求错误
              403: 无权限
              404: 表示请求的页面不存在
            · 5xx: 服务端请求错误
              500: 服务端错误
              503: 服务端暂时性错误，可以一会再试
        ③ HTTP Head(HTTP头)
          HTTP头可以看做一个键值对。原则上，HTTP头也是一种数据，可以自由定义HTTP头和值。在HTTP标准中，有完整的请求/响应头规定，下面是几个重点的：
            Request Header：
              · Accept: 浏览器端接收的格式
              · Accept-Encoding: 浏览器端接收的编码方式
              · Accept-Language: 浏览器端接收的语言，用于服务端判断多语言
              · Cache-Control: 控制缓存的时效性
              · Connection: 连接方式，如果是keep-alive，且服务端支持，则会复用连接
              · Host: http访问使用的域名
              · if-Modified-Since: 上次访问时的更改时间，如果服务端认为此时间后没有更新，则会给出304响应
              · if-None-Match: 上次访问时使用的E-Tag，通常是页面的信息摘要，这个比更改时间更准确一些
              · User-Agent: 客户端标识
              · Cookie: 客户端储存的cookie字符串
            Response Header：
              · Cache-Control: 缓存控制，用于通知各级缓存保存的时间，例：max-age=0，表示不要缓存
              · Connection: 连接类型，Keep-Alive表示复用连接
              · Content-Length: 内容的长度，有利于浏览器判断内容是否已经结束
              · Content-Encoding: 内容编码方式，通常是gzip
              · Content-Type: 内容类型，所有请求网页都是text/html
              · Date: 当前服务器的日期
              · ETag: 页面的摘要信息，用于判断是否需要重新到服务端取回页面
              · Expires: 过期时间，用于下次请求是否需要到服务端请求页面
              · Keep-Alive: 保持连接不断时需要的一些信息，例：timeout=5，max=100
              · Last-Modified: 页面上次修改的时间
              · Server: 服务端软件的类型
              · Set-Cookie: 设置cookie，可以存在多个
              · Via: 服务端的请求链路，对一些调试场景至关重要的一个头
        ④ HTTP Request Body
          HTTP请求的body主要用于提交表单场景。实际上，HTTP请求的 body 是比较自由的，只要浏览器端发送的body服务端认可就行。一些常见的body格式：
            · application-json
            · application/x-www-form-urlencoded
            · multipart/form-data
            · text/html
          使用HTML的form标签提交产生的HTML请求，默认产生 application/x-www-form-urlencoded 的格式数据，当有文件上传时，则会使用 multipart/form-data。
      (3)HTTPS
        在HTTP的基础上，HTTPS和HTTP2规定了更复杂的内容，但是它基本保持了HTTP的设计思想，即：Request-Response模式
        HTTPS有两个作用：
          · 确定请求的目标服务端身份
          · 确保传输的数据不会被网络中间节点窃听或篡改
        HTTPS标准也是由RFS规定的，详情链接：https://tools.ietf.org/html/rfc2818
        HTTPS是使用加密通道来传输HTTP的内容。HTTPS首先与服务端建立一条TLS加密通道。TLS建构在TCP协议上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS跟HTTP没有任何区别。
      (4)HTTP2
        HTTP2是HTTP1.1的升级版本，详情链接：https://tools.ietf.org/html/rfc7540
        HTTP2最大的改进有两点：
          · 支持服务端推送: 服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端放入缓存中，可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。
          · 支持TCP连接复用: 使用同一个TCP连接来传输多个HTTP请求，避免了TCP连接建立时的三次握手开销，和初建TCP连接窗口小的问题。
        其实很多优化涉及更下层的协议。IP层的分包情况，和物理层的建连时间都是需要被考虑的。
    3.构建DOM树
      字符流 -> 状态机 -> token 词 -> 栈 -> DOM树
      (1)解析代码
        HTTP的Response的body是需要去解析的，HTML的结构不算复杂，日常开发需要的90%的词(指编译原理中的token，表示最小的有意义的单元)，种类大约只有标签开始、属性、标签结束、注释、CDATA节点几种。
        ① 词(token)是被如何拆分的
          <p class="a">text</p>
          如果从最小有意义单元的定义来拆分，第一个词是什么呢？显然，作为一个词，整个 p 标签肯定是过大了（它甚至可以嵌套）。考虑到起始标签也是会包含属性的，最小的意义单元其实是“<p” ，所以“ <p” 就是我们的第一个词。
          继续拆分，可以把这段代码依次拆成词:
            · <p 标签的开始
            · class="a" 属性
            · > "标签开始"的结束
            · text 文本
            · </p>标签结束 
          词可以被拆分成7种：front_end\浏览器的实现原理与API\示例文件\image\解析代码-词拆分示例.png
      (2)状态机
        ① 为什么要使用状态机？
          设想，代码开始从HTTP协议收到字符流读取字符。在接收第一个字符前，完全无法判断这是哪一个词，不过，随着接收的字符越来越多，拼出其他的内容可能性就越来越少。
          比如，接受了一个字符"<"，就知道这不是一个文本节点。之后再读取一个字符，比如"x"，那么就知道这不是注释和 CDATA 了，接下来一直读，直到遇到“>”或者空格，这样就得到了一个完整的词了。实际上，每读入一个字符，其实都要做一次决定，而且这些决定是跟"当前状态"有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词，最常见的方案就是使用状态机。
        ② 状态机原理
          绝大多数的语言的词法部分都是用状态机来是实现的，下面是一个示意图：
            例：front_end\浏览器的实现原理与API\示例文件\image\部分词的简易状态机示意图.png
          真正完整的HTML词法状态机，比这张图要复杂的多。更详细的内容，可以参考：https://html.spec.whatwg.org/multipage/parsing.html#tokenization，HTML官方文档规定了80个状态。
          如果仅仅是为了理解原理，上面那个简单的状态机就足够了：
            状态机的初始状态，仅仅区分"<"和"非<":
              · 如果获得的是一个"非<"字符，那么可以认为进入了一个文本节点
              · 如果获得的是一个"<"，那么进入一个标签状态
            在标签状态时，会有以下几种可能：
              · 下一个字符是"!"，那么可能是进入了注释节点或CDATA节点
              · 如果下一个字符是"/"，那么可以确定进入了一个结束标签
              · 如果下一个是字符，那么可以确定进入了一个开始标签
              · 如果要完整处理各种HTML标准中规定的东西，那么还要考虑"?"、"%"等内容
          可以看到，用状态机做词法分析，其实正是把每个词的"特征字符"逐个拆开成独立状态，然后把所有词的特征字符链合并起来，形成一个连通图结构。
        ③ 代码实现
          在 C/C++ 和 JavaScript 中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。（注意：状态机是一种没有办法封装的东西，所以永远不要试图封装状态机。）
            例：front_end\浏览器的实现原理与API\示例文件\简易状态机实现.js
      (3)构建DOM树
        把简单的词变成DOM树，这个过程是使用栈来实现的，任何语言都有栈。
        ① 在接收的同时，即开始构建 DOM 树，当接收完所有输入，栈顶就是最后的根节点，我们 DOM 树的产出，就是这个 栈 的第一项。
        ② 通过这个栈，我们可以构建 DOM 树：
          · 栈顶元素就是当前节点
          · 遇到属性，就添加到当前节点
          · 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点
          · 遇到注释节点，作为当前节点的子节点
          · 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点
          · 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。
    4.DOM树的CSS属性
      构建DOM的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到DOM树上。在这个过程中，可以同步把CSS属性计算出来，依次拿到上一次构造好的元素，去检查它匹配到哪些规则，再根据规则的优先级，做覆盖和调整。
      这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建DOM树的顺序一致，这是一个CSS设计原则，即：保证选择器在DOM树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。
      CSS有五种选择器和两种其他情况：
        · 空格: 后代，选中它的子节点
          例：front_end\浏览器的实现原理与API\示例文件\DOM树的CSS匹配.html 行4
        · >: 子代，选中它的子节点
          例：front_end\浏览器的实现原理与API\示例文件\DOM树的CSS匹配.html 行42
        · +: 直接后继选择器，选中它的下一个相邻节点
        · ~: 后继，选中它之后所有的相邻节点
          例：例：front_end\浏览器的实现原理与API\示例文件\DOM树的CSS匹配.html 行25
        · ||: 选中表格中的一列，它是专门针对表格的选择器，跟表格的模型建立相关。
        · 逗号分隔: CSS选择器还支持逗号分隔，表示"或"的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。
        · 选择器重合: 可以使用树形结构来进行一些合并，来提高效率。注意的是，这里的树，必须要带上连接符。
    5.排版
      排版是确定每一个元素的位置。基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。
      在构建DOM树和计算CSS属性这两个步骤，产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，就没法做到这样了。尤其是表格相关排版、flex排版和Grid排版，它们都有一个特点，那就是子元素之间具有关联性。
      (1)基本概念
        文字、图片、图形、表格等等，把浏览器确定它们位置的过程，叫排版。
        浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟印刷排版类似的排版方案，也跟平时的书写方向文字的方式一致，所以把它叫做正常流。
        浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行顶、行底、文字区域、基线等对齐方式。
        此外，浏览器还支持不同语言，因为不同语言的文字书写顺序不一致，所以浏览器的文字排版还支持双向文字系统。
        浏览器还支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是 盒模型。
        在正常流的基础上，浏览器还支持两类元素：
          · 绝对定位元素: 绝对定位元素把自身从正常流抽出，直接由top和left等属性确定自身位置，不参加排版计算，也不影响其他元素。绝对定位元素由 position 属性控制。
          · 浮动元素: 浮动元素则是使自身在正常流的位置向左或向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。
        除了正常流，浏览器还支持其他排版方式，比如现在非常常用的flex排版，这些排版方式由外部元素的display属性控制。
      (2)正常流文字排版
        正常流是唯一一个文字和盒混排的排版方式。书写文字时，是从左往右书写，每一个字跟上一个都不重叠，文字之间有一定间距，当写满一行，会换一下行写。
        书写中文时，文字的上下中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。
        实际上浏览器环境也类似，但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以，把文字依次书写的延伸方向称为主轴或主方向，换行延伸的方向跟主轴垂直交叉，称为交叉轴或交叉方向。
        一般从某个字体文件中获取某个特定文字的相关信息，获取到的信息大概类似下面：
          例；front_end\浏览器的实现原理与API\示例文件\image\浏览器文字排版-字体信息-横向版本.png  front_end\浏览器的实现原理与API\示例文件\image\浏览器文字排版-字体信息-纵向版本.png
        除了字体提供的字形本身包含的信息，文字排版还受到一些CSS属性的影响，如：line-height、letter-spacing、word-spacing等。
        在正常流的文字排版中，多数元素被当做盒来排版，而只有display为inline的元素中的文字排版时会被直接排版到文字流中，inline元素主轴方向的margin和border属性也会被计算到排版前进距离中。
          注意：当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排盒外。
      (3)正常流中的盒
        在正常流中，display不为inline的元素或伪元素，会以盒的形式跟文字一起排版。多数display属性都可以分为两部分：内部的排版和是否inline，带有 inline-前缀的盒，被称为行内级盒。
        根据盒模型，一个盒具有margin、border、padding、width/height等属性，它在主轴方向上占据的空间是由对应方向的几个属性之和决定的，而vertical-align属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。
        所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。块级盒比较简单，它总是独占一整行，计算出交叉轴方向的高度即可。
      (4)绝对定位元素
        position为absolute的元素，需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的position非static的元素即可。
      (5)浮动元素排版
        float元素非常特别，浏览器对float的处理时先排入正常流，再移动到排版宽度的最左/最右(实际上是主轴的最前/最后)。
        移动后，float元素占据了一定的排版空间，因此，在数行内，主轴的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸，主轴排版尺寸才会恢复。float元素排版完成后，float元素所在的行需要重新确定位置。
      (6)其他排版
        CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 Flex 排版，支持了 flex 属性，flex 属性将每一行排版后的剩余空间平均分配给主轴方向的 width/height 属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。
    6.渲染
      在这里渲染，指的是它在图形学的意义，也就是把模型变成位图的过程。
      这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是DOM树中占据浏览器内存最多的信息，在做内存优化时，主要就是考虑这一部分）。
      浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括HTML元素和伪元素，一个元素可能对应多个盒(比如inline元素，可能会分成多行)。每一个盒对应一张位图。
      渲染过程非常复杂，但是总体来说，分为两个大类，图形和文字：
        · 图形：盒的背景、边框、SVG元素、阴影等特性，都是需要绘制的图形类。这一部分，需要一个底层库来支持。一般的操作系统都会提供一个底层库，比如在Android中提供Skia，而Windows平台择优GDI，一般的浏览器会做一个兼容层来处理平台差异。
        · 文字: 盒中的文字也需要底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。字形分为像素字形和矢量字形。通常的字体，会在6px8px等小尺寸提供像素字形，比较大的尺寸提供矢量字形。矢量字形本身就需要经过渲染才能继续渲染到元素的位图上。目前最常用的字体库是FreeType，这是C++编写的开源字体库。
      在最理想的情况下，渲染过程产生的位图尺寸跟它上一步排版时占据的尺寸相同，但是，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大或者渲染到非常远的位置，所以为了优化，浏览器实际上会把阴影作为一个单独的盒来处理。
      注意：这里的渲染过程，是不会把子元素渲染到位图上的，这样当父元素的相对位置发生变化时，可以保证渲染的结果能够被最大的缓存，减少重新渲染。
    7.合成
      合成的过程，是为了一些元素创建一个"合成后的位图"(合成层)，把一部分子元素渲染到合成的位图上面。这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。
      合成的目标是提高性能，根据这个目标，建立的原则就是最大限度减少绘制次数原则。
      好的合成策略是"猜测"可能变化的元素，把它排除到合成之外。目前，主流浏览器一般根据position、transform等属性来决定合成策略，来"猜测"这些元素未来可能发生变化。
      但是，这样的猜测准确性有限，所以新的CSS标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略。
    8.绘制
      绘制是把"位图最终绘制到屏幕上，变成可见的图像"的过程，不过，一般来说，浏览器并不需要代码来处理这个过程，浏览器只需要把最终显示的位图交给操作系统即可。
      一般最终位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或驱动即可，这取决于浏览器运行的环境。‘
      实际上"绘制"发生的频率相当高，鼠标划过浏览器显示区域，每次移动都会造成重新绘制，这时候，显示重新绘制的面积就非常重要了。计算机图形学中，使用的方案是"脏矩形"算法，也就是把屏幕均匀的分为若干矩形区域。
      当鼠标移动、元素移动或其它导致需要重绘的场景发生时，只需要重新绘制它影响到的几个矩形区域即可。比矩形区域小的影响只会涉及4个矩形区域，大型元素则覆盖多个矩形。重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层的交集部分绘制即可。
      设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。

  二.浏览器API
    1.DOM API
      (1)介绍
        DOM API 是最早被设计出来的一批API，也是用途最广泛的API，这里的DOM，指的是狭义的文档对象模型。
        文档对象模型是用来描述文档，这里的文档，是特指HTML文档(或XML文档)。同时它又是一个"对象模型"，这意味它使用的是对象这样的概念来描述HTML文档。
        HTML文档是一个由标签嵌套而成的树形结构，因此，DOM也是使用树形的对象模型来描述一个HTML文档。
        DOM API 大致会包含四个部分：
          · 节点: DOM树形结构中的节点相关APi
          · 事件: 触发与监听事件相关的API
          · Range: 操作文字相关的API
          · 遍历: 遍历DOM需要的API
      (2)节点
        DOM的树形结构所有节点有统一的接口Node：
          图片：front_end\浏览器的实现原理与API\示例文件\image\DOM节点类型-继承关系.png
        在这些节点中，除了Document和DocumentFragment，都有对应的HTML写法：
          · Element: <tagName>...</tagName>
          · Text: text
          · Comment: <!-- comments -->
          · DocumentType: <!DOCTYPE html>
          · ProcessingInstruction(处理信息): <?a 1?>
        HTML代码运行后，会在内存中得到一棵DOM树，HTML的写法会被转换成对应的文档模型，可以通过JS等语言去访问这个文档模型。
        这里每天需要用到，要重点掌握的是：Document、Element、Text节点。DocumentFragment(文档片段)也非常有用，它常常被用来高性能的批量添加节点。Comment、DocumentType 和 ProcessingInstruction 很少需要运行时去修改和操作。
      (3)Node
        Node是DOM树继承关系的根节点，它定义了DOM节点在DOM树上的操作，首先，Node提供了一组属性，来表示它在DOM树中的关系：
          · parentNode: 返回某节点的父元素，如果没有返回null
            例：front_end\浏览器的实现原理与API\示例文件\Node-DOM树中关系属性.html 行48
          · childNodes: 返回节点的子节点集合，一个 nodeList 对象
            例：front_end\浏览器的实现原理与API\示例文件\Node-DOM树中关系属性.html 行49
          · firstChild: 返回节点的第一个子节点
            例：front_end\浏览器的实现原理与API\示例文件\Node-DOM树中关系属性.html 行50
          · lastChild: 返回节点的最后一个子节点
            例：front_end\浏览器的实现原理与API\示例文件\Node-DOM树中关系属性.html 行51
          · nextSibling: 返回节点的下一个节点(同一树层级)
          · previousSibling: 返回节点的上一个节点(同一树层级)
        操作DOM树的API，主要有以下几种：
          · appendChild: 可向节点的子节点列表末尾添加新的子节点。
            如果要添加的子节点，是DOM树中已经存在了的，添加的子节点将从DOM树中删除，然后重新插入它的新位置。如果要添加的子节点是 DocumentFragment 节点，则不会直接插入它，而是把它的子节点按序插入当前节点的子节点列表末尾。
              例：front_end\浏览器的实现原理与API\示例文件\操作DOM树的API.html 行45
          · insertBefore: 向指定的已有子节点之前插入新的子节点
            例：front_end\浏览器的实现原理与API\示例文件\操作DOM树的API.html 行47
          · removeChild: 删除一个子节点，返回删除的节点
            例：front_end\浏览器的实现原理与API\示例文件\操作DOM树的API.html 行50
          · replaceChild: 用指定节点替换当前节点的一个子节点，并返回被替换的节点
            例：front_end\浏览器的实现原理与API\示例文件\操作DOM树的API.html 行51