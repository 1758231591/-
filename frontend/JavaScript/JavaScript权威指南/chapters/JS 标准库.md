<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [11.1 集合与映射](#111-集合与映射)
  - [11.1.1 Set 类](#1111-set-类)
  - [11.1.2 Map 类](#1112-map-类)
  - [11.1.3 WeakMap 和 WeakSet](#1113-weakmap-和-weakset)
- [11.2 定型数组与二进制数据](#112-定型数组与二进制数据)
  - [11.2.1 定型数组的类型](#1121-定型数组的类型)
  - [11.2.2 创建定型数组](#1122-创建定型数组)
  - [11.2.3 使用定型数组](#1123-使用定型数组)
  - [11.2.4 定型数组的方法与属性](#1124-定型数组的方法与属性)
  - [11.2.5 Date View 与字节序](#1125-date-view-与字节序)
- [11.3 正则表达式与模式匹配](#113-正则表达式与模式匹配)
  - [11.3.1 定义正则表达式](#1131-定义正则表达式)
  - [11.3.2 模式匹配的字符串方法](#1132-模式匹配的字符串方法)
  - [11.3.3 RegExp 类](#1133-regexp-类)
- [11.4 日期与时间](#114-日期与时间)
  - [11.4.1 时间戳](#1141-时间戳)
  - [11.4.2 日期计算](#1142-日期计算)
  - [11.4.3 格式化与解析日期字符串](#1143-格式化与解析日期字符串)
- [11.5 Error 类](#115-error-类)
- [11.6 JSON 序列化与解析](#116-json-序列化与解析)
  - [11.6.1 JSON 自定义](#1161-json-自定义)
- [11.7 国际化 API](#117-国际化-api)
  - [11.7.1 格式化数值](#1171-格式化数值)
  - [11.7.2 格式化日期和时间](#1172-格式化日期和时间)
  - [11.7.3 比较字符串](#1173-比较字符串)
- [11.8 控制台 API](#118-控制台-api)
  - [11.8.1 通过控制台格式化输出](#1181-通过控制台格式化输出)
- [11.9 URL API](#119-url-api)
  - [11.9.1 遗留 URL 函数](#1191-遗留-url-函数)
- [11.10 计时器](#1110-计时器)

<!-- /code_chunk_output -->

某些数据类型，比如数值和字符串、对象和数组对 JS 而言非常之基础，因此可以将其看作这门语言的一部分。本章介绍另外一些重要但却没那么基础的 API，可以把它们看作 JS 的 “标准库”，包括 JS 内置的、在浏览器和 Node 中对所有 JS 程序都可用的类和函数。内容包括：

- 表示值的集合的 `Set` 和一组值到另一组值映射的 `Map`;

- 用于表示二进制数据的数组、被称为定型数组(Typed Array)的类数组对象，以及从非数组二进制数据中提取值的相关类;

- 正则表达式和 `RegExp` 类，这个类定义用于处理文本的文本模式

- 表示和操作日期与时间的 `Date` 类;

- `Error` 类及其子类，JS 程序在出错时会抛出这些类的实例;

- `JSON` 对象，其方法支持 JS 对象、数组、字符串、数值和布尔值等复合数据结构的序列化和反序列化;

- `Intl` 对象以及它定义的类，可用于 JS 程序本地化;

- `Console` 对象，其方法以各种方式输出字符串，对调试程序和记录程序行为特别有用

- `URL` 类，用于简化解析和操作 URL 的任务，也用于编码和解码 URL 及其组件的全局函数;

- `setTimeout()` 和用于指定在一段时间后再执行代码的相关函数。

### 11.1 集合与映射

JS 的 `Object` 类型是一种万能数据结构，可用于把字符串（对象的属性名）映射为任意值。当被映射的值是固定值（如 true）时，对象实际上是一组字符串。

对象在 JS 编程中经常被用作映射和集合，但却要受到对字符串约束的限制。另外，由于对象正常都会继承带名字（如 toString）的属性，而这些属性明显也不是为映射和集合而准备的。为此，ES6 新增了真正的 `Set` 和 `Map` 类。

#### 11.1.1 Set 类

集合就是一组值，与数组类似。但与数组不同的是，集合没有索引或顺序，也不允许重复：**一个值要么是集合的成员，要么不是；这个值不可能在一个集合中出现多次**。

可以使用 `Set()` 构造函数创建集合对象：

```js
let s = new Set(); // 一个新的、空集合
let t = new set([1, s]); // 一个有两个成员的新集合
```

`Set()` 构造函数的参数不一定是数组，但**必须是一个可迭代对象**（包括其他集合）：

```js
let t = new Set(s); // 一个复制了 s 元素的新集合
let unique = new Set('Mississippi'); //4 个元素："M" "i" "s" 和 "p"
```

集合的 `size` 属性类似数组的 `length` 属性，保存着集合包含多少个值：

```js
unique.size; // 4
```

集合不一定在创建时初始化，可以在创建之后再通过 `add()`、`delete()` 和 `clear()` 方法给它添加元素或从中删除元素。集合不能包含重复的值，因此添加集合中已经存在的值没有效果：

```js
let s = new Set(); // 创建空集合
s.size; // 0
s.add(1); // 添加一个数值
s.size; // 1。现在集合有了一个成员
s.add(1); // 再次添加相同的数值
s.size; // 1。大小并没有变
s.add(true); // 添加另一个值;注意，混合值的类型没间题
s.size; // 2
s.add([1,2,3]); // 添加一个数组值
s.size // 3。添加的是数组，而非数组的元素
s.delete(1) // true，成功删除元素1
s.size // 2：大小回到2
s.delete("test") // false："test"不是成员，删除失败
s.delete(true) // true：删除成功
s delete([1,2,3]) // false：集合中包含的是另一个数组
s.size // 1：集合中还有一个数组
s.clear() // 清空集合
s.size // 0
```

关于这段代码有几个地方需要着重说明一下：

- `add()` 方法接收一个参数，如果传入一个数组，它会把数组而不是数组的元素添加到集合中。`add()` 始终返回调用它的集合，因此如果想给集合添加多个值，可以连缀调用 `add()`，如 `s.add('a').add('b').add('c')`;

- `delete()` 方法一次也只删除一个集合元素。不过，与 `add()` 不同，`delete()` 返回一个布尔值。如果指定的值确实是一个集合成员，那么 `delete()` 删除它并返回 true；否则，`delete()` 什么也不做并返回 false。

- 集合成员是根据严格相等来判断是否重复的，类似于使用 `===` 操作符。给集合添加的是一个数组，而传给 `delete()` 方法的则是另一个不同的数组（尽管两个数组包含相同的元素）。如果真想删除第一个数组，必须传入该数组的引用。

实践中，使用集合时最重要的不是添加和删除元素，而是检查某个值是不是集合的成员。为此要使用 `has()` 方法：

```js
let oneDigitPrimes = new Set([2, 3, 5, 7]);
oneDigitPrimes.has(2); // true：2 是一位数字的素数
oneDigitPrimeshas.has(3); // true：3 也是
oneDigitPrimes.has(4); // false，4 不是素数
oneDigitPrimes.has('5'); // false："5" 不是数值
```

**集合专门为成员测试做了优化，无论集合有多少成员，`has()` 方法都非常快**。数组的 `includes()` 方法也执行成员测试，但其执行速度与数组大小成反比。因此，使用数组作为集合比使用真正的 `Set` 对象要慢得多。

`Set` 类是可迭代的，这意味着可以使用 `for/of` 循环枚举集合的所有元素:

```js
let sum = 0;
// 循环遍历一位数字的素数
for (let p of oneDigitPrimes) {
  sum += p; // 求它们的和
}
sum; // 17：2 + 3 + 5 + 7
```

因为 Set 对象是可迭代的，所以可以使用扩展操作符 `...` 把集合转换为数组或参数：

```js
[...oneDigitPrimes]; // [2, 3, 5, 7]：把集合转换为数组
Math.max(...oneDigitPrimes); // 7：把集合元素作为参数传给函数
```

集合经常被称为 “无序集合”，但对 JS 的 Set 类而言，这并不正确。JS 集合是无索引的：不能像对数组那样取得集合的第一个或第三个元素。但 JS 的 Set 类会记住元素的插入顺序，而且始终按该顺序迭代集合：第一个元素第一个迭代（假定之前没有删除它），刚刚添加的元素最后一个迭代。

除了可以迭代，Set 类也实现了一个 `forEach()` 方法，与数组的同名方法类似：

```js
let product = 1;
oneDigitPrimes.forEach((n) => {
  product * n;
});
product; // 210：2 * 3 * 5 * 7
```

> 数组的 `forEach()` 方法把数组索引作为回调函数的第二个参数。但集合没有索引，所以这个方法的 Set 类版本传给回调的第一个和第二个参数都是元素的值。

#### 11.1.2 Map 类

**Map 对象表示一组被称为键的值，其中每个键都关联着（或映射到）另一个值**。从某种角度看，映射类似数组，只不过它并不局限于用连续的整数作为键，而是允许使用任何值作为 “索引”。同样与数组类似，映射速度也很快：无论映射有多大，查询与某个键关联的值都很快（虽然没有通过索引访问数组那么快）。

可以使用 `Map()` 构造函数创建映射对象：

```js
let m = new Map(); // 创建一个新的、空映射

// 初始化新映射，包含字符串到数值的映射
let n = new Map([
  ['one', 1],
  ['two', 2]
]);
```

Map() 构造函数的可选参数应该是一个可迭代对象，产出值为包含两个元素的数组 `[key, value]`。实践中，这意味着如果想在创建映射时初始化它，通常需要把关联的键和值写成数组的数组的形式。不过，也可以使用 Map() 构造函数复制其他映射，或者从已有对象复制属性名和值：

```js
let copy = new Map(n); // 一个新映射，与映射 n 拥有相同的键和值
let o = { x: 1, y: 2 }; // 一个有两个属性的对象
let p = new Map(Object.entries(o)); // 相当于 new Map(["x", 1], ["y", 2])
```

创建 Map 对象后，可以使用 `get()` 方法和键来查询关联的值，使用 `set()` 方法添加新的键/值对。不过，映射是一组键，每个键关联一个值。这跟一组键/值对不完全一样。如果调用 `set()` 传入一个映射中已经存在的键，将会修改与该键关联的值，而不是添加新的键/值映射。除了 `get()` 和 `set()`，Map 类也定义了与 Set 类似的方法，包括检查映射中是否包含指定键的 `has()`、从映射中删除指定键（及其关联值）的 `remove()`、删除映射中所有键/值对的 `clear()` 和保存映射中有多少个键的 `size` 属性。

```js
let m = new Map(); // 开始先创建一个空映射
m.size; // 0：空映射，还没有键
m.set('one', 1); // 映射键 "one" 和值 1
m.set('two', 2); // 添加键 "two" 和值 2
m.size; // 2：现在映射有两个键
m.get('two'); // 2：返回与键 "two" 关联的值
m.get('three'); // undefined：这个键不存在
n.set('one', true); // 修改与已有的键关联的值
m.size; // 2：大小没有变
m.has('one'); // true：映射有键 "one"
m.has(true); // false:映射没有键 true
m.delete('one'); // true：键 "one" 存在且删除成功
m.size; // 1
m.delete('three'); // false：删除不存在的键失败
m.clear(); // 删除映射中所有的键和值
```

与集合的 `add()` 方法类似，映射的 `set()` 方法可以连缀调用：

```js
let m = new Map().set('one', 1).set('two', 2).set('three', 3);
m.size; // 3
m.get('two'); // 2
```

与集合一样，任何 JS 值都可以在映射中作为键或值。这包括 null、undefined 和 NaN，以及对象和数组等引用类型。同样与集合类一样，映射按照全等性而非相等性比较键。因此如果在映射中使用对象或数组作为键，那么这样的键与任何其他对象或数组都不一样，即便它们有完全一样的属性或元素：

```js
// 开始先创建一个空映射
let m = new Map();
m.set({}, 1); // 映射空对象到值
m.set({}, 2); // 映射另一个空对象到值
m.size; // 这个映射中有两个键
m.get({}); // undefined：但这个空对象不是映射的键
m.set(m, undefined); // 把映射自身映射到值 undefined
m.has(m); // true：m 是自己的一个键
m.get(m); // undefined：与 m 不是键时取得的值一样
```

映射对象是可迭代的，迭代的每个值是一个两个元素的数组，其中第一个元素是键，第二个元素是与该键关联的值。如果对映射对象使用扩展操作符，会得到一个数组的数组，就像传给 Map() 构造函数的一样。在使用 `for/of` 循环迭代映射时，习惯上通过解构赋值把键和值赋给不同的变量:

```js
let m = new Map([
  ['x', 1],
  ['y', 2]
]);
[...m]; // [['x', 1], ['y', 2]]
for (let [key, value] of m) {
  // 第一次迭代，键是 "x" 值是 1
  // 第二次迭代，键是 "y" 值是 2
}
```

与 Set 类一样，Map 类也是按照插入顺序迭代的，即迭代的第一个键/值对是最早添加到映射中的，最后一个键/值对是最晚添加的。

如果只想迭代映射的键或关联的值，可以使用 `keys()` 和 `values()` 方法。这两个方法返回的可迭代对象可用于按照插入顺序迭代键和值（另外，`entries()` 方法返回的可迭代对象用于迭代键/值对，与直接迭代映射一样）。

```js
[...m.keys()] // ['x', 'y']：只有键
[...m.values()] // [1, 2]：只有值
[...m.entries()] // [["x", 1], ["y", 2]：等价于 [...m]
```

映射也实现了 `forEach()` 方法，通过这个最早由 Array 类实现的方法也可以迭代映射：

```js
// 注意：是 (value, key) 而不是 (key, value)
m.forEach((value, key) => {
  // 第一次迭代，值是 1 键是 "x"
  // 第二次迭代，值是 2 键是 "y"
});
```

这里传给回调的参数值在前、键在后，而 for/of 循环则是键在前、值在后。可以把映射想象成一种通用数组，只不过整数索引被替换为任何键值。数组的 `forEach()` 方法是先传数组元素，后传数组索引。同样地，映射的 `forEach()` 方法也先传映射的值，后传映射的键。

#### 11.1.3 WeakMap 和 WeakSet

- **WeakMap**

  **WeakMap（弱映射）类是 Map 类的一个变体（不是子类），它不会阻止键值被当作垃圾收集**。垃圾收集是 JS 解释器收回内存空间的过程，凡是已经 “无法访问” 因而无法被程序使用的对象，都会被当作垃圾收回。常规映射对自己的键值保持着 “强” 引用，即使对它们的所有其他引用都不存在了，仍然可以通过映射访问这些键。相对而言，WeakMap 保持着对它们键值的 “弱” 引用，因此无法通过 WeakMap 访问这些键。也就是说，WeakMap 的存在并不妨碍它们的键值被回收。

  WeakMap() 构造函数与 Map() 构造函数类似，但 WeakMap 与映射则有明确区别：

  - WeakMap 的键必须是对象或数组，原始值不受垃圾收集控制，不能作为键。

  - WeakMap 只实现了 `get()`、`set()`、`has()` 和 `delete()` 方法。特别地，WeakMap 不是可迭代对象，所以没有定义 `keys()`、`values()` 和 `forEach()` 方法。如果 WeakMap 是可迭代的，那么它的键就是可访问的，也就谈不上 “弱” 了。

  - 类似地，WeakMap 没有实现 `size` 属性，因为弱映射的大小可能随着对象被当作垃圾收集而随时改变。

  **WeakMap 的主要用途是实现值与对象的关联而不导致内存泄漏**。例如，假设要写一个接收对象参数的函数，然后需要基于这个对象执行某些耗时操作。考虑到效率，会缓存计算后的值以备将来使用。如果使用 Map 对象实现这个缓存，就会阻止其中的对象被当作垃圾回收。而使用 WeakMap 则可以避免这个问题（使用一个[私有的 Symbol 属性](../JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.md#6103-符号作为属性名)直接在对象上缓存计算后的值通常也可以实现类似的效果）。

- **WeakSet**
  **WeakSet（弱集合）实现了一组对象，不会妨碍这些对象被作为垃圾收集**。WeakSet() 构造函数与 Set() 构造函数类似，但正如弱映射与映射一样，弱集合与集合也有着类似的区别：

  - WeakSet 不允许原始值作为成员。
  - WeakSet 只实现了 `add()`、`has()` 和 `delete()` 方法，而且不可迭代。
  - WeakSet 没有 `size` 属性。

  WeakSet 的使用场景不多，其主要应用场景与 WeakMap 类似。例如，如果想把一个对象标记（或标注）为具有特殊属性或类型，可以把它添加到一个 WeakSet 中。然后，无论在哪里，只要想检查该属性或类型，就可以测试该 WeakSet 是否包含相应成员。如果使用常规集合来保存这些被标记的对象，就会妨碍它们被当作垃圾收集，而使用 WeakSet 则没有这个问题。

### 11.2 定型数组与二进制数据

常规 JS 数组可以包含任意类型的元素，可以动态扩展或收缩。JS 实现进行了很多优化，因此 JS 数组在典型的使用场景下速度非常快。然而，这种数组与 C 和 Java 等较低级语言的数组类型还是有很大区别。

ES6 新增了定型数组（typed array），与这些语言的低级数组非常接近。定型数组严格来讲并不是数组（Array.isArray() 对它们返回 false），但它们实现了几乎所有数组方法，外加几个自己的方法。定型数组与常规数组存在如下几个非常重要的区别：

- 定型数组的元素全部都是数值。与常规 JS 数组不同，定型数组允许指定存储在数组中的数值的类型（有符号和无符号数组以及 IEEE-754 浮点数）和大小（8 位到 64 位）。

- 创建定型数组时必须指定长度，且该长度不能再改变。

- 定型数组的元素在创建时始终都会被初始化为 0。

#### 11.2.1 定型数组的类型

JS 并未定义 TypedArray 类，而是定义了 11 种定型数组，每种都有自己类型和构造函数：

| 构造函数            | 数值类型                         |
| ------------------- | -------------------------------- |
| Int8Array()         | 有符号字节                       |
| Uint8Array()        | 无符号字节                       |
| Uint8ClampedArray() | 无符号字节（上溢不归零）         |
| Int16Array()        | 有符号 16 位短整数               |
| Uint16Array()       | 无符号 16 位短整数               |
| Int32Array()        | 有符号 32 位整数                 |
| Uint32Array()       | 无符号 32 位整数                 |
| BigInt64Array()     | 有符号 64 位 Bigint 值（ES2020） |
| BigUint64Array()    | 无符号 64 位 Bigint 值（ES2020） |
| Float32Array()      | 32 位浮点值                      |
| Float64Array()      | 64 位浮点值：常规 JS 数值        |

名字以 Int 开头的类型保存有符号 1、2、4 字节（8、16、32 位）整数。名字以 Uint 开头的类型保存相同长度的无符号整数。Bigint 和 BigUnit 类型保存 64 位整数，以 JS 的 BigInt 值表示。名宇以 Float 开头的类型保存浮点数。Float64Array 的元素与常规 JS 数值是同一种类型。Float32Array 的元素精度较低、表示的范围也较小，但只占用一半内存（这个类型对应 C 和 Java 中的 float）。

Uint8ClampedArray 是 Uint8Array 的一种特殊变体。这两种类型都保存无符号字节，可表示的数值范围是 0 到 255。对 Unit8Array 来说，如果要存储到数组元素的值大于 255 或小于 0，这个值会“翻转”为其他值。这涉及计算机内存的底层工作机制，速度非常快。Unit8ClampedArray 还会额外做一些类型检查，如果要存储的值大于 255 或小于 0，那它会 “固定” 为 255 或 0，而不会翻转（这种固定行为对 HTML `<canvas>` 元素的低级 API 操作像素颜色是必需的）。

> 上面每种定型数组构造函数都有一个 `BYTES_PER_ELEMENT` 属性，根据类型不同，这个属性的值可能是 1、2、4、8。

#### 11.2.2 创建定型数组

- 创建定型数组最简单的方式就是调用相应的构造函数，并传入一个表示数组元素个数的数值参数：

  ```js
  let bytes = new Unit8Array(1024); // 1024 字节
  let matrix = new Float64Array(9); // 3 x 3 矩阵
  let point = new Int16Array(3); // 3D 空间中的一个点
  let rgba = new Uint8ClampedArray(4); // 4 字节的 RGBA 像素值
  let sudoku = new Int8Array(81); // 9 x 9 的数独网格
  ```

  如果以这种方式创建定型数组，则数组元素一定会全部初始化为 0、0n 或 0.0。不过假如知道想要通过定型数组保存的值，也可以在创建它们时指定这些值。每种定型数组构造函数都有静态的工厂方法 `from()` 和 `of()`，类似于 `Array.from()` 和 `Array.of()`：

  ```js
  let white = Uint8ClampedArray.of(255, 255, 255, 0); // RGBA 不透明白色
  ```

- `Array.from()` 工厂方法期待一个类数组或可迭代对象作为其第一个参数。定型数组的这个方法也一样，但期待这个可迭代或类数组对象还必须拥有数值类型的元素。比如，字符串是可迭代的，但把字符串传给 `from()` 工厂方法显然不妥。

  如果只使用带一个参数的 `from()`，可以把 `.from` 去掉而直接把可迭代或类数组对象传给构造函数，结果完全相同。

  > **注意**：构造函数和 `from()` 工厂方法都支持复制已有的定型数组，尽管类型可能会改变：

  ```js
  let ints = Uint32Array.from(white); // 同样 4 个数值，但变成了整数
  ```

  在通过已有数组、可迭代或类数组对象创建新定型数组时，为适应类型限制，已有的值可能被截短。在此过程中，不会有警告，也不会报错：

  ```js
  // 浮点数被截短为整数，长整数被截短为 8 位
  Uint8Array.of(1.23, 2.99, 45000); // new Uint8Array([1, 2, 200])
  ```

- 还有一种创建定型数组的方式，该方式要用到 `ArrayBuffer` 类型。`ArrayBuffer` 是对一块内存的不透明引用。可以通过构造函数创建 ArrayBuffer，只要传入想分配内存的字节数即可：

  ```js
  let buffer = new ArrayBuffer(1024 * 1024);
  buffer.byteLength; // 1024*1024，1兆内存
  ```

  ArrayBuffer 类不允许读取或写入分配的任何字节。但是可以创建使用该缓冲区内存的定型数组，通过这个数组来读取或写入该内存。为此，在调用定型数组的构造函数时需要将 ArrayBuffer 作为第一个参数，将该缓冲区内的字节偏移量作为第二个参数，将数组的长度（单位是元素而非字节）作为第三个参数。第二个参数和第三个参数是可选的。如果省略第二个和第三个参数，则数组会使用缓冲区的所有内存。如果只省略长度参数，则数组会使用从起点位置到缓冲区结束的所有可用内存。关于这种形式的定型数组构造函数，还要记住一点：数组的内存必须是对齐的，所以如果指定了字节偏移量，那么这个值应该是类型大小的倍数。例如，Int32Array() 构造函数要求必须是 4 的倍数，而 Float64Array() 则要求必须是 8 的倍数。

  以前面创建的 ArrayBuffer 为例，可以像下面这样创建定型数组：

  ```js
  let asbytes = new Uint8Array(buffer); // 按字节查看
  let asints = new Int32Array(buffer); // 按 32 位有符号整数查看
  let lastK = new Uint8Array(buffer, 1023 * 1024); // 按字节查看最后 1 千字节
  let ints2 = new Int32Array(buffer, 1024, 256); // 按 256 位整数查看第二个 1 千字节
  ```

  这 4 个定型数组提供了对 ArrayBuffer 所表示内存的 4 个不同视图。关键是要知道，所有定型数组底层都有 ArrayBuffer，即便没有明确指定。如果调用定型数组构造函数时没有传缓冲区对象，则会自动以适当大小创建一个缓冲区。所有定型数组都有一个 `buffer` 属性，引用自己底层的 ArrayBuffer 对象。之所以需要直接使用 ArrayBuffer 对象，是因为有时候可能需要一个缓冲区的多个定型数组视图。

#### 11.2.3 使用定型数组

创建定型数组后，可以通过常规的中括号语法读取或写入其元素，与操作其他类数组对象一样：

```js
// 返回小于 n 的最大素数，使用埃拉托斯特尼筛法
function sieve(n) {
  let a = new Uint8Array(n + 1); // 如果 x 是合数，a[x] 等于 1
  let max = Math.floor(Math.sqrt(n)); // 不分解大于这个数的数
  let p = 2; // 2 是第一个素数
  // 对小于 max 的素数
  while (p <= max) {
    // 将 p 的倍数标记为合数
    for (let i = 2 * p; i <= n; i += p) a[i] = 1;
    while (a[++p]); /*空循环*/ // 下一个未标记的索引是素数
  }
  while (a[n]) n--; // 向后循环查找最后一个素数
  return n; // 返回它
}
```

这个函数用于计算小于指定数值的最大素数。代码中如果使用常规 JS 数组也没问题，但使用 Uint8Array() 而非 Array() 可以让代码快 4 倍以上，且占用内存少 8 倍。

定型数组并不是真正的数组，但它们重新实现了多数数组方法，因此几乎可以像使用常规数组一样使用它们：

```js
let ints = new Int16Array(10); // 10个短整数
ints
  .fill(3)
  .map((x) => x * x)
  .join(''); // 9999999999
```

记住，定型数组的长度是固定的，因此 length 属性是只读的，而定型数组并未实现改变数组长度的方法（如 push()、pop()、unshift()、shift() 和 splice()），但实现了修改数组内容而不改变长度的方法（如 sort()、 reverse() 和 fill()）。诸如 map() 和 slice() 等返回新数组的方法，则返回与调用它们的定型数组相同类型的数组。

#### 11.2.4 定型数组的方法与属性

除了标准的数组方法，定型数组也实现了它们自己的一些方法。其中，`set()` 方法用于一次性设置定型数组的多个元素，即把其他常规数组或定型数组的元素复制到当前定型数组中：

```js
let bytes = new Uint8Array(1024); // 1K 缓冲区
let pattern = new Uint8Array([0, 1, 2, 3]); // 4 字节的数组
bytes.set(pattern); // 把它们复制到另一个字节数组的开头
bytes.set(pattern, 4); // 使用不同的偏移量再复制一次
bytes.set([0, 1, 2, 3], 8); // 或者直接从一个常规数组复制值
bytes.slice(0, 12); // new Uint8Array([0,1,2,3,0,1,2,3,0,1,2,3])
```

`set()` 方法以一个数组或定型数组作为其第一个参数，以一个元素偏移量作为其可选的第二个参数，如果不指定则默认为 0。如果是从一个定型数组向另一个定型数组复制值，那么操作可能极快。

定型数组也有一个 subarray 方法，返回调用它的定型数组的一部分：

```js
let ints = new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); // 10 个短整数
let last3 = ints.subarray(ints.length - 3, ints.length); // 其中最后 3 个
last3[0]; // 7：与 ints[7] 相同
```

subarray() 接收与 slice() 方法相同的参数，而且看起来行为方式也相同。但有一点重要区别：slice() 以新的、独立的定型数组返回指定的元素，不与原始数组共享内存；而 subarray() 则不复制内存，只返回相同底层值的一个新视图：

```js
ints[9] = -1; // 修改原始数组中的一个值
last3[2]; // -1：子数组中也会反映这个变化
```

说到 subarray() 方法返回已有数组的新视图，就要再次提到 ArrayBuffer 每个定型数组都有 3 个属性与底层的缓冲区相关：

```js
last3.buffer; // 定型数组的 ArrayBuffer 对象
last3.buffer === ints.buffer; // true：都是同一个缓冲区的视图
last3.byteOffset; // 14：这个视图从缓冲区的字节 14 开始
last3.byteLength; // 6：这个视图长度为 6 字节（3 个 16 位整数长）
last3.buffer.byteLength; // 20：但底层缓冲区长度为 20 字节
```

`buffer` 属性是数组的 ArrayBuffer，`byteOffset` 是数组数据在这个底层缓冲区的起点位置，而 `byteLength` 是数组数据的字节长度。对于任何定型数组 a，以下不变式都成立：

```js
a.length * a.BYTES_PER_ELEMENT === a.byteLength; //  true
```

ArrayBuffer 只是不透明的字节块。通过定型数组可以访问其中的字节，但 ArrayBuffer 本身并不是定型数组。

> **注意**：可以像对任何 JS 对象一样对 ArrayBuffer 使用数值索引。但这样做并不会访问缓冲区中的字节，只会导致难解的 bug。

```js
let bytes = new Uint8Array(8);
bytes[0] = 1; // 将第 1 个字节设置为 1
bytes.buffer[0]; // undefined：缓冲区没有索引 θ
bytes.buffer[1] = 255; // 尝试错误地设置缓冲区的字节
bytes.buffer[1]; // 255：实际上这只是设置了一个常规 JS 属性
bytes[1]; // 0：上面那一行并未设置字节
```

可以通过 ArrayBuffer() 构造函数创建 ArrayBuffer，然后再使用这个缓冲区来创建定型数组。另一种方式是先创建一个初始化的定型数组，然后使用该数组的缓冲区创建其他视图：

```js
let bytes = new Uint8Array(1024); // 1024 字节
let ints = new Uint32Array(bytes.buffer); // 或者 256 个整数
let floats = new Float64Array(bytes.buffer); // 或者 128 个双精度浮点数
```

#### 11.2.5 Date View 与字节序

使用定型数组可以查看相同字节序列的 8、16、32 或 64 位视图。这就涉及 “字节序” 问题了。所谓**字节序，就是多个字节排列为更长机器字的顺序**。为效率考虑，定型数组使用底层硬件的原生字节序。在小端系统中，ArrayBuffer 中的字节排列顺序为低字节到高字节。在大端系统中，字节排列顺序为高字节到低字节。可以使用以下代码确定底层平台的字节序：

```js
// 如果整数 0x000001 在内存中排列为 01 00 00 00，则底层平台使用小端字节序。在大端字节序平台中，看到的字节排列应该是 00 00 00 01
let littleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;
```

今天，市面上常见的 CPU 都是小端字节序。很多网络协议及某些二进制文件格式则要求使用大端字节序。如果定型数组要使用来自网络或文件的数据，可以假定平台字节序与数据字节序一致。通常，在使用外部数据时，可以使用 Int8Array 和 Uint8Array 来查看数组中的单个字节，但不应该使用字大小为多字节的其他定型数组。此时，可以使用 DataView 类，这个类定义的方法可以显式指定读、写 ArrayBuffer 值时的字节序：

```js
// 假设要处理一个二进制字节的定型数组
// 首先，创建 DataView 对象，以便从字节中灵活地读取值
let view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
let int = view.getInt32(0); // 从字节开始按大端字节序读取有符号整数
int = view.getInt32(4, false); // 下一个整数还是大端字节序
int = view.getUnit32(8, true); // 下一个整数是小端字节序且无符号
view.setUint3(8, int, false); // 将其以大端字节序写回缓冲区
```

DataView 为 10 种定型数组类（不包括 Uint8ClampedArray）定义了 10 个 get 方法。这些方法的名字类似 getInt16、getUnit32()、getBigInt64() 和 getFloat64()。它们的第一个参数是 ArrayBuffer 中的字节偏移量，表示读取值的开始位置。所有这些读取方法（除 getInt8() 和 getUint8() 之外）都接收一个可选的布尔值作为第二个参数。如果第二个参数被省略或是 false，则使用大端字节序。如果第二个参数是 true，则使用小端字节序。

DataView 也定义了 10 个对应的设置方法，用于向底层 ArrayBuffer 写入值。这些方法的第一个参数是偏移量，表示写入值的开始位置。其中每个方法（除 setInt8() 和 setUnit8()之外）都接收一个可选的第三个参数。如果这个参数被省略或是 false，则以大端字节序格式写入值，即最高有效字节在前。如果这个参数是 true，则以小端字节序格式写入值，即最低有效字节在前。

> 定型数组和 DataView 提供了处理二进制数据所需的全部工具，可以编写能够解压 ZIP 文件或者从 JPEG 文件中提取元数据之类的 JS 程序。

### 11.3 正则表达式与模式匹配

正则表达式是一种描述文本模式的对象。JS 的 RegExp 类表示正则表达式，String 和 RegExp 都定义了使用正则表达式对文本执行强大模式匹配和搜索替换功能的方法。

#### 11.3.1 定义正则表达式

在 JS 中，正则表达式通过 RegExp 对象来表示。RegExp 对象可以使用 RegExp() 构造函数来创建，但更多的是通过一种特殊的字面量语法来创建。正则表达式字面量就是包含在一对斜杠（`/`）字符之间的字符。因此，可以在 JS 代码中这样声明一个正则表达式：

```js
let pattern = /s$/;
```

这行代码创建了一个新的 RegExp 对象，并将它赋值给变量 pattern。这个特殊的 RegExp 对象匹配任意以字母 “s” 结尾的字符串。同样的正则表达式也可以使用 RegExp() 构造函数像下面这样来创建：

```js
let pattern = new RegExp('s$');
```

正则表达式模式由一系列字符构成。多数字符，包括所有字母数字字符，都只用来描述直接匹配的字符。正则表达式中还有一些字符并不直接匹配字符本身，而是具有特殊的含义。例如，正则表达式 `/s$/` 包含两个字符，第一个 “s” 匹配自身，而第二个 “$” 就是一个特殊字符，匹配字符串的末尾。因此，这个正则表达式就匹配任何以字母 “s” 作为最后一个字符的字符串。

正则表达式也支持一个或多个标志字符，用于控制匹配的方式。在正则表达式字面量中，标志需要放在第二个斜杠字符后面，在 RegExp() 构造函数中，标志要作为第二个字符串参数。比如，要匹配以 “s” 或 “S” 结尾的字符串，可以给正则表达式添加标志，表示希望匹配不区分大小写：

```js
let pattern = /s$/i;
```

**字面量字符**
所有字母字符和数字在正则表达式中都匹配自身的字面值。JS 正则表达式语法通过以反斜杠（`\`）开头的转义序列也支持一些非字母字符。例如，`\n` 匹配字符串中换行字符的字面值。

表 11-1：则表达式字面量字符

| 字符         | 匹配目标                                                                                                                            |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| 字母数字字符 | 自身                                                                                                                                |
| \0           | NUL 字符（\u0000）                                                                                                                  |
| \t           | 制表符（\u0009）                                                                                                                    |
| \n           | 换行符（\000A）                                                                                                                     |
| \v           | 垂直制表符（\u000B）                                                                                                                |
| \f           | 进纸符（\u000C）                                                                                                                    |
| \r           | 回车符（\u000D）                                                                                                                    |
| \xnn         | 十六进制数值 nn 指定的拉丁字符。例如，\x0A 等同于 \n                                                                                |
| \uxxxx       | 十六进制数值 xxxx 指定的 Unicode 字符。例如，\u0009 等同于 \t                                                                       |
| \u{n}        | 码点 n 指定的 Unicode 字符，其中 n 是介于 0 到 10FFFF 之间的 1 到 6 个十六进制数字。注意，这种语法仅在使用 u 标志的正则表达式中支持 |
| \cX          | 控制字符 ^X。例如，\cJ 等价于换行符 \n                                                                                              |

有一些英文标点符号在正则表达式中具有特殊含义，它们是：

```text
^ $ . * + ? = !  : | \ / () [] {}
```

其中有的字符只在正则表达式的特定上下文中具有特殊含义，在其他上下文中仍然按字面值对待。但作为一个通用的规则，如果想在正则表达式中包含这些标点符号的字面值，必须在这些字符前面加个反斜杠（`\`）。其他标点
符号字符，如引号和 `@`，在正则表达式不具有特殊含义，仅匹配自身的字面值。

> **注意**：如果使用 RegExp() 构造函数，正则表达式中的任何反斜杠都要写两次，因为字符串也使用反斜杠作为转义字符。

**字符类**
把个别字面值字符放到方括号中可以组合成字符类。字符类匹配方括号中包含的任意字符。因此，正则表达式 `/[abc]/` 匹配 a、b 或 c 中的任意一个字母。也可以定义排除性的字符类，匹配除方括号中包含的字符之外的任意字符。排除性字符类就是把插入符号（`^`）作为方括号中的第一个字符。如正则表达式 `/[^abc]/` 匹配除 a、b 和 c 之外的任意一个字符。

字符类可以使用连字符表示字符范围。要匹配拉丁字母表中的任意一个小写字母，可以使用 `/[a-z]/` （如果想通过字符类匹配真正的连字符，只要把它放到右方括号前面，作为作为字符类的最后一个字符即可）。

某些字符类很常用，JS 正则表达式语法中包含一些特殊字符和转义序列来表示这些字符类。例如，`\s` 匹配空格字符、制表字符和其他 Unicode 空白字符。而 `\S` 匹配任何非 Unicode 空白字符。表 11-2 列出了这些特殊字符并总结了字符类语法（注意，其中一些字符类转义序列只匹配 ASCII 字符，目前尚未扩展到匹配 Unicode 字符。不过，要匹配 Unicode 字符，也可以自己定义 Unicode 宇符类。例如，要匹配任何西里尔字母，可以定义 Unicode 字符类 `/[u0400-\u04FF]/`）。

表 11-2：正则表达式字符类

| 字符     | 匹配目标                                                                                               |
| -------- | ------------------------------------------------------------------------------------------------------ |
| `[...]`  | 方括号中的任意一个字符                                                                                 |
| `[^...]` | 不在方括号中的任意一个字符                                                                             |
| .        | 除换行或其他 Unicode 行终止符之外的任意字符。如果 RegExp 使用 s 标志，则句点匹配任意字符，包括行终止符 |
| \w       | 任意 ASCII 单词字符。等价于 `[a-zA-Z0-9_]`                                                             |
| \W       | 任意非 ASCI 单词字符。等价于 `[^a-zA-Z0-9_]`                                                           |
| \s       | 任意 Unicode 空白字符                                                                                  |
| \S       | 任意非 Unicode 空白字符                                                                                |
| \d       | 任意 ASCII 数字字符。等价于 `[0-9]`                                                                    |
| \D       | 任意非 ASCII 数字字符。等价于 `[^0-9]`                                                                 |
| [\b]     | 退格字符字面值（特例）                                                                                 |

> **注意**：所有特殊字符类转义序列本身也可以出现在方括号中。`\s` 匹配任意空白字符，而 `\d` 匹配任意数字，所以 `/[\s\d]/` 匹配任意空白字符或数字。不过有一个特例，即 `\b` 转义序列有一个特殊含义。如果出现在字符类中，`\b` 表示退格字符。因此要在正则表达式中表示一个退格字符的字面值，就要使用只包含一个元素的字符类: `/[\b]/`。

**Unicode 字符类**
在 ES2018 中，如果正则表达式使用了 `u` 标志，则支持字符类 `\p{...}` 及其排除性形式 `\P{^...}`。这些字符类建立在 Unicode 标准定义的属性基础之上，它们表示的字符集可能随着 Unicode 标准的发展而变化。

`\d` 字符类只匹配 ASCII 数字。如果想从世界书写体系中匹配一个十进制数字，可以使用 `/\p{Decimal_Number}/u`。如果想匹配任意语言中的非十进制数字，可以大写 p，即写成 `/P{Decimal_Number}/u`。如果想匹配任意类数值字符，包括分数和罗马数字以使用 `/p{Number}/`。

> **注意**：“Decimal Number” 和 “Number” 并非 JS 或正则表达式语法特有的，它们是 Unicode 标准定义的字符类别的名字。

`\w` 字符类只匹配 ASCII 文本，但使用可以模拟一个这样的国际化版本：

```js
/[\p{Alphabetic}\p(Decimal_Number)\p{Mark}]/u;
```

如果真要完全兼容世界上各式各样的语言，其实还需要添加 “Connector_Punctuation” 和 “Join_Control” 两个分类。

最后一个例子要展示的是 `\p` 语法也支持定义匹配特定字母表或文字（script）中字符的正则表达式：

```js
let greekLetter = /\p{Script=Greek}/u;
let cyrillicLetter = /\p{Script=Cyrillic}/u;
```

**重复**
指定重复的字符始终跟在应用它们的模式后面。由于某些重复的形式非常常用，还会有特殊字符表示这些情况。例如，`+` 表示前面的模式出现一次或多次的情形。

表 11-3：正则表达式重复字符

| 字符   | 含义                                                   |
| ------ | ------------------------------------------------------ |
| {n, m} | 匹配前项至少 n 次，但不超过 m 次                       |
| {n,}   | 匹配前项 n 或更多次                                    |
| {n}    | 匹配前项恰好 n 次                                      |
| `?`    | 匹配前项零或一次。换句话说，前项是可选的。等价于{0，1} |
| `+`    | 配前项一或多次。等价于 {1,}                            |
| `*`    | 匹配前项零或多次。等价于 {0,}                          |

**非贪婪重复**
表 11-3 中列出的重复字符会尽可能多地匹配，同时也允许正则表达式剩余的部分继续匹配。这种重复是 “贪婪的”。在重复字符后面简单地加个问号，就可以指定非贪婪地重复，如 `??`、`+?`、`*?`，甚至 `{1, 5}?`。举个例子，正则表达式 `/a+/` 匹配一个或多个字母 “a”。在应用到字符串 “aaa” 时，它匹配全部 3 个字母。`/a+?/` 同样也匹配一个或多个字符“a”，但在应用到字符串“a”时，它只匹配第一个字母 “a”。

使用非贪婪重复不一定总能得到期待的结果。比如模式 `/a+b/` 匹配一个或多个 “a” 后跟字母 “b”。在应用到字符串 “aaab” 时，它匹配整个字符串。而使用非贪婪版本的 `/a+?b/` 时似乎应该匹配字母 “b” 前面有最少的字母“a”。在应用到同样的字符串 “aaab” 时，本意是希望它只匹配一个 “a” 和最后的字母 “b”。但事实上，这个模式也会匹配整个字符串，与贪婪的版本一样。这是因为正则表达式模式的匹配会从字符串的第一个位置开始査找匹配项。由于在字符串一开始就找到了匹配项，所以从后续字母开始的更短的匹配项就不在考虑之列了。

**任选、分组和引用**
正则表达式的语法中也包含指定任选、分组子表达式和引用前面子表达式的特殊字符。竖线字符 `|` 用于分隔任选模式。例如，`/abcd|ef/` 匹配字符串 “ab” 或字符串 “cd” 或字符串 “ef”。而 `/\d{3}|[a-z]{4}/` 匹配 3 个数字或 4 个小写字母。

> **注意**：在找到匹配项之前，会从左到右依次适配任选模式。如果左边的任选模式匹配，则忽略右边的模式，即使右边的模式可以得到 “更好” 的匹配。比如，模式 `/a|ab/` 应用到字符串 “ab” 只会匹配字母 “a”。

圆括号在正则表达式中有几种不同的作用：

- **把独立的模式分组为子表达式**
  从而让这些模式可以被 `|`、`*`、`+`、`?` 等当作一个整体。例如，`/java(script)?/` 匹配 “java” 后跟可选的 “script”。而 `/(ab|cd)+|ef/` 匹配字符串 “ef”，也匹配一个或多个字符串 "ab” 或 “cd”。

- **在完整的模式中定义子模式**
  当正则表达式成功匹配一个目标字符串后，可以从目标字符串中提取出与圆括号包含的子模式对应的部分。例如，假设要查找一个或多个小写字母后跟一个或多个数字。可以使用模式 `/[a-z]+\d+/`。但假设只关心每个匹配项中的数字部分。如果把匹配数字的模式放到一对圆括号中 `/[a-z]+(\d+)/`，那么就可以从整个模式的匹配项中提取出相应的数字。

- **与圆括号分组的子表达式相关的一个用途是在同一个正则表达式中回引子表达式**
  回引前面的子表达式要使用 `\` 字符加上数字。这里的数字指的是圆括号分组的子表达式在整个正则表达式中的位置。例如，`\1` 回引第一个子表达式，`\3` 回引第三个。

  > **注意**：由于子表达式可能会嵌套，所以它们的位置是按照左括号来计算的。例如，在下面的正则表达式中，嵌套的子表达式 `([Ss]cript)` 要使用 `\2` 来引用：

  ```js
  /([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/;
  ```

  对正则表达式中前面子表达式的引用并不会引用该子表达式的模式，而是会引用该模式匹配的文本。因此，引用可以用来强制字符串中不同的部分包含完全相同的字符。例如，下面的正则表达式匹配位于一对单或双引号间的一个或多个字符。但是，它不要求开始和结尾的引号匹配（即必须都是单引号或都是双引号）：

  ```js
  /['"][^'"]*['"]/;
  ```

  如果想要求引号必须匹配，可以使用引用：

  ```js
  /(['"])[^'"]*\1/;
  ```

  这个 `\1` 匹配第一个圆括号分组的子表达式匹配的内容。在这个例子中，它强制结尾的引号必须匹配开始的引号。这个正则表达式不允许双引号字符串中出现单引号或者单引号字符串中出现双引号（**在字符类中使用引用是不合法的**，因此不能这么写: `/(['"])[^\1]*\1/`。这种对圆括号分组子表达式的引用在正则表达式搜索替换操作中是非常强大的特性。

  如果不想让圆括号分组的子表达式生成数字引用，那么可以不用 `(` 和 `)` 分组，而是开头用 `(?:`，结尾用 `)`。来看下面的模式：

  ```js
  /([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/;
  ```

  在这个例子中，子表达式 `(?:[Ss]cript)` 仅仅是一个分组，从而让 `?` 重复字符可以应用到该组。这样修改后的圆括号不会产生引用，因此在这个正则表达式中 `\2` 引用的是 `(fun\w*)` 匹配的文本。

表 11-4 总结了正则表达式的任选、分组和引用操作符。

表 11-4：正则表达式任选、分组和引用字符

| 字符    | 含义                                                                                                                                   |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `\|`    | 任选：可以匹配左侧的子表达式，也可以匹配右侧的子表达式。                                                                               |
| (...)   | 分组：将模式分组为一个单元，以便使用 `*`、`+`、`?`、`\|` 等。同时记住与分组匹配的字符，以便在后面的引用中使用                          |
| (?:...) | 仅分组：将模式分组为一个单元，但不记住分组匹配的字符                                                                                   |
| \n      | 匹配与第 n 个分组匹配的相同字符。分组是圆括号（可能嵌套）中的子表达式。分组编号是按照左圆括号从左到右计数的。由 `(?:` 开头的分组不计数 |

**命名捕获组**
ES2018 标准化了一个新特性，让正则表达式可以自我解释且更容易理解。这个新特性被称为 “命名捕获组”（named capture group），即可以给正则表达式中的每个左圆括号指定一个关联的名字，以便后面使用这个名字而不是数字来引用匹配的文本。使用名字可以让阅读代码的人更容易理解正则表达式中该部分的用途。

要命名一个分组，使用 `(?<...>`，把分组的名字放在尖括号内。例如，下面这个正则表达式可以用来检查美国邮件地址最后一行的格式：

```js
/(?<city>\w+) (?<state>[A-Z]{2}) (?<zipcode>\d{5})(?<zip9>-\d{4})?/;
```

> **注意**：分组的名字为正则表达式提供了很多上下文信息，让它变得更容易理解了。

如果想在正则表达式中回引某个命名捕获组，可以使用名字。在前面的例子中，可以使用正则表达式的 “反向引用” 来写一个 RegExp，让它匹配单引号或双引号字符串，同时两头的引号也必须匹配。使用命名捕获组和命名反向引用，也可以把该 RegExp 重写为这样：

```js
/(?<quote>['"])[^'"]*\k<quote>/;
```

这里的 `\k<quote>` 是一个命名反向引用，引用捕获开引号的命名分组。

**命名捕获组的解构赋值和替换**
有了命名捕获组以后，可以使用解构赋值直接从匹配结果上为变量赋值：

```js
let {
  groups: { one, two }
} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');
one; // foo
two; // bar
```

字符串替换时，使用 `$<组名>` 引用分组：

```js
let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;
'2021-08-12'.replace(re, '$<day>/$<month>/$<year>'); // 08/12/2021
```

上面代码中，`replace()` 的第二个参数是一个字符串，而不是正则表达式。`repalce()` 的第二个参数也可以是函数：

```js
'2021-08-12'.replace(
  re,
  (
    matched, // 整个匹配结果 2021-08-12
    capture1, // 第一个组匹配 2021
    capture2, // 第二个组分配 08
    capture3, // 第三个组分配 12
    position, // 匹配开始的位置 0
    S, // 原字符串 2021-08-12
    groups // 命名捕获组构成的一个对象 {year, month, day}
  ) => {
    let { day, month, year } = groups;
    return `${day}/${month}/${year}`;
  }
);
```

命名捕获组在原来的基础上新增了最后一个函数参数：分组构成的一个对象。

**指定匹配位置**
正则表达式的很多组件匹配字符串中的一个字符。还有一些正则表达式组件匹配字符间的位置而非实际的字符。例如，`\b` 匹配 ASCII 词边界，即 `\w`（ASCII 单词字符）与 `\W`（非单词字符）的边界，或者 ASCII 单词字符与字符串开头或末尾的边界。像 `\b` 这样的组件并不表示匹配的字符串中用到的任何字符，它们表示的是匹配可以发生的合法位置。有时候，这些组件也被称作正则表达式锚点，因为它们把模式锚定到被搜索字符串中特定的位置。最常用的锚点组件是 `^` 和 `$`，分别把模式锚定字符串开头和末尾的位置。

例如，要匹配独占一行的 “JavaScript” 字符串，可以使用正则表达式 `/^JavaScript$/`。如果想搜索 “Java” 这个单词（不是作为前缀，因为它在 “JavaScript” 中），可以使用模式 `/\sava\s/`，即单词前后必须有一个空格。但这个方案存在两个问题。首先，它不匹配位于字符串开头或末尾的 “Java”，只匹配两侧有空格的情况。其次，在这个模式找到匹配项之后，返回的匹配字符串前后都会带空格，这通常并不是想要的。为此，可以把匹配实际空格的 `\s` 替换成匹配（或锚定）词边界的 `\b`：`/\bJava\b/`。相应地，组件 `\B` 锚定与非词边界匹配的位置。换句话说，模式 `/\B[Ss]cript/` 匹配 “JavaScript” 和 “postscript"，但不匹配 “script” 或 “Scripting”。

可以使用任意正则表达式作为锚定条件。如果在 `(?=` 和 `)` 字符之间包含一个表达式，因为这些字符构成向前查找断言，所以就意味着其中的字符必须存在，但并不实际匹配。比如，要匹配常用编程语言的名字，但必须后面跟着一个冒号，可以使用 `/[Jj]ava([Ss]cript)?(?=\:)/`。这个模式匹配 “JavaScript: The Definitive Guide” 中的 “JavaScript”，但不匹配 “Java in a nutshell” 中的 “Java”，因为它的后面没有冒号。

如果把前面提到的断言改为以 `(?!` 开头，那就变成了否定式向前查找断言，表示必须不存在断言中指定的字符。例如，`/Java(?!Script)([A-Z]\w*)/` 匹配 “Java” 后跟一个大写字母及任意数量的 ASCII 单词字符，但 “Java” 后面必须不能是 “Script”。因此它匹配 “JavaBeans”，不匹配 “Javanese”，匹配 “JavaScrip”，不匹配 “JavaScript” 或 “JavaScripter”。表 11-5 总结了正则表达式锚点字符。

表 11-5：正则表达式锚点字符

| 字符  | 含义                                                                                                                |
| ----- | ------------------------------------------------------------------------------------------------------------------- |
| ^     | 匹配字符串开头，或者在使用 m 标志时，匹配一行的开头                                                                 |
| $     | 匹配字符串末尾，或者在使用 m 标志时，匹配一行的末尾                                                                 |
| \b    | 匹配单词边界。换句话说，匹配 \w 字符和 \W 字符之间或 \w 与字符串开头或末尾之间的位置（但要注意，[\b] 匹配退格字符） |
| \B    | 匹配非单词边界的位置                                                                                                |
| (?=p) | 肯定式向前查找断言。要求后面的字符匹配模式 p，但匹配结果不包含与之匹配的字符                                        |
| (?!p) | 否定式向前查找断言。要求后面的字符不匹配模式 p                                                                      |

**向后查找断言**
ES2018 扩展了正则表达式语法，支持 “向后查找” 断言。向后查找断言与向前查找断言类似，但关注的是当前匹配位置之前的文本。肯定式向后查找断言使用 `(?<=...)`，否定式向后查找断言使用 `(?<!...)`。例如，要搜索美国邮件地址，希望从中匹配 5 位邮政编码，但仅限于前面是两位字母的州简写的情况，可以这样写：

```js
/(?<= [A-Z]{2} )\d{5}/;
```

而要匹配前面不带 Unicode 货币符号的数字字符串，可以像下面这样使用否定式向后断言：

```js
/(?<![\p{Currency_Symbol}\d.])\d+(\.\d+)?/u;
```

**标志**
每个正则表达式都可以带一个或多个标志，用于修改其行为。JS 定义了 6 个标志，每个标志都用一个字母表示。标志在正则表达式字面量中放在第二个斜杠后面，或者在使用 RegEXp() 构造函数时要以字符串形式作为第二个参数。JS 正则表达式支持的标志及含义如下所示：

- **g**
  g 标志表示正则表达式是 “全局性的”（global），换句话说，使用这个标志意味着想要找到字符串中包含的所有匹配项，而不只是找到第一个匹配项。这个标志不改变模式匹配的方式，但它会从重要的方面修改 String 的 `match()` 方法和 RegExp 的 `exec()` 方法的行为。

- **i**
  i 标志表示模式匹配应该不区分大小写。

- **m**
  m 标志表示匹配应该以 “多行”（multiline）模式进行。意思是这个 RegExp 要用于多行字符串，而且 `^` 和 `$` 锚点应该既匹配字符串的开头和末尾，也匹配字符串中任何一行的开头和末尾。

- **s**
  与 m 标志类似，s 标志同样可以用在要搜索的文本包含换行符的时候。正常情况下，`.` 在正则表达式中匹配除行终止符之外的任何字符。但在使用 s 标志时，`.` 将匹配任何字符，包括行终止符。s 标志是 ES2018 引入 JS 的。

- **u**
  u 标志代表 Unicode，可以让正则表达式匹配完整的码点而不是匹配 16 位值。这个标志是 ES6 新增的，如果没有特殊原因，应该对所有正则表达式都使用这个标志。

  如果不使用这个标志，那正则表达式将无法识别表情符号和其他需要 16 位以上表示的字符（包括很多中文字符）。没有 u 标志，`.` 字符匹配任意 1 个 UTF-16 16 位值。而有 u 标志，`.` 匹配一个 Unicode 码点，包括超过 16 位编码的值。

  在正则表达式上添加 u 标志之后，就可以使用新的 `\u{...}` 转义序列表示 Unicode 字符，同时也可以使用 `\p{...}` 表示 Unicode 字符类。

- **y**
  y 标志表示正则表达式是 “有粘性的”（sticky），应该在字符串开头匹配或在紧跟前一个匹配的第一个字符处匹配。在应用给只想查找一个匹配项的正则表达式时，这个标志的作用就类似给正则表达式加上了 `^` 锚点，将其锚定到字符串的开头。

  对于用来在字符串中反复查找所有匹配项的正则表达式，这个标志比较有用。这时候，它会导致 String 的 `match()` 方法和 RegExp 的 `exec()` 方法产生特殊行为，强制将每个后续匹配都锚定到前一个匹配（在字符串中）的结束位置。

> 以上这些标志可以任意组合，顺序也不分先后。

#### 11.3.2 模式匹配的字符串方法

String 支持 4 个使用正则表达式的方法。

**search()**
这个方法接收一个正则表达式参数，返回第一个匹配项起点字符的位置，如果没有找到匹配项，则返回 -1：

```js
'JavaScript'.search(/script/iu); // 4
'Python'.search(/script/iu); // -1
```

如果 search() 方法的参数不是正则表达式，它会先把这个参数传给 RegEXp() 构造函数，把它转换为正则表达式。search() 方法不支持全局搜索，因此其正则表达式参数中包含的 `g` 标志会被忽略。

**replace()**
replace() 方法执行搜索替换操作。它接收一个正则表达式作为第一个参数，接收一个替换字符串作为第二个参数。它搜索调用它的字符串，寻找与指定模式匹配的文本。如果正则表达式带 `g` 标志，replace() 方法会用替换字符串中的所有匹配项；否则，它只替换第一个匹配项。

如果 replace() 的第一个参数是字符串而非正则表达式，这个方法不会像 search() 那样将字符串通过 RegExp() 转换为正则表达式，而是会按照字面值搜索。比如，可以像下面这样使用 replace() 规范文本字符串中所有 “JavaScript” 的大小写：

```js
// 无论之前是什么大小形式，都替换成规范的大小写形式
text.replace(/javascript/gi, 'JavaScript');
```

不过，replace() 的能力远不止这些。正则表达式中括号分组的子表达式是从左到右编号的，而且正则表达式能够记住每个子表达式匹配的文本。如果替换字符串中出现了 `$` 符号后跟一个数字，replace() 会将这两个字符替换为与指定子表达式匹配的文本。比如，可以通过它将字符串中的引号替换成其他字符：

```js
// quote 表示一个引号后跟任意多个非引号字符，最后又是一个引号
let quote = /"([^"]*)"/g;
// 将直引号替换成书名号，同时引用的文本不变（保存在 $1 中）
'He said "stop"'.replace(quote, '《$1》'); // 'He said 《stop》'
```

如果 RegExp 中使用的是命名捕获组，可以通过名字而非数字来引用匹配的文本：

```js
let quote = /"(?<quotedText>[^"]*)"/g;
'He said "stop"'.replace(quote, '《<quotedText>》'); // 'He said 《stop》'
```

除了给 replace() 传替换字符串，还可以传一个函数，这个函数会被调用以计算替换的值。这个替换函数在被调用时会接收到几个参数。第一个是匹配的整个文本。然后，如果 RegExp 有捕获组，则后面几个参数分别是这些捕获组匹配的子字符串。再接下来的参数是在字符串找到匹配项的位置。再然后一个参数是调用 replace() 方法的整个字符串。最后，如果 RegExp 包含命名捕获组，替换函数还会收到一个参数，这个参数是一个对象，其属性名是捕获组的名字，属性值是匹配的文本。比如，下面的代码使用替换函数将字符串中的十进制整数替换成了十六进制：

```js
let s = '15 times 15 is 225';
s.replace(/\d+/gu, (n) => parseInt(n).toString(16)); // "f times f is e1"
```

**match()**
match() 是字符串最通用的正则表达式方法，它只有一个正则表达式参数（如果参数不是正则表达式，会把它传给 RegExp() 构造函数），返回一个数组，其中包含匹配的结果；如果没有找到匹配项，就返回 null。如果正则表达式有 `g` 标志，这个方法返回的数组会包含在字符串中找到的所有匹配项。例如：

```js
'7 plus 8 equals 15'.match(/d+/g); // ["7", "8", "15"]
```

如果正则表达式没有 `g` 标志，match() 不会执行全局搜索，只会查找第一个匹配项。在非全局搜索时，match() 仍然返回数组，但数组元素完全不同。在没有 `g` 标志的情况下，返回数组的第一个元素是匹配的字符串，剩下的所有元素是正则表达式中括号分组的捕获组匹配的子字符串。因此，如果 match() 返回一个数组 a，则 `a[0]` 包含与整个正则表达式匹配的字符串，`a[1]` 包含与第一个捕获组匹配的子字符串，以此类推。如果与 replace() 方法做个比较，则 `a[1]` 相当于 `$1`，`a[2]` 相当于 `$2`，以此类推。

比如，下面的代码是一个解析 URL 的例子：

```js
// 一个非常简单的解析 URL 的 RegExp
let url = /(\w+):\/\/([\w.]+)\/(\S*)/;
let text = 'visit my blog at http://www.example.com/~david';
let match = text.match(url);
let fullurl, protocol, host, path;
if (match !== null) {
  fullurl = match[0]; // fullurl == "http://www.example.com/~david"
  protocol = match[1]; // protocol == "http"
  host = match[2]; // host == "www.example.com"
  path = match[3]; // path == "~david"
}
```

在非全局搜索的情况下，match() 返回的数组除了可以通过数值索引的元素，也有一些对象属性。其中，`input` 属性引用调用 match() 的字符串。`index` 属性是匹配项在字符串中的起始位置。如果正则表达式包含命名捕获组，则返回的数组也有一个 `groups` 属性，其值是一个对象。这个对象的属性就是命名捕获组的名字，而属性的值就是匹配的文本。比如，可以将前面那个匹配 URL 的例子重写成下面这样：

```js
let url = /?<protocol>\w+):\/\/(?<host>[\w.]+)\/(?<path>\S*)/;
let text = 'visit my blog at http://www.example.com/~david';
let match = text.match(url);
match[0]; // http://www.example.com/~david
match.input; // text
match.index; // 17
match.groups.protocol; // "http"
match.groups.host; // "www.example.com"
match.groups.path; // "~david"
```

match() 的行为会因为 RegExp 是否带 `g` 标志而有很大不同。另外，是否设置 `y` 标志对 match() 的行为也有一些影响。`y` 标志通过控制字符串匹配的开始位置让正则表达式 “有粘性”。如果 RegExp 同时设置了 `g` 和 `y` 标志，match() 返回包含所有匹配字符串的数组，就跟只设置了 `g` 而没有设置 `y` 一样。但第一个匹配项必须始于字符串开头，每个后续的匹配项必须从前一个匹配项的后一个字符开始。

如果只设置了 `y` 而没有设置 `g` 标志，match() 会尝试找到第一个匹配项，且默认情况下，这个匹配项被限制在字符串开头。不过，这个默认的起始位置是可以修改的，设置 RegExp 对象的 `lastIndex` 属性就可以指定匹配开始的位置。如果找到了匹配项，`lastIndex` 属性会自动被更新为匹配项之后第一个字符的位置，因此如果像这里一样再次调用 match()，它会继续寻找后面的匹配项（`lastIndex` 看起来并不像是一个可以指定下一次匹配开始位置的属性）。

```js
let vowel = /[aeiou]/y; // 粘着元音匹配
'test'.match(vowel); // null："test" 开头的字符不是元音字母
voweL.lastIndex = 1; // 指定一个不同的匹配位置
'test'.match(vowel)[0]; // "e"：在位置 1 找到了元音字母
voweL.lastIndex; // 2：lastIndex 会自动更新
test.match(voweL); // null：位置 2 不是元音字母
vowel.lastIndex; // 0：匹配失败后，lastIndex 会被重置
```

> **注意**：即给字符串的 math() 方法传一个非全局正则表达式，相当于把字符串传给正则表达式的 exec() 方法。这两种情况下返回的数组及其属性都相同。

**matchAll()**
matchAll() 方法是 ES2020 中定义的。matchAll() 接收一个带 `g` 标志的正则表达式。但它并不像 match() 那样返回所有匹配项的数组，而是返回一个迭代器，每次迭代都产生一个与使用 match() 时传入非全局 RegExp 得到的匹配对象相同的对象。正因为如此，matchAll() 成为循环遍历字符串中所有匹配项最简单和最通用的方式。

可以像下面这样使用 matchAll() 遍历字符串中包含的单词：

```js
// 位于词边界之间的一个或多个 Unicode 字母字符
const words = /\b\p{Alphabetic}+\b/gu;
const text = 'This is a naive test of the matchAll() method.';
for (let word of text.matchAll(words)) {
  console.log(`Found '${word[0]}' at index ${word.index}.`);
}
```

也可以设置 RegExp 对象的 `lastIndex` 属性，告诉 matchAll() 从字符串中的哪个索引开始匹配。但是，与其他模式匹配方法不同的是，matchAll() 不会修改传入 RegExp 的 `lastIndex` 属性，这也使得它不太可能在代码中导致 bug。

**split()**
String 对象的最后一个正则表达式方法是 split()。这个方法使用传入的参数作为分隔符，将调用它的字符串拆分为子字符串保存到一个数组中。可以像这样给它传入一个字符串参数：

```js
'123,456,789'.split(','); // ['123', '456', '789']
```

split() 方法也可以接收一个正则表达式参数，这样就可以指定更通用的分隔符。下面这个例子中指定的分隔符允许逗号两侧包含任意数量的空格：

```js
'1, 2, 3,\n4, 5'.split(/\s*,\s*/); // ['1', '2', '3', '4', '5']
```

如果调用 split() 时传入 RegExp 作为分隔符，且这个正则表达式中包含捕获组，则捕获组匹配的文本也会包含在返回的数组中：

```js
const htmlTag = /<([^>]+)>/; // < 后跟一个或多个非 > 字符，再后跟 >
'Testing<br/>1,2,3'.split(htmLTag); // ["Testing", "br/", "1,2,3"]
```

#### 11.3.3 RegExp 类

RegExp() 构造函数接收一个或两个字符串参数，创建一个新 RegExp 对象。这个构造函数的第一个参数是包含正则表达式主体的表达式，即在正则表达式字面量中出现在斜杠中间的部分。

> **注意**：字符串字面量和正则表达式都使用 `\` 字符转义，因此在以字符串字面量形式给 RegExp() 传入正则表达式时，必须把所有 `\` 字符替换成 `\\`。

RegExp() 的第二个参数是可选的。如果提供了这个参数，则代表指定正则表达式的标志。这个参数应该是 `g`、`i`、`m`、`s`、`u`、`y` 或它们的任意组合。

```js
// 查找字符串中包含的所有 5 位数字。注意这里的双反斜杠 \\。
let zipcode = new RegExp('\\d{5}', 'g');
```

**RegExp() 构造函数主要用于动态创建正则表达式，即创建那些无法用正则表达式字面量语法表示的正则表达式**。例如，要搜索用户输入的字符串，就必须使用 RegExp() 在运行时创建正则表达式。

除了给 RegExp() 的第一个参数传字符串，也可以传一个 RegExp 对象。这样可以复制已有的正则表达式，并且修改它的标志：

```js
let exactMatch = /JavaScript/;
let caseInsensitive = new RegExp(exactMatch, 'i');
```

**RegExp 属性**
RegExp 对象有以下属性。

`source`
: 这是个只读属性，包含正则表达式的源文本，即出现在 RegExp 字面量的两个斜杠中间的字符。

`flags`
: 这是个只读属性，包含指定 RegExp 标题的一个或多个字母。

`global`
: 只读布尔属性，如果设置了 `g` 标志则为 true。

`ignoreCase`
: 只读布尔属性，如果设置了标志 `i` 则为 true。

`multiline`
: 只读布尔属性，如果设置了 `m` 标志则为 true。

`dotAll`
: 只读布尔属性，如果设置了 `s` 标志则为 true。

`unicode`
: 只读布尔属性，如果设置了 `u` 标志则为 true。

`sticky`
: 只读布尔属性，如果设置了 `y` 标志则为 true。

`lastIndex`
: 这是个可以读、写的整数属性。对于带有 `g` 或 `y` 标志的模式，这个属性用于指定下次匹配的起始字符位置。

**test()**
RegExp 类的 test() 方法是使用正则表达式的最简单方式。该方法接收一个字符串参数，如果字符串与模式匹配则返回 true，如果没有找到匹配项则返回 false。

test() 方法的原理很简单，它会调用下面的（更复杂的）exec()方法，如果 exec() 返回非空值就返回 true。正因为如此，如果调用 test() 的 RegExp 使用了 `g` 或 `y` 标志，则这个方法的行为取决于 RegExp 对象的 `lastIndex` 属性的值，而这个属性的值可能会被意外修改。详细信息可以参考下面的 “lastIndex 属性与重用 RegExp”。

**exec()**
RegExp 的 exec() 方法是使用正则表达式最通常、最强大的方式。该方法接收一个字符串参数，并从这个字符串寻找匹配。如果没有找到匹配项，则返回 null。而如果找到了匹配项，则会返回一个数组，跟字符串的 match() 方法在非全局搜索时返回的数组一样。这个数组的元素 0 包含匹配整个正则表达式的字符串，后面的数组元素包含与正则表达式中捕获组匹配的子字符串。这个返回的数组也有对象属性：`index` 属性包含匹配项起始字符的位置，`input` 属性包含搜索的目标字符串，而 `groups` 属性（如果有捕获组）引用一个对象，保存与每个命名捕获组匹配的子字符串。

与 String 的 match() 方法不同，exec() 方法无论正则表达式是否设置了 `g` 标志都会返回相同的数组。match() 方法在收到一个全局正则表达式时会返回所有匹配项的数组。相对而言，exec() 始终返回一个匹配项，并提供关于该匹配项的完整信息。

在通过设置了全局 `g` 或粘着 `y` 标志的正则表达式调用 exec() 时，exec() 会根据 RegExp 对象的 `lastIndex` 属性来决定从哪里开始査找匹配（如果设置了 `y` 标志，那么也会限制匹配项必须从该位置开始）。对一个新创建的 RegExp 对象来说，它的 `lastIndex` 为 0，因此搜索从字符串的起点开始。但每次 exec() 成功执行，找到一个匹配项，都会更新 RegExp 的 `lastindex` 属性，将其改写为匹配文本之后第一个字符的索引。如果 exec() 没有找到匹配项，它会将 `lastIndex` 重置为 0。这个特殊行为得以重复调用 exec()，从而逐个找到字符串中所有的匹配项（ES2020 及之后的版本为 String 新增了 catchAll() 方法。而 matchAll() 是遍历所有匹配的更简单方式）。例如，下面代码中的循环会运行两次：

```js
let pattern = /Java/g;
let text = 'JavaScript > Java';
let match;
while ((match = pattern.exec(text)) !== null) {
  console.log(`Matched ${match[0]} at ${match.index}`);
  console.log(`Next search begins at ${pattern.lastIndex}`);
}
```

**lastIndex 属性与重用 RegExp**
JS 正则表达式 API 是比较复杂的。其中配合 `g` 和 `y` 标志的 `lastIndex` 属性则是这套 API 中最费解的地方。每当使用这两个标志时，都要在调用 match()、exec() 或 test()方法时特别小心。因为这些方法的行为依赖于 `lastIndex`，而 `lastIndex` 的值依赖于之前对 RegExp 对象做了什么。这一连串的依赖很容易导致写出问题代码。

比如，假设想找到一段 HTML 文本中所有 `<p>` 标签的索引，可能会写出下面这样的代码：

```js
let match,
  positions = [];
// 可能无穷循环
while ((match = /<p>/g.exec(html)) !== null) {
  positions.push(match.index);
}
```

这段代码不会达成想要的结果。如果 html 字符串包含至少一个 `<p>` 标签，那循环将永远不会停止。问题在于 while 循环条件中使用了一个 RegExp 字面量。循环的每次选代都创建一个新的 RegExp 对象，其 lastIndex 初始值为 0。因此 exec() 每次都从字符串的开头查找，如果有匹配，那就会一遍一遍不停地匹配。解决方案当然就是只定义一次 RegExp，把它们保存在一个变量中，让循环的每次选代都使用同一个 RegExp 对象。

另一方面，有时候重用一个 RegExp 对象也是不对的。比如，假设要遍历一个词典中的所有单词，查找其中所有包含双字母的单词：

```js
let dictionary = ['apple', 'book', 'coffee'];
let doubleLetterWords = [];
let doubleLetter = /(\w)\1/g;
for (let word of dictionary) {
  if (doubleLetter.test(word)) {
    doubleLetterWords.push(word);
  }
}
doubleLetterwords; // ["apple", "coffee"]：没有 "book"!
```

由于这个 RegExp 设置了 `g` 标志，所以它的 `lastIndex` 属性会在每次成功匹配后被修改，而（基于 exec() 的）test()方法就会从 `lastIndex` 指定的位置开始下一次搜索。在匹配完 “apple” 中的 “pp” 后，`lastIndex` 值被更新为 3，因此再从位置 3 开始搜索 “book” 时就会跳过其中包含的 “oo”。

要解决这个问题，可以删除 `g` 标志（在这个特定的例子中 `g` 标志并不是必需的），也可以把 RepExp 字面量挪到循环体内，以便每次迭代时都创建一个新实例，还可以在每次调用 test() 之前把 `lastIndex` 重置为 0。

> 举上面这些例子是为了说明 lastIndex 让 RegExp API 很容易出错。因此在使用 `g` 或 `y` 标志和循环时要格外注意。在 ES2020 及之后的版本中，应该使用 String 的 `matchAll()` 方法而不是 exec() 来避开这个问题，因为 `matchAll()` 不会修改 lastIndex。

### 11.4 日期与时间

Date 类是 JS 中用于操作日期和时间的 API。使用 Date() 构造函数可以创建一个日期对象。在不传参数的情况下，这个构造函数会返回一个表示当前日期和时间的 Date 对象：

```js
let now = new Date(); // 当前时间
```

如果传入一个数值参数，Date() 构造函数会将其解释为自 1970 年至今经过的亳秒数：

```js
let epoch = new Date(0); // 格林尼治标准时间 1970 年 1 月 1 日 θ 时
```

如果传入一个或多个整数参数，它们会被解释为本地时区的年、月、日、时、分、秒和毫秒，如下所示：

```js
let century = new Date(
  2100, // 2100 年
  0, // 1 月
  1, // 1 日
  2,
  3,
  4,
  5 //本地时间 02:03:04.005
);
```

Date API 有个奇怪的地方，即每年第一个月对应数值 0，而每月第一天对应数值 1。如果省略时间字段，Date() 构造函数默认它们都为 0，将时间设置为半夜 12 点。

> **注意**：在使用多个参数调用时，Date() 构造函数会使用本地计算机的时区来解释它们。如果想以 UTC（Universal Coordinated Time，通用协调时间；也称 GMT，即 Greenwich Mean Time，格林尼治标准时间）指定日期和时间，可以使用 `Date.UTC()`。这个静态方法接收与 Date() 构造函数同样的参数，但使用 UTC 来解释它们，并返回毫秒时间戳，可以传给 Date() 构造函数：

```js
// 英格兰 2100 年 1 月 1 日半夜 12 点
let century = new Date(Date.UTC(2100, 0, 1));
```

如果要打印日期，默认会以本地时区打印。如果想以 UTC 显示日期，应该先使用 `toUTCString()` 或 `toISOString()` 转换它。

最后，如果给 Date() 构造函数传入字符串，它会尝试按照日期和时间格式来解析该字符串。这个构造函数可以解析 `toString()`、`toUTCString()` 和 `toISOString()` 方法产生的格式：

```js
let century = new Date('2100-01-01T00:00:00Z'); // ISO 格式的日期
```

有了一个 Date 对象后，可以通过很多方法获取或设置这个对象的年、月、日、时、分、秒和毫秒字段。这些方法都有两种形式：

- 使用本地时间获取和设置
- 使用 UTC 时间获取和设置

比如，要获取或设置一个 Date 对象的年份，可以使用 `getFullYear()`、`getUTCFullYear()`、`setFullYear()` 或 `setUTCFullYear()`：

```js
let d = new Date(); // 先用当前日期创建
d.setFullYear(d.getFullYear() + 1); // 增加1年
```

要获取或设置 Date 的其他字段，只要将前面方法中的 “FullYear” 替换成 “Month” “Date” “Hours” “Minutes” “Seconds” 或 “Milliseconds” 即可。其中一些日期设置方法允许一次性设置多个字段。`setFullYear()` 和 `setUTCFullYear()` 也可选地允许同时设置月和日。而 `setHours()` 和 `setUTCHours()` 除了支持小时字段，还允许指定分钟、秒和毫秒字段。

> **注意**：查询日的方法是 `getDate()` 和 `getUTCDate()`。而名字听起来更自然的函数 `getDay()` 和 `getUTCDay()` 返回的是代表周几的数值（0 表示周日，6 表示周六）。周几字段是只读的，因此没有对应的 `setDay()` 方法。

#### 11.4.1 时间戳

JS 在内部将日期表示为整数，代表自 1970 年 1 月 1 日半夜 12 点起（或之前）的毫秒数。最大支持的整数是 8640000000000000，因此 JS 表示的时间不会超过 27 万年。

对于任何 Date 对象，`getTime()` 方法返回这个内部值，而 `setTime()` 方法设置这个值。因此，可以像下面这样给一个 Date 对象添加 30 秒：

```js
d.setTime(d.getTime() + 30000);
```

这些毫秒值有时候也被称为时间戳（timestamp），有时候直接使用这些值比使用 Date 对象更方便。静态的 `Date.now()` 方法返回当前时间的时间戳，经常用于度量代码运行时间：

```js
let startTime = Date.now();
reticulateSplines(); // 执行一些耗时操作
let endTime = Date.now();
console.log(`Spline reticulation took ${endTime - startTime}ms.`);
```

**高精度时间戳**
`Date.now()` 返回的时间戳是以毫秒为单位的。毫秒对计算机来说实际上是个比较长的时间单位。有时候可能需要使用更高的精度来表示经历的时间。此时可以使用 `performance.now()`，虽然它返回的也是以毫秒为单位的时间戳，但返回值并不是整数，包含毫秒后面的小数部分。`performance.now()` 返回的值并不是像 `Date.now()` 返回的值一样的绝对时间戳，而是相对于网页加载完成后或 Node 进程启动后经过的时间。

performance 对象是 W3C 定义的 Performance API 的一部分，已经被浏览器和 Node 实现。要在 Node 中使用 performance 对象，必须先导入它：

```js
const { performance } = require('perf_hooks');
```

高精度计时可能会让一些没有底线的网站用于采集访客指纹，因此浏览器默认可能会降低 `performance.now()` 的精度。可以通过某种方式更新启用高精度计时（比如在 Firefox 中可以设置 privacy.reduceTimePrecision 为 false）。

#### 11.4.2 日期计算

Date 对象可以使用 JS 标准的 <、<=、> 和 >= 等比较操作符进行比较。可以用一个 Date 对象减去另一个以确定两个日期相关的毫秒数（这本质上是因为 Date 类定义了 valueOf() 方法，这个方法返回的是日期的时间戳）。

如果想要给 Date 对象加或减指定数量的秒、分或小时，最简单的方式就是像前面例子中（给日期加上 30 秒）那样修改时间戳。但这种方式在涉及加天时就比较麻烦了，因为这不适合所有月份和年份，不同月份和年份的天数也可能不一样。要完成涉及天数、月数和年数的计算，可以使用 `setDate()`、`setMonth()` 和 `setYear()`。比如，下面的代码给当前日期加上了 3 个月和 2 周：

```js
let d = new Date();
d.setMonth(d.getMonth() + 3, d.getDate() + 14);
```

**日期设置方法即使在数值溢出的情况下也能正确工作**。比如，在给当前月份加了 3 个月之后，最终值可能大于 11(11 表示 12 月)。setMonth() 在遇到这种情况时会按照需要增加年份。类似地，在将天数设置为超过相应月份的天数时，月份也会相应递增。

#### 11.4.3 格式化与解析日期字符串

如果使用 Date 类去记录日期和时间（而不只是度量时间），那很可能需要通过代码向用户展示日期和时间。Date 类定义了一些方法，可以将日期对象转换为字符串。下面是几个例子：

```js
let d = new Date(2020, 0, 1, 17, 10, 30); // 2020 年元旦 5:10:30pn
d.toString(); // "Wed Jan 01 2020 17:10:30 GMT+0800 (GMT+08:00)"
d.toUTCString(); // "Wed, 01 Jan 2020 09:10:30 GMT"
d.toLocaleDateString(); // "2020/1/1"
d.toLocaleTimeString(); // "下午5:10:30"
d.toISOString(); // "2020-01-01T09:10:30.000Z"
```

下面分别介绍 Date 类定义的全部字符串格式化方法。

**toString()**
: 这个方法使用本地时区但不按照当地惯例格式化日期和时间。

**toUTCString()**
: 这个方法使用 UTC 时区但不按照当地惯例格式化日期。

**toISOString()**
: 这个方法以标准的 ISO-8601 “年-月-日时:分:秒:毫秒” 格式打印日期和时间。字母 “T” 在输出中分隔日期部分和时间部分。时间以 UTC 表示，可以通过输出末尾的字母 “Z” 看出来。

**toLocaleString()**
: 这个方法使用本地时区及与用户当地惯例一致的格式。

**toDateString()**
: 这个方法只格式化 Date 的日期部分，忽略时间部分。它使用本地时区，但不与当地惯例适配。

**toLocaleDateString()**
: 这个方法只格式化日期部分。它使用本地时区，也适配当地惯例。

**toTimeString()**
: 这个方法只格式化时间部分。它使用本地时区，但不与当地惯例适配。

**toLocaleTimeString()**
: 这个方法只格式化时间部分。它使用本地时区，也适配当地惯例。

除了将 Date 对象转换为字符串的方法，还有一个静态的 `Date.parse()` 方法。该方法接收一个字符串参数，并尝试将其作为日期和时间来解析，返回一个表示该日期的时间戳。`Date.parse()` 可以像 Date() 构造函数一样解析同样的字符串，也可以解析 `toISOString()`、`toUTCString()` 和 `toString()` 的输出。

### 11.5 Error 类

JS 的 `throw` 和 `catch` 语句可以抛出和捕获任何 JS 值，包括原始值。虽然没有用来表示错误的异常类型，但 JS 定义了一个 Error 类。惯常的做法是使用 Error 类或其子类的实例作为 throw 抛出的错误。

使用 Error 对象的一个主要原因就是在创建 Error 对象时，该对象能够捕获 JS 的栈状态，如果异常未被捕获，则会显示包含错误消息的栈跟踪信息，而这对排查错误很有帮助（注意，栈跟踪信息会展示创建 Error 对象的地方，而不是 throw 语句抛出它的地方。如果始终在抛出之前创建该对象，如 throw new Error()，就不会造成任何困惑）。

Error 对象有几个属性：

- `message`
  message 属性的值是传给 Error() 构造函数的值，必须时会被转换为字符串。

- `name`
  对使用 Error() 创建的错误对象，name 属性的值始终是 “Error”。

- 还有一个 `toString()` 方法。
  `toString()` 方法返回一个字符串，由 name 属性的值后跟一个冒号和一个空格，再后跟 message 属性的值构成。

- `stack`
  虽然 ECMAScript 标准并没有定义，但 Node 和所有现代浏览器也都在 Error 对象上定义了 `stack` 属性。这个属性的值是一个多行字符串，包含创建错误对象时 JS 调用栈的栈跟踪信息。在捕获到异常错误时，可以将这个属性的信息作为日志收集起来。

除了 Error 类，JS 还定义了一些它的子类，以便触发 ECMAScript 定义的一些特殊类型的错误。这些子类包括: `EvalError`、`RangeError`、`ReferenceError`、`SyntaxError`、`TypeError` 和 `URIError`。可以按照自己认为合适的方式在代码中使用这些错误类。与基类 Error 一样，这些子类也都有一个构造函数，接收一个消息参数。每个子类的实例都有一个 `name` 属性，其值就是构造函数的名字。

可以自定义 Error 的子类，以便更好地封装自己程序的错误信息。自定义错误对象可以不限于 `message` 和 `name` 属性。在定义自己的子类时，可以任意添加新属性以提供更多的错误细节。例如，要使用 HTTP 请求，可能需要定义一个 `HttpError` 类，这个类通过 `status` 属性保存请求失败对应的 HTTP 状态码（例如 404 或 500）。

```js
class HttpError extends Error {
  constructor(status, statusText, url) {
    super(`${status} ${statusText}: ${url}`);
    this.status = status;
    this.statusText = statusText;
    this.url = url;
  }

  get name() {
    return 'HTTPError';
  }
}

let error = new HttpError(404, 'not Found', 'http://example.com/');
error.status; // 404
error.message; // "404 not Found http://example.com/"
error.name; // "HTTPError"
```

在 ECMAScript 2022 规范中，new Error() 中可以指定导致它的原因：

```js
function readFiles(filePaths) {
  return filePaths.map((filePath) => {
    try {
      // ···
    } catch (error) {
      throw new Error(`While processing ${filePath}`, { cause: error });
    }
  });
}
```

### 11.6 JSON 序列化与解析

当程序需要保存数据或需要通过网络连接向另一个程序传输数据时，必须将内存中的数据结构转换为字节或字符的序列，才可以保存或传输。而且，之后可以再被解析或恢复为原来内存中的数据结构。这个将数据结构转换为字节或字符流的方式称为序列化（serialization），也称为编排（marshaling）或制备（pickling）。

**JS 中序列化数据的最简单方式是使用一种称为 JSON 的序列化格式**。JSON 是 “JavaScript Object Notation”（JavaScript 对象表示法）的简写形式。顾名思义，这种格式使用 JS 对象和数组字面量语法，将对象和数组形式的数据结构转换为字符串。

JSON 支持原始数值和字符串，也支持 true、false 和 null 值，以及在这些原始值基础上构建起来的对象和数组。JSON 不支持其他 JS 类型，如 Map、Set、RegExp、Date 或定型数组。但实践已经证明 JSON 是一种非常通用的数据格式，就连很多非 JS 程序都支持它。

JS 通过两个函数 `JSON.stringify()` 和 `JSON.parse()` 支持 JSON 序列化和反序列化。如果一个对象或数组，不包含任何无法序列化的值，都可以把它传给 `JSON.stringify()` 进行序列化。顾名思义，`JSON. stringify()` 返回一个字符串值。而给定 `JSON.stringify()` 返回的字符串，可以把它传给 `JSON.parse()` 再重建原始的数据结构：

```js
let o = { s: '', n: 0, a: [true, false, null] };
let s = JSON.stringify(o); // s == '{"s":"","n":0,"a":[true,false,null]}'
let copy = JSON.parse(s); // copy == {s:"", n: 0, a: [true, false, null]};
```

如果不考虑将序列化之后的数据保存到文件中，或者通过网络发送出去，可以使用这对函数（以没有那么高效的方式）创建对象的深度副本：

```js
// 创建任何可序列化对象或数组的深度副本
function deepcopy(o) {
  return JSON.parse(JSON.stringify(o));
}
```

**JSON 是 JS 的子集**
数据被序列化为 JSON 格式后，结果是有效的 JS 表达式源代码，可以求值为原始数据结构的一个副本。如果在 JSON 字符串前面加上 `var data =` 并将结果传给 `eval()`，就可以把原始数据结构的一个副本赋值给变量 data。但是不要这样做，因为这是一个巨大的安全漏洞。如果攻击者可以向 JSON 文件中注入任意 JS 代码，那就可以让程序运行他们的代码。使用 `JSON.parse()` 解码 JSON 格式的数据既快也安全。

JSON 有时候也被用为人类友好的配置文件格式。JSON 格式是 JS 的严格子集。不允许有注释，属性名也必须包含在双引号中。

通常，只会给 `JSON.stringify()` 和 `JSON.parse()` 传一个参数，这两个函数其实都可以接收可选的第二个参数，能够扩展 JSON 格式。`JSON.stringify()` 还接收可选的第三个参数。如果希望 JSON 格式字符串对人类友好（比如要用作配置文件），那可以在第二个参数传 null，第三个参数传一个数值或字符串。`JSON.stringify()` 的第三个参数告诉它应该把数据格式化为多行缩进格式。如果第三个参数是个数值，则该数值表示每级缩进的空格数。如果第三个参数是空白符（如 '\t'）字符串，则每级缩进就使用该字符串。

```js
let o = { s: 'test', n: 0 };
JSON.stringify(o, null, 2); // '{\n  \"s\": \"test\",\n  \"n\": 0\n}'
```

> `JSON.parse()` 忽略空白符，因此给 `JSON.stringify()` 传第三个参数不会影响将其输出的字符串再转换为原型的数据结构。

#### 11.6.1 JSON 自定义

如果 `JSON.stringify()` 在序列化时碰到了 JSON 格式原生不支持的值，它会查找这个值是否有 `toJSON()` 方法。如果有这个方法，就会调用它，然后将其返回值字符串化以代替原始值。Date 对象实现了 `toJSON()` 方法，这个方法返回与 `toISOString()` 方法相同的值。这意味着如果序列化的对象中包含 Date，则该日期会自动转换为一个字符串。而在解析序列化之后的字符串时，重新创建的数据结构就不会与开始时的完全一样了，因为原来的 Date 值变成了字符串。

如果想重新创建这个 Date 对象（或以其他方式修改解析后的对象），可以给 `JSON.parse()` 的第二个参数传一个 “复活”（revive）函数。如果指定了这个 “复活” 函数，该函数就会在解析输入字符串中的每个原始值时被调用（但解析包含这些原始值的对象和数组时不会调用）。调用这个函数时会给它传入两个参数。第一个是属性名，可能是对象属性名，也可能是转换为字符串的数组索引。第二个参数是该对象属性或数组元素对应的原始值。而且，这个函数会作为包含上述原始值的对象或数组的方法调用，因此可以在其中通过 this 关键字引用包含对象。

复活函数的返回值会变成命名属性的新值。如果复活函数返回它的第二个参数，那么属性保持不变。如果它返回 undefined，则相应的命名属性会从对象或数组中删除，即 `JSON.parse()` 返回给用户的对象中将不包含该属性。

下面来看一个例子。这个例子调用 `JSON.parse()` 时传入了复活函数，用于过滤某些属性并重新创建 Date 对象：

```js
let data = JSON.parse(text, function (key, value) {
  // 删除以下划线开头的属性和值
  if (key[0] === '_') return undefined;

  // 如果值是 ISO 8601 格式的日期字符串，则转换为 Date。
  if (typeof value === 'string' && /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/.test(value)) {
    return new Date(value);
  }
  // 否则,返回原始值
  return value;
});
```

除了使用 `toJSON()`，`JSON.stringify()` 也支持给它传入一个数组或函数作为第二个参数来自定义其输出字符串。如果第二个参数传入的是一个字符串数组（或者数值数组，其中的数值会转换为字符串），那么这些字符串会被当作对象属性（或数组元素）的名字。任何名字不在这个数组之列的属性会被字符串化过程忽略。而且，返回字符串中包含的属性的顺序也会与它们在这个数组中的顺序相同（这在编写测试时非常有用）。

如果给 `JSON.stringify()` 的第二个参数传入一个函数，则该函数就是一个替代函数（作用与传给 `JSON.parse()` 的可选的复活函数恰好相反）。这个替代函数的第一个参数是对象属性名或值在对象中的数组索引，第二个参数是值本身。这个替代函数会作为包含要被字符串化的值的对象或数组的方法调用。替代函数的返回值会替换原始值。如果替代函数返回 undefined 或什么也不返回，则该值（及其数组元素或对象属性）将在字符串化过程中被忽略。

```js
// 指定要序列化的字段，以及序列化它们的顺序
let text = JSON.stringify(address, ['city', 'state', 'country']);

// 指定替代函数，忽略值为 RegExp 的属性
let json = JSON.stringify(o, (k, v) => (v instanceof RegExp ? undefined : v));
```

这里对 `JSON.stringify()` 的两次调用友好地使用了第二个参数，即产生的序列化输出在反序列化时不需要特殊的复活函数。但一般来说，如果为某个类型定义了 `toJSON()` 方法，或者使用替代函数将本来无法序列化的值变成了可序列化的值，应该都要写一个自定义的复活函数让 `JSON.parse()` 能够复原最初的数据结构。如果真的这样做了，那应该知道这是在自定义数据格式，因而也牺牲了可移植性以及与庞大 JSON 工具、语言生态的兼容性。

### 11.7 国际化 API

JS 国际化 API 包括 3 个类：

- Int.NumberFormat
- Intl.DateTimeFormat
- Intl.Collator

这 3 个类允许以适合当地的方式格式化数值（包括货币数量和百分数）日期和时间，以及以适合当地的方式比较字符串。这些类并不是 ECMAScript 标准定义的，而是 ECMA402 标准定义的，而且得到了浏览器的普遍支持。Node 也支持 Intl API，但 2020 年初，预构建版 Node 二进制文件中并未包含除 US English 地区之外的国际化 API 依赖的本地化数据。因此要在 Node 中使用这些类，可能需要单独下载数据包或者使用自定义构建的 Node 版本。

#### 11.7.1 格式化数值

世界各地的用户对数值格式的预期是不同的。小数点可能是句点，也可能是逗号。千分位分隔符可能是逗号，也可能是句点，而且并不是所有地区都是 3 个数字一组。某些地区的货币要以百为单位分隔，有些则以千为单位，还有的不需要分隔。虽然所谓的阿拉伯数字 0 到 9 在很多语言中使用，但其实也不是普适的，某些国家的用户期待看到以自己的文字书写的数字。

`Intl.NumberFormat` 类定义了一个 `format()` 方法，考虑到了上述所有格式化的可能性。这个构造函数接收两个参数，第一个参数指定作为数值格式化依据的地区，第二个参数是用于指定格式化细节的对象。如果第一个参数被省略，或者传入的是 undefined，则使用系统设置中的地区（假设该地区为用户偏好地区）。如果第一个参数是字符串，那它指定就是期望地区，例如 "en-U5"（美国英语）和 "fr"（法语）。第一个参数也可以是一个地区字符串数组，此时 Intl.NumberFormat 会选择支持最好的一个。

如果指定 `Intl.NumberFormat()` 构造函数的第二个参数，则该函数应该是一个对象，且包含一个或多个下列属性：

**style**
: 指定必需的数值格式类型。默认为 "decimal"，如果指定 "percent" 则按百分比格式化数值，指定 "currency" 则表示数值为货币数量。

**currency**
: 如果 style 的值为 "currency"，则这个属性是必需的，用于指定 3 个字母的 ISO 货币代码（如 "USD" 表示美元，"GBP" 表示英镑）。

**currencyDisplay**
: 如果 style 的值为 "currency"，则这个属性指定如何显示货币值。默认值为 "symbol"，即如果货币有符号则使用货币符号。值 "code" 表示使用 3 个字母的 ISO 代码，值 "name" 表示以完整形式拼出货币的名字。

**useGrouping**
: 如果不想让数值有千分位分隔符（或其他地区相关的样式），将这个属性设置为 false。

**minimumIntegerDigits**
: 数值中最少显示几位整数。如果数值的位数小于这个值，则在左侧填补 0。默认值是 1，但最高可以设置为 21。

**minimumFractionDigits、maximumFractionDigits**
: 这两个属性控制数值小数部分的格式。如果数值的小数部分位数小于最小值，则在右侧填补 0。如果大于最小值，则小数部分会被舍入。这两个属性的取值范围是 0 到 20。默认最小值为 0，最大值为 3，但格式化货币数量时是例外，此时小数部分的长度根据指定的货币会有所不同。

**minimumSignificantDigits、maximumSignificantDigits**
: 这两个属性控制数值中有效位的数量，比如让它们适合格式化科学数据。如果指定，这两个属性会覆盖前面列出的整数和小数属性。合法取值范围是 1 到 21。

以期望的地区和选项创建了 Intl.Numberformat 对象之后，可以把要格式化的数值传给这个对象的 format() 方法，该方法返回适当格式化之后的字符串。例如：

```js
let euros = Intl.NumberFormat('es', { style: 'currency', currency: 'EUR' });
euros.format(10); // "10.00 €"：10欧元，西班牙惯例

let pounds = Intl.NumberFormat('en', { style: 'currency', currency: 'GBP' });
pounds.format(1000); // "1,000.00"：1000 镑，英国格式
```

Intl.NumberFormat（及其他 Int 类）有一个很有用的特性，即它的 format() 方法会绑定到自己所属的 NumberFormat 对象。因此，不需要定义变量引用这个格式化对象，然后再在上面调用 format() 方法，而是可以直接把这个 format() 方法赋值给一个变量，然后就像使用独立的函数一样使用它，比如:

```js
let data = [0.05, 0.75, 1];
let formatData = Intl.NumberFormat(undefined, {
  style: 'percent',
  minimumFractionDigits: 1,
  maximumFractionDigits: 1
}).format;

data.map(formatData); // ["5.0%", "75.0%", "100.0%"]：地区是 en-US
```

某些语言，比如阿拉伯语，使用自己的文字表示十进制数字：

```js
let arabic = Intl.NumberFormat('ar', { useGrouping: false }).format;
arabic(1234567890);
```

其他语言，如印地语（北印度语）使用有自己数字符号的文字，但倾向于默认使用 ASCI 数字 0~9。如果想覆盖这种用于数字的默认文字，可以在地区中加上 `-u-nu-`，后面跟上简写形式的文字名。比如，可以像下面这样使用印度风格的分组和梵文字母来格式化数值：

```js
let hindi = Intl.NumberFormat('hi-IN-u-nu-deva').format;
hindi(1234567890);
```

`-u-` 在地区中表示后面是一个 Unicode 扩展。`nu` 是记数制扩展的名字，deva 则是梵文 Devanagari 的简写。Intl API 标准也为其他一些记数制定义了名字，大多数针对南亚和东南亚的印欧语系。

#### 11.7.2 格式化日期和时间

Intl.DateTimeFormat 类与 Intl.Numberformat 类很相似。`Intl.DateTimeFormat()` 构造函数与 `Intl.NumberFormat()` 接收相同的两个参数：

- 一个地区或地区数组
- 格式化选项的对象

使用 Intl.DateTimeFormat 实例的方式也是调用其 format() 方法，将 Date 对象转换为字符串。

Date 类定义了简单的 `toLocaleDateString()` 和 `toLocaleTimeString()` 方法，可以生成适合用户地区的输出。但这些方法不支持对要显示的日期和时间进行任何控制。比如，想要在输出中省略年份，同时增加一周就做不到。

Intl.DateTimeformat 类提供了细粒度的控制，通过传给构造函数的第二个选项对象的属性来实现。但是，Intl.DateTimeFormat 并不能始终严格按照要求来输出。比如，如果指定了格式化时和秒的选项，但省略了分钟的，格式化的结果仍然会包含分钟的。背后的思想是可以通过选项对象指定想向用户展示哪些日期和时间的字段，以及这些字段的展示样式（如展示名字还是数值），而格式化程序则会选择与这个选项对象含义最接近的地区格式。

选项对象中的属性如下所示：

**year**
: 年，使用 "numeric" 表示完整的 4 位数年份，或使用 "2-digit" 表示两位数简写形式。

**month**
: 月，使用 "numeric" 表示可能比较短的数字，如 “1”，或使用 "2-digit" 表示始终使用 2 位数字，如 “01”。使用 "long" 表示全名，如 “January”，使用 "short" 表示简称，如 “Jan”，而使用 "narrow" 表示高度简写的名字，如“J”，但不保证唯一。

**day**
: 日，使用 "numeric" 表示 1 位或 2 位数字，或使用 "2-digit" 表示 2 位数字。

**weekday**
： 周，使用 "long" 表示全名，如 “Monday"，或使用 "short" 表示简称，如 “Mon”，或使用 "narrow" 表示高度简写的名字，如 “M”，但不保证唯一。

**era**
: 这个属性指定日期在格式化时是否考虑纪元，例如 CE 或 BCE。这个属性在格式化很久以前的日期或者使用日文日历时有用。合法值为 "long" "short" 和 "narrow"。

**hour、minute、second**
: 这几个属性指定如何显示时间。使用 "numeric" 表示 1 位或 2 位数字，使用 "2-digit" 表示强制 1 位数值在左侧填补 0

**timeZone**
: 这个属性指定格式化日期时使用的时区。如果省略，则使用本地时区。实现可能始终以 UTC 时区为准，也可能以 IANA（Internet Assigned Numbers Authority，因特网地址分配机构）的时区（如 “America/Los——Angeles”）为准。

**timeZoneName**
: 这个属性指定在格式化的日期和时间中如何显示时区。使用 "long" 表示时区全称，而 "short" 表示简写或数值形式的时区。

**hour12**
: 这是个布尔值属性，指定是否使用 12 小时制。默认值取决于地区设置，但可以使用这个属性来覆盖。

**hourCycle**
: 这个属性允许指定半夜 12 点是写为 0 时、12 时还是 24 时。默认值取决于地区设备，但可以使用这个属性来覆盖。注意：hour12 相比这个属性具有更高的优先级。使用 "h11" 指定半夜 12 点是 0 时，而此前 1 小时是晚上 11 点。使用"h12"指定半夜是 2 点。使用 "h23“ 指定半夜是 0 时，而此前 1 小时是 23 时。最后，使用 "h24" 将半夜指定为 24 时。

下面是几个例子：

```js
let d = new Date('2020-01-02T13:14:15Z'); // Thu Jan 02 2020 21:14:15 GMT+0800 (中国标准时间)

// 没有选项对象，就是基本的数值式日期格式
Intl.DateTimeFormat('en-US').format(d); // "1/2/2020"
Intl.DateTimeFormat('fr-FR').format(d); // "02/01/2020"

// 周和月使用名字
let opts = { weekday: 'long', month: 'long', year: 'numeric', day: 'numeric' };
Intl.DateTimeFormat('en-US', opts).format(d); // "Thursday, January 2, 2020"
Intl.DateTimeFormat('es-ES', opts).format(d); // "jueves, 2 de enero de 2020"

// 纽约时间，但适合讲法语的加拿大人
opts = { hour: 'numeric', minute: '2-digit', timeZone: 'America/New_York' };
Intl.DateTimeFormat('fr-CA', opts).format(d); // "8 h 14"
```

Intl.DateTimeFormat 默认使用儒略历，但也可以使用其他日历。虽然有些地区默认可能使用非儒略历，但可以在地区中添加 `-u-ca-` 后跟日期名来明确指定要使用什么日历。可以使用的日历名包括 “buddhist” “chinese” “coptic” “ethiopic” “gregory” “hebrew” “indian” “islamic” “iso8601” “japanese” 和 “persian”。继续前面的例子，可以使用各种非公历来确定年份：

```js
let opts = { year:"numeric", era:"short"}
Intl.DateTimeFormat("en", opts) format(d) // "2020 AD"
Intl.DateTimeFormat("en-u-ca-iso8601", opts).format(d) // "2020 AD"
Intl.DateTimeFormat("en-u-ca-hebrew", opts) format(d) // "5780 AM"
Intl.DateTimeFormat("en-u-ca-buddhist", opts).format(d) // "2563 BE"
Intl.DateTimeFormat("en-U-ca-islamic", opts).format(d) // "1441 AH"
Intl.DateTimeFormat("en-u-ca-persian", opts).format(d)// "1398 AP"
Intl.DateTimeFormat("en-U-ca-indian", opts).format(d) // "1941 Saka"
Intl.DateTimeFormat("en-u-ca-chinese", opts) format(d) // "36 78"
Intl.DateTimeFormat("en-u-ca-japanese",opts).format(d) // "2 Reiwa"
```

#### 11.7.3 比较字符串

按字母顺序对字符串排序（或者更通用的说法是对非字母文字 “整理排序”）是一个经常超出英语人士预想的问题。英语的字母表相对较小，没有重音字母，而且有字符编码的优势（ASCII，已经整合到 Unicode 中），其中数字值完全匹配英语标准的字符串排序习惯。对其他语言来说就没有那么简单了。

如果想以自然的方式向用户显示字符串，只使用字符串数组的 `sort()` 方法是不够的。但如果创建一个 IntlCollator 对象，可以将这个对象的 compare() 方法传给 sort() 方法，以执行适合当地的字符串排序。Intl.Collator 对象可以配置让 compare() 方法执行不匹配大小写的比较，甚至只考虑基本字母且忽略重音和其他变音符号的比较。

与 Intl.NumberFormat() 和 Intl.DateTimeFormat() 类似，Intl.Collator() 构造函数也接收两个参数。第一个参数指定地区或地区数组，第二个参数是一个可选的对象，其属性指定具体执行哪种比较。以下是选项对象参数支持的属性。

**usage**
: 这个属性指定如何使用整理器（collator）对象，默认值为 "sort"，但也可以指定为 "search"。背后的思想是在排序字符串时，通常希望整理器区分尽可能多的字符串以产生可靠的排序。但在比较两个字符串时，某些地区可能想进行不那么严格的比较，比如忽略重音。

**sensitivity**
: 这个属性指定整理器在比较字符串时是否区分字母大小写和重音。值 "base" 意味着比较时忽略大小写和重音，只考虑每个字符的基本字母（不过要注意，某些语言认为有的重读字符不同于基本字母）。"accent" 在比较时考虑重音但忽略大小写。"case" 考虑大小写但忽略重音。而 "variant" 执行严格的比较，既区分大小写也考虑重音。这个属性的默认值在 usage 是 "sort" 时是 "variant"。如果 usage 是 "search"，默认的大小写规则取决于地区。

**ignorePunctuation**
: 将这个属性设置为 true 以便在比较字符串时忽略空格和标点符号。比如，将这个属性设置为 true 时，字符串 “any one” 和 “anyone” 会被认为相等。

**numeric**
: 如果比较的内容是整数或包含整数，而希望按照数值顺序而非字母顺序对它们进行排序，要将这个属性设置为 true。设置这个选项后，字符串 “Version9” 会排在 “Version10” 前面。

**caseFirst**
: 这个属性指定是大写字母还是小写字母应该排在前面。如果指定 "upper"，则 "A" 会排在 "a" 前面。如果指定 "lower"，则 "a" 会排在 "A" 前面。无论哪种形式优先，同一字母的大写变体和小写变体在排序中都会紧挨在一起，而不同于所有 ASCII 大写字母会位于所有 ASCII 小写字母之前的 Unicode 字典顺序（即 Array 的 sort() 方法的默认行为）。这个属性的默认值因地区而异，实现可能会忽略这个属性，不允许覆盖大小写排列的顺序。

在通过选项为目标地区创建 Intl.Collator 对象之后，可以使用它的 compare() 方法比较两个字符串。这个方法返回一个数值。如果返回的值小于 0，则第一个字符串位于第二个字符串前面。如果返回的值大于 0，则第一个字符串位于第二个字符串后面。如果 compare() 返回 0，则说明整理器认为两个字符串相等。

compare() 方法接收两个字符串参数，返回一个小于、等于或大于 0 的数值，这跟 Array 的 sort() 方法期待的可选参数和返回值特点完全一致。同样，Intl.Collator 也会自动将 compare() 方法绑定到它的实例，因此可以直接把这个方法传给 sort() 而无须编写包装函数再通过整理器调用它。下面是几个例子：

```js
// 按照用户地区排序的简单整理器
// 千万不要像这个例子这样什么也不传就对人类可读的字符串进行排序
const collator = new Intl.Collator().compare;
['a', 'z', 'A', 'Z'].sort(collator); // ["a", "A", "z", "Z"]

// 文件名经常包含数值，因此需要进行特殊排序
const filenameOrder = new Intl.Collator(undefined, { numeric: true }).compare;
['page10', 'page9'].sort(filenameOrder); // ["page9", "page10"]

// 查找大致匹配目标字符串的所有字符串
const fuzzyMatcher = new Intl.Collator(undefined, {
  sensitivity: 'base',
  ignorePunctuation: true
}).compare;

let strings = ['food', 'fool', 'Fog Bar'];
strings.findIndex((s) => fuzzyMatcher(s, 'foobar') === 0); // 2
```

有些地区可能存在多种整理顺序。比如在德国，电话号码簿使用与字典顺序稍微不一样的字母发音排序。1994 年以前在西班牙，“ch” 和 “ll” 被当成两个字母，因此该国目前有一个现代排序和一个传统排序。而在中国，整理顺序可以基于字符的编码、字符的笔画或字符的拼音。这些不同的整理方式无法通过 Intl.collator 的选项对象来指定，但可以通过给地区字符串添加 `-u-co-` 及期待的变体名字来指定。比如，在德国可以使用 "de-DE-U-co-phonebk" 来指定按字母发音排序：

```js
//1994年以前，西班牙将 CH 和 LL 当成两个字母
const modernSpanish = Intl.Collator('es-ES').compare;
const traditionalspanish = Intl.Collator('es-es-u-co-trad').compare;
let palabras = ['Luz', 'llama', 'como', 'chico'];
palabras.sort(modernSpanish); // ["chico", "como", "llama", "Luz"]
palabras.sort(traditionalSpanish); // ["como", "chico", "luz", "llama"]
```

### 11.8 控制台 API

在浏览器中，console.log() 会在开发者工具面板的 “控制台” 标签页中打印字符串，这是排查问题时非常有用的功能。在 Node 中，console.log() 是通用的输出函数，可以将其参数打印到进程的标准输出流，通常会作为程序输出显示在用户的终端窗口中。

除了 console.log() 之外，控制台 API 还定义了其他几个非常有用的函数。这个 API 并不是 ECMAScript 标准，但已经被浏览器和 Node 支持，并已经正式写入标准并通过 WHATWG 标准化: [https://console.spec.whatwg.org/](https://console.spec.whatwg.org/)

控制台 API 定义了以下函数：

**console.log()**
: 这是最常用的控制台函数。它将参数转换为字符串并输出到控制台。它会在参数之间输出空格，并在输出所有参数后重新开始一行。

**console.debug()、 console.info()、 console.warn()、 console.error()**
: 这几个函数与 console.log() 几乎相同。在 Node 中 console.error() 将其输出发送到标准错误流，而不是标准输出流。除此之外的其他函数都是 console.log() 的别名。在浏览器中，这几个函数生成的输出消息前面可能会带一个图标，表示级别或严重程度。开发者控制台可能也支持开发者按照级别筛选控制台消息。

**console.assert()**
: 如果这个函数的第一个参数是真值（也就是断言通过），则这个函数什么也不做。但如果第一个参数是 false 或其他假值，则剩余参数会像被传给 console.error() 一样打印出来，且前面带一个 “Assertion failed” 前缀。注意，与典型的 assert() 函数不同，console.assert() 不会在断言失败时抛出异常。

**console.clear()**
: 这个函数在可能的情况下清空控制台。在浏览器及 Node 中通过终端显示输出时，这个函数是有效的。如果 Node 的输出被重定向到文件或管道，则调用这个函数没有任何效果。

**console.table()**
: 这个函数有一个极其强大但却鲜为人知的特性，即可以生成表列数据输出，这对于需要产生摘要数据的 Node 程序尤其有用。console.table() 尝试以表列形式显示其参数（如果无法实现，则使用常规的 console.log() 格式）。如果参数是相对比较短的对象数组，而数组中的所有对象具有（不那么多的）相同属性时，使用这个函数效果最好。在这种情况下，数组中的每个对象的信息会显示在表格的一行中，对象的每个属性就是表格的一列。也可以传入一个属性数组作为可选的第二个参数，以指定想要显示的列。如果传显示属性值入的是对象而非对象的数组，那么输出会用一列显示属性名，一列显示属性名。如果属性值本身也是对象，则它们的属性名会变成表格的列。

**console.dir()**
: 可以显示指定 JS 对象的属性列表，并以交互式的形式展现。输出结果呈现为分层列表，包含展开/折叠的三角形图标，可用于查看子对象的内容。

**console.trace()**
: 这个函数会像 console.log() 一样打印它的参数，此外在输出之后还会打印栈跟踪信息。在 Node 中，这个函数的输出会进入标准错误而不是标准输出。

**console.count()**
: 这个函数接收一个字符串参数，并打印该字符串，后面跟着已经通过该字符串调用的次数。在调试事件处理程序时，如果需要知道事件处理程序被触发的次数，可以使用这个函数。

**console.countReset()**
: 这个函数接收一个字符串参数，并重置针对该字符串的计数器。

**console.group()**
: 这个函数将它的参数像传给 console.log() 一样打印到控制台，然后设置控制台的内部状态，让所有后续的控制台消息（在下一次调用 console.groupEnd() 之前）相对刚刚打印的消息缩进。这样可以通过缩进从视觉上把相关消息分为一组。在浏览器中，开发者控制台通常支持分组后消息以组为单位折叠和扩展。console.group() 的参数通常用于为分组提供解释性的名字。

**console.groupCollapsed()**
: 这个函数与 console.group() 类似，但在浏览器中分组默认会被 “折叠”，因而其中包含的消息会隐藏，除非用户点击扩展分组。在 Node 中，这个函数与 console.group() 是同义函数。

**console.groupEnd()**
: 这个函数没有参数，本身也没有输出，只用于结束由最近一次调用 console.group() 或 console.groupCollapsed() 导致的缩进和分组。

**console.time()**
: 这个函数接收一个字符串参数，并记录以该字符串调用自身时的时间，没有输出。

**console.timeLog()**
: 这个函数接收字符串作为第一个参数。如果这个字符串之前传给过 console.time()，那么它会打印该字符串及自上次调用 console.time() 之后经过的时间。如果还有额外的参数传给 console.timeLog()，则这些参数会像被传给 console.log() 一样打印出来。

**console.timeEnd()**
: 这个函数接收一个字符串参数。如果该参数之前传给过 console.time()，则它打印该参数及经过的时间。在调用 console.timeEnd() 之后，如果不再调用 console.time()，则调用 console.timeLog() 将是不合法的。

**console.memory**
: 这是一个属性，而不是方法，可以用来检查内存信息。

#### 11.8.1 通过控制台格式化输出

像 console.log() 这样打印自己参数的控制台函数都有一个不太为人所知的特性：如果第一个参数是包含 `%s`、`%i`、`%d`、`%f`、`%o`、`%O` 或 `%c` 的字符串，则这个参数会被当成格式字符串，后续参数的值会被代入这个字符串，以取代这些两个字符的 `%` 序列。

这些序列的含义如下：

**%s**
: 这个参数会被转换为字符串。

**%i 和 %d**
: 这个参数会被转换为数值，然后截断为整数。

**%f**
: 这个参数会被转换为数值。

**%o 和 %O**
: 这个参数会被转换为对象，对象的属性名和值会显示出来（在浏览器中，显示结果通常是可以交互的，用户可以扩展和折叠属性以查看嵌套的数据结构）。`%o` 和 `%O` 都会显示对象细节。但大写的变体使用实现决定的输出格式，即由实现决定什么格式对软件开发者最有用。

**%c**
: 在浏览器中，这个参数会被解释为 CSS 样式字符串，用于给后面的文本添加样式（直到下一个 `%c` 序列或字符串结束）。在 Node 中，`%c` 序列及其对应的参数会被忽略。

> **注意**：在使用控制台函数时，通常并不需要格式字符串。一般来说，只要把一个或多个值（包括对象）传给这些函数，由实现决定如何以有用的方式显示它们就可以了。比如，给 console.log() 传入一个 Error 对象，它会自动在打印输出中包含栈跟踪信息。

### 11.9 URL API

由于 JS 多用于浏览器和服务器，因此 JS 代码经常需要操作 URL。URL 类可以解析 URL，同时允许修改已有的 URL（如添加搜索参数或修改路径），还可以正确处理对不同 URL 组件的转义和反转义。

URL 类并不是 ECMAScript 标准定义的，但 Node 和所有浏览器（除 IE 之外）都实现了它。这个类是在 WHATWG 中标准化的，参见 [https://url.spec.whatwg.org/](https://url.spec.whatwg.org/)

使用 URL() 构造函数创建 URL 对象时，要传入一个绝对 URL 作为参数。也可以将一个相对 URL 作为第一个参数，将其相对的绝对 URL 作为第二个参数。创建了 URL 对象后，可以通过它的各种属性查询 URL 不同部分的非转义值：

```js
let url = new URL('https://example.com:8000/path/name?q=term#fragment');
url.href; // "https://example.com:8000/path/name?q=term#fragment"
url.origin; // "https://example.com:8000"
url.protocol; // "https:"
url.host; // "example.com:8000"
url.hostname; // "example.com"
url.port; // 8080
url.pathname; // "/path/name"
url.search; // "?q=term"
url.hash; // "#fragment"
```

尽管并不常用，但 URL 可以包含用户名或者用户和密码，URL 类也可以解析这些 URL 组件：

```js
let url = new URL('ftp://admin:1337!@ftp.example.com/');
url.href; // "ftp://admin:1337!@ftp.example.com/"
url.origin; // "ftp://ftp.example.com"
url.username; // "admin"
url.password; // 1337
```

这里的 `origin` 属性就是 URL 协议和主机的组合（如果提供了端口，则也会包含在内），而且它是个只读属性。但前面例子中展示的其他属性是可读写属性，即可以通过设置这些属性来设置 URL 中对应的部分：

```js
let url = new URL('https://example.com'); // 创建服务器 URL
url.pathname = 'api/search'; // 为这个 API 添加路径
url.search = 'q=test'; // 添加查询参数
url.toString(); // "https://example.com/api/search?q=test"
```

**URL 类有一个重要特性，即它会在需要时正确地在 URL 中添加标点符号及转义特殊字符**：

```js
let url = new URL('https://example.com');
url.pathname = 'path with spaces';
url.search = 'q=foo#bar';
url.pathname; // "/path%20with%20spaces"
url.search; // "?q=foo%23bar"
url.href; // "https://example.com/path%20with%20spaces?q=foo%23bar"
```

以上例子中的 `href` 属性比较特殊，读取 `href` 属性相当于调用 toString()，即将 URL 的所有部分组合成一个字符串形式的正式 URL。将 `href` 设置为一个新字符串会返回新字符串的 URL 解析器，就好像再次调用了 URL() 构造函数一样。

在前面的例子中，使用 `search` 属性引用 URL 中的整个查询部分。查询部分从一个问号开头到 URL 末尾或第一个井字符结束。有时候，把这个部分作为一个 URL 属性就足够了。但是，HTTP 请求经常会使用 `application/x-www-form-urlencoded` 格式将多个表单字段的值或多个 API 参数编码为 URL 的查询部分。在这个格式中，URL 的查询部分以问号开头，然后是一个或多个由和号（&）分隔的名/值对。可以有多个相同的名字，此时该搜索参数就有多个值。

如果要把这种名/值对编码为 URL 的查询部分，那么 `searchParams` 属性比 `search` 属性更有用。`search` 属性是一个可读写的字符串，通过它可以获取或设置 URL 的查询部分。`searchParams` 属性则是一个对 URLSearchParams 对象的只读引用，而 URLSearchParams 对象具有获取、设置、添加、删除和排序参数（该参数编码为 URL 查询部分）的 API：

```js
let url = new URL("https://example.com/search");
url.search // "" 还没有参数
url.searchParams.append("q", "term");// 添加一个搜索参数
url.search// "?q=term"
url.searchParams.set("q","x") // 修改这个参数的值
url.search // "?q=x"
url.searchParams.get("q") // "x"：查询参数值
url.searchParams.has("q") // true：有一个 q 参数
url.searchParams.has ("p") // false：没有 p 参数
url.searchParams.append("opts","1");// 再添加一个搜索参数
url.search // "?q=x&opts=1"
url.searchParams.append("opts","&"); // 为同一个参数再添加一个值
url.search // "?q=x&opts=1&opts=%26"：有转义
url.searchParams.get("opts") // "1"：第一个值
url.searchParams.getAll("opts") // ["1", "&"]：所有值
url.searchParams.sort() // 对参数进行排序
url.search // "?opts=1&opts=%26&q=x"
url.searchParams.set("opts","y"); // 修改 opts 参数
url.search // "?opts=y&q=x"
// searchParams 是可迭代对象
[...urL.searchParams] // [["opts", "y"],["q", "x"]]
url.searchParams.delete("opts") // 删除 opts 参数
url.search // "?q=x"
url.href // "https://example.com/search?q=x"
```

`searchParams` 属性的值是一个 URLSearchParams 对象。如果想把 URL 参数编码为查询字符串，可以创建 URLSearchParams 对象，追加参数，然后再将它转换为字符串并将其赋值给 URL 的 search 属性：

```js
let url = new URL('http://example.com');
let params = new URLSearchParams();
params.append('q', 'term');
params.append('opts', 'exact');
params.toString(); // "q=term&opts=exact"
url.search = params;
url.href; // "http://example.com/?q=term&opts=exact"
```

#### 11.9.1 遗留 URL 函数

在前面介绍的 URL API 标准化之前，JS 语言也曾多次尝试支持对 URL 的转义和反转义。第一次尝试定义全局的 escape() 和 unescape() 函数，这两个函数如今已经废弃，但仍然被广泛实现了。不应该再使用这两个函数了。

在废弃 escape()和 unescape() 的同时，ECMAScript 增加了两对替代性的全局函数：

**encodeURI() 和 decodeURI()**
: encodeURI() 接收一个字符串参数，返回一个新字符串，新字符串中非 ASCII 字符及某些 ASCII 字符（如空格）会被转义。decodeURI() 正好相反。需要转义的字符首先会被转换为它们的 UTF-8 编码，然后再将该编码的每个字节替换为 `%xx` 转义序列，其中 `xx` 是两个十六进制数字。因为 encodeURI() 是要编码整个 URL，所以不会转义 URL 分隔符（如`/`、`?` 和 `#`）。但这意味着 encodeURI() 不能正确地处理其组件中包含这些字符的 URL。

**encodeURIComponent() 和 decodeURIComponent()**
: 这对函数与 encodeURI() 和 decodeURI() 类似，只不过它们专门用于转义 URL 的单个组件，因此它们也会转义用于分隔 URL 组件的 `/`、`?` 和 `#` 字符。这两个函数是最有用的遗留 URL 函数，但要注意 encodeURIComponent() 也会转义路径名中的 `/` 字符，而这可能并不是想要的。另外它也会把查询参数中的空格转换为 `%20`，而实际上查询参数中的空格应该被转义为 `+`。

> 这些遗留函数的根本问题在于它们都在寻求把一种编码模式应用给 URL 的所有部分，而事实却是 URL 的不同部分使用的是不同的编码方案。如果想正确地格式化和编码 URL，最简单的办法就是使用 URL 类完成所有 URL 相关的操作。

### 11.10 计时器

从 JS 问世开始，浏览器就定义了两个函数: `setTimeout()` 和 `setInterval()`。利用这两个函数，程序可以让浏览器在指定的时间过后调用一个函数，或者每经过一定时间就重复调用一次某个函数。这两个函数至今没有被写进核心语言标准，但所有浏览器和 Node 都支持，属于 JSON 标准库的事实标准。

setTimeout() 的第一个参数是函数，第二个参数是数值，数值表示过多少毫秒之后调用第一个函数。在经过指定时间后（如果系统忙可能会稍微晚一点），将会调用作为第一个参数的函数，没有参数。

> **注意**：setTimeout() 并不会等到指定时间之后再返回。它会立即运行并返回，只是在未到 1000 毫秒时什么也不会发生。

如果省略传给 setTimeout() 的第二个参数，则该参数默认值为 0。但这并不意味着函数会立即被调用，只意味着这个函数会被注册到某个地方，将被 “尽可能快地” 调用。如果浏览器由于处理用户输入或其他事件而没有空闲，那么调用这个函数的时机可能在 10 毫秒甚至更长时间以后。

setTimeout() 注册的函数只会被调用一次。有时候，这个函数本身会再次调用 setTimeout()，以便将来某个时刻会再有一次调用。不过，要想重复调用某个函数，通常更简单的方式是使用 setInterval()。setInterval() 接收的参数与 setTimeout() 相同，但会导致每隔指定时间（同样是个近似的毫秒值）就调用一次指定函数。

setTimeout() 和 setInterval() 都返回一个值。如果把这个值保存在变量中，之后可以把它传给 clearTimeout() 或 clearInterval() 以取消对函数的调用。在浏览器中，这个返回值通常是一个数值，而在 Node 中则是一个对象。具体什么类型其实不重要，只要把它当成一个不透明的值就行了。这个值的唯一作用就是可以把它传给 clearTimeout() 以取消使用 setTimeout() 注册的函数调用（假设函数尚未被调用），或者传给 clearInterval() 以取消对通过 setInterval() 注册的函数的重复调用。
