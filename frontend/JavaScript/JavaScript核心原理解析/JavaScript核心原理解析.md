# JavaScript 核心原理解析

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [JavaScript 核心原理解析](#javascript-核心原理解析)
  - [一. JS 是如何构建起来的](#一-js-是如何构建起来的)
    - [1.1 规范引用](#11-规范引用)
      - [1.1.1 delete 删除的是表达式的引用类型的结果](#111-delete-删除的是表达式的引用类型的结果)
      - [1.1.2 规范中的引用](#112-规范中的引用)
      - [1.1.3 引用的作用](#113-引用的作用)
    - [1.2 声明语句与语法改变了 JS 语言核心性质](#12-声明语句与语法改变了-js-语言核心性质)
      - [1.2.1 声明](#121-声明)
      - [1.2.2 赋值](#122-赋值)
      - [1.2.3 变量泄露：向一个不存在的变量名赋值](#123-变量泄露向一个不存在的变量名赋值)
    - [1.3 表达式执行与语句声明之间的区别](#13-表达式执行与语句声明之间的区别)
    - [1.4 名字的使用](#14-名字的使用)
      - [1.4.1 解析 export](#141-解析-export)
      - [1.4.2 导出语句的处理逻辑](#142-导出语句的处理逻辑)
      - [1.4.3 导出名字和导出值的差异](#143-导出名字和导出值的差异)
      - [1.4.4 匿名函数表达式的执行结果](#144-匿名函数表达式的执行结果)
      - [1.4.5 知识补充](#145-知识补充)
    - [1.5 语句中的块级作用域](#15-语句中的块级作用域)
      - [1.5.1 块级作用域的特例](#151-块级作用域的特例)
      - [1.5.2 for 循环的代价](#152-for-循环的代价)
  - [二. JS 是如何运行的](#二-js-是如何运行的)
    - [2.1 中断语句](#21-中断语句)
      - [2.1.1 用中断（Break）代替跳转](#211-用中断break代替跳转)
      - [2.1.2 执行现场的回收](#212-执行现场的回收)
      - [2.1.3 语句执行的意义](#213-语句执行的意义)
      - [2.1.4 中断语句的特殊性](#214-中断语句的特殊性)
    - [2.2 JS 中特殊的可执行结构](#22-js-中特殊的可执行结构)
      - [2.2.1 参数表](#221-参数表)
      - [2.2.2 扩展风格的参数表](#222-扩展风格的参数表)
      - [2.2.3 模板赋值](#223-模板赋值)
      - [2.2.4 模板字面量](#224-模板字面量)
    - [2.3 函数式语言的核心抽象：函数与表达式的同一性](#23-函数式语言的核心抽象函数与表达式的同一性)
      - [2.3.1 函数的一体两面（一等公民）](#231-函数的一体两面一等公民)
      - [2.3.2 两个语义组件](#232-两个语义组件)
      - [2.3.3 参数类型](#233-参数类型)
      - [2.3.4 传入参数的处理](#234-传入参数的处理)
      - [2.3.5 非简单参数的无初值绑定](#235-非简单参数的无初值绑定)
    - [2.4 重构函数语义组件-执行体](#24-重构函数语义组件-执行体)
      - [2.4.1 递归与迭代](#241-递归与迭代)
      - [2.4.2 迭代对执行过程的重造和使用](#242-迭代对执行过程的重造和使用)
      - [2.4.3 内部迭代过程](#243-内部迭代过程)
      - [2.4.4 管理循环与异常处理](#244-管理循环与异常处理)
    - [2.5 重构函数语义组件-结果和参数](#25-重构函数语义组件-结果和参数)
      - [2.5.1 将迭代过程展开](#251-将迭代过程展开)
      - [2.5.2 逻辑的重现](#252-逻辑的重现)
      - [2.5.3 .next() 方法](#253-next-方法)
      - [2.5.4 对传入参数的改造](#254-对传入参数的改造)
    - [2.6 ECMAScript 规范](#26-ecmascript-规范)
      - [2.6.1 最简单语法榜](#261-最简单语法榜)
      - [2.6.2 在语句之外看语句](#262-在语句之外看语句)
      - [2.6.3 值的覆盖与读取](#263-值的覆盖与读取)
      - [2.6.4 引用的值](#264-引用的值)
      - [2.6.5 完成状态](#265-完成状态)
  - [三. JS 是如何一步步走向应用编程语言的](#三-js-是如何一步步走向应用编程语言的)
    - [3.1 JS 面向对象系统](#31-js-面向对象系统)
      - [3.1.1 JS 1.0~1.3 中的对象](#311-js-1013-中的对象)
      - [3.1.2 属性访问与可见性](#312-属性访问与可见性)
      - [3.1.3 从原型中继承来的属性](#313-从原型中继承来的属性)
      - [3.1.4 字面量与标识符](#314-字面量与标识符)
      - [3.1.5 属性存取的不确定性](#315-属性存取的不确定性)
    - [3.2 从构造器到类](#32-从构造器到类)
      - [3.2.1 基于对象的 JS](#321-基于对象的-js)
      - [3.2.2 类与构造器](#322-类与构造器)
      - [3.2.3 ES6 之后的类](#323-es6-之后的类)
      - [3.2.4 创建 this 的顺序问题](#324-创建-this-的顺序问题)
      - [3.2.5 用户返回 new 的结果](#325-用户返回-new-的结果)
    - [3.3 super.xxx()](#33-superxxx)
      - [3.3.1 super 出现的原因](#331-super-出现的原因)
      - [3.3.2 super 指向父类](#332-super-指向父类)

<!-- /code_chunk_output -->

**JS 是一门多范型语言，也称为混合范型语言**。JS 的简单来自于此，复杂也来自于此；生存能力来自于此，抨击诟病也来自于此。

JS 主要包括 5 个方面的语言特性：

- 结构化编程
- 面向对象编程
- 动态语言
- 函数式语言
- 并行语言

所谓的语言特性，其实是对语言的核心抽象概念的语法表现。

## 一. JS 是如何构建起来的

“物理到逻辑” 的映射。

### 1.1 规范引用

早期的 JS 在推广时，仍然采用传统的数据类型的分类方法，也就是说，它宣称自己同时支持值类型和引用类型的数据，并且，所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。

JS 强行定义了 “Object 和 Function 就是引用类型”。对象和函数也就可以理解为：它们按引用来传递和使用。绝大多数情况下，这样解释起来是行得通的。但是到了 `delete` 运算这里，就不行。

因为这样一来，`delete 0` 就是删除一个值，而 `delete x` 就既可能是删除一个值，也可能是删除一个引用。然而，当时 JS 又同时约定：那些在 global 对象上声明的属性，就 “等同于” 全局变量。于是，这就带来了第三个问题：`delete x` 还可能是删除一个 global 对象上的属性。而它在执行这个操作的时候，看起来却像是一个全局变量。

`delete` 这个运算的表面意思，是该运算试图销毁某种东西。然而，`delete 0` 中的 0 是一个具体的、字面量表示的 “值”。一个字面量值 “0” 如何在现实世界中销毁呢？假定它销毁了，那是不是说，在这个语言当前的运行环境中，就不能使用 0 这个值了呢？显然，这不合理。所以，JS 认为 “**所有删除值的 delete 就直接返回 true**”，表明该行为过程中没有异常。

`delete` 出现的时代并没有结构化异常处理（即 try/catch 语句）。所以，通过函数调用中返回 true 来表明 “没有异常”，其实是很常规的做法。然而，返回值只表明执行过程中没有异常，但实际的执行行为是 “什么也没发生”。显然不可能真的将 “0” 从执行系统中清理出去。

那么接下来，就还剩下删除变量和删除属性。由于全局变量实际上是通过全局对象的属性来实现的，因此删除变量也就存在识别这两种行为的必要性。例如：

```js
delete x;
```

出于 JS 是动态语言这项特性，从根本上来说，是没有办法在语法分析期来判断 x 的性质的。所以现在，需要有一种方法在运行期来标识 x 的性质，以便进一步地处理它。这就导致了一种新的 “引用” 类型呼之欲出。

#### 1.1.1 delete 删除的是表达式的引用类型的结果

对于一门编译型语言来说，所谓 “0”，就是上面所述的一个值，它可以是基础值（Primitive values），也可以是数值类型。但如果将这个问题上升到编译之前的、所谓语法分析的阶段，那么 “0” 就会被称为一个记号（Tokens）。一个记号是没有语义的，记号既可以是语言能识别的，也可以是语言不能识别的。唯有把这二者同时纳入语言范畴，那么这个语言才能识别所谓的 “语法错误”。

`delete` 不仅仅是要操作 0 或 x 这样的单个记号或标识符（例如变量）。因为这个语法实际起作用的是一个对象的属性，也就是 “删除对象的成员”。那么它真正需要的语法其实是：

```js
delete obj.x;
```

只不过因为全局对象的成员可以用全局变量的形式来存取，所以它才能这样写：

```js
delete x;
```

所以，这正好将之前所认识的倒转过来，是删除 x 这个成员，而不是删除 x 这个值。不过有一点是没错的：既然没办法表达异常，而 delete 0 又不产生异常，那么它自然就该返回 true。

然而，如果理解了 `delete obj.x`，那么就一定会想到：`obj.x` 既不是引用类型，也不是值类型，它与 `typeof(x)` 识别的所有类型都无关。因为，它是一个表达式。所以，**delete 这个操作的正式语法设计并不是 “删除某个东西”，而是 “删除一个表达式的结果”**：

**表达式的结果**
**在 JS 中表达式是一个很独特的东西，所有一切表达式运算的终极目的都是为了得到一个值**。然后再用另外一些操作将这个值输出出来，例如变成网页中的一个元素（element）。这是 JS 语言创生的原力，也是它的基础设计。也只是因为有了这种设计，它才变得既像面向对象的，又像函数式语言的样子。

这个表达式得到的值，才是 delete 这个操作要删除的东西。在 JS 中，有两个东西可以被执行并存在执行结果：

- **语句**

  比如用 eval() 来执行一个字符串，那么实际上，执行的是一个语句，并返回了语句的值。

- **表达式**

  如果使用一对括号来强制一个表达式执行，那么这个括号运算得到的，就是这个表达式的值。表达式的值，在 ECMAScript 的规范中，称为 “引用”。这是一种称为 “规范类型” 的东西。

#### 1.1.2 规范中的引用

实际上这个概念出现得很早。从 JS 1.3 开始，ECMAScript 规范就在语言定义的层面，正式地将上述的天坑补起来，推出了 “（真正的）引用类型”。

但是，由于这个时候规范的影响力在开发人员中并不那么大，所以开发人员还是习惯性地将对象和函数称为引用，而其它类型就称为值，并且继续按照传统的理解来解释 JS 中对数据的处理。

这种情况下，一个引用只是在语法层面上表达 “它是对某种语法元素的引用”，而与在执行层面的值处理或引用处理没关系。所以，下面这行简短的语句：

```js
delete 0;
```

实际上是在说：JS 将 0 视为一个表达式，并尝试删除它的求值结果。所以，现在这里的 0，不是值类型的数据，而是一个表达式运算的结果。而在进一步的删除操作之前，JS 需要检测这个 Result 的类型：

- 如果它是值，则按照传统的 JS 的约定返回 true。
- 如果它是一个引用，那么对该引用进行分析，以决定如何操作。

ECMAScript 约定：任何表达式计算的结果要么是一个值，要么是一个引用。并且需要留意的是，在这个描述中，所谓对象，其实也是值。准确地说，是 “非引用类型”。例如：

```js
delete {};
```

那么显然，这里要删除的一对大括号是表示一个字面量的对象，当它被作为表达式执行的时候，结果也是一个值。这也是这类表达式被称为 “单值表达式” 的原因，这里并没有所谓的 “引用”。

可以这样，非常细致而准确地解释这一行代码：_单值表达式的运算结果返回那个 “对象字面量” 的单值。然后，delete 运算发现它的操作数是 “值/非引用类型”，就直接返回了 true。所以，什么也没有发生。_

在 JS 的内部，“引用” 是可以转换为 “值”，以便参与值运算的。因为表达式的本质是求值运算，所以引用是不能直接作为最终求值的操作数的。这依赖于一个非常核心的、称为 “GetValue()” 的**内部操作**。所谓内部操作，也称为内部抽象操作（internal abstract operations），是 ECMAScript 描述一个符合规范的引擎在具体实现时应当处理的那些行为。

**GetValue() 是从一个引用中取出值来的行为**。比如说下面这行代码：

```js
x = x;
```

上面的表达式其实是一个赋值表达式， “引用 x 赋值给引用 x” 其实这在语法层面来解释是非常直接的：

> 所有赋值操作的含义，是将右边的 “值”，赋给左边用于包含该值的 “引用”。

上面的 x=x，其实就是被翻译成：

```js
x = GetValue(x);
```

JS 识别两个 x 的不同的方法被称为**手性**，即是所谓 “左手端（lhs, left hand side）” 和 “右手端（rhs）”。它本来是用来描述自然语言的语法中，一个修饰词应该是放在它的主体的前面或是后面的。而在程序设计语言中，它用来说明一个记号（Token）是放在了赋值符号（例如 “=” 号）的左边或是右边。

> x 放在左边作为 lhs，它是引用。放在右边作为 rhs，就是值。

所以 x=x 的语义并不是 “x 赋给 x”，而是 “**把值 x 赋给引用 x**”。因此 “delete x” 归根到底，**是在删除一个表达式的、引用类型的结果**，而不是在删除 x 表达式，或者这个删除表达式的值。

在 JS 中的 delete 是一个很罕见的、能直接操作 “引用” 的语法元素。由于这里的 “引用” 是在 ECMAScript 规范层面的概念，因此在 JS 语言中能操作它的语法元素其实非常少。

#### 1.1.3 引用的作用

“属性存取运算符（.）” 返回一个关于 “x” 的引用，然后它可以作为下一个操作符（例如函数调用运算 “()”）的左手端来使用，这才有了著名的 “对象方法调用” 运算：

```js
obj.x();
```

因为在对象方法调用的时候，函数 x() 是来自于 obj.x 这个引用的，所以这个引用将 obj 这个对象传递给 x()，这才会让函数 x() 内部通过 this 来访问到 obj。

根本上来说，如果 obj.x 只是值，或者它作为右手端，那么它就不能 “携带” obj 这个对象，也就完成不了后续的方法调用操作。

> 对象存取 + 函数调用 = 方法调用

这是 JS 通过连续表达式运算来实现新的语义/语法的经典示例。而 “连续运算” 其实是函数式运算范式的基本原则。也就是说，obj.x() 是在 JS 中集合了 “引用规范类型操作” “函数式” “面向对象” 和 “动态语言” 等多种特性于一体的一个简单语法。

而它对语言的基础特性的依赖，就在于：

- delete 0 中的这个 0 是一个表达式求值
- delete x 中的 x 是一个引用
- delete obj.x 中 obj.x 是一组表达式连续运算的结果/引用

当 x 是全局对象 global 的属性时，所谓 delete x 其实只需要返回 global.x 这个引用就可以了。而当它不是全局对象 global 的属性时，那么就需要从当前环境中找到一个名为 x 的引用。找到这两种不同的引用的过程，称为 ResolveBinding；而这两种不同的 x，称为不同环境下绑定的标识符/名字。

### 1.2 声明语句与语法改变了 JS 语言核心性质

#### 1.2.1 声明

至今为止，除标签声明之外，JS 中一共只有六条声明用的语句。

> **注意**：所有真正被定义 “声明” 的语法结构都一定是 “语句”，并且都用于声明一个或多个标识符。这里的标识符包括变量、常量等。

严格意义上讲，JS 只有变量和常量两种标识符，六条声明语句中：

- `let x`：声明变量 x。不可在赋值之前读。
- `const x`：声明常量 x。不可写。
- `var x`：声明变量 x。在赋值之前可读取到 undefined 值。
- `function x`：声明变量 x。该变量指向一个函数。
- `class x`：声明变量 x。该变量指向一个类（该类的作用域内部是处理严格模式的）。
- `import x`：导入标识符并作为常量（有多种声明标识符的模式和方法）。

除了这六个语句之外，还有两个语句有潜在的声明标识符的能力，不过它们并不是严格意义上的声明语句（声明只是它们的语法效果）。这两个语句是指：

- `for (var|let|const x)`：for 语句有多种语法来声明一个或多个标识符，用作循环变量。
- `try … catch (x)`：catch 子句可以声明一个或多个标识符，用作异常对象变量。

声明是在语法分析阶段就处理的，并且因此它会使得当前代码上下文在正式执行之前就拥有了被声明的标识符，例如 x。

这其实非常有趣，因为这表明 **JS 虽然被称为是 “动态语言”，但确实是拥有静态语义的**。而在 JS 的早期，这个静态语义其实并没有处理得太好，一个典型的问题就是所谓的 “变量提升”。也就是可以在变量声明之前访问该变量。例如：

```js
console.log(x); // undefined
var x = 100;
console.log(x); // 100
```

由于标识符是在用户代码执行之前就已经由静态分析得到，并且创建在环境中，因此 let 声明的变量和 var 声明的变量在这一点上没有不同：它们都是在读取一个 “已经存在的” 标识符名。

在 ES6 之后出现的 let/const 变量在 “声明（和创建）一个标识符” 这件事上，与 var 并没有什么不同，只是 JS 拒绝访问还没有绑定值的 let/const 标识符而已。

ES6 之前：JS 是允许访问还没有绑定值的 var 所声明的标识符的。这种标识符后来统一约定称为 “**变量声明**（varDecls）”，而 “let/const” 则称为 “**词法声明**（lexicalDecls）”。JS 环境在创建一个 “变量名（varName in varDecls）” 后，会为它初始化绑定一个 undefined 值，而 “词法名字（lexicalNames）” 在创建之后就没有这项待遇，所以它们在默认情况下就是 “还没有绑定值” 的标识符。

> 6 种声明语句中的函数是按变量声明的规则声明的；类的内部是处于严格模式中，它的名字是按 let 来处理的，而 import 导入的名字则是按 const 的规则来处理的。所以，**所有的声明本质上只有三种处理模式：var 变量声明、let 变量声明和 const 常量声明**。

#### 1.2.2 赋值

如果是在一门其它的（例如编译型的）语言中，“为变量 x 绑定一个初值” 就可能实现为 “在创建环境时将变量 x 指向一个特定的初始值”。这通常是静态语言的处理方法。JS 是门动态的语言，所以它的 “绑定初值” 的行为是通过动态的执行过程来实现的，也就是赋值操作。

在 JS 中，不是 `值 = 变量` 而是将右操作数（的值）赋给左操作数（的引用）：

```js
lRef = rValue;
```

它的严格语法表达是：

```txt
LeftHandSideExpression < = | AssignmentOperator >
AssignmentExpression
```

也就是说，在 JS 中，一个赋值表达式的左边和右边其实 “都是” 表达式。

#### 1.2.3 变量泄露：向一个不存在的变量名赋值

这是从 JS 1.0 开始就遗留下来的一个巨坑，也就是 “变量泄漏” 问题。这在早期的 JS 中的确是一个好用的特性：如果向一个不存在的变量名赋值，那么 JS 会在全局范围内创建它。

也就是说，代码中不需要显式地声明一个变量了，变量可以随用随声明，也不用像后来的 let 语句一样，还要考虑在声明语句之前能不能访问的问题了。这非常简单，在少量的代码中也相当易用。

但是，如果代码规模扩大，变成百千万行代码，那么 “一个全局变量是在哪里声明和创建的” 就变成一个非常要紧的问题。

如果随时都可能泄露一个代码给全局，或者随时都可能因为忘记本地的声明而读写了全局变量，那对调试除错将是一场灾难。另外，晚一些出现的运行期优化技术也不能很好地处理这种情况。所以从 ECMAScript5 开始的严格模式就禁止了这种特性，试图避免用户将变量泄露到全局环境。然而，即使在严格模式下这种漏露也未能避免，被称为 “**间接执行**”。

这种变量声明的发生是因为在早期设计中，JS 的全局环境是引擎使用一个称为 “**全局对象**” 东西管理起来的。

这个全局对象几乎类似或完全等同于一个普通对象。只不过，JS 引擎将全局的一些默认对象、运行期环境的原生对象等东西都初始化在这个全局对象的属性中，并使用这个对象创建了一个称为 “**全局对象闭包**” 的东西，从而得到了 JS 的全局环境。

早期的 JS 的引擎实现非常简洁，许多基础的技术组件都是直接复用的，例如这里的所谓全局环境、全局闭包，或者全局对象的实现方法，就与 “with 语句” 的效果完全相同——他们是相互复用的。

当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此 JS 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了 “可以动态地向全局环境中添加一个变量”。并且，可以删除掉这个动态添加的 “变量”，因为本质上就是在删除全局对象的属性。

ES6 的全局环境为了兼容旧的 JS 语言设计，所以仍然是通过将全局对象初始化为这样的一个全局闭包来实现的。但是为了得到一个 “尽可能” 与其它变量环境相似的声明效果（varDecls），ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames），所有在静态语法分析期或在 eval() 中使用 var 声明的变量名就被放在这个列表中。然后约定，这个变量名列表中的变量是 “直接声明的变量”，不能使用 delete 删除。

于是，得到了这样的一种结果：

```js
// a 和 x 都是 global 的属性
var a = 100;
x = 200;

Object.getOwnPropertyDescriptor(global, 'a'); // { value: 100, writable: true, enumerable: true, configurable: false }
Object.getOwnPropertyDescriptor(global, 'x'); // { value: 200, writable: true, enumerable: true, configurable: true }

// a 不能删除，x 可以被删除
delete a; // false
delete x; // true

// 检查
console.log(a); // 100
console.log(x); // ReferenceError: x is not defined
```

所以，表面看起来 “泄漏到全局的变量” 与使用 var 声明的都是全局变量，并且都实现为 global 的属性，但事实上它们是不同的。并且当 var 声明发生在 eval() 中的时候，这一特性又还有所不同，例如：

```js
// 使用eval声明
eval('var b = 300');

// 它的性质是可删除的
Object.getOwnPropertyDescriptor(global, 'b').configurable; // true

// 检测与删除
b; // 300
delete b; // true
b; // ReferenceError: b is not defined
```

这种情况下使用 var 声明的变量名尽管也会添加到 varNames 列表，但它也可以从 varNames 中移除（这是唯一一种能从 varNames 中移除项的特例，而 lexicalNames 中的项是不可移除的）。

### 1.3 表达式执行与语句声明之间的区别

JS 总是严格按照从左至右的顺序来计算表达式。

```js
w = x + y * z;
```

上面的代码中将首先计算子表达式 w，然后计算 x、y 和 z；然后，y 的值和 z 的值相乘，再加上 x 的值；最后将其赋值给表达式 w 所指代的变量或属性。

任何运算的操作数都是严格从左至右计算的，因此 x 先被处理，然后才会尝试对 y 和 z 求乘积。这里的 “x 先被处理” 是 JS 中的一个特异现象，即：**一切都是表达式，一切都是运算**。

这一现象在语言中是函数式的特性，类似 “一切被操作的对象都是函数求值的结果，一切操作都是函数”。

```js
var a = { n: 1 };
a.x = a = { n: 2 };
console.log(a.x); // undefined
```

上面代码中的第二行是两个连续赋值的表达式：

1. **a.x 总是最先被计算求值的**（从左至右）

   “a.x” 也是一个表达式，其结果是一个 “引用”。这个表达式 “a.x” 本身也要再计算它的左操作数，也就是 “a”。完整地讲，“a.x” 这个表达式的语义是：

   - 计算单值表达式 a，得到 a 的引用。
   - 将右侧的名字 x 理解为一个标识符，并作为 “.” 运算的右操作数。
   - 计算 “a.x” 表达式的结果。

   表达式 “a.x” 的计算结果是一个引用，因此通过这个引用保存了一些计算过程中的信息——例如它保存了 “a” 这个对象，以备后续操作中 “可能会” 作为 this 来使用。所以现在，在整行代码的表达式计算过程中，“a” 是作为一个**引用**被暂存下来了的。由第一行代码可知，这时保存在 “a.x” 这个引用中的 “a” 是当前的 “{n: 1}” 这个对象。

2. **再执行 `a =`**

   ```js
   var a = {n:1};
   a.x =     // <- `a` is {n:1}
         a = // <- `a` is {n:1}
   // ...
   ```

   这里的 “a = …” 中的 a 仍然是当前环境中的变量，与上一次暂存的值是相同的。

3. **第一次赋值**

   ```js
   // ...
   a.x = // <- `a` is {n:1}
     a =
       // <- `a` is {n:1}
       { n: 2 }; // 赋值，覆盖当前的左操作数（变量`a`）
   ```

   于是，左操作数 a 作为一个引用被覆盖了，这个引用仍然是当前上下文中的那个变量 a。因此，这里真实地发生了一次 `a = {n:2}`。

   但是，表达式最开始被保留在 “一个结果” 中的引用 a 不会更新。因为那是一个 “**运算结果**”，这个结果有且仅有引擎知道，它现在是一个引擎才理解的“**引用**（规范对象）”，对于它的可能操作只有：

   - 取值或置值（GetValue/PutValue）
   - 作为一个引用向别的地方传递等

4. **第二次赋值**

   现在，在整个语句行的最左侧 “空悬” 了一个已经求值过的 “a.x”。当它作为赋值表达式的左操作数时，它是一个被赋值的引用（这里是指将 a.x 的整体作为一个引用规范对象）。而它作为结果所保留的 “a”，可以从下面的代码看出来，是在被第一次赋值操作覆盖之前的、那个 “原始的变量 a”。

   ```js
   // 声明“原始的变量a”
   var a = { n: 1 };

   // 使它的属性表冻结（不能再添加属性）
   Object.freeze(a);

   try {
     a.x = a = { n: 2 };
   } catch (x) {
     // 异常发生，说明第二次赋值 “a.x = ...” 中操作的`a`正是原始的变量a
     console.log('第二次赋值导致异常.');
   }

   // 第一次赋值是成功的
   // a {n: 2}
   console.log(a.n); // 2
   ```

   而原始变量 a 在第一次赋值时被废弃了，所以第二次赋值是无意义的。最后 a 的值为 `{n: 2}`。

### 1.4 名字的使用

**ECMAScript 6 模块是静态装配的**，而传统的 Node.js 模块却是动态加载的。因而两种模块的实现效果与处理逻辑都大相径庭。

有且仅有六种[声明语法](#121-声明)，而本质上 export 也就只能导出这六种声明语法所声明的标识符，并且在导出时将它们统一称为 “名字”。

在语言设计中，所谓 “标识符” 与 “名字” 是有语义差别的，export 将之称为名字，就意味着这是一个标识符的子集。类似的其它子集也是存在的，例如 “保留字是标识符名，但不能用作标识符（A reserved word is an IdentifierName that cannot be used as an Identifier）”。

在 JS 语言的设计上，除了那些预设的标点符号（例如大括号、运算符之类），以及部分的保留字和关键字之外，事实上用户代码可以书写的只有三种东西。这包括：

- **标识符**：（通常是）一个**名字**。
- **字面量**：表明由它的字面含义所决定的一个**值**。
- **模板**：一个可计算结果的字符串**值**。

所以，如果在这个层面上解构一份 JS 代码，那么所能书写/声明的，就一定只有 “名字和值”。

这个结论是非常非常关键的。因为 export 事实上就只能导出 “名字和值”。然而一旦它能导出 “名字和值”，也就意味着它能导出一个模块中的 “全部内容”，因为如上所面所讲的：“名字和值” 正是所书写的代码的全部。

> 语言设计层面上来讲，代码就是文本，是没有应用逻辑的。而所写的代码绝大多数都是应用逻辑，当去除掉这些应用逻辑之后，那些剩下的死气沉沉的、纯粹的符号，才是语言层面的所谓 “代码文本”。去掉了执行逻辑所表达的那些行为、动作、结果和用户操作的代码，就是静态代码了。而事实上，ES6 中的模块就是用来理解程序中的那些静态代码的，也就是那些没有任何生气的字符和符号。因此它也就只能理解上面的 6 种声明，以及它们声明出来的那些 “名字和值”。

#### 1.4.1 解析 export

将所有 export 语法分类，其实也就只有两个大类。如下：

```js
// 导出 “（声明的）名字”
export <let/const/var> x ...;
export function x() ...
export class x ...
export {x, y, z, ...};

// 导出 “（重命名的）名字”
export { x as y, ...};
export { x as default, ... };

// 导出 “（其它模块的）名字”
export ... from ...;

// 导出 “值”
export default <expression>
```

对于最后这种形式，也就是 “（导出）值” 的形式，事实上是非常特殊的。因为如同在上面所讲过的，要导出一个模块的全部内容就必须导出 “（全部的）名字和值”，然而纯粹的值没有名字，于是也就没法访问了，所以这就与 “导出点什么东西” 的概念矛盾了。

因为这个东西要是没名字，也就连 “自己是什么” 都说不清楚，也就什么也不是了。

所以 ECMAScript 6 模块约定了一个称为 "default" 的名字，用于来导出当前模块中的一个 “值”。显然的，由于所谓 “值” 是表达式的运算结果，所以这里的语法形式就是：

```js
export default <expression>;
```

其中的 “expression” 就是用于求值的，以便得到一个结果（Result）并导出成为默认的名字 “default”。这里有两个便利的情况：

- 在 JS 中，一般的字面量也是值、也是单值表达式，因此导出这样一个字面量也是合法的：

  ```js
  export default 2;  // as state of the module, etc.
  export default "some messages"; // data or information
  ```

- 因为 JS 中对象也是字面量、也是值、也是单值表达式。而对象成员可以组合其它任何数据，所以通过上述的语法几乎可以导出当前模块中全部的 “值”（亦即是任何可以导出的数据）。例如：

  ```js
  var varName = 100;
  export default {
    varName, // 直接导出名字
    propName: 123, // 导出值
    funcName: function () {}, // 导出函数
    foo() {
      // 或导出与主对象相关联的方法
      // method
    }
  };
  ```

所以，事实上 `export default ...` 虽然简单，却是对 “导出名字” 的非常必要的补充。这样一来，用户既可以导出那些有名字的数据，也可以导出那些没有名字的数据，即一个模块中所有的数据都可以被导出了。

#### 1.4.2 导出语句的处理逻辑

一个 export 可以理解为这样两个步骤：

1. 导出一个名字
2. 为上述名字绑定一个值

这两个步骤其实与使用 “var x = 100” 来声明一个变量的过程是一致的。因此以如下代码为例（六种声明在名字处理上是类似的）：

```js
export var x = 100;
```

在导出的时候，其实是先在 “某个名字表” 中登记一个 “名字 x” 就可以了。这个过程也就是 JS 在模块装载之前对 export 所做的全部工作。不过如果是从另一端（亦即是 import 语句）的角度看过来，那么就会多出来一个步骤。import 语句会（例如 import {x} from ...）：

1. （与 export 类似）按照语法在当前模块中声明名字，例如上面的 x。
2. 添加一个当前模块对目标模块的依赖项。

有了上述的第二步操作，JS 就可以依据所有它能在静态文本中发现的 import 语句来形成模块依赖树，最后就可以找到这个模块依赖树最顶端的根模块，并尝试加载。

所以关键的是，在 “模块 export/import” 语法中，JS 是依赖 import 来形成依赖树的，与 export 无关。但是直到目前为止（意思是直到找到所有导入和导出的名字，并完成所有模块的装配的现在为止），没有任何一行用户的 JS 代码是被执行过的。至于原因，就是上面讲的：export/import 过程中，源代码只被理解为静态的、没有逻辑的 “代码文本”。那么既然 “没有逻辑”，就不可能执行类似于 `export default <expression>` 中的 expression。表达式就是程序的计算逻辑。

**在处理 export/import 语句的全程，没有表达式被执行**。

#### 1.4.3 导出名字和导出值的差异

```js
export default <expression>;
```

既然其中的 “expression” 在导入导出中完全不起作用（不执行），那么这行语句又能做什么呢？事实上，这行语句与直接 “导出一个名字” 并没有任何区别。它与这样的语法相同：

```js
export var x = 100;
```

它们都只是导出一个名字，只是前者导出的是 “default” 这个特殊名字，而后者导出的是一个变量名 “x”。它们都是确定的、符合语法规则的标识符，也可以表示为一个字符串的字面文本。它们的作用也完全一致：就是在前面所说的 “某个名字表” 中添加 “一个登记项” 而已。

所以，导出名字与导出值本质上并没有差异，在静态装配的阶段，它们都只是表达为一个名字而已。

然后，也正是如同 `var x = 100;` 在执行阶段需要有一个将 “值 100” 绑定给 “变量 x（的引用）” 的过程一样，这个 `export default ...;` 语句也需要有完全相同的一个过程来将它后面的表达式（expression）的结果绑定给 “default” 这个名字。如果不这么做，那么 “export default” 在语义上的就无法实现导出名字 “default” 了——在静态装配阶段，名字 “default” 只是被初始化为一个 “单次绑定的、未初始化的标识符”。

所以现在就可以在语义上模拟这样一个过程，即：

```js
export default function() {}

// 类似于如下代码
//（但并不在当前模块中声明名字 "default"）
export var default = function() {}
```

可以进一步地模拟 JS 后续的装配过程。这个过程其实非常简单：

- 找到并遍历模块依赖树的所有模块（这个树是排序的），然后
- 执行这些模块最顶层的代码（Top Level Module Evaluation）。

在执行到上述 var default ....（或类似对应的 export default ...）语句时，执行后面的表达式，并将执行结果（Result）绑定给左侧的那个变量就可以了。如此，直到所有模块的顶层代码都执行完毕，那么所有的导出名字和它们的值也都必然是绑定完成了的。

同样，由于 import 的名字与 export 的名字只是一个映射关系，所以 import 的名字（所对应的值）也就初始化完成了。

**所谓模块的装配过程，就是执行一次顶层代码而已**。

#### 1.4.4 匿名函数表达式的执行结果

function() {} 这个匿名函数表达式，按照 JS 的约定，可以理解为一个函数的 “字面量（值）”。理解 “字面量值” 这个说法是很有意义的，因为它意味着它没有名字。

“字面量（值）没有名字” 就意味着执行这个 “单值表达式” 不会在当前作用域中产生一个名字，即使这个函数是具名的，也必然是如此。所以，这才带来了 JS 中的经典示例，即：**具名函数作为表达式时，名字在块级作用域中无意义**。例如：

```js
// 具名函数作为表达式
var x1 = function x2() {
  // ...
};

// 具名函数（声明）
function x3() {
  // ...
}
```

上面的例子中，x1~3 都是具有不同的语义的。其中，x2 是不会在当前作用域（示例中是全局）中登记为名字。而使用下面的语法：

```js
export default function() { }
export default function x() { }
```

导出一个匿名函数，或者一个具名的函数的时候，这两种情况下是不同的。但无论它是否具名，它们都是不可能在当前作用域中绑定给 default 这个名字，作为这个名字对应的值的。

这段处理逻辑被添加在语法：ExportDeclaration: export default AnonymousFunctionDefinition;

> ECMAScript 是将这里导出的对象称为 _Expression_/AssignmentExpression，这里所谓 _AnonymousFunctionDefinition_ 则是其中 _AssignmentExpression_ 的一个具体实例。

的执行（Evaluation）处理过程中。也就是说当执行这行声明时，如果后面的表达式是匿名函数声明，那么它将强制在当前作用域中登记为 “default” 这样一个特殊的名字，并且在执行时绑定该匿名函数。所以，尽管语义上需要将它登记为类似 var default ...所声明的名字 “default”，但事实上它被处理成了一个不可访问的中间名字，然后影射给该模块的 “某个名字表”。

> **注意**：这是一个**匿名函数定义**（AnonymousFunctionDefinition），而不是一个匿名函数表达式（Anonymous FunctionExpression）。一般函数的语句则被称为声明（或更严谨地称为宣告，Function Declarations）。而所谓匿名函数定义，其本身是表述为：`aName = FunctionExpression`。
> 或类似于此的语法风格的。它可以用在一般的赋值表达式、变量声明的右操作数，以及对象声明的成员初始值等等位置。在这些位置上，该函数表达式总是被关联给一个名字。一方面，这种关联不是严格意义上的 “名字 -> 值” 的绑定语义；另一方面，当该函数关联给名字（aName）时，JS 又会反向地处理该函数（作为对象 f）的属性 f.name，使该名字指向 aName。

所以，“export default function() {}”，在严格意义上来说：**它并不是导出了一个匿名函数表达式，而是导出了一个匿名函数定义**（Anonymous Function Definition）。

因此，该匿名函数初始化时才会绑定给它左侧的名字 “default”，这会导致 import f from ... 之后访问 f.name 值会得到 “default” 这个名字。

#### 1.4.5 知识补充

关于 export 还有一些补充的知识点：

- export ... 语句通常是按它的词法声明来创建的标识符的，例如 `export var x = ...` 就意味着在当前模块环境中创建的是一个变量，并可以修改等等。但是当它被导入时，在 import 语句所在的模块中却是一个常量，因此总是不可写的。这是因为导出项（的名字）总是作为词法声明被声明在当前模块作用域中的，这意味着它不可删除，且不可重复导出。亦即是说即使是用 var x ... 来声明，这个 x 也是在 _lexicalNames_ 中，而不是在 _varNames_ 中。

- 由于 export default ... 没有显式地约定名字 “default” 应该按 let/const/var 的哪一种来创建，因此 JS 默认将它创建成一个普通的变量（var），但即使是在当前模块环境中，它事实上也是不可写的，因为无法访问一个命名为 “default” 的变量——它不是一个合法的标识符。

- 所谓匿名函数，仅仅是当它直接作为操作数（而不是具有上述 “匿名函数定义” 的语法结构）时，才是真正匿名的，例如：

  ```js
  console.log(function () {}.name); // ""
  ```

- 由于类表达式（包括匿名类表达式）在本质上就是函数，因此它作为 default 导出时的性质与上面是一致的。

- 所谓 “某个名字表”，对于 export 来说是模块的导出表，对于 import 来说就是名字空间（名字空间是用户代码可以操作的组件，它映射自内部的模块导入名字表）。不过，如果用户代码不使用 “import /\* as …” 的语法来创建这个名字空间，那么该名字表就只存在于 JS 的词法分析过程中，而不会（或并不必要）创建它在运行期的实例。这也是一直用 “某个名字表” 来称呼它的原因，它并不总是以实体形式存在的。

- 上述名字表简化了 ECMAScript 中对导入导出记录（ImportEntry/ExportEntry Record Fields）的理解。因此如果试图了解更多，建议阅读 ECMAScript 的具体章节。

- 没有模块会导出（传统意义上的）main()，因为 ECMAScript 为了维护模块的静态语义，而把执行过程及其入口的定义丢回给了引擎或宿主本身。

### 1.5 语句中的块级作用域

语句，是 JS 中组织代码的基础语法组件，包括函数声明等等在内的六种声明，其实都被归为 “语句” 的范畴。因此，如果将一份 JS 代码中的所有语句抽离掉，那么大概就只会剩下为数不多的、在全局范围内执行的表达式了。所以，理解 “语句” 在 JS 中的语义是重中之重。

尽管如此，实际上要了解的也无非是**顺序**、**分支**、**循环**这三种执行逻辑而已，相比于它们，其它语句在语义上的复杂性通常不值一提。而这三种逻辑中尤其复杂的就是循环。

在 ECMAScript 6 之后，JS 实现了块级作用域。但从语言设计的原则上来看，越少作用域的执行环境调度效率也就越高，执行时的性能也就越好。因此**绝大多数 JS 语句都并没有自己的块级作用域**。

基于这个原则，switch 语句被设计为有且仅有一个作用域，无论它有多少个 case 语句，其实都是运行在一个块级作用域环境中的。例如：

```js
var x = 100,
  c = 'a';
switch (c) {
  case 'a':
    console.log(x); // Uncaught ReferenceError: Cannot access 'x' before initialization
    break;
  case 'b':
    let x = 200;
    break;
}
```

在这个例子中，switch 语句内是无法访问到外部变量 x 的，即便声明变量 x 的分支 `case 'b'` 永远都执行不到。这是因为所有分支都处在同一个块级作用域中，所以任意分支的声明都会给该作用域添加这个标识符，从而覆盖了全局的变量 x。

一些简单的、显而易见的块级作用域包括：

```js
//** try/catch/finally **/
try {
  // 作用域1
} catch (e) {
  // 表达式 e 位于作用域2
  // 作用域2
} finally {
  // 作用域3
}

/** with 这里没有使用大括号 **/
with (x /* 作用域1 */); // 这里存在一个块级作用域

/** 块语句 **/
{
  // 作用域1
}
// if/else 中的 “块级作用域” 都是一对大括号表示的 “块语句” 自带的，与 if 语句本身无关。
if() {};
if (x) {}
else {};
```

除了这三个语句和一个循环语句 `for (<let/const>...) ...` 以及相同设计的：

- `for await (<let/const> x of ...) ...`
- `for (<let/const> x ... in ...) ...`
- `for (<let/const> x ... of ...) ...`

除了上面四种语句，所有其它的语句都是没有块级作用域的。并且可以看到上面的 for 循环语句中没有列出 `var` 关键字。

#### 1.5.1 块级作用域的特例

`for (<let/const>...) ...` 所有在语句内可以存在的东西只有四种：

- 表达式
- 其它语句
- 标识符声明（取决于声明语句或其它的隐式声明的方式）
- 特殊的语法元素，称为 “标签”。

所谓 “块级作用域”，本质上只包括一组标识符。因此，只有当存在潜在标识符冲突的时候，才有必要新添加一个作用域来管理它们。例如函数，由于函数存在 “重新进入” 的问题，所以它必须有一个作用域来管理 “重新进入之前” 的那些标识符。这个就是**闭包**。

在语言设计时，有三种需求会促使语句构建自己的作用域：

- 标识符管理
- 在语法上支持多语句（例如 try/catch/finally）
- 语句所表达的语义要求有一个块，例如 “{ }” 在语义上就要求它自己是一个块级作用域。

所以 _标签_、 _表达式_ 和 _其它语句_ 这三种东西都不需要使用一个 “独立作用域” 去管理起来。所谓 “其它语句” 当然存在这种冲突，不过显然这种情况下它们也应该自己管理这个作用域。所以，对于当前语句来说，就只需要考虑剩下的唯一一种情况，就是在 “语句中包含了标识符声明” 的情况下，需要创建块级作用域来管理这些声明出来的标识符。

在所有六种声明语句之外，只剩下 for 循环语句能在它的语法中去做这样的标识符声明。所以，它就成了块级作用域的这个唯一特例。

var 声明是特例中的特例。这一特性来自于 JS 远古时代的作用域设计。在早期的 JS 中，并没有所谓的块级作用域，那个时候的作用域设计只有 “函数内” 和 “函数外” 两种，如果一个标识符不在任何（可以多层嵌套的）函数内的话，那么它就一定是在 “全局作用域” 里。

而在这个时代，变量也就只有 var 声明的变量。由于作用域只有上面两个，所以任何一个 var 声明的标识符，要么是在函数内的，要么就是在全局的，没有例外。

按照这个早期设计，`for (var x = ...)` 这个语句中的变量 x，是不应该出现在 “for 语句所在的” 块级作用域中的。它应该出现其外层的某个函数作用域，或者全局作用域中。这种越过当前语法范围，而在更外围的作用域中登记名字行为就称为 “**提升**（Hoisting/Hoistable）”。

ECMAScript 6 在添加块级作用域特性时充分考虑了对旧有语法的兼容，因此当上述语法中出现 var 声明 时，它所声明的标识符是与该语句的块级作用域无关的。在 ECMAScript 中，这是两套标识符体系，也是使用两套作用域来管理的：

- 所有 var 声明和函数声明的标识符都登记为 varNames，使用 “**变量作用域**” 管理
- 其它情况下的标识符/变量声明，都作为 lexicalNames 登记，使用 “**词法作用域**” 管理。

所以，`for (<const/let> x ...) ...` 语法中的标识符 x 是一个词法名字，应该由 for 语句为它创建一个（块级的）词法作用域来管理。接下来，分析一下 for 语句中有几个作用域：

首先，必须要拥有至少一个块级作用域。这是出于管理标识符的必要性。下面的示例简单说明这个块级作用域的影响：

```js
var x = 100;
for (let x = 102; x < 105; x++) console.log('value:', x); // 显示 “value: 102~104”
console.log('outer:', x); // 显示 “outer: 100”
```

因为 for 语句的这个块级作用域的存在，导致循环体内访问了一个局部的 x 值（循环变量），而外部的变量 x 是不受影响的。

那么在循环体内是否需要一个新的块级作用域呢？这取决于在语言设计上是否支持如下代码：

```js
for (let x = 102; x < 105; x++)
  let x = 200;
```

也就是说，如果循环体（单个语句）允许支持新的变量声明，那么为了避免它影响到循环变量，就必须为它再提供另一个块级作用域。在这里，**JS 不允许声明新的变量**。上述的示例会抛出一个异常：“SyntaxError: Lexical declaration cannot appear in a single-statement context”。

这个语法错误并不常见，因为很少有人会尝试构建这样的特殊代码。然而事实上，它是一个普遍存在的语法禁例，例如以下语句语法：

```js

// if 语句中的禁例
if (false) let x = 100;

// while 语句中的禁例
while (false) let x = 200;

// with 语句中的禁例
with (0) let x = 300
```

所以，现在可以确定：**循环语句（对于支持 “let/const” 的 for 语句来说）“通常情况下” 只支持一个块级作用域**。

但是如果在 for 语句支持了 let/const 的情况下，仅仅只有一个块级作用域是不方便的。例如：

```js
for (let i in x)
  /* 代码 */
```

在这个例子中，“let i ...” 在语义上需要被执行多次——因为在静态结构中它的多次迭代都作用于同一个语法元素。而 let 语句的变量不能重复声明的。所以，这里就存在了一个冲突：“let/const” 语句的单次声明（不可覆盖）的设计，与迭代多次执行的现实逻辑矛盾了。

这个矛盾的起点，就是 “只有一个块级作用域”。所以，在 JS 引擎实现 “支持 let/const 的 for 语句” 时，就在这个地方做了特殊处理：为循环体增加一个作用域。

这样一来，“let i” 就可以只执行一次，然后将 “i in x” 放在每个迭代中来执行，这样避免了与 “let/const” 的设计冲突。然而，这个问题到了具体的运行环境中，变量又有些不同了。

#### 1.5.2 for 循环的代价

在 JS 的具体执行过程中，作用域是被作为环境的上下文来创建的。如果将 for 语句的块级作用域称为 **forEnv**，将为循环体增加的作用域称为 **loopEnv**，那么 loopEnv 它的外部环境就指向 forEnv。

于是在 loopEnv 看来，变量 i 其实是登记在父级作用域 forEnv 中，并且 loopEnv 只能访问变量 i，在本质上就是通过环境链回溯来查找标识符（Resolve identifier, or Get Identifier Reference）。

但是如果是下面这种情况。例如：

```js
for (let i in x) setTimeout(() => console.log(i), 1000);
```

这个例子创建了一些定时器。当定时器被触发时，函数会通过它的闭包（这些闭包处于 loopEnv 的子级环境中）来回溯，并试图再次找到那个标识符 i。然而，当定时器触发时，整个 for 迭代有可能都已经结束了。这种情况下，要么上面的 forEnv 已经没有了、被销毁了，要么它即使存在，那个 i 的值也已经变成了最后一次迭代的终值。

所以，要想使上面的代码符合预期，这个 loopEnv 就必须是 “随每次迭代变化的”。也就是说，需要为每次迭代都创建一个新的作用域副本，这称为**迭代环境**（iterationEnv）。因此，每次迭代在实际上都并不是运行在 loopEnv 中，而是运行在该次迭代自有的 iterationEnv 中。

也就是说，在语法上这里只需要两个 “块级作用域”，而实际运行时却需要为其中的第二个块级作用域创建无数个副本。这就是 for 语句中使用 “let/const” 这种块级作用域声明所需要付出的代价。

## 二. JS 是如何运行的

语言体系的建立。

### 2.1 中断语句

#### 2.1.1 用中断（Break）代替跳转

在 Basic 语言还很流行的时代，许多语言的设计中都会让程序代码支持带地址的 “语句”。例如，Basic 就为每行代码提供一个标号，可以把它叫做 “**行号**”，但它又不是绝对物理的行号，通常为了增减程序的方便，会使用 “1，10，20…...” 等等这样的间隔。如果想在第 10 行后追加 1 行，就可以将它的行号命名为 “11”。

行号是一种很有历史的程序逻辑控制技术，更早一些可以追溯到汇编语言，或可以手写机器代码的时代。那时由于程序装入位置被标定成内存的指定位置，所以这个位置也通常就是个地址偏移量，可以用数字化或符号化的形式来表达。所有这些 “为代码语句标示一个位置” 的做法，其根本目的都是**为了实现 “GOTO 跳转”**，任何时候都可以通过 “GOTO 标号” 的语法来转移执行流程。

然而，这种黑科技在 20 世纪的 60~70 年代就已经普遍地被先辈们批判过了。这样的编程方式只会大大地降低程序的可维护性，其正确性或正确性验证都难以保障。所以，半个多世纪之前开始的 **“结构化” 运动**一直影响至今，包括现在 JS，都是 “结构化程序设计” 思想的产物。

简单地说：JS 中没有 GOTO 语句了。取而代之的，是**分块代码**，以及**基于代码分块的流程控制技术**。这些控制逻辑基于一个简单而明了的原则：如果代码分块中需要 GOTO 的逻辑，那么就为它设计一个 “自己的 GOTO”。这样一来，所有的 GOTO 都是 “块（或块所在语句）自己知道的”。这使得程序可以在 “自己知情的前提下自由地 GOTO”。

然而，问题是那些 “标号” 或 “程序地址” 之类的东西已经被没有了，因此人们想出两种方法来解决：

- **约定 “可以通过 GOTO 到达的位置”**

  在这种情况下，JS 将 GOTO 的 “离开某个语句” 这一行为理解为 “_中断（Break）该语句的执行_”。由于这个中断行为是明确针对于该语句的，所以 “GOTO 到达的位置” 也就可以毫无分歧地约定为该语句（作为代码块）的结束位置。这是 “break” 作为子句的由来。它用在某些 “_可中断语句_（BreakableStatement）” 的内部，用于中断并将程序流程 “跳转（GOTO）到语句的结束位置”。在语法上，这表示为**该语法只作用于对 “可中断语句” 的中断**。

  “可中断语句” 其实只有两种：

  - 全部的循环语句
  - switch 语句

  在这两种语句内部使用的 “break;”，采用的就是这种处理机制——**中断当前语句，将执行逻辑交给下一语句**。

- **可以中断 “任意的标签化语句”**

  所谓标签化语句，就是在一般语句之前加上 `xxx:` 这样的标签，用以指示该语句：

  ```js
  // 标签 aaa
  aaa: {
    // ...
  }

  // 标符 bbb
  bbb: if (true) {
    // ...
  }
  ```

  在标签 aaa 中，显然 aaa 指示的是后续的 “块语句” 的块级作用域；而在标签 bbb 中，if 语句是没有块级作用域的，那么 bbb 到底指示的是 “if 语句” 还是其后的 “块语句” 呢？

  这个问题本质上是在 “块级作用域” 与 “标签作用的（语句）范围” 之间撕裂了一条鸿沟。由于标签 bbb 在语义上只是要 “标识其后的一行语句”，因此这种指示是与 “块级作用域（或词法环境）” 没有关系的。简单地说，**标签化语句理解的是 “位置”，而不是 “（语句在执行环境中的）范围”**。

  因此，中断这种标签化语句的 “break” 的语法，也是显式地用 “标签” 来标示位置的。例如：

  ```js
  // 在 if 语句的两个分支中都可以使用 break;
  // （在分支中深层嵌套的语句中也是可以使用 break 的）
  aaa: if (true) {
    // ...
  } else {
    // ...
    break aaa;
  }

  // 在 try/catch/finally 中也可以使用 break;
  bbb: try {
    // ...
  } finally {
    break bbb;
  }
  ```

#### 2.1.2 执行现场的回收

break 将 “语句的‘代码块’” 理解为**位置**，而不是理解为作用域/环境，这是非常重要的前设。然而，程序代码中的 “位置” 已经被先辈们干掉了。他们用了半个世纪来证明了一件事情：**想要更好、更稳定和更可读的代码，那么就忘掉“（程序的）位置”这个东西吧！**

通过 “作用域” 来管理代码的确很好，但是作用域与 “语句的位置” 以及 “GOTO 到新的程序执行” 这样的理念是矛盾的。它们并不在同一个语义系统内，这也是**标签**与**变量**可以重名而不相互影响的根本原因。由于这个原因，在使用标签的代码上下文中，执行现场的回收就与传统的 “块” 以及 “块级作用域” 根本上不同。

JS 的执行机制包括 “执行权” 和 “数据资源” 两个部分，分别映射可计算系统中的 “逻辑” 与 “数据”。而块级作用域（也称为词法作用域）以及其他的作用域本质上就是一帧数据，以保存执行现场的一个瞬时状态（也就是每一个执行步骤后的现场快照）。而 JS 的运行环境被描述为一个后入先出的栈，这个栈顶永远就是当前 “执行权” 的所有者持用的那一帧数据，也就是代码活动的现场。

JS 的运行环境通过函数的 CALL/RETURN 来模拟上述 “数据帧” 在栈上的入栈与出栈过程。任何一次函数的调用，即是向栈顶压入该函数的上下文环境（也就是作用域、数据帧等等，它们在不同场合下的相同概念）。所以，包括那些在全局或模块全局中执行的代码，以及 Promise 中执行调度的那些内部处理，所有的这些 JS 内部过程或外部程序都统一地被封装成函数，通过 CALL/RETURN 来激活、挂起。

所以，“作用域”就是在上述过程中被操作的一个对象。

- 作用域退出，就是函数 RETURN。
- 作用域挂起，就是执行权的转移。
- 作用域的创建，就是一个闭包的初始化。
- ……

然而如之前所说的，“break labelName;” 这一语法独立于 “执行过程” 的体系，它表达一个位置的跳转，而不是一个数据帧在栈上的进出栈。这是 labelName 独立于标识符体系（也就是词法环境）所带来的附加收益。基于对 “语句” 的不同理解，JS 设计了一种全新方法，用来清除这个跳转所带来的影响（也就是回收跳转之前的资源分配）。而这多余出来的设计，其实也是上述收益所需要付出的代价。

#### 2.1.3 语句执行的意义

对于语句的跳转来说，“离开语句” 意味着清除语句所持有的一切资源，如同函数退出时回收闭包。但是，这也同样意味着 “语句” 中发生的一切都消失了，对于函数来说，return 和 yield 是唯二从这个现场发出信息的方式。那么语句呢？语句的执行现场从这个“程序逻辑的世界”中湮灭之后，又留下了什么呢？

语句执行与函数执行并不一样。函数是求值，所以返回的是对该函数求值的结果（Result），该结果或是值（Value），或是结果的引用（Reference）。而语句是命令，语句执行的返回结果是该命令得以完成的状态（Completion, Completion Record Specification Type）。

> **注意**：JS 是一门混合了函数式与命令式范型的语言，而这里对函数和语句的不同处理，正是两种语言范型根本上的不同抽象模型带来的差异。

在 ECMAScript 规范层面，本质上所有 JS 的执行都是语句执行（这很大程度上解释了为什么 eval 是执行语句）。因此，ECMAScript 规范中对执行的描述都称为 “运行期语义（Runtime Semantics）”，它描述一个 JS 内部的行为或者用户逻辑的行为的过程与结果。也就是说这些运行期语义都最终会以一个完成状态（Completion）来返回。例如：

- **一个函数的调用**：调用函数——执行函数体（EvaluateBody）并得到它的 “完成” 结果（result）。
- **一个块语句的执行**：执行块中的每行语句，得到它们的 “完成” 结果（result）。

这些结果（result）包括的状态有五种，称为完成的类型，可以分为以下两类：

- 包含了有效的、可用于计算的数据值（Value）：

  - 正常完成（normal）
  - 一个函数调用的返回（return）

- 是一个不可（像数据那样）用于计算或传递的纯粹状态：

  - 循环过程中的继续下次迭代（continue）
  - 中断（break）
  - 异常（throw）

所以当运行期出现了一这个称为 “中断（break）” 的状态时，JS 引擎需要找到这个 “break” 标示的目标位置（result.Target），然后与当前语句的标签（如果有的话）对比：

- 如果一样，则取 break 源位置的语句执行结果为值（Value）并以正常完成状态返回
- 如果不一样，则继续返回 break 状态

这与函数调用的过程有一点类似之处：由于对 “break 状态” 的拦截交给语句退出（完成）之后的下一个语句，因此如果语句是嵌套的，那么其后续（也就是外层的）语句就可以得到处理这个 “break 状态” 的机会。举例来说：

```js
console.log(
  eval(`
  aaa: {
    1+2;
    bbb: {
     3+4;
     break aaa;
    }
  }
`)
); // 输出值：7
```

在这个示例中，“break aaa” 语句是发生于 bbb 标签所示块中的。但当这个中断发生时：

- 标签化语句 bbb 将首先捕获到这个语句完成状态，并携带有标签 aaa。
- 由于 bbb 语句完成时检查到的状态中的中断目标（Target）与自己的标签不同，所以它将这个状态继续作为自己的完成状态，返回给外层的 aaa 标签化语句 aaa。
- 语句 aaa 得到上述状态，并对比标签成功，返回结果为语句 3+4 的值（作为完成状态传出）。

所以，语句执行总是返回它的完成状态，且如果这个完成状态是包含值（Value）的话，那么它是可以作为 JS 代码可访问的数据来使用的。例如，如果该语句被作为 eval() 来执行，那么它就是 eval() 函数返回的值。

#### 2.1.4 中断语句的特殊性

```js
x: break x;
```

这行语句有两个特殊之处：

- 它是最小化的 break 语句的用法，不可能写出更短的代码了。
- 这种所谓 “不会对其他任何代码构成任何影响” 的语句，也是 JS 中的特有设计。

首先，由于 “标签化语句” 必须作用于 “一个” 语句，而语句理论上的最小化形式是 “空语句”。但是将空语句作为 break 的目标标签语句是不可能的，因为还必须在标签语句所示的语句范围内使用 break 来中断。空语句以及其他一些单语句是没有这样的语句范围的，因此最小化的示例就只能是对 break 语句自身的中断。

其次，语句的返回与函数的返回有相似性。例如，函数可以不返回任何东西给外部，这种情况下外部代码得到的函数出口信息会是 undefined 值。

由于典型的函数式语言的 “函数” 应该是没有副作用的，所以这意味着该函数的执行过程不影响任何其他逻辑——也不在这个 “程序逻辑的世界” 中留下任何的状态。事实上，还可以用 “void” 运算符来阻止一个函数返回的值影响它的外部世界。函数是 “表达式运算” 这个体系中的，因此用一个运算符来限制它的逻辑，这很合理。

虽然 “break labelName” 的中止过程是可以传出 “最后执行语句” 的状态的，但是这个过程存在一个悖论：**任何被 break 的代码上下文中，最后执行语句必然会是 “break 语句” 本身**。所以，如果要在这个逻辑中实现 “语句执行状态” 的传递，那么就必须确保：

- “break 语句” 不返回任何值（ECMAScript 内部约定用 “Empty” 值来表示）
- 上述 “不返回任何值” 的语句，也不会影响任何语句的既有返回值。

所以，事实上已经探究了 **“break 语句” 返回值的两个关键特性**的由来：

- 它的类型必然是 “break”
- 它的返回值必然是 “空（Empty）”

对于 Empty 值，在 ECMAScript 中约定：**在多行语句执行时它可以被其他非 Empty 值更新（UpdateEmpty），而 Empty 不可以覆盖其他任何值**。这就是空语句等也同样 “不会对其他任何代码构成任何影响” 的原因了。

### 2.2 JS 中特殊的可执行结构

JS 中，有**语句**和**表达式**两种基本的可执行元素。这在语言设计的层面来讲，是很普通的，大多数语言都这么设计。少数的语言会省略掉语句这个语法元素，或者添加其它一些奇怪的东西，不过通常情况下它的结果就是让语言变得不那么人性。

就如 JS 中的模板，其实是**一种特殊的可执行结构**。所有特殊可执行结构都是来自于某种固定的、确定的逻辑。这些逻辑语义是非常明确的，输入输出都很确定，这样才能被设计成一个标准的、易于理解的可执行结构。并且，如果在一门语言中添加太多的、有特殊含义的执行结构，那么这门语言就会显得 “渐渐地有些奇怪了”。

如果抛开 JS 核心库或者标准语言运行时里面的那些东西，例如 Map、Set 等等，专门考察一下在语言及语法层面定义的特殊可执行结构的话，会有以下几种可执行结构。

#### 2.2.1 参数表

在 JS 语言的内核中，参数表其实是一个独立的语法组件：

- 对于函数来说，参数表就是在函数调用时传入的参数
- 对于构造器以及构造器的 new 运算来说，参数表就是 new 运算的一个运算数

这二者略微有一点区别，在远古时期的 JS 中，它们是很难区分的。然而在 ECMAScript 的规范中，这个参数表被统一成了标准的 List。这个 List 也是一种 ECMAScript 中的规范类型，与引用、属性描述符等等规范类型类似，它在相关的操作中是作为一个独立的部分参与运算的。

例如在 JS 的反射机制中，使用代理对象就能拿到一个函数调用的入参，或者 new 运算过程中传入的参数，它们都表示成一个标准的数组：

```js
handler.apply = function (target, thisArgument, argArray) {
  // ...
};
```

这里 argArray 表示为一个数组，但这只是参数表在传入后通过 “特殊可执行结构” 执行的结果。如果追究这个行为背后的逻辑，那么这个列表实际上是根据形式参数的样式（Formal of Parameters），按照传入参数逐一匹配出来的。这个所谓 **“逐一匹配”，就是 “特殊的可执行的逻辑”**。

任何实际参数在传入一个函数的形式参数时，都会经历这样的一个执行过程，它是 “**函数实例化（函数从源代码文本变成一个可以执行的、运行期的闭包的过程**）” 这个内部行为的一个处理阶段。

在这个过程中，参数表作为可执行结构，它的执行结果就是将传入的参数值变成与形式参数规格一致的实际参数，最终将这些参数中所有的值与它们 “在形式参数表中的名字” 绑定起来，作为函数闭包中可以访问的名字。

简单化地讲，就是**把参数放在 arguments 列表中，然后让 arguments 中的值与参数表中的名字对应起来**。而这就是对 “参数表（argArray）” 这个可执行结构的全部操作。

箭头函数也是采用与上述过程完全一致的处理逻辑，只是在最后没有向闭包绑定 arguments。而 JS 中有种形式参数的风格，称为 “简单参数（可以在形式参数表中可以明确数出参数个数的、没有使用扩展风格声明参数的参数表）”，这与 argArray 的使用存在莫大的关系。

#### 2.2.2 扩展风格的参数表

它与其它几种可执行结构有关，如**默认参数**：

```js
function foo(x = 100) {
  // ...
}
```

这意味着在语法分析期，JS 就得帮助该参数登记下 “100” 这个值。然后在实际处理这个参数时，至少需要一个赋值表达式的操作，用来将这个值与它的名字绑定起来。所以，foo() 函数调用时，总有一段执行逻辑来访问形式参数表以及执行这个赋值表达式。让问题变得更复杂的地方在于：这个值 “100” 可以是一个表达式的运算结果，由于表达式可以引用上下文中的其它变量，因此上面的所谓 “登记”，就不能只是记下一个字面量值那么简单，必须登记一个表达式，并且在运行期执行它。例如：

```js
let x = 0;
function foo(i = x++) {
  console.log(i);
}
foo(); // 1
foo(); // 2
```

这样每次调用 foo() 的时候，“x++”就都会得到执行了。所以，默认参数就是一种可执行结构，是参数表作为可执行结构的逻辑中的一部分。同样的，**剩余参数**和**参数展开**都具有类似的性质，也都是参数表作为可执行结构的逻辑中的一部分。

参数展开是唯一一个可以影响“传入参数个数”的语法。例如：

```js
foo(...args);
```

这个语法的关键处不在于形式参数的声明，而在于实际参数的传入。这里传入时实际只用到了一个参数，即 “args”，但是 `...` 语法对这个数组进行了展开，并且根据 args.length 来扩展了参数表的长度/大小。由于其它参数都是按实际个数计数的，所以这里的参数展开就成了唯一能动态创建和指定参数个数的语法。

> 在传统的 JS 中，这一语法是使用 foo.apply() 来替代的。历史中，“new Function()” 这个语法没有类似于 apply() 的创建和处理参数表的方式，所以早期的 JS 需要较复杂的逻辑，或者是调用 eval() 来处理动态的 new 运算。

**参数展开其实是数组展开的一种应用，而数组展开在本质上是依赖迭代器的**。可以在任何内置迭代器的对象（即是 Symbol.iterator 这个符号属性有值的对象上使用展开语法，使它们按迭代顺序生成相应多个 “元素（elements）”，并将这些元素用在需要的地方，而不仅仅是将它展开。例如 `yield*`，又例如模板赋值。迭代器是有一组界面约定的，那么这个迭代器界面本质上也是一种可执行结构。

#### 2.2.3 模板赋值

模板赋值是 ECMAScript 6 之后提供一种声明标识符的语法，该语法依赖一个简单的赋值过程，可以抽象地理解为下面这样：

```js
a = b;
```

等号的左侧称为赋值模板（AssignmentPattern），而右侧称为值（Value）。

在 JS 中，任何出现类似语法或语义过程的位置，本质上都可以使用模板赋值的。也就是说，即使没有这个 “赋值符号（等号）”，只要语义是 **“向左操作数（lhs）上的标识符，赋以右操作数（rhs）的值”**，那么它就适用于模板赋值。

前面说的 “向参数表中的形式参数（的名字），赋以实际参数的值”，也是这样的一个过程。所以，JS 在语法上很自然地就支持了在参数表中使用模板赋值，以及在任何能够声明一个变量或标识符的地方，来使用模板赋值。例如：

```js
function foo({x, y}) {
  ...
}

for (let {x, y} in obj) {
  ...
}
```

而所有这些地方的赋值模板，都是在语法解析期就被分析出来，并在 JS 内部作为一个可执行结构存放着。然后在运行期，会用它们来完成一个 “从右操作数按模板取值，并赋值给左操作数” 的过程。这与将函数的参数表作为**样式**（Formal）存放起来，然后在运行期逐一匹配传入值是异曲同工的。

所有上述的执行结构，都可以归为一个大类，称为 “**名字和值的绑定**”。

也就是说，所有这些执行的结果都是一个名字，执行的语义就是给这个名字一个值。显然这是不够的，因为除了给这个名字一个值之外，最终还得使用这个名字以便进行更多的运算。那么，这个 “找到名字并使用名字” 的过程，就称为 “**发现**（Resolve binding）”，而其结果，就称为 “**引用**（reference）”。

任何的名字，以及任何的字面量的值，本质上都可以作为一个被发现的对象，并且在实际应用中也是如此。在代码的语法分析阶段，发现一个名字与发现一个值本质上没有什么不同，所以如下的两行代码：

```js
a = 1
1 = 1
```

其实在 JS 中都可以通过语法解析，并且进入实际的代码执行阶段。所以 “1=1” 是一个运行期错误（ReferenceError），而不是语法错误（SyntaxError）。那么所谓的 “发现的结果——引用（Reference）”，也就不是简单的一个语法标识符，而是一个可执行结构了。更进一步地说，如下面这些代码，每一个都会导致一个引用（的可执行结构）：

```jst
a;
1;
'use strict';
obj.foo;
```

正是因此，所以上面的第三行代码才会成为一个 “可以导致当前作用域切换为严格模式” 的**指令**。因为它是引用，也是可执行结构。对待它，JS 只需要像调用函数一样，将它处理成一段确定逻辑就可以了。

这几个引用中有一个非常特殊的引用，就是 obj.foo，它被称为**属性引用**（Property Reference）。属性引用不是简单的标识符引用，而是一个属性存取运算的结果。所以，表达式运算的结果可以是一个引用。它是为数不多的、可以存储原表达式信息，并将该信息 “传递” 到后续表达式的特殊结构。严格地说，所有的引用都可以设计成这个样子，只不过属性引用是最常见到的。

为什么要用 “引用（Reference）” 这种结构来承担这一责任呢？这与 JS 中的 “方法调用” 这一语义的特殊实现有关。JS 并不是静态分析的，因此它无法在语法阶段确定 “obj.foo” 是不是一个函数，也不知道用户代码在得到 “obj.foo” 这个属性之后要拿来做什么用。

```js
obj.foo();
```

直到运行期处理到下一个运算（例如上面这样的运算时），JS 引擎才会意识到：这里要调用一个方法。

然而，方法调用的时候是需要将 obj 作为 foo() 函数的 this 值传入，这个信息只能在上一步的属性存取 “obj.foo” 中才能得到。所以 obj.foo 作为一个属性引用，就有责任将这个信息保留下来，传递给它的下一个运算。只有这样，才能完成一次 “将函数作为对象方法调用” 的过程。

引用作为函数调用（以及其它某些运算）的 “左操作数（lhs）” 时，是需要传递上述信息的。这也就是 “引用” 这种可执行结构的确定逻辑。

本质上来说，它就是要帮助 JS 的执行系统来完成 “发现/解析（Resolve）” 过程，并在必要时保留这个过程中的信息。在引擎层面，如果一个过程只是将 “查找的结果展示出来”，那么它最终就表现为值；如果包括这个过程信息，通常它就表现为引用。

而作为一个执行系统来讲，JS 执行的最终的结果是 “值”。因为没有办法将一个引用（包括它的过程信息）在屏幕上打印出来，而且即便打印出来，用户也没有兴趣。用户真正关心的是打印出来的那个结果。所以无论如何，JS 创建引用也好，处理这些引用或特殊结构的执行过程也好，最终目的，还是计算求值。

#### 2.2.4 模板字面量

```js
`${1}`;
```

模板字面量是上述所有这些可执行结构的集大成者。它本身是一个特殊的可执行结构，但是它调动了包括引用、求值、标识符绑定、内部可执行结构存储，以及执行函数调用在内的全部能力。这是 JS 厘清了所有基础的可执行结构之后，才在语法层面将它们融会如一的结果。

模板字面量关注的是值，它存储的是 “结果” 与 “结果的计算过程” 之间的关系。由于模板字面量的执行结果是一个字符串，所以当它作为值来读取时，就会激活它的运算求值过程，并返回一个字符串值。

```js
foo`${1}`;
```

模板字面量与所有其它字面量（能作为引用）相似，它也可以作为引用。所以上面这行代码在语法上也是成立的。因为在这个表达式中，`${1}` 使用的不是模板字面量的值，而是它的一个“（类似于引用的）结构”。

“**模板字面量调用**（TemplateLiteral Call）” 是唯一一个会使用模板字面量的引用形态（并且也没有直接引用它的内部结构）的操作。这种引用形态的模板字面量也被称为 “标签模板（Tagged Templates）”，主要包括模板的位置和那些可计算的标签的信息。例如：

```js
let x = 1;
foo = (...args) => console.log(...args);
foo`hello ${x} world`; // [ 'hello ', ' world' ] 1
```

模板字面量的内部结构中，主要包括将模板多段截开的一个数组，原始的模板文本（raw）等等。在引擎处理模板时，只会将该模板解析一次，并将这些信息作为一个可执行结构缓存起来（以避免多次解析降低性能），此后将只使用该缓存的一个引用。当它作为字面量被取值时，JS 会在当前上下文中计算各个分段中的表达式，并将表达式的结果填回到模板从而拼接成一个结果，最后返回给用户。

### 2.3 函数式语言的核心抽象：函数与表达式的同一性

语句执行是命令式范型的体现，而**函数执行**代表了 JS 中对函数式范型的理解。很多人会从对象的角度来理解 JS 中的函数，认为 “函数就是具有 `[[Call]]` 私有槽的对象”。这并没有错，但是这却是从静态视角来观察函数的结果。

要知道函数是执行结构，执行过程发生的事从对象的视角是既观察不到，也得不到答案的。并且，再稍稍深入一点，例如 “对象的方法是怎么执行的”，那么就必须要回到 “函数的视角”，或者运行期的、动态的角度来解释这一切。

#### 2.3.1 函数的一体两面（一等公民）

用静态的视角来看函数，函数的实例就是一个函数对象。如果不考虑它作为对象的那些特性，那么函数也无非就是 “用三个语义组件构成的实体”：

- **参数**：函数总是有参数的，即使它的形式参数表为空。
- **执行体**：函数总是有它的执行过程，即使是空的函数体或空语句。
- **结果**：函数总是有它的执行的结果，即使是 undefined。

在静态的语义分析阶段，函数的三个组件中的两个是显式的，例如在下面的声明中：

```js
function f() {
  // ...
}
```

语法( )指示了参数，而{ }指示了执行体，并且，隐式地知道该函数有一个结果。这也是 JS 设计经常被批判的一处：由于没有静态类型声明，所以也无法知道函数返回何种结果。当把这三个部分构成的一个整体看作执行体的时候：

```js
(function f() {
  // ...
});
```

那么它的结果是一个函数类型的 “数据”。这在函数式语言中称为 “[函数是一等公民](/frontend/浏览器/图解GoogleV8/图解GoogleV8.md#213-函数是一等公民)”，也就是说函数既是可以执行的**逻辑**，也同时是可以被逻辑处理的**数据**。

函数作为数据时，它是 “原始的函数声明” 的一个实例（注意这里并不强调它是对象实例）。这个实例必须包括上述三个语义组件中的两个，即**参数**与**执行体**。否则，它作为实例将是不完整的、不能准确复现原有的函数声明的。为了达到这个目的，JS 为每个实例创建了一个闭包，并且作为上述 “函数类型的‘数据’” 的实际结果。例如：

```js
let arr = new Array();
for (let i = 0; i < 5; i++) {
  arr.push(function f() {
    // ...
  });
}
arr[0] === arr[1]; // false
```

在这个例子中，静态的函数 f() 有且仅有一个，而在执行后，arr[] 中将存在该函数 f() 的 5 个实例，每一个称为该函数的一个运行期的闭包。它们各各不同。所以，任何时候只要用户代码引用一次这样的函数（的声明或字面量），那么它就会拿到该函数的一个闭包。

> **注意**：得到这个闭包的过程与是否调用它是无关的。

#### 2.3.2 两个语义组件

上一节的闭包有两个语义组件：参数和执行体。在创建这个闭包时，它们也将同时被实例化。这样做的目的，是为了保证每个实例/闭包都有一个自己独立的运行环境，也就是**运行期上下文**。JS 中的闭包与运行环境并没有明显的语义差别，唯一不同之处，仅在于这个 “运行环境” 中每次都会有一套新的 “参数”，且执行体的运行位置（如果有的话）被指向函数代码体的第一个指令。

将闭包与之前的 for 循环对照起来观察的话，就会发现一个事实：函数体和 for 的循环体（这些用来实现逻辑复用的执行结构）的创建技术，是完全一样的。也就是说，命令式语句和函数式语言，是采用相同的方式来执行逻辑的。只不过前者把它叫做 `_iteratorEnv_`，是 `_loopEnv_` 的实例；后者把它叫做闭包，是函数的实例。

再往源头探究一点：导致 for 循环需要多个 `_iteratorEnv_` 实例的原因，在于循环语句试图在多个迭代中复用参数（迭代变量），而函数这样做的目的，也同时是为了处理这些参数（形式参数表）的复用而已。所以，闭包的作用与实现方法都与 “for 循环” 中的迭代环境没有什么不同。

```js
x => x;
```

上面这行代码，它首先代表了这样两个语义组件：

- 参数 x
- 执行体 x

在闭包创建时，参数 x 将作为闭包（作用域/环境）中的名字被初始化——这个过程中 “参数 x” 只作为名字或标识符，并且将会在闭包中登记一个名为 x 的变量；按照约定，它的值是 undefined。并且，还需要强调的是，这个过程是引擎为闭包初始化的，发生于用户代码得到这个闭包之前。

#### 2.3.3 参数类型

```js
(x = x) => x;
```

在 ECMAScript 6 之前的函数声明中，它们的参数都是 “简单参数类型” 的。在 ECMAScript 6 之后，凡是在参数声明中使用了**默认参数**、**剩余参数**和**模板参数**之一的，都不再是 “简单的”（non-simple parameters）。在具体实现中，这些新的参数声明意味着它们会让函数进入一种特殊模式，由此带来三种限制：

- 函数无法通过显式的 "use strict" 语句来切换到严格模式，但能接受它被包含在一个严格模式的语法块中（从而隐式地切换到严格模式）。
- 无论是否在严格模式中，函数参数声明都将不接受 “重名参数”。
- 无论是否在严格模式中，形式参数与 arguments 之间都将解除绑定关系。

这样处理的原因在于：在使用传统的简单参数时，只需要将调用该参数时传入的实际参数与参数对象（arguments）绑定就可以了；而使用 “非简单参数” 时，**需要通过 “初始器赋值” 来完成名字与值的绑定**。同样，这也是导致形式参数与 arguments 之间解除绑定关系的原因。

> 两种绑定模式的区别在于：通常将实际参数与参数对象绑定时，只需要映射两个数组的下标即可，而 “初始器赋值” 需要通过名字来索引值（以实现绑定），因此一旦出现 “重名参数” 就无法处理了。

所以，所谓参数的登记过程，事实上还影响了它们今后如何绑定实际传入的参数。

#### 2.3.4 传入参数的处理

首先，JS 的函数是 “非惰性求值” 的，也就是说在函数界面上不会传入一个延迟计算的求值过程，而是 “积极地” 传入已经求值的结果。例如：

```js
// 一般函数声明
function f(x) {
  console.log(x);
}

// 表达式 a=100 是 “非惰性求值” 的
f((a = 100));
```

在这个示例中，传入函数 f() 的将是赋值表达式 a = 100 完成计算求值之后的结果。考虑到这个 “结果” 总是存在 “值和引用” 两种表达形式，所以 JS 在这里约定 “传值”。于是，上述示例代码最终执行到的将是 f(100)。

接下来才来到具体调用这个函数 f() 的步骤中。而直到这个时候，JS 才需要向环境中的那些名字（例如 function f(x) 中的形式参数名 x）“绑定实际传入的值”。对于这个 x 来说，由于参数与函数体使用同一个块作用域，因此如果函数参数与函数内变量同名，那么它们事实上将是同一个变量。例如：

```js
function f(x) {
  console.log(x);
  var x = 200;
}
// 由于 “非惰性求值”，所以下面的代码在函数调用上完全等义于 `f(a = 100)`
f(100);
```

在这个例子中，函数内的三个 x 实际将是同一个变量，因此这里的 console.log(x) 将显示变量 x 的传入参数值 100，而 var x = 200;并不会导致“重新声明”一个变量，仅仅是覆盖了既有的 x。

#### 2.3.5 非简单参数的无初值绑定

对在闭包中执行 “绑定实际传入的参数” 的过程来说，如果参数是简单的，那么 JS 引擎只需要简单地绑定它们的一个对照表就可以了。并且，由于所有被绑定的、传入的东西都是 “值”，所以没有任何需要引用其它数据的显式执行过程。“值” 是数据，而非逻辑。

所以，对于简单参数来说，是没有 “求值过程” 发生于函数的调用界面上的。然而，对于下面例子中这样的 “非简单参数” 函数声明来说：

```js
function foo(x = 100) {
  console.log(x);
}
foo();
```

在 “绑定实际传入的参数” 时，就需要执行一个 “x = 100” 的计算过程。不同于之前的 f(a = 100)，在这里的表达式 x = 100 将执行于这个新创建的闭包中。左侧的 “参数 x” 是闭包中的一个语法组件，是初始化创建在闭包中的一个变量声明，因此只有将表达式放在这个闭包中，它才可以正确地完成计算过程。

然而这样一来，在下面这个示例中，表达式右侧的 x 也将是该闭包中的 x：

```js
f = (x = x) => x;
f(); // Uncaught ReferenceError: Cannot access 'x' before initialization
```

这个异常提示其实并不准确，因为在这个上下文环境（闭包）中，x 显然是声明过的。事实上，这也是两种不同的登记过程（“直接 arguments 绑定” 与 “初始器赋值”）的主要区别之一。尽管在本质上，这两种登记过程所初始化的变量都是相同的，称为 “**可变绑定**（Mutable Binding）”。

“可变” 是指它们可以多次赋值，简单地说就是 let/var 变量。但显然地，上述的示例正好展示了 var/let 的两种不同性质。

由于 let 变量不能在它的声明语句之前（亦即是未初始化之前）访问。也就是说，在 `(x = x) => x` 中的三个 x 都是指向相同的变量，并且当函数在尝试执行 “初始器赋值” 时会访问第 2 个 x，然而此时由于变量 x 是未赋值的，因此它就如同 let 变量一样不可访问，从而触发异常。

对于 var/let 来说，一开始的时候它们其实都是 “无初值的绑定”。只不过 JS 在处理 var 语句声明的变量时，将这个 “绑定（Binding）” 赋了一个初值 undefined，因此才可以在代码中自由、提前地访问那些 “var 变量”。而对应的，let 语句声明的变量没有 “默认地” 赋这个初值，所以才不能在赋值语句之前访问它。

处理函数参数的过程与此完全相同：参数被创建成 “可变绑定”，如果它们是简单参数则被置以初值 undefined，否则它们就需要一个所谓的 “初始器” 来赋初值。也就是说，并非 JS 要刻意在这里将它作为 var/let 变量之一来创建，而只是用户逻辑执行到这个位置的时候，所谓的 “可变绑定” 还没有来得及赋初值罢了。

在 “默认参数” 的语法设计里面，undefined 正好是一个有意义的值，它用于表明参数表指定位置上的形式参数是否有传入，所以参数 undefined 也就不能作为初值来绑定，这就导致了使用 “初始器” 的参数表中，所对应那些变量是一个 “无初值的绑定”。

因此如果这个 “初始器”（它初始化的阶段里面）正好也要访问变量自身，那么就会导致出错了。而这个出错的过程和原因也就与上面示例的代码是一样的。

### 2.4 重构函数语义组件-执行体

函数是三个语义组件构成的分别是指参数、执行体和结果。最主要的价值就在于：**通过改造这三个语义组件的不同部分，可以得到不同的 “函数式的” 执行特征与效果**。换而言之，可以通过更显式的、特指的或与应用概念更贴合的语法来表达新的语义。与所谓 “特殊可执行结构” 一样，这些语义也用于映射某种固定的、确定的逻辑。_语言的设计，本质就是为确定的语义赋以恰当的语法表达_。

#### 2.4.1 递归与迭代

如果循环是一种确定的语义，那么有以下方式合适为它设计在函数执行中的语法表达：

- **递归**

  递归绝对是一个好的、经典的求解思路。递归将循环的次数直接映射成函数 “执行体” 的重复次数，将循环条件放在函数的参数界面中，并通过函数调用过程中的值运算来传递循环次数之间的数值变化。

  递归作为语义概念简单而自然，唯一与函数执行存在（潜在的）冲突的只是所谓栈的回收问题，亦即是尾递归的处理技巧等，但这些都是实现层面的要求，而与语言设计无关。

  由于递归并不改变函数的三个语义组件中的任何一个，因此它与函数执行过程完全没有冲突，也没有任何新的需求与设计。这句话的潜在意思是说，函数的三个语义组件都不需要为此作出任何的设计修改，例如：

  ```js
  const f = x => x && f(--x);
  ```

  在这段代码中，是没有出现任何特殊的语法和运算/操作符的，它只是对函数、（变量或常量的）声明、表达式以及函数调用等等的简单组合。

- **迭代**

  迭代也是循环语义的一种实现，它说明循环是 “函数体” 的重复执行，而不是 “递归” 所理解的 “函数调用自己” 的语义。这是一种可受用户代码控制的循环体。可以尝试创建这样一个简单的迭代函数：

  ```js
  // 迭代函数
  function foo(x = 5) {
    return {
      next: () => {
        return { done: !x, value: x && x-- };
      }
    };
  }
  ```

  在这个迭代函数中有 “值（value）和状态（done）” 两个控制变量，并且它的实际执行代码与上面的函数 f() 是一样的：

  ```js
  // in 函数f()
  x && f(--x);

  // in 迭代foo()
  x && x--;
  ```

  也就是说，递归函数“f()”和迭代函数“foo()”其实是在实现相同的过程。只是由于“递归完成与循环过程的结束”在这里是相同的语义，因此函数“f()”中不需要像迭代函数那样来处理“状态（done）”的传出。递归函数“f()”，要么结束，要么无穷递归。

#### 2.4.2 迭代对执行过程的重造和使用

在 JS 中，是通过一个中间对象来使用迭代过程 foo() 的。该中间对象称为**迭代器**，foo() 称为**迭代器函数**，用于返回该迭代器。例如：

```js
let tor = foo();
```

迭代器具有 .next() 方法用于一次（或每次）迭代调用。由于没有约定迭代调用的方式，因此可以用任何过程来调用它。例如：

```js
// 在循环语句中处理迭代调用
let tor = foo(5),
  result = tor.next();
while (!result.done) {
  console.log(result.value);
  result = tor.next();
}
```

根据约定，如果有一个对象“包含”这样一个迭代器函数（以返回一个迭代器），那么这个对象就是可迭代的。基于 JS 中“对象是属性集（所以所有包含的东西都必然是属性）”的概念，这个迭代函数被设计为称为“Symbol.iterator”的符号属性。例如：

```js
let x = {};
x[Symbol.iterator] = foo;
console.log(...x); // 5 4 3 2 1
```

`...` 是[可扩展操作符](/frontend/JavaScript/JavaScript权威指南/JavaScript权威指南.md#712-扩展操作符)，是仅在对象字面量中有效的一种特殊语法。

这个语法与函数的第三个语义组件——“值”是有关的。在 JS 中（也包括在绝大多数支持函数的语言中），函数只能返回一个值。与此类似，语句也只有一个这样的单值返回，所以批语句执行也仍然只是返回最后一行的结果。并且，一旦 ...x 被理解为语句，那么它就不能用作操作数，成为一个表达式的部分。这在概念上是不容许的。

所以，当在“函数”这个级别表达多次调用时，尽管它可以通过“对象（迭代对象）”来做形式上的封装，却无法有效地表达“多次调用的多个结果”。这才是展开语法被设计出来的原因。

如果可迭代对象表达的是“多个值”，那么可以作用于它的操作或运算通常应该是那些面向“值的集合（Collections）”的。更确切地说，它是**可以面向“索引集合（Indexed Collections）”和“键值集合（Keyed Collections）”设计的语法概念**。

#### 2.4.3 内部迭代过程

迭代的本质是多次函数调用，在 JS 内部实现这一机制，本质上就是管理这些多次调用之间的关系。这显然包括一个循环过程，和至少一个循环控制变量。

这个迭代有一个开启过程，简单的如展开语法（...），复杂的如 for…of 语句。

迭代是“一个执行过程”，既然是过程，那么就存在过程被中断的可能。简单的示例如下：

```js
while (!result.done) {
  break;
}
```

这个过程什么也不会发生。如果是在经典的 while 循环里面，那么它的 result 和 tor，以及 foo() 调用所开启的那个函数闭包都被当前上下文管理或回收。然而，如果在一个展开过程，或者 for…of 循环中，相应的“语法”管理上述这些组件的时候又需要怎样的处理，例如：

```js
function touch(x) {
  if (x === 2) throw new Error('hard break');
}

// 迭代函数
function foo2(x = 5) {
  return {
    next: () => {
      touch(x); // some process methods
      return { done: !x, value: x && x-- };
    }
  };
}

let x = {};
x[Symbol.iterator] = foo2;

console.log(...x); // Error: hard break
```

这个示例是一个简单异常，但如果这个异常发生于 for…of 中：

```js
for (let i of x) console.log(i);
// 5
// 4
// 3
// Error: hard break
```

在这两种示例中，异常都是发生于 foo2() 这个函数调用的一个外部处理过程中，而等到用户代码有机会操作时，已经处于 console.log() 调用或 for…of 循环中了，如果用户在这里设计异常处理过程，那么 foo2() 中的 touch(x) 管理和涉及的资源都无法处理。因此，ECMAScript 设计了另外两个方法来确保 foo2() 中的代码在“多次调用”中仍然是受控的。这包括两个回调方法：

- `tor.return()`：当迭代正常过程退出时回调
- `tor.throw()`：当迭代过程异常退出时回调

```js
Object.getOwnPropertyNames(tor.constructor.prototype); // [('constructor', 'next', 'return', 'throw')];
```

现在给 tor 的 return 属性加一个回调函数：

```js
function foo2(x = 5) {
  return {
    // 每次 .next() 都不会返回 done 状态，因此可列举无穷次
    next: () => {},
    return: () => console.log('RETURN!')
  };
}
let x = {};
x[Symbol.iterator] = foo2;

// 第一次迭代后即执行 break
for (let i of x) break; // RETURN!
```

#### 2.4.4 管理循环与异常处理

并且如果试图在 tor.throw 中去响应 foo() 迭代中的异常，却什么也得不到：

```js
// 迭代函数
function foo3(x = 5) {
  return {
    // 第一个.next()执行时即发生异常
    next: () => {
      throw new Error();
    },
    throw: () => console.log('THROW!')
  };
}
let x = {};
x[Symbol.iterator] = foo3;

// 异常直接被抛给了全局
console.log(...x); // throw Error
```

显然可以把这个例子跟最开始使用的 foo() 组合起来，foo() 迭代可以正确地得到 5 4 3 2 1，而上面的 return/throw 可以捕获过程的退出或异常。例如：

```js
function foo4(x = 5) {
  return {
    // foo() 中的 next
    next: () => {
      return { done: !x, value: x && x-- };
    },

    // foo2() 和 foo3() 中的 return 和 throw
    return: () => console.log('RETURN!'),
    throw: () => console.log('THROW!')
  };
}

let x = {};
x[Symbol.iterator] = foo4;
```

迭代过程并不是一个语法执行的过程，而是应该理解为一组函数执行的过程；对于这一批函数执行过程中的结束行为，也应该理解为函数内的异常或退出。因此，尽管在 for…of 的表面上看，是 break 发生了语句中的中止，而在迭代处理的内部发生的，却是“一个迭代过程的退出”。与此同样复杂的是，在这一批函数的多个执行上下文中，不论是在哪儿发生了异常，其实只有外层的第一个能捕获异常的环境能响应这个异常。

简单地说：“退出（RETURN）”是执行过程的，“异常（THROW）”是外部的。

JS 中，迭代被处理为两个实现用的组件，一个是（循环的）迭代过程，另一个是（循环的）迭代控制变量。表现在 tor 这个迭代对象上来看，就是（对于循环来说）“如果谁使用迭代变量 tor，那么就是谁管理迭代过程”。

这个“管理循环过程”意味着：

- 如果迭代结束（不论它因为什么结束），那么触发 tor.return 事件。
- 如果发现异常（只要是当前环境能捕获到的异常），那么触发 tor.throw 事件。

这两个过程总是发生在“管理循环过程”的行为框架中。例如在下面这个过程中：

```js
for (let i of x) {
  if (i == 2) break;
}
```

由于 for...of 语句将获得 x 对象的迭代变量 tor，那么它也将管理 x 对象的迭代过程。因此，在 for 语句 break 之后（在 for 语句将会退出自己的作用之前），它也就必须去通知 x 对象迭代过程也结束了，于是这个语句触发了 tor.return 事件。同样，如果是一个数组展开过程：

```js
console.log(...x);
```

那么将是 ...x 这个“展开语法”来负责上述的迭代过程的管理和“通知”，这个语法在它所在的位置上是无法响应异常的。该语法所在位置是一个表达式，不可能在它内部使用 try...catch 语句。

```js
function touch(x) {
  if (x === 2) throw new Error('hard break');
}

// 迭代函数
function foo5(x = 5) {
  return {
    next: () => {
      touch(x);
      return { done: !x, value: x && x-- };
    },

    return: () => console.log('RETURN!'),
    throw: () => console.log('THROW!')
  };
}

let x = {};
x[Symbol.iterator] = foo5;

try {
  console.log(...x);
} catch (e) {} // m
```

这段示例代码将 mute 掉一切：既没有 console.log() 输出，也没有异常信息，tor 的 return/throw 一个也没有发生。

对于 x 这个可迭代对象，以及 foo5() 这个迭代器函数来说，它既不知道自己发生了什么，也不知道它的外部世界发生了什么。因为 ...x 这个语法既没有管理迭代过程（因此不理解 tor 的退出行为），也没有在异常发生时向内通知 tor.throw 事件的能力。

### 2.5 重构函数语义组件-结果和参数

#### 2.5.1 将迭代过程展开

迭代器可以表达为一组函数的连续执行。那么，如果要把这一组函数展开来看的话，其实它们之间的相似性是极强的。

```js
// 迭代函数
function foo(x = 5) {
  return {
    next: () => {
      return { done: !x, value: x && x-- };
    }
  };
}

let x = new Object();
x[Symbol.iterator] = foo; // default `x` is 5
console.log(...x);

// 事实上相当于只调用了 5 次 return 语句，可以展开如下：
console.log(
  /* return */ { done: false, value: 5 }.value,
  /* return */ { done: false, value: 4 }.value,
  /* return */ { done: false, value: 3 }.value,
  /* return */ { done: false, value: 2 }.value,
  /* return */ { done: false, value: 1 }.value
);
```

事实上连续的 tor.next() 调用最终仅是为了获取它们的值（result.value），那么如果封装这些值的生成过程，就可以用一个新的函数来替代一批函数。这样的一个函数就称为**生成器函数**。

但是，由于函数只有一个出口（RETURN），所以用“函数的退出”是无法映射“函数包含一个多次生成值的过程”这样的概念的。如果要实现这一点，就必须让函数可以多次进入和退出。而这也就是 `yield` 运算符的作用。这些作用有两个方面：

- **逻辑上**：它产生一次函数的退出，并接受下一次 tor.next() 调用所需要的进入。
- **数据上**：它在退出时传出指定的值（结果），并在进入时携带传入的数据（参数）。

所以，yield 实际上就是在生成器函数中用较少的代价来实现一个完整“函数执行”过程所需的“参数和结果”。而至于“执行体”这个组件就是 tor.next() 所推动的那个迭代逻辑。

例如，上面的例子用生成器来实现就是：

```js
function* foo2(x = 5) {
  while (x--) yield x;
}

// 测试
let x = {};
x[Symbol.iterator] = foo2;
console.log(...x); // 4 3 2 1 0
```

#### 2.5.2 逻辑的重现

**生成器的关键在于如何产生 yield 运算所需要的两个逻辑：（函数的）退出和进入**。

事实上生成器内部是顺序的 5 行代码，还是一个循环逻辑，所以对于外部的使用者来说它是不可知的。生成器通过一个迭代器接口的界面与外部交互，只要 for..of 或 ...x 以及其他任何语法、语句或表达式识别该迭代器接口，那么它们就可以用 tor.next() 以及 result.done 状态来组织外部的业务逻辑，而不必在乎后面的（例如数据传入传出的）细节了。

然而，对于生成器来说，“（函数的）退出和进入”是如何实现的呢？前面提到过[“执行现场”](#212-执行现场的回收)这个东西，事实上它包括三个层面的概念：

- 块级作用域以及其他的作用域本质上就是一帧数据，交由所谓“环境”来管理。
- 函数是通过 CALL/RETURN 来模拟上述“数据帧”在栈上的入栈与出栈过程，也称为调用栈。
- 执行现场是上述环境和调用栈的一个瞬时快照（包括栈上数据的状态和执行的“位置”）。

其中的“位置”是一个典型的与“（逻辑的）执行过程”相关的东西。函数的进入（CALL）意味着数据帧的建立以及该数据帧压入调用栈，而退出（RETURN）意味着它弹出栈和数据帧的销毁。从这个角度上来说，yield 运算必然不能使该函数退出（或者说必须不能让数据帧从栈上移除和销毁）。因为 yield 之后还有其他代码，而一旦数据帧销毁了，那么其他代码就无法执行了。

所以，yield 是为数不多的能“挂起”当前函数的运算。但这并不是 yield 主要的、标志性的行为。yield 操作最大的特点是**它在挂起当前函数时，还将函数所在栈上的执行现场移出了调用栈**。由于 yield 可以存在于生成器函数内的第 n 层作用域中。

```js
function foo3() { // 块作用域1
  if (true) {  // 块作用域2
    while (true) { // 块作用域3
      yield 100
      // ...
    }
  }
}
```

所以，一个在多级的块作用域深处的 yield 运算发生时，需要向这个数据帧（作用域链）外层检索到第一个函数帧（即函数环境，FunctionEnvironment），挂起它以及它内部的全部环境。而执行位置，将会通过函数的调用关系，一次性地返回到上一次 tor.next() 的下一行代码。也就是说相当于在 tor.next() 内部执行了一次 return。

为了简化所谓“向外层检索”这一行为，JS 通常是使用所谓“执行上下文”来管理这些数据帧（环境）与执行位置的。执行上下文与函数或代码块的词法上下文不同，因为执行上下文只与“可执行体”相关，是 JS 引擎内部的数据结构，它总是被关联（且仅只关联）到一个函数入口。

由于 JS 引擎将 JS 代码理解为函数，因此事实上这个“执行上下文”能关联所有的用户代码文本。

“所有的代码文本”意味着“.js 文件”的全局入口也会被封装成一个函数，且全部的模块顶层代码也会做相同的封装。这样一来，所有通过文件装载的代码文本都会只存在于同一个函数中。由于在 Node.js 或其他一些具体实现的引擎中，无法同时使用标准的 ECMAScript 模块装载和.js 文件装载，因此事实上来说，这些引擎在运行 JS 代码时（通常地）也就只有一个入口的函数。

而所有的代码其实也就只运行在该函数的、唯一的一个“执行上下文”中。

如果用户代码——通过任意的手段——试图挂起这唯一的执行上下文，那么也就意味着整个的 JS 都停止了执行。因此，“挂起”这个上下文的操作是受限制的，被一系列特定的操作规范管理。

如果模块与文件装载机制分开，那么模块入口和文件入口就是二选一的。当然在不同的引擎中这也不尽相同。

**模块入口**是所有模块的顶层代码的顺序组合，它们被封装为一个称为“顶层模块执行（TopLevelModule Evaluation Job）”的函数，作为模块加载的第一个执行上下文创建。

类似的是，一般的 .js 文件装载也会创建一个称为“脚本执行（Script EvaluationJob）”的函数。后者，也是文件加载中所有全局代码块称为“Script 块”的原因。

除了这两种执行上下文之外，eval() 总是会开启一个执行上下文的。

JS 为 eval() 所分配的这个执行上下文，与调用 eval() 时的函数上下文享有同一个环境（包括词法环境和变量环境等等），并在退出 eval() 时释放它的引用，以确保同一个环境中“同时”只有一个逻辑在执行。

接下来，如果一个一般函数被调用，那么它也将形成一个对应的执行上下文，但是由于这个上下文是“被”调用而产生的，所以它会创建一个“调用者（caller）”函数的上下文的关联，并创建在 caller 之后。由于栈是后入先出的结构，因此总是立即执行这个“被调用者（callee）”函数的上下文。

这也是调用栈入栈“等义于”调用函数的原因。

但这个过程也就意味着这个“当前的（活动的）”调用栈是由一系列执行上下文以及它们所包含的数据帧所构成的。而且，就目前来说，这个调用栈的底部，要么是模块全局（TopLevelModuleEvaluationJob 任务），要么就是脚本全局（ScriptEvaluationJob 任务）。

了解了上面的，就能理解生成器的特殊之处了：**所有其他上下文都在执行栈上，而生成器的上下文（多数时间是）在栈的外面**。

#### 2.5.3 .next() 方法

```js
function* foo3() {
  yield 10;
}
// 获得迭代器对象，在语法形式上，貌似 foo3() 函数已经执行了一次。
let tor = foo3();

// 但是，事实上 foo3() 所声明的函数体并没有执行（因为它是生成器函数）
// 而是直到用户代码调用 tor.next() 迭代器方法的时候，foo3() 所声明的函数体才正式执行并直到那唯一的一行代码。
tor.next(); // { value: 10, done: false }
```

在代码 tor = foo3() 中，函数调用 “foo3()” 的实际执行效果是：**生成一个迭代过程，并将该过程交给了 tor 对象**。

换而言之：tor 是 foo3() 生成器（内部的）迭代过程的一个句柄。从引擎内的实现过程来说，tor（GeneratorFunction.prototype 的一个实例）其实包括：

- **状态**

  这个 tor 所代表的生成器在创建出来的时候将立即被挂起，因此状态值（state）初始化置为"启动时挂起（suspendedStart）"，而当在调用 tor.next() 因 yield 运算而导致的挂起称为"Yield 时挂起（suspendedYield）"。

- **执行上下文**（context）

  指向 tor 被创建时的上下文。所谓上下文一定指的是一个外部的、内部的或由全局/模块入口映射成的函数。

  接下来，当 tor.next() 执行时，tor 所包括的 context 信息被压到栈顶执行；当 tor.next() 退出时，这个 context 就被从栈上移除。这个过程与调用 eval() 是类似的，总是能保证指定栈是全局唯一活动的一个栈。如果活动栈唯一，那么系统就是同步的。因为只需要一个执行线程。

#### 2.5.4 对传入参数的改造

生成器对“函数执行”的执行体加以改造，使之变成由 tor.next() 管理的多个片断。用来映射多次函数调用的“每个 body”。除此之外，它还对传入参数加以改造，使执行“每个 body”时可以接受不同的参数。这些参数是通过 tor.next() 来传入，并作为 yield 运算的结果而使用的。

这里 JS 偷偷地更换了概念。也就是说，在：

```js
x = yield x
```

这行表达式中，从语法上看是表达式 yield x 求值，实际的执行效果是：yield 向函数外发送计算表达式 x 的值。而 x = ... 的赋值语义变成了：yield 接受外部传入的参数并作为结果赋给 x。

将 tor.next() 联合起来看，由于 tor 所对应的上下文在创建后总是挂起的，因此第一个 tor.next() 调用总是将执行过程“推进”到第一行 yield 并挂起。例如：

```js
function* foo4(x = 5) {
  console.log(x--);
  // ...

  x = yield x; // 传出 x 的值
  console.log(x); // 传入的arg
  // ...
}

let tor = foo4();
result = tor.next(); // 第一次调用.next()的参数将被忽略
console.log('result', result.value);
// 5
// result 4
```

而 foo4() 函数在 yield 表达式执行后将挂起。而当在下一次调用 tor.next(arg) 时，一个已经被 yield 挂起的生成器将恢复（resume），这时传入的参数 arg 就将作为 yield 表达式（在它的上下文中）的结果。也就是上例中第二个 console.log(x) 中的 x 值。例如：

```js
// 传入 100，将作为 foo4() 内的 yield 表达式求值结果赋给 `x = ...`
tor.next(100); // 100
```

### 2.6 ECMAScript 规范

在 ECMAScript 规范中，对 JS 语法的实现，尤其是语句、表达式，以及基础特性最核心的部分等等，都可以在对 “最简单的 JS 语法榜” 前三名的实现过程和渐次演进关系中展示出来。甚至可以说，**只要理解了最简单榜的前三名，也就理解了设计一门计算机语言的基础模型与逻辑**。

#### 2.6.1 最简单语法榜

throw 语句在 ECMAScript 规范描述中，它的执行实现逻辑只有三行：

```txt
ThrowStatement: throw Expression;
1.Let exprRef be the result of evaluating Expression.
2.Let exprValue be ? GetValue(exprRef).
3.Return ThrowCompletion(exprValue).
```

这三行代码描述包括两个 Let 语句，以及最后一个 Return 返回值。当然，这里的 Let/Return 是自然语言的语法描述，是 ECMAScript 规范中的写法，而不是某种语言的代码。

将这三行代码倒过来看，最后一行的 ThrowCompletion() 调用其实是一个简写，完整的表示法是一行用于返回完成记录的代码。这里的“记录”，也是一种在 ECMAScript 规范中的“规范类型”，是 ECMAScript 特有的。

```txt
Return Completion { [Type]: exprValue, [[Target]]: empty }
```

在 ECMAScript 规范的书写格式中，一对大括号“{ }”是记录的字面量（Record Literals）表示。也就是说，执行 throw 语句，在引擎层面的效果就是：**返回一个类型为"throw"的一般记录**。`[[target]]` 字段的作用，仅仅用作 “break labelName” 和 “continue labelName” 中的标签名。

这行代码也反映了 “JS 语句执行是有值（Result）的” 这一事实。也就是说，任何 JS 语句执行时总是会“返回”一个值，包括空语句。

空语句其实也是“最简单榜”的 Top 1，因为它在 ECMAScript 的实现代码有且仅有一行：

```txt
1.Return NormalCompletion(empty).
```

其中的 NormalCompletion() 也是一个简写，完整的表示法与上面的 ThrowCompletion() 也类似，不过其中的传入参数 argument 在这里是 empty。

```txt
Return Completion { [Type]: argument, [[Target]]: empty }
```

而传入参数 argument 在这里是 empty，这是 ECMAScript 规范类型中的一个特殊值，理解为规范层面可以识别的 Null 值就可以了（例如它也用来指没有 `[[Target]]`）。也就是说，所谓“空语句（Empty statement）”，就是返回结果为“空值（Empty）”的一般语句。

#### 2.6.2 在语句之外看语句

在 JS 中，除了 eval() 之外，从无 “如何执行语句” 一说。

这是因为任何情况下，“装载脚本 + 执行脚本” 都是引擎自身的行为，用户代码在引擎内运行时，如 “鱼不知水” 一般，是难以知道语句本身的执行情况的。并且，即使是 eval()，由于它的语义是 “语句执行并求值”，所以事实上从 eval() 的结果来看是无法了解语句执行的状态的。因为“求值”就意味着去除了“执行结果（Result）”中的状态信息。

ECMAScript 为 JS 提供语言规范，出于 ECMAScript 规范书写的特殊性，它也同时是引擎实现的一个规范。在 ECMAScript 中，所有语句都被解析成待处理的结点，最顶层的位置总是被称为 _Script_ 或 _Module_ 的一个块（块语句），其他的语句将作为它的一级或更深层级的、嵌套的子级结点，这些结点称为 _“Parse Node”_，它们构成的整个结构称为 _“Parse Tree”_。

无论如何，语句总是一个树或子树，而表达式可以是一个子树或一个叶子结点。

> 空语句可以是叶子结点，因为没有表达式做它的子结点。

执行语句与执行表达式在这样的结构中是没有明显区别的，而所谓“执行代码”，在实现上就被映射成执行这个树上的子树（或叶子结点）。

所谓“顺序执行的语句”表现在 _“Parse Tree”_ 这个树上，就是同一级的子树。它们之间平行（相同层级），并且相互之间没有“相互依赖的运算”，所以它们的值（也就是尝试执行它们共同的父结点所对应的语句）就将是最后一个语句的结果。所有顺序执行语句的结果向前覆盖，并返回最终语句的结果（Result）。

事实上在表达式中，也存在相同语句的执行过程。也就是如下两段代码在执行效果上其实没有什么差异：

```js
// 表达式的顺序执行
1, 2, 3, 4;

// 语句的顺序执行
// 1; 2; 3; 4;
```

更进一步地说，如下两种语法，其抽象的语义上也是一样的：

```js
// 通过分组来组合表达式
1, 2, 3, 4;

// 通过块语句来组合语句
// {1; 2; 3; 4;}
```

所以，从语法树的效果上来看，所谓“语句的执行者”，其实就是它外层的语句；而最外层的语句，总是被称为 _Script_ 或 _Module_ 的一个块，并且它会将结果返回给 shell、主进程或 eval()。

除了 eval() 之外，所有外层语句都并不依赖内层语句的返回值；除了 shell 程序或主进程程序之外，也没有应用逻辑来读取这些语句默认状态下的值。

#### 2.6.3 值的覆盖与读取

语句的五种完成状态（normal, break, continue, return, 以及 throw）中：

- “Normal（默认状态）”大多数情况下是不被读取的
- break 和 continue 用于循环和标签化语句
- return 则是用于函数的返回值

于是，所有的状态中，就只剩下 “异常抛出（throw）” 这个状态。

> 有且仅有 return 和 throw 两个状态是确保返回时携带有效值（包括 undefined）的。其他的完成类型则不同，可能在返回时携带“空（empty）”值，从而需要在语句外的代码（shell、主进程或 eval）进行特殊的处理。

return 语句总是显式地返回值或隐式地置返回值为 undefined，也就是说它总是返回值，而 break 和 continue 则是不携带返回值的。但 ECMAScript 语言约定，在块中的多个语句顺序执行时，遵从两条规则：

1. 在向前覆盖既有的语句完成值时，empty 值不覆盖任何值。

2. 部分语句在没有有效返回值，且既有语句的返回值是 empty 时，默认用 undefined 覆盖之。

   出现在 if、do…while、while、for/for…in/for…of、with、switch 和 try 语句块中。在 ECMAScript 6 之后，这些语句约定不会返回 empty，因此它的执行结果“至少会返回一个 undefined 值”，而在此之前，它们的执行结果是不确定的，既可能返回 undefined 值，也可能返回 empty，并导致上一行语句值不覆盖。

#### 2.6.4 引用的值

表达式的本质是求值运算，而引用是不能直接作为最终求值的操作数的。因此引用实际上不能作为语句结果来返回，并且它在表达式计算中也仅是作为中间操作数（而非表达最终值的操作数）。所以在语句返回值的处理中，总是存在一个“执行表达式并‘取值’”的操作，以便确保不会有“引用”类型的数据作为语句的最终结果。而这，也就是在 ECMAScript 规中的 throw 1 语句的第二行代码的由来：

> 2.Let exprValue be ? GetValue(exprRef).

事实上在这里的符号“? opName()”语法也是一个简写，在 ECMAScript 中它表示一个 ReturnIfAbrupt(x) 的语义：如果设一个“处理（opName()）”的结果是 x，那么：

1. 如果 x 是特殊的（非 normal 类型的）完成记录，则返回 x。
2. 否则返回一个以 `x.[[value]]` 为值的、normal 类型的完成记录。

简而言之，就是在 GetValue() 这个操作外面再封装一次异常处理。这往往是很有效的，例如一个 throw 语句，它自己的 throw 语义还没有执行到，结果在处理它的操作数时就遇到一个异常：

```js
throw 1 / 0;
```

那么 exprRef 作为表达式的计算结果，其本身就将是一个异常，于是 `? GetValue(exprRef)` 就可以返回这个异常对象（而不是异常的值）本身了。

类似地，所谓“表达式语句”（这是排在“最简单语句榜”的第二名的语句）就直接返回这个值：

```txt
ExpressionStatement: Expression;
1.Let exprRef be the result of evaluating Expression.
2.Return ? GetValue(exprRef).
```

#### 2.6.5 完成状态

```txt
1.Let exprRef be the result of evaluating Expression.
```

其中的 “result of evaluating…” 基本上算是 ECMAScript 中一个约定俗成的写法。不管是执行语句还是表达式，都是如此。这意味着引擎需要按之前的那些执行逻辑来处理对应的代码块、表达式或值（操作数），然后将结果作为 Result 返回。

ECMAScript 所描述的引擎，能够理解“执行一行语句”与“执行一个表达式”的不同，并且由此决定它们返回的是一个“引用记录”还是“完成记录”（规范类型）。当外层的处理逻辑发现是一个引用时，会再根据当前逻辑的需要将“引用”理解为左操作数（取引用）或右操作数（取值）；否则当它是一个完成记录时，就尝试检测它的类型，也就是语句的完成状态（throw、return、normal 或其他）。

所以，throw 语句也好，return 语句也罢，所有的语句与它“外部的代码块（或 Parse Tree 中的父级结点）”间其实都是通过这个**完成状态**来通讯的。而外部代码块是否处理这个状态，则是由外部代码自己来决定的。

而几乎所有的外部代码块在执行一个语句（或表达式）时，都会采用上述的 ReturnIfAbrupt(x) 逻辑来封装，也就是说，如果是 normal，则继续处理；否则将该完成状态原样返回，交由外部的、其他的代码来处理。所以，就有了下面这样一些语法设计：

1. 循环语句用于处理非标签化的 continue 与 break，并处理为 normal。
2. 否则，标签语句用于拦截那些“向外层返回”的 continue 和 break；且，如果能处理（例如是目标标签），则替换成 normal。
3. 函数的内部过程 `[[Call]]`，将检查“函数体执行”（将作为一个块语句执行）所返回状态是否是 return 类型，如果是，则替换成 normal。

显而易见，所有语句行执行结果状态要么是 normal，要么就是还未被拦截的 throw 类型的语句完成状态。try 语句用于处理那些漏网之鱼（throw 状态）：在 catch 块中替换成 normal，以表示 try 语句正常完成；或在 finally 中不做任何处理，以继续维持既有的完成状态，也就是 throw。

## 三. JS 是如何一步步走向应用编程语言的

### 3.1 JS 面向对象系统

#### 3.1.1 JS 1.0~1.3 中的对象

在 JS 1.0 的时候，对象是不支持继承的。那时的 JS 使用的是称为“**类抄写**”的技术来创建对象，就是“在一个函数中将 this 引用添加属性，并且使用 new 运算来创建对象实例”，例如：

```js
function Car() {
  this.name = 'Car';
  this.color = 'Red';
}

var x = new Car();
```

这样的“类 → 对象”的模型其实是很简单和粗糙的。但 JS 1.0 时代的对象就是如此，并且，重要的是，事实上直到现在 JS 的对象仍然如此。ECMAScript 规范明确定义了这样的一个概念：**对象是零到多个的属性的集合**。

> In ECMAScript, an object is a collection of zero or more properties.

JS 1.0 的对象系统是有类的，并且在语义上也是“对象创建自类”。这使得它在表面上“看起来”还是有一些继承性的。例如，一个对象必然继承了它的类所声明的那些性质，也就是“属性”。但是因为这个 1.0 版存在的时间很短，所以后来大多数人都不记得 JS “有类，而又不支持类的继承” 这件事情，从而将从 JS 1.1 才开始具有的**原型继承**作为它最主要的面向对象特征。

在这个阶段，JS 中有关全局环境和全局变量的设计也已经成熟了，简单地来说，就是：

1. 向没有声明的变量名赋值，会隐式地创建一个全局变量。
2. 全局变量会被绑定为全局对象（global）的属性。

这样一来，JS 的变量环境（或者全局环境）与对象系统就关联了起来。而接下来，由于 JS 也实现了带有闭包性质的函数，因此 “闭包” 也成了环境的管理组件。也就是说，闭包与对象都具有实现变量环境的能力。

因此，在这个阶段，JS 提出了“**对象闭包**”与“**函数闭包**”两个概念，并把它们用来实现的环境称为“**域**（Scope）”。这些概念和语言特性，一直支持 JS 走到 1.3 版本，并随着 ECMAScript ed3 确定了下来。

在这个时代，JS 语言的设计与发展还基本是以它的发明者布兰登·艾奇（Brendan Eich）为主导的，JS 的语言特性也处于一个较小的集合中，并且它的应用也主要是以浏览器客户端为主。这时代的 JS 深得早期设计与语言定义的精髓。这些东西，可以从后来布兰登·艾奇的一个开源项目中读到。这个项目称为 Narcissus，是用 JS 来实现的一个完整的 JS 1.3。在这个项目中，对象和函数所创建的闭包都统一由一个简单的对象表示，称为 scope，它包括“object”和“parent”两个成员，分别表示本闭包的对象，以及父一级的作用域。例如：

```txt
scope = {
  object: <创建本闭包的对象或函数>,
  parent: <父级的scope>
}
```

因此，所谓“**使用 with 语句创建一个对象闭包**”就简单地被实现为“向既有的作用域链尾加入一个新的 scope”。

```js
// code from $(narcissus)/src/jsexec.js
// ...
// 向x所代表的scope-chain表尾加入一个新的scope
x.scope = { object: t, parent: x.scope };
try {
  // n.body是with语句中执行的语句块
  execute(n.body, x); // 指在该闭包（链）`x`中执行上述语句
} finally {
  x.scope = x.scope.parent; // 移除链尾的一个scope
}
```

可见 JS 1.3 时代的执行环境，其实就是一个闭包链的管理。而且这种闭包既可以是对象的，也可以是函数的。尽管在静态语法说明或描述时，它们被称为**作用域**或**域**（Scope），或者在动态环境中它们被称为**上下文**（Context），但在本质上，它们是同样的一堆东西。

综合来看，**JS 中的对象本质上是属性集**，这可以视为一个**键值列表**，而对象继承是由这样的列表构成的、称为原型的链。另一方面，执行的上下文就是函数或全局的变量表，这同样可以表达为一个键值列表，而执行环境也可以视为一个由该键值列表构成的链。

于是，在 JS 1.3，以及 ECMAScript ed3 的整个时代，这门语言仅仅依赖键值列表和基于它们的链实现并完善了它最初的设计。

#### 3.1.2 属性访问与可见性

从一开始，JS 就有一个东西没有说清楚，那就是属性名的可见性。

这种可见性在 OOP（面向对象编程）中有专门的、明确的说法，但在早期的 JS 中，它可以简单地理解为“**一个属性是否能用 for…in 语句列举出来**”。如果它可以被列举，那么就是可见的，否则就称为隐藏的。

任何对象都有 `constructor` 这个属性，默认指向创建它的构造器函数，并且它应当是隐藏的属性。但是在早期的 JS 中，这个属性如何隐藏，却是没有规范来约定的。例如在 JScript 中，它就是一个特殊名字，只要是这个名字，就隐藏；而在 SpiderMonkey 中，当用户重写这个属性后，它就变成了可见的。

后来 ECMAScript 就约定了所谓的“**属性的性质**（attributes）”这样的东西，也就是现在的**可写性**、**可列举性**（可见性）和**可配置性**。ECMAScript 约定：

- “constructor” 默认是一个不可列举的属性
- 使用赋值表达式添加属性时，属性的可列举性默认为 true。

这样一来，“constructor” 在可见性（这里是指可列举性）上的行为就变得可预期了。

类似于此的，ECMAScript 约定了读写属性的方法，以及在属性中访问、操作性质的全部规则，并统一使用所谓“属性描述符”来管理这些规则。于是，这使得 ECMAScript 规范进入了 5.x 时代。相较于早期的 3.x，这个版本的 ECMAScript 规范并没有太多的改变，只是从语言概念层面上实现了“大一统”，所有浏览器厂商，以及引擎的开发者都遵循了这些规则，为后续的 JS 大爆发——ECMAScript 6 的发布铺平了道路。

到目前为止，JS 中的对象仍然是简单的、原始的、使用 JS 1.x 时代的基础设计的原型继承。而每一个对象，仍然都只是简简单单的一个所谓的“属性包”。

#### 3.1.3 从原型中继承来的属性

对于绝大多数对象来说，“constructor”是从它的原型继承来的一个属性，这有别于它“自有的（Own）”属性。在原型继承中，在子类实例重写属性时，实际发生的行为是“**在子类实例的自有属性表中添加一个新项**”。这并不改变原型中相同属性名的值，但子类实例中的**属性性质**以及**值**覆盖了原型中的。这是原型继承——几乎是公开的——所有的秘密所在。

在使用原型继承来的属性时，有两种可能的行为，这取决于属性的具体性质——属性描述符的类型：

- **数据描述符**（d）：那么 d.value 总是指向这个数据的值本身。

- **存取描述符**：那么 d.get() 和 d.set() 将分别指向属性的存取方法。

  存取方法（get/setter）并不一定关联到数据，也并不一定是数据的置值或取值。某些情况下，存取方法可能会用作特殊的用途，例如模拟在 VBScript 中常常出现的“无括号的方法调用”。

  ```js
  excel = Object.defineProperty(new Object(), 'Exit', {
    get() {
      process.exit();
    }
  });

  // 类似JScript/VBScript中的ActiveObject组件的调用方法
  excel.Exit;
  ```

当用户不使用属性赋值或 defineProperty() 等方法来添加自有的属性时，属性访问会（默认地）上溯原型链直到找到指定属性。这一定程度上成就了“包装类”这一特殊的语言特性。

**包装类**是 JS 从 Java 借鉴来的特性之一，它使得用户代码可以用标准的面向对象方法来访问普通的值类型数据。于是，所谓“一切都是对象”就在眨眼间变成了现实。例如，下面这个示例中使用的字符串常量 x，它的值是"abc"：

```js
x = 'abc';
console.log(x.toString());
```

当在使用 x.toString() 时，JS 会自动将“值类型的字符串（“abc”）”通过包装类变成一个字符串对象。这类似于执行下面的代码，使用函数 Object() 来“将这个值显式地转换为对象”。

```js
console.log(Object(x).toString());
```

这个包装的过程发生于**函数调用运算“( )”**的处理过程中，或者将“x.toString”作为整体来处理的过程中（例如作为一个 ECMAScript 规范引用类型来处理的过程）。也就是说，仅仅是“对象属性存取”这个行为本身，并不会触发一个普通“值类型数据”向它的包装类型转换。

除了 Undefined，基本类型中的所有值类型数据都有自己的包装类，包括符号，又或者布尔值。这使得这些值类型的数据也可以具有与之对应的包装类的原型属性或方法。这些属性与方法自己引用自原型，而不是自有数据。值类型数据本身并不是对象，因此也不可能拥有自有的属性表。

#### 3.1.4 字面量与标识符

通常情况下，开发人员会将标识符直接称为**名字**（在 ECMAScript 规范中，它的全称是“标识符名字（IdentifierName）”），而**字面量**是一个数据的文本表示。通常标识符就用作后者的名字标识。对于这两种东西，在 ECMAScript 中的处理机制并不太一样，并且在文本解析阶段就会把二者区分开来。

```js
// var x = 1;
1;
x;
```

比如在这个例子中，如果其中“1”是字面量值，JS 会直接处理它；而 x 是一个标识符（哪怕它只是一个值类型数据的变量名），就需要建立一个“引用”来处理了。但是接下来，如果是代码（假设下面的代码是成立的）：

```js
1.toString
```

那么它作为“整体”就需要被创建为一个引用，以作为后续计算的操作数（取成员值，或仅是引用该成员）。就它们同是“引用”这一事实而言，“1.toString”与“x”在引擎级别有些类似。

然而在数字字面量中，“1.xxxxx”这样的语法是有含义的。它是浮点数的表示法。所以“1.toString”这样的语法在 JS 中会报错，这个错误来自于浮点数的字面量解析过程，而不是“.作为存取运算符”的处理过程。在 JS 中，浮点数的小位数是可以为空的，因此“1.”和“1.0”将作为相同的浮点数被解析出来。

既然“1.”表示的是浮点数，那么 `1..constructor` 表示的就是该浮点数字面量的“.constructor”属性。`1 in 1..constructor` 其实是一个表达式。在语义上，“1..constructor” 与 “Object(1.0).constructor” 这样的表达式是等义的，且它们的使用效果也是一样的。

#### 3.1.5 属性存取的不确定性

除了存取器（get/setter）带来的不确定性之外，JS 的属性存取结果还受到原型继承（链）的影响。上例中的表达式值并不恒为 false，例如给 Number 加一个下标值为 1 的属性，那么表达式 `1 in 1..constructor` 的值就会是 true 了。

```js
// 修改原型链中的对象
Number[1] = 'scope';
// 1 in 1..constructor // true
```

因为 Object(1.) 意味着将数字“1.0”封装成它对应的包装类的一个对象实例（x），假设这个对象是 x，那么 `1..constructor` 也就指向 x.constructor。

```js
x = new Number(1.0);
```

而“x.constructor”不是自有属性，并且，由于 x 是“Number()”这个类/构造器的子类实例，因此该属性实际继承自原型链上的 “Number.prototype.constructor” 这个属性。然后，在默认情况下，“Function.prototype.constructor” 指向这个函数自身。

也就是说，“Number.prototype.constructor” 与 “1..constructor” 相同，且都指向 Number() 自身。

所以上面的示例中，当添加了 `Number[1]` 这个下标属性之后，表达式的值就变了。

### 3.2 从构造器到类

**构造器**是 JS 中面向对象系统的核心概念之一。跟“属性”相比，如果属性是静态的结构，那么“构造器”就是动态的逻辑。

没有构造器的 JS，就是一个充填了无数数据的、静态的对象空间。这些对象之间既没有关联，也不能衍生，更不可能发生交互。然而，这却真的就是 JS 1.0 那个时代的所谓“面向对象系统”的基本面貌。

#### 3.2.1 基于对象的 JS

JS 1.0 的时代，也就是最早最早的 JS 其实是没有继承的。

JS 1.0 已经可以将函数作为构造器，并且在函数中向它的实例（也就是 this 对象）抄写类声明的那些属性。在早期的面向对象理论里面，就已经可以称这个函数为**类**，而这个被创建出来的实例为**对象**了。

所以，有了类、对象，以及一个约定的构造过程，有了这三个东西，JS 就声称了自己是一门“面向对象”的语言，并且还是一门“有类语言”。

所以 JS 从 1.0 开始就有类，在这个类（也就是构造器）中采用的是所谓“类抄写”的方案，将类所拥有的属性声明一项一项地抄写到对象上面，而这个对象，就是现在的 this 引用。

这样一来，一段声明类和构造对象的代码，大概写出来就是下面这个样子，在一个函数里面不停地向 this 对象写属性，最后再用 new 运算符来创建一下它的实例就好了：

```js
function Car() {
  this.name = 'Car';
  this.color = 'Red';
}

var x = new Car();
// ...
```

#### 3.2.2 类与构造器

由于在这样的构造过程中，this 是作为 new 运算所构造出来的那个实例来使用的，因此 JS 1.0 约定全局环境中不能使用 this 的。因为全局环境与 new 运算无关，全局环境中也并不存在一个被 new 创建出来的实例。

然而随着 JS 1.1 的到来，JS 支持“**原型继承**”了，于是“类抄写”成为了一个过时的方案。对于继承性来说，它显得无用；对于一个具体的实例来说，它又具有“类‘说明了’实例的结构”这样的语义。

因此，从“原型继承”在 JS 中出现的第一天开始，“类继承 VS 原型继承”之间就存在不可调和的矛盾。在 JS 1.1 中，类抄写是可以与原型继承混合使用的。

例如，可以用类抄写的方式写一个 Device() 类，然后再写一个 Car() 类，最后将 Car() 类的原型指向 Device。这一切都是合理的、正常的写法。

```js
function Device() {
  this.id = 0;
}

function Car() {
  this.name = 'Car';
  this.color = 'Red';
}

Car.prototype = new Device();

var x = new Car();
console.log(x.id); // 0
```

于是现在，可以用 new 运算来创建子类 Car() 的实例了，例如按照以前的习惯，称这个实例为 x，这也仍然没有问题。

但是在面向对象编程（OOP）中，x 既是 Car() 的子类实例，也是“Device()”的子类实例，这是 OOP 的继承性所约定的基本概念。这正是这门语言很有趣的地方：**一方面使用了类继承的基础结构和概念，另一方面又要实现原型继承和基于原型链检查的逻辑**。例如，用 `x instanceof Device` 这样的代码来检查，就会看到 x 是 Device() 的子类实例。

于是，这里的 instanceof 运算被实现为一个**动态地访问原型链**的过程：它将从 Car.prototype 属性逆向地在原型链中查到指定的——“原型”。

首先，JS 从对象 x 的内部结构中取得它的原型。这个原型的存在，与 new 运算是直接相关的——在早期的 JS 中，有且仅有 new 运算会向对象内部写“原型”这个属性（称为"`[[Prototype]]`"内部槽）。由于 new 运算是依据它运算时所使用的构造器来填写这个属性的，所以这意味着它在实际实现时，将 Car.prototype 这个值，直接给填到 x 对象的内部属性去了。

```js
// x = new Car()
x.[[Prototype]] === Car.prototype; // true
```

在 instanceof 运算中，x instanceof AClass 表达式的右侧是一个类名（对于之前的例子来说，它指向构造器 Car），但实际上 JS 是使用 AClass.prototype 来做比对的，对于“Car() 构造器”来说，就是“Car.prototype”。但是，如果上一个例子需要检查的是 x instanceof Device，也就是“Device.prototype”，那么这二者显然是不等值的。

所以，instanceof 运算会再次取 `x.[[Prototype]].[[Prototype]]` 这个内部原型，也就是顺着原型链向上查找，并且将找到一个等值于“x 的内部原型”的东西。

```js
// 因为
x.[[Prototype]] === Car.prototype
// 且
Car.prototype = new Device()
// 所以
x.[[Prototype]].[[Prototype]] === Device.prototype
```

现在，由于在 x 的原型链上发现了“x instanceof Device”运算右侧的“Device.prototype”，所以这个表达式将返回 True 值，表明：_对象 x 是 Device() 或其子类的一个实例_。

#### 3.2.3 ES6 之后的类

在 ECMAScript 6 之前，JS 中的**函数**、**类**和**构造器**这三个概念是混用的。一般来说，它们都被统一为“函数 Car()”这个基础概念，而当它用作“x = new Car()”这样的运算，或从 x.constructor 这样的属性中读取时，它被理解为构造器；当它用作“x instanceof Car”这样的运算，或者讨论 OOP 的继承关系时，它被理解为类。

习惯上，如果程序要显式地、字面风格地说明一个函数是构造器、或者用作构造过程，那么它的函数名应该首字母大写。同时，如果一个函数要被明确声明为“静态类（也就不需要创建实例的类，例如 Math）”，那么它的函数名也应该首字母大写。

从 ECMAScript 6 开始，JS 有了使用 class 来声明“类”的语法。例如：

```js
class AClass {}
```

自此之后，JS 的“类”与“函数”有了明确的区别：**类只能用 new 运算来创建，而不能使用“()”来做函数调用**。

在 ECMAScript 6 之后，JS 内部是明确区分方法与函数的：**不能对方法做 new 运算**。如果尝试这样做，JS 会抛一个异常出来，提示“这个函数不是一个构造器（is not a constructor）”。

```js
// 声明一个带有方法的对象字面量
let obj = { foo() {} };

// 对方法使用 new 运算会导致异常
new obj.foo(); // TypeError: obj.foo is not a constructor
```

在 ECMAScript 6 之后，函数可以简单地分为三个大类：

- **类**：只可以做 new 运算。

- **方法**：只可以做调用“()”运算。在内部声明时，有三个主要特征：

  - 具有一个名为 “主对象`[[HomeObject]]`” 的内部槽
  - 没有名为 “构造器`[[Construct]]`” 的内部槽
  - 没有名为 “prototype” 的属性

  后两种特征（没有`[[Construct]]`内部槽和 prototype 属性）完全排除了一个普通方法用作构造器的可能。对照来看，所谓“类”其实也是作为方法来创建的，但它有独立的构造过程和原型属性。

- **一般函数**：（除部分函数有特殊限制外，）同时可以做 new 和调用运算。

  函数的 “.prototype” 的属性描述符中的设置比较特殊，它不能删除，但可以修改（‘writable’ is true）：

  - 当这个值被修改成 null 值时，它的子类对象是以 null 值为原型的。
  - 当它被修改成非对象值时，它的子类对象是以 Object.prototype 为原型的。
  - 否则，当它是一个对象类型的值时，它的子类才会使用该对象作为原型来创建实例。

  运算符“new”总是依照这一规则来创建对象实例 this。不过，对于“类”和一般的“构造器（函数）”，这个创建过程会略有不同。

#### 3.2.4 创建 this 的顺序问题

如前所述，如果对 ECMAScript 6 之前的构造器函数（例如 f）使用 new 运算，那么这个 new 运算会使用 f.prototype 作为原型来创建一个 this 对象，然后才是调用 f() 函数，并将这个函数的执行过程理解为“类抄写（向用户实例抄写类所声明的属性）”。从用户代码的视角上来看，这个新对象就是由当前 new 运算所操作的那个函数 f() 创建的。

这在语义上非常简洁明了：由于 f() 是 this 的类，因此 f.prototype 决定了 this 的原型，而 f() 执行过程决定了初始化 this 实例的方式。但是它带来了一个问题，一个从 JS 1.1 开始至今都困扰 JS 程序员的问题：**无法创建一个有特殊性质的对象，也无法声明一个具有这类特殊性质的类**。

比如说，所有的函数有一个公共的父类/祖先类，称为 Function()。所以可以用 new Function() 来创建一个普通函数，这个普通函数也是可以调用的，在 JS 中这是很正常的用法，例如：

```js
f = new Function();
f instanceof Function; // true
f(); // undefine
```

接下来，也确实可以用传统方法写一个 Function() 的子类，但这样的子类创建的实例就不能调用。例如：

```js
MyFunction = function () {};
MyFunction.prototype = new Function();
f = new MyFunction();
[f instanceof MyFunction, f instanceof Function]; // [ true, true ]

f(); // TypeError: f is not a function
```

JS 所谓的函数，其实是“一个有`[[Call]]`内部槽的对象”。而 Function() 作为 JS 原生的函数构造器，它能够在创建的对象（例如 this）中添加这个内部槽，而当使用上面的继承逻辑时，用户代码（例如 MyFunction()）就只是创建了一个普通的对象，因为用户代码没有能力操作 JS 引擎层面才支持的那些“内部槽”。

所以，有一些“类 / 构造器”在 ECMAScript 6 之前是不能派生子类的，例如 Function，又例如 Date。

而到了 ECMAScript 6，它的“类声明”采用了不同的构造逻辑。ECMAScript 6 要求所有子类的构造过程都不得创建这个 this 实例，并主动的把这个创建的权力“交还”给父类、乃至祖先类。这也就是 ECMAScript 6 中类的两个著名特性的由来，即，如果类声明中通过 extends 指定了父类，那么：

- 必须在构造器方法（constructor）中显式地使用 super() 来调用父类的构造过程
- 在上述调用结束之前，是不能使用 this 引用的。

显然，真实的 this 创建就通过层层的 super() 交给了父类或祖先类中支持创建这个实例的构造过程。这样一来，子类中也能得到一个“拥有父类所创建的带有内部槽的”实例，因此上述的 Function() 和 Date() 等等的子类也就可以实现了。例如，可以在 class MyFunction 的声明中直接用 extends 指示父类为 Function。

```js
class MyFunction extends Function {}
f = new MyFunction();
f(); // undefine
```

这样一来，即使 MyFunction() 的类声明中缺省了“constructor()”构造方法，这种情况下 JS 会在这种情况下为它自动创建一个，并且其内部也仅有一个“super()”代码。这个过程会带来一个必然结果：**ECMAScript 6 的类是由父类或祖先类创建 this 实例的**。

> 如果类声明 class 中不带有 extends 子句，那么它所创建出来的类与传统 JS 的函数/构造器是一样的，也就是由自己来创建 this 对象。很显然，这是因为它无法找到一个显式指示的父类。不过关于这种情况，仍然隐藏了许多[实现细节](#33-superxxx)。

#### 3.2.5 用户返回 new 的结果

在 JS 中关于 new 运算与构造函数的最后一个有趣的设计，就是**用户代码可以干涉 new 运算的结果**。默认情况下，这个结果就是上述过程所创建出来的 this 对象实例，但是用户可以通过在构造器函数/方法中使用 return 语句来显式地重置它。

这也是从 JS 1.0 就开始具有的特性。因为 JS 1.x 中的函数、类与构造器是混用的，所以用户代码在函数中“返回些什么东西”是正常的语法，也是正常的逻辑需求。但是 JS 要求在构造器中返回的数据必须是一个对象，否则就将抛出一个运行期的异常。

这个处理的约定，从 ECMAScript ed3 开始有了些变化。从 ECMAScript ed3 开始，检测构造器返回值的逻辑从 new 运算符中移到了 `[[Construct]]` 的处理过程中，并且重新约定：当构造器返回无效值（非对象值或 null）时，使用原有已经创建的 this 对象作为构造过程 `[[Construct]]` 的返回值。

因此到了 ECMAScript 6 之后，那些一般函数，以及非派生类，就延续了这一约定：**使用已经创建的 this 对象来替代返回的无效值**。这意味着它们总是能返回一个对象，要么是 new 运算按规则创建的 this，要么是用户代码返回的对象。

然而严格来说，引擎是不能理解“为什么用户代码会在构造器中返回一个一般的值类型数据”的。因为对于类的预期是返回一个对象，返回这种“无效值”是与预期矛盾的。因此，对于那些派生的子类（即声明中使用了 extends 子句的类），ECMAScript 要求严格遵循“不得在构造器中返回非对象值（以及 null 值）”的设计约定，并在这种情况下直接抛出异常。例如：

```js
// (注：ES3之前将抛出异常）
new (function () {
  return 1;
})(); // {}

// 非派生类的构造方法返回无效值
new (class {
  constructor() {
    return 1;
  }
})(); // {}

// 派生类的构造方法返回无效值
new (class extends Object {
  constructor() {
    return 1;
  }
})(); // TypeError: Derived constructors may only return object or undefine
```

### 3.3 super.xxx()

JS 1.0 实现了以“类抄写”为基础的、基本的面向对象模型。而在此之后，JS 1.1 开始提出，并在后来逐渐完善了原型继承。这样一来，在 JS 中，从概念上来讲，所谓对象就是一个从原型对象衍生过来的实例，因此这个子级的对象也就具有原型对象的全部特征。

然而，既然是子级的对象，必然与它原型的对象有所不同。所以，有了原型继承带来的子级对象（这样的抽象层级），在这个子级对象上，就还需要有让它们跟原型表现得有所不同的方法。这时，JS 1.0 里面的那个“类抄写”的特性就跳出来了，它正好可以通过“抄写”往对象（也就是构造出来的那个 this）上面添加些东西，来制造这种不同。

也就是说，JS 1.1 的面向对象系统的设计原则就是：**用原型来实现继承，并在类（也就是构造器）中处理子一级的抽象差异**。所以，从 JS 1.1 开始，JS 有了自己的面向对象系统的完整方案，这个示例代码大概如下：

```js
// 这里用于处理“不同的东西”
function CarEx(color) {
  this.color = color;
  // ...
}

// 这里用于从父类继承“相同的东西”
CarEx.prototype = new Car('Eagle', 'Talon TSi', 1993);

// 创建对象
myCar = new CarEx('red');
```

这个方案基本上来说，就是两个解决思路的集合：使用构造器函数来处理一些“不同的东西”；使用原型继承，来从父类继承“相同的东西”。最后，new 运算符在创建对象的过程中分别处理“原型继承”和构造器函数中的“类抄写”，补齐了最后的一块木板。

一个对象系统既能处理继承关系中那些“相同的东西”，又能处理“不同的东西”，所以显而易见：**这个系统能处理基于对象的“全部的东西”**。正是因为这种概念上的完整性，所以从 JS 1.1 开始，一直到 ECMAScript 5 都在对象系统的设计上没能再有什么突破。

#### 3.3.1 super 出现的原因

对象继承有一个典型需求：**子级的对象除了要继承父级的“全部的东西”之外，它还要继承“全部的能力”**。

然而，传统的 JS 却做不到“继承全部的能力”。那个时候的 JS 其实是能够在一定程度上继承来自原型的“部分能力”的，譬如说原型有一个方法，那么子级的实例就可以使用这个方法，这时候子级也就继承了原型的能力。然而如果子级的对象重写了这个方法，在 ECMAScript 6 之前：**原型中的这个方法相对于子级对象来说，就失效了**。

原则上来讲，在子级对象中就再也找不到这个原型的方法了。这个问题非常地致命：这意味着子级对象必须重新实现原型中的能力，才能安全地覆盖原型中的方法。如果是这样，子级对象就等于要重新实现一遍原型，那继承性就毫无意义了。

这个问题追根溯源，还是要怪到 JS 1.0~1.1 的时候，设计面向对象模型时偷了的那一次懒。也就是直接将“类抄写”用于实现子级差异的这个原始设计，太过于简陋。“类抄写”只能处理那些显而易见的属性、属性名、属性性质，等等，却无法处理那些“方法/行为”背后的逻辑的继承。

由于这个缘故，JS 1.1 之后的各种大规模系统中，都有人不断地在跳坑和补坑，致力于解决这么一个简单的问题：**在“类抄写”导致的子类覆盖中，父类的能力丢失了**。

为了解决这种继承问题，ECMAScript 6 就提出了一个标准解决方案，这就是 `super` 这个关键字的由来。ECMAScript 6 约定，**如果父类中的名字被覆盖了，那么可以在子类中用 super 来找到它们**。

#### 3.3.2 super 指向父类
