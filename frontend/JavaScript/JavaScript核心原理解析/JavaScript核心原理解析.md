# JavaScript 核心原理解析

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [JavaScript 核心原理解析](#javascript-核心原理解析)
  - [一. JS 是如何构建起来的](#一-js-是如何构建起来的)
    - [1.1 delete](#11-delete)
      - [1.1.1 delete 删除的是表达式的引用类型的结果](#111-delete-删除的是表达式的引用类型的结果)
      - [1.1.2 规范中的引用](#112-规范中的引用)
      - [1.1.3 引用的作用](#113-引用的作用)
    - [1.2 声明语句与语法改变了 JS 语言核心性质](#12-声明语句与语法改变了-js-语言核心性质)
      - [1.2.1 声明](#121-声明)
      - [1.2.2 赋值](#122-赋值)
      - [1.2.3 变量泄露：向一个不存在的变量名赋值](#123-变量泄露向一个不存在的变量名赋值)
    - [1.3 引用在表达式连续运算中传递计算过程的信息](#13-引用在表达式连续运算中传递计算过程的信息)
    - [1.4 export](#14-export)
      - [1.4.1 解析 export](#141-解析-export)
      - [1.4.2 导出语句的处理逻辑](#142-导出语句的处理逻辑)
      - [1.4.3 导出名字和导出值的差异](#143-导出名字和导出值的差异)
      - [1.4.4 匿名函数表达式的执行结果](#144-匿名函数表达式的执行结果)
      - [1.4.5 知识补充](#145-知识补充)
    - [1.5 语句中的块级作用域](#15-语句中的块级作用域)
      - [1.5.1 块级作用域的特例](#151-块级作用域的特例)
      - [1.5.2 for 循环的代价](#152-for-循环的代价)
  - [二. JS 是如何运行的](#二-js-是如何运行的)
    - [2.1 中断语句](#21-中断语句)
      - [2.1.1 用中断（Break）代替跳转](#211-用中断break代替跳转)
      - [2.1.2 执行现场的回收](#212-执行现场的回收)
      - [2.1.3 语句执行的意义](#213-语句执行的意义)
      - [2.1.4 中断语句的特殊性](#214-中断语句的特殊性)
    - [2.2 JS 中特殊的可执行结构 - 模板](#22-js-中特殊的可执行结构---模板)

<!-- /code_chunk_output -->

**JS 是一门多范型语言，也称为混合范型语言**。JS 的简单来自于此，复杂也来自于此；生存能力来自于此，抨击诟病也来自于此。

JS 主要包括 5 个方面的语言特性：

- 结构化编程
- 面向对象编程
- 动态语言
- 函数式语言
- 并行语言

所谓的语言特性，其实是对语言的核心抽象概念的语法表现。

## 一. JS 是如何构建起来的

### 1.1 delete

早期的 JS 在推广时，仍然采用传统的数据类型的分类方法，也就是说，它宣称自己同时支持值类型和引用类型的数据，并且，所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。

JS 强行定义了 “Object 和 Function 就是引用类型”。对象和函数也就可以理解为：它们按引用来传递和使用。绝大多数情况下，这样解释起来是行得通的。但是到了 `delete` 运算这里，就不行。

因为这样一来，`delete 0` 就是删除一个值，而 `delete x` 就既可能是删除一个值，也可能是删除一个引用。然而，当时 JS 又同时约定：那些在 global 对象上声明的属性，就 “等同于” 全局变量。于是，这就带来了第三个问题：`delete x` 还可能是删除一个 global 对象上的属性。而它在执行这个操作的时候，看起来却像是一个全局变量。

`delete` 这个运算的表面意思，是该运算试图销毁某种东西。然而，`delete 0` 中的 0 是一个具体的、字面量表示的 “值”。一个字面量值 “0” 如何在现实世界中销毁呢？假定它销毁了，那是不是说，在这个语言当前的运行环境中，就不能使用 0 这个值了呢？显然，这不合理。所以，JS 认为 “**所有删除值的 delete 就直接返回 true**”，表明该行为过程中没有异常。

`delete` 出现的时代并没有结构化异常处理（即 try/catch 语句）。所以，通过函数调用中返回 true 来表明 “没有异常”，其实是很常规的做法。然而，返回值只表明执行过程中没有异常，但实际的执行行为是 “什么也没发生”。显然不可能真的将 “0” 从执行系统中清理出去。

那么接下来，就还剩下删除变量和删除属性。由于全局变量实际上是通过全局对象的属性来实现的，因此删除变量也就存在识别这两种行为的必要性。例如：

```js
delete x;
```

出于 JS 是动态语言这项特性，从根本上来说，是没有办法在语法分析期来判断 x 的性质的。所以现在，需要有一种方法在运行期来标识 x 的性质，以便进一步地处理它。这就导致了一种新的 “引用” 类型呼之欲出。

#### 1.1.1 delete 删除的是表达式的引用类型的结果

对于一门编译型语言来说，所谓 “0”，就是上面所述的一个值，它可以是基础值（Primitive values），也可以是数值类型。但如果将这个问题上升到编译之前的、所谓语法分析的阶段，那么 “0” 就会被称为一个记号（Tokens）。一个记号是没有语义的，记号既可以是语言能识别的，也可以是语言不能识别的。唯有把这二者同时纳入语言范畴，那么这个语言才能识别所谓的 “语法错误”。

`delete` 不仅仅是要操作 0 或 x 这样的单个记号或标识符（例如变量）。因为这个语法实际起作用的是一个对象的属性，也就是 “删除对象的成员”。那么它真正需要的语法其实是：

```js
delete obj.x;
```

只不过因为全局对象的成员可以用全局变量的形式来存取，所以它才能这样写：

```js
delete x;
```

所以，这正好将之前所认识的倒转过来，是删除 x 这个成员，而不是删除 x 这个值。不过有一点是没错的：既然没办法表达异常，而 delete 0 又不产生异常，那么它自然就该返回 true。

然而，如果理解了 `delete obj.x`，那么就一定会想到：`obj.x` 既不是引用类型，也不是值类型，它与 `typeof(x)` 识别的所有类型都无关。因为，它是一个表达式。所以，**delete 这个操作的正式语法设计并不是 “删除某个东西”，而是 “删除一个表达式的结果”**：

**表达式的结果**
**在 JS 中表达式是一个很独特的东西，所有一切表达式运算的终极目的都是为了得到一个值**。然后再用另外一些操作将这个值输出出来，例如变成网页中的一个元素（element）。这是 JS 语言创生的原力，也是它的基础设计。也只是因为有了这种设计，它才变得既像面向对象的，又像函数式语言的样子。

这个表达式得到的值，才是 delete 这个操作要删除的东西。在 JS 中，有两个东西可以被执行并存在执行结果：

- **语句**

  比如用 eval() 来执行一个字符串，那么实际上，执行的是一个语句，并返回了语句的值。

- **表达式**

  如果使用一对括号来强制一个表达式执行，那么这个括号运算得到的，就是这个表达式的值。表达式的值，在 ECMAScript 的规范中，称为 “引用”。这是一种称为 “规范类型” 的东西。

#### 1.1.2 规范中的引用

实际上这个概念出现得很早。从 JS 1.3 开始，ECMAScript 规范就在语言定义的层面，正式地将上述的天坑补起来，推出了 “（真正的）引用类型”。

但是，由于这个时候规范的影响力在开发人员中并不那么大，所以开发人员还是习惯性地将对象和函数称为引用，而其它类型就称为值，并且继续按照传统的理解来解释 JS 中对数据的处理。

这种情况下，一个引用只是在语法层面上表达 “它是对某种语法元素的引用”，而与在执行层面的值处理或引用处理没关系。所以，下面这行简短的语句：

```js
delete 0;
```

实际上是在说：JS 将 0 视为一个表达式，并尝试删除它的求值结果。所以，现在这里的 0，不是值类型的数据，而是一个表达式运算的结果。而在进一步的删除操作之前，JS 需要检测这个 Result 的类型：

- 如果它是值，则按照传统的 JS 的约定返回 true。
- 如果它是一个引用，那么对该引用进行分析，以决定如何操作。

ECMAScript 约定：任何表达式计算的结果要么是一个值，要么是一个引用。并且需要留意的是，在这个描述中，所谓对象，其实也是值。准确地说，是 “非引用类型”。例如：

```js
delete {};
```

那么显然，这里要删除的一对大括号是表示一个字面量的对象，当它被作为表达式执行的时候，结果也是一个值。这也是这类表达式被称为 “单值表达式” 的原因，这里并没有所谓的 “引用”。

可以这样，非常细致而准确地解释这一行代码：_单值表达式的运算结果返回那个 “对象字面量” 的单值。然后，delete 运算发现它的操作数是 “值/非引用类型”，就直接返回了 true。所以，什么也没有发生。_

在 JS 的内部，“引用” 是可以转换为 “值”，以便参与值运算的。因为表达式的本质是求值运算，所以引用是不能直接作为最终求值的操作数的。这依赖于一个非常核心的、称为 “GetValue()” 的**内部操作**。所谓内部操作，也称为内部抽象操作（internal abstract operations），是 ECMAScript 描述一个符合规范的引擎在具体实现时应当处理的那些行为。

**GetValue() 是从一个引用中取出值来的行为**。比如说下面这行代码：

```js
x = x;
```

上面的表达式其实是一个赋值表达式， “引用 x 赋值给引用 x” 其实这在语法层面来解释是非常直接的：

> 所有赋值操作的含义，是将右边的 “值”，赋给左边用于包含该值的 “引用”。

上面的 x=x，其实就是被翻译成：

```js
x = GetValue(x);
```

JS 识别两个 x 的不同的方法被称为**手性**，即是所谓 “左手端（lhs, left hand side）” 和 “右手端（rhs）”。它本来是用来描述自然语言的语法中，一个修饰词应该是放在它的主体的前面或是后面的。而在程序设计语言中，它用来说明一个记号（Token）是放在了赋值符号（例如 “=” 号）的左边或是右边。

> x 放在左边作为 lhs，它是引用。放在右边作为 rhs，就是值。

所以 x=x 的语义并不是 “x 赋给 x”，而是 “**把值 x 赋给引用 x**”。因此 “delete x” 归根到底，**是在删除一个表达式的、引用类型的结果**，而不是在删除 x 表达式，或者这个删除表达式的值。

在 JS 中的 delete 是一个很罕见的、能直接操作 “引用” 的语法元素。由于这里的 “引用” 是在 ECMAScript 规范层面的概念，因此在 JS 语言中能操作它的语法元素其实非常少。

#### 1.1.3 引用的作用

“属性存取运算符（.）” 返回一个关于 “x” 的引用，然后它可以作为下一个操作符（例如函数调用运算 “()”）的左手端来使用，这才有了著名的 “对象方法调用” 运算：

```js
obj.x();
```

因为在对象方法调用的时候，函数 x() 是来自于 obj.x 这个引用的，所以这个引用将 obj 这个对象传递给 x()，这才会让函数 x() 内部通过 this 来访问到 obj。

根本上来说，如果 obj.x 只是值，或者它作为右手端，那么它就不能 “携带” obj 这个对象，也就完成不了后续的方法调用操作。

> 对象存取 + 函数调用 = 方法调用

这是 JS 通过连续表达式运算来实现新的语义/语法的经典示例。而 “连续运算” 其实是函数式运算范式的基本原则。也就是说，obj.x() 是在 JS 中集合了 “引用规范类型操作” “函数式” “面向对象” 和 “动态语言” 等多种特性于一体的一个简单语法。

而它对语言的基础特性的依赖，就在于：

- delete 0 中的这个 0 是一个表达式求值
- delete x 中的 x 是一个引用
- delete obj.x 中 obj.x 是一组表达式连续运算的结果/引用

当 x 是全局对象 global 的属性时，所谓 delete x 其实只需要返回 global.x 这个引用就可以了。而当它不是全局对象 global 的属性时，那么就需要从当前环境中找到一个名为 x 的引用。找到这两种不同的引用的过程，称为 ResolveBinding；而这两种不同的 x，称为不同环境下绑定的标识符/名字。

### 1.2 声明语句与语法改变了 JS 语言核心性质

#### 1.2.1 声明

至今为止，除标签声明之外，JS 中一共只有六条声明用的语句。

> **注意**：所有真正被定义 “声明” 的语法结构都一定是 “语句”，并且都用于声明一个或多个标识符。这里的标识符包括变量、常量等。

严格意义上讲，JS 只有变量和常量两种标识符，六条声明语句中：

- `let x`：声明变量 x。不可在赋值之前读。
- `const x`：声明常量 x。不可写。
- `var x`：声明变量 x。在赋值之前可读取到 undefined 值。
- `function x`：声明变量 x。该变量指向一个函数。
- `class x`：声明变量 x。该变量指向一个类（该类的作用域内部是处理严格模式的）。
- `import x`：导入标识符并作为常量（有多种声明标识符的模式和方法）。

除了这六个语句之外，还有两个语句有潜在的声明标识符的能力，不过它们并不是严格意义上的声明语句（声明只是它们的语法效果）。这两个语句是指：

- `for (var|let|const x)`：for 语句有多种语法来声明一个或多个标识符，用作循环变量。
- `try … catch (x)`：catch 子句可以声明一个或多个标识符，用作异常对象变量。

声明是在语法分析阶段就处理的，并且因此它会使得当前代码上下文在正式执行之前就拥有了被声明的标识符，例如 x。

这其实非常有趣，因为这表明 **JS 虽然被称为是 “动态语言”，但确实是拥有静态语义的**。而在 JS 的早期，这个静态语义其实并没有处理得太好，一个典型的问题就是所谓的 “变量提升”。也就是可以在变量声明之前访问该变量。例如：

```js
console.log(x); // undefined
var x = 100;
console.log(x); // 100
```

由于标识符是在用户代码执行之前就已经由静态分析得到，并且创建在环境中，因此 let 声明的变量和 var 声明的变量在这一点上没有不同：它们都是在读取一个 “已经存在的” 标识符名。

在 ES6 之后出现的 let/const 变量在 “声明（和创建）一个标识符” 这件事上，与 var 并没有什么不同，只是 JS 拒绝访问还没有绑定值的 let/const 标识符而已。

ES6 之前：JS 是允许访问还没有绑定值的 var 所声明的标识符的。这种标识符后来统一约定称为 “**变量声明**（varDecls）”，而 “let/const” 则称为 “**词法声明**（lexicalDecls）”。JS 环境在创建一个 “变量名（varName in varDecls）” 后，会为它初始化绑定一个 undefined 值，而 “词法名字（lexicalNames）” 在创建之后就没有这项待遇，所以它们在缺省情况下就是 “还没有绑定值” 的标识符。

> 6 种声明语句中的函数是按变量声明的规则声明的；类的内部是处于严格模式中，它的名字是按 let 来处理的，而 import 导入的名字则是按 const 的规则来处理的。所以，**所有的声明本质上只有三种处理模式：var 变量声明、let 变量声明和 const 常量声明**。

#### 1.2.2 赋值

如果是在一门其它的（例如编译型的）语言中，“为变量 x 绑定一个初值” 就可能实现为 “在创建环境时将变量 x 指向一个特定的初始值”。这通常是静态语言的处理方法。JS 是门动态的语言，所以它的 “绑定初值” 的行为是通过动态的执行过程来实现的，也就是赋值操作。

在 JS 中，不是 `值 = 变量` 而是将右操作数（的值）赋给左操作数（的引用）：

```js
lRef = rValue;
```

它的严格语法表达是：

```txt
LeftHandSideExpression < = | AssignmentOperator >
AssignmentExpression
```

也就是说，在 JS 中，一个赋值表达式的左边和右边其实 “都是” 表达式。

#### 1.2.3 变量泄露：向一个不存在的变量名赋值

这是从 JS 1.0 开始就遗留下来的一个巨坑，也就是 “变量泄漏” 问题。这在早期的 JS 中的确是一个好用的特性：如果向一个不存在的变量名赋值，那么 JS 会在全局范围内创建它。

也就是说，代码中不需要显式地声明一个变量了，变量可以随用随声明，也不用像后来的 let 语句一样，还要考虑在声明语句之前能不能访问的问题了。这非常简单，在少量的代码中也相当易用。

但是，如果代码规模扩大，变成百千万行代码，那么 “一个全局变量是在哪里声明和创建的” 就变成一个非常要紧的问题。

如果随时都可能泄露一个代码给全局，或者随时都可能因为忘记本地的声明而读写了全局变量，那对调试除错将是一场灾难。另外，晚一些出现的运行期优化技术也不能很好地处理这种情况。所以从 ECMAScript5 开始的严格模式就禁止了这种特性，试图避免用户将变量泄露到全局环境。然而，即使在严格模式下这种漏露也未能避免，被称为 “**间接执行**”。

这种变量声明的发生是因为在早期设计中，JS 的全局环境是引擎使用一个称为 “**全局对象**” 东西管理起来的。

这个全局对象几乎类似或完全等同于一个普通对象。只不过，JS 引擎将全局的一些缺省对象、运行期环境的原生对象等东西都初始化在这个全局对象的属性中，并使用这个对象创建了一个称为 “**全局对象闭包**” 的东西，从而得到了 JS 的全局环境。

早期的 JS 的引擎实现非常简洁，许多基础的技术组件都是直接复用的，例如这里的所谓全局环境、全局闭包，或者全局对象的实现方法，就与 “with 语句” 的效果完全相同——他们是相互复用的。

当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此 JS 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了 “可以动态地向全局环境中添加一个变量”。并且，可以删除掉这个动态添加的 “变量”，因为本质上就是在删除全局对象的属性。

ES6 的全局环境为了兼容旧的 JS 语言设计，所以仍然是通过将全局对象初始化为这样的一个全局闭包来实现的。但是为了得到一个 “尽可能” 与其它变量环境相似的声明效果（varDecls），ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames），所有在静态语法分析期或在 eval() 中使用 var 声明的变量名就被放在这个列表中。然后约定，这个变量名列表中的变量是 “直接声明的变量”，不能使用 delete 删除。

于是，得到了这样的一种结果：

```js
// a 和 x 都是 global 的属性
var a = 100;
x = 200;

Object.getOwnPropertyDescriptor(global, 'a'); // { value: 100, writable: true, enumerable: true, configurable: false }
Object.getOwnPropertyDescriptor(global, 'x'); // { value: 200, writable: true, enumerable: true, configurable: true }

// a 不能删除，x 可以被删除
delete a; // false
delete x; // true

// 检查
console.log(a); // 100
console.log(x); // ReferenceError: x is not defined
```

所以，表面看起来 “泄漏到全局的变量” 与使用 var 声明的都是全局变量，并且都实现为 global 的属性，但事实上它们是不同的。并且当 var 声明发生在 eval() 中的时候，这一特性又还有所不同，例如：

```js
// 使用eval声明
eval('var b = 300');

// 它的性质是可删除的
Object.getOwnPropertyDescriptor(global, 'b').configurable; // true

// 检测与删除
b; // 300
delete b; // true
b; // ReferenceError: b is not defined
```

这种情况下使用 var 声明的变量名尽管也会添加到 varNames 列表，但它也可以从 varNames 中移除（这是唯一一种能从 varNames 中移除项的特例，而 lexicalNames 中的项是不可移除的）。

### 1.3 引用在表达式连续运算中传递计算过程的信息

JS 总是严格按照从左至右的顺序来计算表达式。

```js
w = x + y * z;
```

上面的代码中将首先计算子表达式 w，然后计算 x、y 和 z；然后，y 的值和 z 的值相乘，再加上 x 的值；最后将其赋值给表达式 w 所指代的变量或属性。

任何运算的操作数都是严格从左至右计算的，因此 x 先被处理，然后才会尝试对 y 和 z 求乘积。这里的 “x 先被处理” 是 JS 中的一个特异现象，即：**一切都是表达式，一切都是运算**。

这一现象在语言中是函数式的特性，类似 “一切被操作的对象都是函数求值的结果，一切操作都是函数”。

```js
var a = { n: 1 };
a.x = a = { n: 2 };
console.log(a.x); // undefined
```

上面代码中的第二行是两个连续赋值的表达式：

1. **a.x 总是最先被计算求值的**（从左至右）

   “a.x” 也是一个表达式，其结果是一个 “引用”。这个表达式 “a.x” 本身也要再计算它的左操作数，也就是 “a”。完整地讲，“a.x” 这个表达式的语义是：

   - 计算单值表达式 a，得到 a 的引用。
   - 将右侧的名字 x 理解为一个标识符，并作为 “.” 运算的右操作数。
   - 计算 “a.x” 表达式的结果。

   表达式 “a.x” 的计算结果是一个引用，因此通过这个引用保存了一些计算过程中的信息——例如它保存了 “a” 这个对象，以备后续操作中 “可能会” 作为 this 来使用。所以现在，在整行代码的表达式计算过程中，“a” 是作为一个**引用**被暂存下来了的。由第一行代码可知，这时保存在 “a.x” 这个引用中的 “a” 是当前的 “{n: 1}” 这个对象。

2. **再执行 `a =`**

   ```js
   var a = {n:1};
   a.x =     // <- `a` is {n:1}
         a = // <- `a` is {n:1}
   // ...
   ```

   这里的 “a = …” 中的 a 仍然是当前环境中的变量，与上一次暂存的值是相同的。

3. **第一次赋值**

   ```js
   // ...
   a.x = // <- `a` is {n:1}
     a =
       // <- `a` is {n:1}
       { n: 2 }; // 赋值，覆盖当前的左操作数（变量`a`）
   ```

   于是，左操作数 a 作为一个引用被覆盖了，这个引用仍然是当前上下文中的那个变量 a。因此，这里真实地发生了一次 `a = {n:2}`。

   但是，表达式最开始被保留在 “一个结果” 中的引用 a 不会更新。因为那是一个 “**运算结果**”，这个结果有且仅有引擎知道，它现在是一个引擎才理解的“**引用**（规范对象）”，对于它的可能操作只有：

   - 取值或置值（GetValue/PutValue）
   - 作为一个引用向别的地方传递等

4. **第二次赋值**

   现在，在整个语句行的最左侧 “空悬” 了一个已经求值过的 “a.x”。当它作为赋值表达式的左操作数时，它是一个被赋值的引用（这里是指将 a.x 的整体作为一个引用规范对象）。而它作为结果所保留的 “a”，可以从下面的代码看出来，是在被第一次赋值操作覆盖之前的、那个 “原始的变量 a”。

   ```js
   // 声明“原始的变量a”
   var a = { n: 1 };

   // 使它的属性表冻结（不能再添加属性）
   Object.freeze(a);

   try {
     a.x = a = { n: 2 };
   } catch (x) {
     // 异常发生，说明第二次赋值 “a.x = ...” 中操作的`a`正是原始的变量a
     console.log('第二次赋值导致异常.');
   }

   // 第一次赋值是成功的
   // a {n: 2}
   console.log(a.n); // 2
   ```

   而原始变量 a 在第一次赋值时被废弃了，所以第二次赋值是无意义的。最后 a 的值为 `{n: 2}`。

### 1.4 export

**ECMAScript 6 模块是静态装配的**，而传统的 Node.js 模块却是动态加载的。因而两种模块的实现效果与处理逻辑都大相径庭。

有且仅有六种[声明语法](#121-声明)，而本质上 export 也就只能导出这六种声明语法所声明的标识符，并且在导出时将它们统一称为 “名字”。

在语言设计中，所谓 “标识符” 与 “名字” 是有语义差别的，export 将之称为名字，就意味着这是一个标识符的子集。类似的其它子集也是存在的，例如 “保留字是标识符名，但不能用作标识符（A reserved word is an IdentifierName that cannot be used as an Identifier）”。

在 JS 语言的设计上，除了那些预设的标点符号（例如大括号、运算符之类），以及部分的保留字和关键字之外，事实上用户代码可以书写的只有三种东西。这包括：

- **标识符**：（通常是）一个**名字**。
- **字面量**：表明由它的字面含义所决定的一个**值**。
- **模板**：一个可计算结果的字符串**值**。

所以，如果在这个层面上解构一份 JS 代码，那么所能书写/声明的，就一定只有 “名字和值”。

这个结论是非常非常关键的。因为 export 事实上就只能导出 “名字和值”。然而一旦它能导出 “名字和值”，也就意味着它能导出一个模块中的 “全部内容”，因为如上所面所讲的：“名字和值” 正是所书写的代码的全部。

> 语言设计层面上来讲，代码就是文本，是没有应用逻辑的。而所写的代码绝大多数都是应用逻辑，当去除掉这些应用逻辑之后，那些剩下的死气沉沉的、纯粹的符号，才是语言层面的所谓 “代码文本”。去掉了执行逻辑所表达的那些行为、动作、结果和用户操作的代码，就是静态代码了。而事实上，ES6 中的模块就是用来理解程序中的那些静态代码的，也就是那些没有任何生气的字符和符号。因此它也就只能理解上面的 6 种声明，以及它们声明出来的那些 “名字和值”。

#### 1.4.1 解析 export

将所有 export 语法分类，其实也就只有两个大类。如下：

```js
// 导出 “（声明的）名字”
export <let/const/var> x ...;
export function x() ...
export class x ...
export {x, y, z, ...};

// 导出 “（重命名的）名字”
export { x as y, ...};
export { x as default, ... };

// 导出 “（其它模块的）名字”
export ... from ...;

// 导出 “值”
export default <expression>
```

对于最后这种形式，也就是 “（导出）值” 的形式，事实上是非常特殊的。因为如同在上面所讲过的，要导出一个模块的全部内容就必须导出 “（全部的）名字和值”，然而纯粹的值没有名字，于是也就没法访问了，所以这就与 “导出点什么东西” 的概念矛盾了。

因为这个东西要是没名字，也就连 “自己是什么” 都说不清楚，也就什么也不是了。

所以 ECMAScript 6 模块约定了一个称为 "default" 的名字，用于来导出当前模块中的一个 “值”。显然的，由于所谓 “值” 是表达式的运算结果，所以这里的语法形式就是：

```js
export default <expression>;
```

其中的 “expression” 就是用于求值的，以便得到一个结果（Result）并导出成为缺省的名字 “default”。这里有两个便利的情况：

- 在 JS 中，一般的字面量也是值、也是单值表达式，因此导出这样一个字面量也是合法的：

  ```js
  export default 2;  // as state of the module, etc.
  export default "some messages"; // data or information
  ```

- 因为 JS 中对象也是字面量、也是值、也是单值表达式。而对象成员可以组合其它任何数据，所以通过上述的语法几乎可以导出当前模块中全部的 “值”（亦即是任何可以导出的数据）。例如：

  ```js
  var varName = 100;
  export default {
    varName, // 直接导出名字
    propName: 123, // 导出值
    funcName: function () {}, // 导出函数
    foo() {
      // 或导出与主对象相关联的方法
      // method
    }
  };
  ```

所以，事实上 `export default ...` 虽然简单，却是对 “导出名字” 的非常必要的补充。这样一来，用户既可以导出那些有名字的数据，也可以导出那些没有名字的数据，即一个模块中所有的数据都可以被导出了。

#### 1.4.2 导出语句的处理逻辑

一个 export 可以理解为这样两个步骤：

1. 导出一个名字
2. 为上述名字绑定一个值

这两个步骤其实与使用 “var x = 100” 来声明一个变量的过程是一致的。因此以如下代码为例（六种声明在名字处理上是类似的）：

```js
export var x = 100;
```

在导出的时候，其实是先在 “某个名字表” 中登记一个 “名字 x” 就可以了。这个过程也就是 JS 在模块装载之前对 export 所做的全部工作。不过如果是从另一端（亦即是 import 语句）的角度看过来，那么就会多出来一个步骤。import 语句会（例如 import {x} from ...）：

1. （与 export 类似）按照语法在当前模块中声明名字，例如上面的 x。
2. 添加一个当前模块对目标模块的依赖项。

有了上述的第二步操作，JS 就可以依据所有它能在静态文本中发现的 import 语句来形成模块依赖树，最后就可以找到这个模块依赖树最顶端的根模块，并尝试加载。

所以关键的是，在 “模块 export/import” 语法中，JS 是依赖 import 来形成依赖树的，与 export 无关。但是直到目前为止（意思是直到找到所有导入和导出的名字，并完成所有模块的装配的现在为止），没有任何一行用户的 JS 代码是被执行过的。至于原因，就是上面讲的：export/import 过程中，源代码只被理解为静态的、没有逻辑的 “代码文本”。那么既然 “没有逻辑”，就不可能执行类似于 `export default <expression>` 中的 expression。表达式就是程序的计算逻辑。

**在处理 export/import 语句的全程，没有表达式被执行**。

#### 1.4.3 导出名字和导出值的差异

```js
export default <expression>;
```

既然其中的 “expression” 在导入导出中完全不起作用（不执行），那么这行语句又能做什么呢？事实上，这行语句与直接 “导出一个名字” 并没有任何区别。它与这样的语法相同：

```js
export var x = 100;
```

它们都只是导出一个名字，只是前者导出的是 “default” 这个特殊名字，而后者导出的是一个变量名 “x”。它们都是确定的、符合语法规则的标识符，也可以表示为一个字符串的字面文本。它们的作用也完全一致：就是在前面所说的 “某个名字表” 中添加 “一个登记项” 而已。

所以，导出名字与导出值本质上并没有差异，在静态装配的阶段，它们都只是表达为一个名字而已。

然后，也正是如同 `var x = 100;` 在执行阶段需要有一个将 “值 100” 绑定给 “变量 x（的引用）” 的过程一样，这个 `export default ...;` 语句也需要有完全相同的一个过程来将它后面的表达式（expression）的结果绑定给 “default” 这个名字。如果不这么做，那么 “export default” 在语义上的就无法实现导出名字 “default” 了——在静态装配阶段，名字 “default” 只是被初始化为一个 “单次绑定的、未初始化的标识符”。

所以现在就可以在语义上模拟这样一个过程，即：

```js
export default function() {}

// 类似于如下代码
//（但并不在当前模块中声明名字 "default"）
export var default = function() {}
```

可以进一步地模拟 JS 后续的装配过程。这个过程其实非常简单：

- 找到并遍历模块依赖树的所有模块（这个树是排序的），然后
- 执行这些模块最顶层的代码（Top Level Module Evaluation）。

在执行到上述 var default ....（或类似对应的 export default ...）语句时，执行后面的表达式，并将执行结果（Result）绑定给左侧的那个变量就可以了。如此，直到所有模块的顶层代码都执行完毕，那么所有的导出名字和它们的值也都必然是绑定完成了的。

同样，由于 import 的名字与 export 的名字只是一个映射关系，所以 import 的名字（所对应的值）也就初始化完成了。

**所谓模块的装配过程，就是执行一次顶层代码而已**。

#### 1.4.4 匿名函数表达式的执行结果

function() {} 这个匿名函数表达式，按照 JS 的约定，可以理解为一个函数的 “字面量（值）”。理解 “字面量值” 这个说法是很有意义的，因为它意味着它没有名字。

“字面量（值）没有名字” 就意味着执行这个 “单值表达式” 不会在当前作用域中产生一个名字，即使这个函数是具名的，也必然是如此。所以，这才带来了 JS 中的经典示例，即：**具名函数作为表达式时，名字在块级作用域中无意义**。例如：

```js
// 具名函数作为表达式
var x1 = function x2() {
  // ...
};

// 具名函数（声明）
function x3() {
  // ...
}
```

上面的例子中，x1~3 都是具有不同的语义的。其中，x2 是不会在当前作用域（示例中是全局）中登记为名字。而使用下面的语法：

```js
export default function() { }
export default function x() { }
```

导出一个匿名函数，或者一个具名的函数的时候，这两种情况下是不同的。但无论它是否具名，它们都是不可能在当前作用域中绑定给 default 这个名字，作为这个名字对应的值的。

这段处理逻辑被添加在语法：ExportDeclaration: export default AnonymousFunctionDefinition;

> ECMAScript 是将这里导出的对象称为 _Expression_/AssignmentExpression，这里所谓 _AnonymousFunctionDefinition_ 则是其中 _AssignmentExpression_ 的一个具体实例。

的执行（Evaluation）处理过程中。也就是说当执行这行声明时，如果后面的表达式是匿名函数声明，那么它将强制在当前作用域中登记为 “default” 这样一个特殊的名字，并且在执行时绑定该匿名函数。所以，尽管语义上需要将它登记为类似 var default ...所声明的名字 “default”，但事实上它被处理成了一个不可访问的中间名字，然后影射给该模块的 “某个名字表”。

> **注意**：这是一个**匿名函数定义**（AnonymousFunctionDefinition），而不是一个匿名函数表达式（Anonymous FunctionExpression）。一般函数的语句则被称为声明（或更严谨地称为宣告，Function Declarations）。而所谓匿名函数定义，其本身是表述为：`aName = FunctionExpression`。
> 或类似于此的语法风格的。它可以用在一般的赋值表达式、变量声明的右操作数，以及对象声明的成员初始值等等位置。在这些位置上，该函数表达式总是被关联给一个名字。一方面，这种关联不是严格意义上的 “名字 -> 值” 的绑定语义；另一方面，当该函数关联给名字（aName）时，JS 又会反向地处理该函数（作为对象 f）的属性 f.name，使该名字指向 aName。

所以，“export default function() {}”，在严格意义上来说：**它并不是导出了一个匿名函数表达式，而是导出了一个匿名函数定义**（Anonymous Function Definition）。

因此，该匿名函数初始化时才会绑定给它左侧的名字 “default”，这会导致 import f from ... 之后访问 f.name 值会得到 “default” 这个名字。

#### 1.4.5 知识补充

关于 export 还有一些补充的知识点：

- export ... 语句通常是按它的词法声明来创建的标识符的，例如 `export var x = ...` 就意味着在当前模块环境中创建的是一个变量，并可以修改等等。但是当它被导入时，在 import 语句所在的模块中却是一个常量，因此总是不可写的。这是因为导出项（的名字）总是作为词法声明被声明在当前模块作用域中的，这意味着它不可删除，且不可重复导出。亦即是说即使是用 var x ... 来声明，这个 x 也是在 _lexicalNames_ 中，而不是在 _varNames_ 中。

- 由于 export default ... 没有显式地约定名字 “default” 应该按 let/const/var 的哪一种来创建，因此 JS 默认将它创建成一个普通的变量（var），但即使是在当前模块环境中，它事实上也是不可写的，因为无法访问一个命名为 “default” 的变量——它不是一个合法的标识符。

- 所谓匿名函数，仅仅是当它直接作为操作数（而不是具有上述 “匿名函数定义” 的语法结构）时，才是真正匿名的，例如：

  ```js
  console.log(function () {}.name); // ""
  ```

- 由于类表达式（包括匿名类表达式）在本质上就是函数，因此它作为 default 导出时的性质与上面是一致的。

- 所谓 “某个名字表”，对于 export 来说是模块的导出表，对于 import 来说就是名字空间（名字空间是用户代码可以操作的组件，它映射自内部的模块导入名字表）。不过，如果用户代码不使用 “import \* as …” 的语法来创建这个名字空间，那么该名字表就只存在于 JS 的词法分析过程中，而不会（或并不必要）创建它在运行期的实例。这也是一直用 “某个名字表” 来称呼它的原因，它并不总是以实体形式存在的。

- 上述名字表简化了 ECMAScript 中对导入导出记录（ImportEntry/ExportEntry Record Fields）的理解。因此如果试图了解更多，建议阅读 ECMAScript 的具体章节。

- 没有模块会导出（传统意义上的）main()，因为 ECMAScript 为了维护模块的静态语义，而把执行过程及其入口的定义丢回给了引擎或宿主本身。

### 1.5 语句中的块级作用域

语句，是 JS 中组织代码的基础语法组件，包括函数声明等等在内的六种声明，其实都被归为 “语句” 的范畴。因此，如果将一份 JS 代码中的所有语句抽离掉，那么大概就只会剩下为数不多的、在全局范围内执行的表达式了。所以，理解 “语句” 在 JS 中的语义是重中之重。

尽管如此，实际上要了解的也无非是**顺序**、**分支**、**循环**这三种执行逻辑而已，相比于它们，其它语句在语义上的复杂性通常不值一提。而这三种逻辑中尤其复杂的就是循环。

在 ECMAScript 6 之后，JS 实现了块级作用域。但从语言设计的原则上来看，越少作用域的执行环境调度效率也就越高，执行时的性能也就越好。因此**绝大多数 JS 语句都并没有自己的块级作用域**。

基于这个原则，switch 语句被设计为有且仅有一个作用域，无论它有多少个 case 语句，其实都是运行在一个块级作用域环境中的。例如：

```js
var x = 100,
  c = 'a';
switch (c) {
  case 'a':
    console.log(x); // Uncaught ReferenceError: Cannot access 'x' before initialization
    break;
  case 'b':
    let x = 200;
    break;
}
```

在这个例子中，switch 语句内是无法访问到外部变量 x 的，即便声明变量 x 的分支 `case 'b'` 永远都执行不到。这是因为所有分支都处在同一个块级作用域中，所以任意分支的声明都会给该作用域添加这个标识符，从而覆盖了全局的变量 x。

一些简单的、显而易见的块级作用域包括：

```js
//** try/catch/finally **/
try {
  // 作用域1
} catch (e) {
  // 表达式 e 位于作用域2
  // 作用域2
} finally {
  // 作用域3
}

/** with 这里没有使用大括号 **/
with (x /* 作用域1 */); // 这里存在一个块级作用域

/** 块语句 **/
{
  // 作用域1
}
// if/else 中的 “块级作用域” 都是一对大括号表示的 “块语句” 自带的，与 if 语句本身无关。
if() {};
if (x) {}
else {};
```

除了这三个语句和一个循环语句 `for (<let/const>...) ...` 以及相同设计的：

- `for await (<let/const> x of ...) ...`
- `for (<let/const> x ... in ...) ...`
- `for (<let/const> x ... of ...) ...`

除了上面四种语句，所有其它的语句都是没有块级作用域的。并且可以看到上面的 for 循环语句中没有列出 `var` 关键字。

#### 1.5.1 块级作用域的特例

`for (<let/const>...) ...` 所有在语句内可以存在的东西只有四种：

- 表达式
- 其它语句
- 标识符声明（取决于声明语句或其它的隐式声明的方式）
- 特殊的语法元素，称为 “标签”。

所谓 “块级作用域”，本质上只包括一组标识符。因此，只有当存在潜在标识符冲突的时候，才有必要新添加一个作用域来管理它们。例如函数，由于函数存在 “重新进入” 的问题，所以它必须有一个作用域来管理 “重新进入之前” 的那些标识符。这个就是**闭包**。

在语言设计时，有三种需求会促使语句构建自己的作用域：

- 标识符管理
- 在语法上支持多语句（例如 try/catch/finally）
- 语句所表达的语义要求有一个块，例如 “{ }” 在语义上就要求它自己是一个块级作用域。

所以 _标签_、 _表达式_ 和 _其它语句_ 这三种东西都不需要使用一个 “独立作用域” 去管理起来。所谓 “其它语句” 当然存在这种冲突，不过显然这种情况下它们也应该自己管理这个作用域。所以，对于当前语句来说，就只需要考虑剩下的唯一一种情况，就是在 “语句中包含了标识符声明” 的情况下，需要创建块级作用域来管理这些声明出来的标识符。

在所有六种声明语句之外，只剩下 for 循环语句能在它的语法中去做这样的标识符声明。所以，它就成了块级作用域的这个唯一特例。

var 声明是特例中的特例。这一特性来自于 JS 远古时代的作用域设计。在早期的 JS 中，并没有所谓的块级作用域，那个时候的作用域设计只有 “函数内” 和 “函数外” 两种，如果一个标识符不在任何（可以多层嵌套的）函数内的话，那么它就一定是在 “全局作用域” 里。

而在这个时代，变量也就只有 var 声明的变量。由于作用域只有上面两个，所以任何一个 var 声明的标识符，要么是在函数内的，要么就是在全局的，没有例外。

按照这个早期设计，`for (var x = ...)` 这个语句中的变量 x，是不应该出现在 “for 语句所在的” 块级作用域中的。它应该出现其外层的某个函数作用域，或者全局作用域中。这种越过当前语法范围，而在更外围的作用域中登记名字行为就称为 “**提升**（Hoisting/Hoistable）”。

ECMAScript 6 在添加块级作用域特性时充分考虑了对旧有语法的兼容，因此当上述语法中出现 var 声明 时，它所声明的标识符是与该语句的块级作用域无关的。在 ECMAScript 中，这是两套标识符体系，也是使用两套作用域来管理的：

- 所有 var 声明和函数声明的标识符都登记为 varNames，使用 “**变量作用域**” 管理
- 其它情况下的标识符/变量声明，都作为 lexicalNames 登记，使用 “**词法作用域**” 管理。

所以，`for (<const/let> x ...) ...` 语法中的标识符 x 是一个词法名字，应该由 for 语句为它创建一个（块级的）词法作用域来管理。接下来，分析一下 for 语句中有几个作用域：

首先，必须要拥有至少一个块级作用域。这是出于管理标识符的必要性。下面的示例简单说明这个块级作用域的影响：

```js
var x = 100;
for (let x = 102; x < 105; x++) console.log('value:', x); // 显示 “value: 102~104”
console.log('outer:', x); // 显示 “outer: 100”
```

因为 for 语句的这个块级作用域的存在，导致循环体内访问了一个局部的 x 值（循环变量），而外部的变量 x 是不受影响的。

那么在循环体内是否需要一个新的块级作用域呢？这取决于在语言设计上是否支持如下代码：

```js
for (let x = 102; x < 105; x++)
  let x = 200;
```

也就是说，如果循环体（单个语句）允许支持新的变量声明，那么为了避免它影响到循环变量，就必须为它再提供另一个块级作用域。在这里，**JS 不允许声明新的变量**。上述的示例会抛出一个异常：“SyntaxError: Lexical declaration cannot appear in a single-statement context”。

这个语法错误并不常见，因为很少有人会尝试构建这样的特殊代码。然而事实上，它是一个普遍存在的语法禁例，例如以下语句语法：

```js

// if 语句中的禁例
if (false) let x = 100;

// while 语句中的禁例
while (false) let x = 200;

// with 语句中的禁例
with (0) let x = 300
```

所以，现在可以确定：**循环语句（对于支持 “let/const” 的 for 语句来说）“通常情况下” 只支持一个块级作用域**。

但是如果在 for 语句支持了 let/const 的情况下，仅仅只有一个块级作用域是不方便的。例如：

```js
for (let i in x)
  /* 代码 */
```

在这个例子中，“let i ...” 在语义上需要被执行多次——因为在静态结构中它的多次迭代都作用于同一个语法元素。而 let 语句的变量不能重复声明的。所以，这里就存在了一个冲突：“let/const” 语句的单次声明（不可覆盖）的设计，与迭代多次执行的现实逻辑矛盾了。

这个矛盾的起点，就是 “只有一个块级作用域”。所以，在 JS 引擎实现 “支持 let/const 的 for 语句” 时，就在这个地方做了特殊处理：为循环体增加一个作用域。

这样一来，“let i” 就可以只执行一次，然后将 “i in x” 放在每个迭代中来执行，这样避免了与 “let/const” 的设计冲突。然而，这个问题到了具体的运行环境中，变量又有些不同了。

#### 1.5.2 for 循环的代价

在 JS 的具体执行过程中，作用域是被作为环境的上下文来创建的。如果将 for 语句的块级作用域称为 **forEnv**，将为循环体增加的作用域称为 **loopEnv**，那么 loopEnv 它的外部环境就指向 forEnv。

于是在 loopEnv 看来，变量 i 其实是登记在父级作用域 forEnv 中，并且 loopEnv 只能访问变量 i，在本质上就是通过环境链回溯来查找标识符（Resolve identifier, or Get Identifier Reference）。

但是如果是下面这种情况。例如：

```js
for (let i in x) setTimeout(() => console.log(i), 1000);
```

这个例子创建了一些定时器。当定时器被触发时，函数会通过它的闭包（这些闭包处于 loopEnv 的子级环境中）来回溯，并试图再次找到那个标识符 i。然而，当定时器触发时，整个 for 迭代有可能都已经结束了。这种情况下，要么上面的 forEnv 已经没有了、被销毁了，要么它即使存在，那个 i 的值也已经变成了最后一次迭代的终值。

所以，要想使上面的代码符合预期，这个 loopEnv 就必须是 “随每次迭代变化的”。也就是说，需要为每次迭代都创建一个新的作用域副本，这称为**迭代环境**（iterationEnv）。因此，每次迭代在实际上都并不是运行在 loopEnv 中，而是运行在该次迭代自有的 iterationEnv 中。

也就是说，在语法上这里只需要两个 “块级作用域”，而实际运行时却需要为其中的第二个块级作用域创建无数个副本。这就是 for 语句中使用 “let/const” 这种块级作用域声明所需要付出的代价。

## 二. JS 是如何运行的

### 2.1 中断语句

#### 2.1.1 用中断（Break）代替跳转

在 Basic 语言还很流行的时代，许多语言的设计中都会让程序代码支持带地址的 “语句”。例如，Basic 就为每行代码提供一个标号，可以把它叫做 “**行号**”，但它又不是绝对物理的行号，通常为了增减程序的方便，会使用 “1，10，20…...” 等等这样的间隔。如果想在第 10 行后追加 1 行，就可以将它的行号命名为 “11”。

行号是一种很有历史的程序逻辑控制技术，更早一些可以追溯到汇编语言，或可以手写机器代码的时代。那时由于程序装入位置被标定成内存的指定位置，所以这个位置也通常就是个地址偏移量，可以用数字化或符号化的形式来表达。所有这些 “为代码语句标示一个位置” 的做法，其根本目的都是**为了实现 “GOTO 跳转”**，任何时候都可以通过 “GOTO 标号” 的语法来转移执行流程。

然而，这种黑科技在 20 世纪的 60~70 年代就已经普遍地被先辈们批判过了。这样的编程方式只会大大地降低程序的可维护性，其正确性或正确性验证都难以保障。所以，半个多世纪之前开始的 **“结构化” 运动**一直影响至今，包括现在 JS，都是 “结构化程序设计” 思想的产物。

简单地说：JS 中没有 GOTO 语句了。取而代之的，是**分块代码**，以及**基于代码分块的流程控制技术**。这些控制逻辑基于一个简单而明了的原则：如果代码分块中需要 GOTO 的逻辑，那么就为它设计一个 “自己的 GOTO”。这样一来，所有的 GOTO 都是 “块（或块所在语句）自己知道的”。这使得程序可以在 “自己知情的前提下自由地 GOTO”。

然而，问题是那些 “标号” 或 “程序地址” 之类的东西已经被没有了，因此人们想出两种方法来解决：

- **约定 “可以通过 GOTO 到达的位置”**

  在这种情况下，JS 将 GOTO 的 “离开某个语句” 这一行为理解为 “_中断（Break）该语句的执行_”。由于这个中断行为是明确针对于该语句的，所以 “GOTO 到达的位置” 也就可以毫无分歧地约定为该语句（作为代码块）的结束位置。这是 “break” 作为子句的由来。它用在某些 “_可中断语句_（BreakableStatement）” 的内部，用于中断并将程序流程 “跳转（GOTO）到语句的结束位置”。在语法上，这表示为**该语法只作用于对 “可中断语句” 的中断**。

  “可中断语句” 其实只有两种：

  - 全部的循环语句
  - switch 语句

  在这两种语句内部使用的 “break;”，采用的就是这种处理机制——**中断当前语句，将执行逻辑交给下一语句**。

- **可以中断 “任意的标签化语句”**

  所谓标签化语句，就是在一般语句之前加上 `xxx:` 这样的标签，用以指示该语句：

  ```js
  // 标签 aaa
  aaa: {
    // ...
  }

  // 标符 bbb
  bbb: if (true) {
    // ...
  }
  ```

  在标签 aaa 中，显然 aaa 指示的是后续的 “块语句” 的块级作用域；而在标签 bbb 中，if 语句是没有块级作用域的，那么 bbb 到底指示的是 “if 语句” 还是其后的 “块语句” 呢？

  这个问题本质上是在 “块级作用域” 与 “标签作用的（语句）范围” 之间撕裂了一条鸿沟。由于标签 bbb 在语义上只是要 “标识其后的一行语句”，因此这种指示是与 “块级作用域（或词法环境）” 没有关系的。简单地说，**标签化语句理解的是 “位置”，而不是 “（语句在执行环境中的）范围”**。

  因此，中断这种标签化语句的 “break” 的语法，也是显式地用 “标签” 来标示位置的。例如：

  ```js
  // 在 if 语句的两个分支中都可以使用 break;
  // （在分支中深层嵌套的语句中也是可以使用 break 的）
  aaa: if (true) {
    // ...
  } else {
    // ...
    break aaa;
  }

  // 在 try/catch/finally 中也可以使用 break;
  bbb: try {
    // ...
  } finally {
    break bbb;
  }
  ```

#### 2.1.2 执行现场的回收

break 将 “语句的‘代码块’” 理解为**位置**，而不是理解为作用域/环境，这是非常重要的前设。然而，程序代码中的 “位置” 已经被先辈们干掉了。他们用了半个世纪来证明了一件事情：**想要更好、更稳定和更可读的代码，那么就忘掉“（程序的）位置”这个东西吧！**

通过 “作用域” 来管理代码的确很好，但是作用域与 “语句的位置” 以及 “GOTO 到新的程序执行” 这样的理念是矛盾的。它们并不在同一个语义系统内，这也是**标签**与**变量**可以重名而不相互影响的根本原因。由于这个原因，在使用标签的代码上下文中，执行现场的回收就与传统的 “块” 以及 “块级作用域” 根本上不同。

JS 的执行机制包括 “执行权” 和 “数据资源” 两个部分，分别映射可计算系统中的 “逻辑” 与 “数据”。而块级作用域（也称为词法作用域）以及其他的作用域本质上就是一帧数据，以保存执行现场的一个瞬时状态（也就是每一个执行步骤后的现场快照）。而 JS 的运行环境被描述为一个后入先出的栈，这个栈顶永远就是当前 “执行权” 的所有者持用的那一帧数据，也就是代码活动的现场。

JS 的运行环境通过函数的 CALL/RETURN 来模拟上述 “数据帧” 在栈上的入栈与出栈过程。任何一次函数的调用，即是向栈顶压入该函数的上下文环境（也就是作用域、数据帧等等，它们在不同场合下的相同概念）。所以，包括那些在全局或模块全局中执行的代码，以及 Promise 中执行调度的那些内部处理，所有的这些 JS 内部过程或外部程序都统一地被封装成函数，通过 CALL/RETURN 来激活、挂起。

所以，“作用域”就是在上述过程中被操作的一个对象。

- 作用域退出，就是函数 RETURN。
- 作用域挂起，就是执行权的转移。
- 作用域的创建，就是一个闭包的初始化。
- ……

然而如之前所说的，“break labelName;” 这一语法独立于 “执行过程” 的体系，它表达一个位置的跳转，而不是一个数据帧在栈上的进出栈。这是 labelName 独立于标识符体系（也就是词法环境）所带来的附加收益。基于对 “语句” 的不同理解，JS 设计了一种全新方法，用来清除这个跳转所带来的影响（也就是回收跳转之前的资源分配）。而这多余出来的设计，其实也是上述收益所需要付出的代价。

#### 2.1.3 语句执行的意义

对于语句的跳转来说，“离开语句” 意味着清除语句所持有的一切资源，如同函数退出时回收闭包。但是，这也同样意味着 “语句” 中发生的一切都消失了，对于函数来说，return 和 yield 是唯二从这个现场发出信息的方式。那么语句呢？语句的执行现场从这个“程序逻辑的世界”中湮灭之后，又留下了什么呢？

语句执行与函数执行并不一样。函数是求值，所以返回的是对该函数求值的结果（Result），该结果或是值（Value），或是结果的引用（Reference）。而语句是命令，语句执行的返回结果是该命令得以完成的状态（Completion, Completion Record Specification Type）。

> **注意**：JS 是一门混合了函数式与命令式范型的语言，而这里对函数和语句的不同处理，正是两种语言范型根本上的不同抽象模型带来的差异。

在 ECMAScript 规范层面，本质上所有 JS 的执行都是语句执行（这很大程度上解释了为什么 eval 是执行语句）。因此，ECMAScript 规范中对执行的描述都称为 “运行期语义（Runtime Semantics）”，它描述一个 JS 内部的行为或者用户逻辑的行为的过程与结果。也就是说这些运行期语义都最终会以一个完成状态（Completion）来返回。例如：

- **一个函数的调用**：调用函数——执行函数体（EvaluateBody）并得到它的 “完成” 结果（result）。
- **一个块语句的执行**：执行块中的每行语句，得到它们的 “完成” 结果（result）。

这些结果（result）包括的状态有五种，称为完成的类型，可以分为以下两类：

- 包含了有效的、可用于计算的数据值（Value）：

  - 正常完成（normal）
  - 一个函数调用的返回（return）

- 是一个不可（像数据那样）用于计算或传递的纯粹状态：

  - 循环过程中的继续下次迭代（continue）
  - 中断（break）
  - 异常（throw）

所以当运行期出现了一这个称为 “中断（break）” 的状态时，JS 引擎需要找到这个 “break” 标示的目标位置（result.Target），然后与当前语句的标签（如果有的话）对比：

- 如果一样，则取 break 源位置的语句执行结果为值（Value）并以正常完成状态返回
- 如果不一样，则继续返回 break 状态

这与函数调用的过程有一点类似之处：由于对 “break 状态” 的拦截交给语句退出（完成）之后的下一个语句，因此如果语句是嵌套的，那么其后续（也就是外层的）语句就可以得到处理这个 “break 状态” 的机会。举例来说：

```js
console.log(
  eval(`
  aaa: {
    1+2;
    bbb: {
     3+4;
     break aaa;
    }
  }
`)
); // 输出值：7
```

在这个示例中，“break aaa” 语句是发生于 bbb 标签所示块中的。但当这个中断发生时：

- 标签化语句 bbb 将首先捕获到这个语句完成状态，并携带有标签 aaa。
- 由于 bbb 语句完成时检查到的状态中的中断目标（Target）与自己的标签不同，所以它将这个状态继续作为自己的完成状态，返回给外层的 aaa 标签化语句 aaa。
- 语句 aaa 得到上述状态，并对比标签成功，返回结果为语句 3+4 的值（作为完成状态传出）。

所以，语句执行总是返回它的完成状态，且如果这个完成状态是包含值（Value）的话，那么它是可以作为 JS 代码可访问的数据来使用的。例如，如果该语句被作为 eval() 来执行，那么它就是 eval() 函数返回的值。

#### 2.1.4 中断语句的特殊性

```js
x: break x;
```

这行语句有两个特殊之处：

- 它是最小化的 break 语句的用法，不可能写出更短的代码了。
- 这种所谓 “不会对其他任何代码构成任何影响” 的语句，也是 JS 中的特有设计。

首先，由于 “标签化语句” 必须作用于 “一个” 语句，而语句理论上的最小化形式是 “空语句”。但是将空语句作为 break 的目标标签语句是不可能的，因为还必须在标签语句所示的语句范围内使用 break 来中断。空语句以及其他一些单语句是没有这样的语句范围的，因此最小化的示例就只能是对 break 语句自身的中断。

其次，语句的返回与函数的返回有相似性。例如，函数可以不返回任何东西给外部，这种情况下外部代码得到的函数出口信息会是 undefined 值。

由于典型的函数式语言的 “函数” 应该是没有副作用的，所以这意味着该函数的执行过程不影响任何其他逻辑——也不在这个 “程序逻辑的世界” 中留下任何的状态。事实上，还可以用 “void” 运算符来阻止一个函数返回的值影响它的外部世界。函数是 “表达式运算” 这个体系中的，因此用一个运算符来限制它的逻辑，这很合理。

虽然 “break labelName” 的中止过程是可以传出 “最后执行语句” 的状态的，但是这个过程存在一个悖论：**任何被 break 的代码上下文中，最后执行语句必然会是 “break 语句” 本身**。所以，如果要在这个逻辑中实现 “语句执行状态” 的传递，那么就必须确保：

- “break 语句” 不返回任何值（ECMAScript 内部约定用 “Empty” 值来表示）
- 上述 “不返回任何值” 的语句，也不会影响任何语句的既有返回值。

所以，事实上已经探究了 **“break 语句” 返回值的两个关键特性**的由来：

- 它的类型必然是 “break”
- 它的返回值必然是 “空（Empty）”

对于 Empty 值，在 ECMAScript 中约定：**在多行语句执行时它可以被其他非 Empty 值更新（UpdateEmpty），而 Empty 不可以覆盖其他任何值**。这就是空语句等也同样 “不会对其他任何代码构成任何影响” 的原因了。

### 2.2 JS 中特殊的可执行结构 - 模板
