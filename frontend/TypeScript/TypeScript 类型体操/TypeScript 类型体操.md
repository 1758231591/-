# TypeScript 类型体操

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

## 一. 类型系统

静态类型编程语言都有自己的类型系统，从简单到复杂可以分为 3 类：

- **简单类型系统**

  变量、函数、类等都可以声明类型，编译器会基于声明的类型做类型检查，类型不匹配时会报错。这是最基础的类型系统，能保证类型安全，但有些死板。比如一个 add 函数既可以做整数加法、又可以做浮点数加法，却需要声明两个函数：

  ```c++
  int add(int a, int b) {
    return a + b;
  }

  double add(double a, double b) {
      return a + b;
  }
  ```

  这个问题的解决思路很容易想到：如果类型能传参数就好了，传入 int 就是整数加法，传入 double 就是浮点数加法。所以，就有了第二种类型系统。

- **支持泛型的类型系统**

  泛型的英文是 Generic Type，通用的类型，它可以代表任何一种类型，也叫做**类型参数**。

  它给类型系统增加了一些灵活性，在整体比较固定，部分变量的类型有变化的情况下，可以减少很多重复代码。比如上面的 add 函数，有了泛型之后就可以这样写：

  ```c++
  T add<T>(T a, T b) {
    return a + b;
  }

  add(1, 2);
  add(1.111, 2.2222);
  ```

  声明时把会变化的类型声明成泛型，在调用的时候再确定类型。Java 就是这种类型系统。这确实是一个很好的增加类型系统灵活性的特性。

  但是，这种类型系统的灵活性对于 JS 来说还不够，因为 JS 太过灵活了。比如，在 Java 里，对象都是由类 new 出来的，不能凭空创建对象，但是 JS 却可以，它支持对象字面量。

- **支持类型编程的类型系统**

  **对传入的类型参数（泛型）做各种逻辑运算，产生新的类型，这就是类型编程**。

  ```ts
  function getPropValue<T extends object, Key extends keyof T>(obj: T, key: Key): T[Key] {
    return obj[key];
  }
  ```

  这里的 keyof T、`T extends object` 就是对类型参数 T 的类型运算。TypeScript 的类型系统就是第三种，支持对类型参数做各种逻辑处理，可以写很复杂的类型逻辑。

  TypeScript 的类型系统是**图灵完备**的，也就是能描述各种可计算逻辑。简单点来理解就是循环、条件等各种 JS 里面有的语法它都有，JS 能写的逻辑它都能写。
