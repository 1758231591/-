# Vue 设计与实现

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

## 一. 框架设计概览

### 1.1 权衡的艺术

框架设计里到处都体现了权衡的艺术。

#### 1.1.1 命令式和声明式

从范式上来看，视图层框架通常分为：

- **命令式**

  早年间流行的 jQuery 就是典型的命令式框架。命令式框架的一大特点就是**关注过程**。例如，把下面这段话翻译成对应的代码：

  ```txt
  获取 id 为 app 的 div 标签
  它的文本内容为 hello world
  为其绑定点击事件
  当点击时弹出提示：ok
  ```

  对应的代码为：

  ```js
  $('#app') // 获取 div
    .text('hello world') // 设置文本内容
    .on('click', () => {
      alert('ok');
    }); // 绑定点击事件
  ```

  可以看到，自然语言描述能够与代码产生一一对应的关系，代码本身描述的是 “做事的过程”，这符合逻辑直觉。

- **声明式**

  声明式框架更加**关注结果**。

  ```html
  <div @click="() => alert('ok')">hello world</div>
  ```

  这段类 HTML 的模板就是 Vue.js 实现如上功能的方式。可以看到，提供的是一个 “结果”，至于如何实现这个 “结果”，则是由 Vue.js 完成的。换句话说，Vue.js 封装了过程。因此，Vue.js 的内部实现一定是命令式的，而暴露给用户的却更加声明式。

它们各有优缺点。作为框架设计者，应该对两种范式都有足够的认知，这样才能做出正确的选择，甚至想办法汲取两者的优点并将其捏合。

#### 1.1.2 性能与可维护性的权衡

命令式和声明式各有优缺点，在框架设计方面，则体现在**性能与可维护性之间的权衡**。这里先抛出一个结论：**声明式代码的性能不优于命令式代码的性能**。

理论上命令式代码可以做到极致的性能优化，因为明确知道哪些发生了变更，只做必要的修改就行了。但是声明式代码不一定能做到这一点，因为它描述的是结果。

对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是命令式的。

如果把直接修改的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有：

- 命令式代码的更新性能消耗 = A
- 声明式代码的更新性能消耗 = B + A

可以看到，声明式代码会比命令式代码多出找出差异的性能消耗。

Vue.js 要选择声明式的设计方案原因就在于**声明式代码的可维护性更强**。在采用命令式代码开发的时候，需要维护实现目标的整个**过程**，包括要手动完成 DOM 元素的创建、更新、删除等工作。而声明式代码展示的就是要的**结果**，看上去更加直观，至于做事儿的过程，Vue.js 都封装好了。

这就体现了在框架设计上要做出的关于可维护性与性能之间的权衡。在采用声明式提升可维护性的同时，性能就会有一定的损失，而框架设计者要做的就是：在保持可维护性的同时让性能损失最小化。

#### 1.1.3 虚拟 DOM 的性能到底如何

声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗，因此，如果能够最小化找出差异的性能消耗，就可以让声明式代码的性能无限接近命令式代码的性能。而所谓的虚拟 DOM，就是为了最小化找出差异这一步的性能消耗而出现的。
