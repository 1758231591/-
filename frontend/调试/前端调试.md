# 前端调试

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [前端调试](#前端调试)
  - [一. 用 VSCode 调试网页](#一-用-vscode-调试网页)
    - [1.1 VSCode Chrome Debugger 配置详解](#11-vscode-chrome-debugger-配置详解)
  - [二. 用 VSCode Debugger 调试 Node.js](#二-用-vscode-debugger-调试-nodejs)
  - [三. 用 Chrome DevTools 调试网页](#三-用-chrome-devtools-调试网页)
  - [四. 常用调试工具原理](#四-常用调试工具原理)
    - [4.1 Chrome DevTools 原理](#41-chrome-devtools-原理)
    - [4.2 VSCode Debugger 原理](#42-vscode-debugger-原理)
    - [4.3 Vue/React DevTools](#43-vuereact-devtools)
    - [4.4 调试工具四要素](#44-调试工具四要素)

<!-- /code_chunk_output -->

代码在某个平台运行，把运行时的状态通过某种方式暴露出来，传递给开发工具做 UI 的展示和交互，辅助开发者排查问题、梳理流程、了解代码运行状态等，这个就是调试。

这里的某个平台，可以是浏览器、Node.js、Electron、小程序等任何能执行 JS 代码的平台。

暴露出的运行时状态，可能是调用栈、执行上下文，或者 DOM 的结构，React 组件的状态等。

暴露出这些数据的方式一般是通过基于 WebSocket 的调试协议，当然也会有别的方式。

## 一. 用 VSCode 调试网页

### 1.1 VSCode Chrome Debugger 配置详解

- `launch/attach`

  创建 Chrome Debug 配置有两种方式：launch 和 attach，它们只是 request 的配置不同。

  调试就是把浏览器跑起来，访问目标网页，这时候会有一个 ws 的调试服务，用 frontend 的 ws 客户端连接上这个 ws 服务，就可以进行调试了。

  ![调试原理](./image/%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.webp)

  VSCode 的 Debugger 会多一层适配器协议的转换，但是原理差不多。

  launch 的意思是把 url 对应的网页跑起来，指定调试端口，然后 frontend 自动 attach 到这个端口。但如果已经有一个在调试模式跑的浏览器了，那直接连接上就行，这时候就直接使用 attach。

  [使用 attach 前需要预先安装插件和设置 Chrome](/public_knowledge/VSCode/VisualStudioCode.md#421-web-开发利器)

- `userDataDir`

  user data dir 是保存用户数据的地方，比如浏览记录、cookies、插件、书签、网站的数据等。用户数据目录有个特点，就是只能被一个 Chrome 实例所访问，如果之前启动了 Chrome 用了这个默认的 user data dir，那就不能再启动一个 Chrome 实例用它了。如果用户数据目录已经跑了一个 Chrome 实例，再跑一个就会报错 `Unable to attach to browser`。

  所以用调试模式启动 Chrome 的时候，需要单独指定一下 user data dir 的位置。或者把之前的 Chrome 实例关掉，这样才能用默认的。

  只能在 request 为 launch 模式下配置，默认为 true，代表创建一个临时目录来保存用户数据。也可以设置为 false，使用默认 user data dir 启动 chrome。这样的好处就是登录状态、历史记录都有。也可以指定一个自定义的路径，这样用户数据就会保存在那个目录下。

  更重要的是，安装的 Vue DevTools 等插件都是在默认用户数据目录的，要是用临时数据目录跑调试，这些就都没了。当 `userDataDir` 设置为 true 的时候，Vue DevTools 插件是没有的，需要再安装，userDataDir 设置为 false 的时候，安装过的插件都可以直接用。这个问题可以用下面的配置解决。

- `runtimeExecutable`

  调试网页的 JS，需要先把 Chrome 跑起来，默认跑的是 Google Chrome，其实它还有另外一个版本 Canary。这是给开发者用的每日构建版，能够快速体验新特性，但是不稳定。可以在[官网](https://www.google.com/intl/zh-CN/chrome/canary/)下载。然后指定 `runtimeExecutable` 为 canary，使用默认的用户数据目录启动。这样就可以调试用 canary，平时用 chrome 了，两种不共用同一个数据目录。

  当然，runtimeExecutable 还可以指定用别的浏览器跑，可以是 stable，也就是稳定的 Google Chrome，或者 canary 还可以是 custom，然后用 CHROME_PATH 环境变量指定浏览器的地址。

- `runtimeArgs`

  启动 Chrome 的时候，可以指定启动参数，比如每次打开网页都默认调起 Chrome DevTools，就可以加一个 `--auto-open-devtools-for-tabs` 的启动参数：

  ```json
  {
    "request": "launch",
    "runtimeArgs": ["--auto-open-devtools-for-tabs"]
  }
  ```

  想要无痕模式启动，也就是不加载插件，没有登录状态，就可以加一个 `--incognito` 的启动参数。

  其实设置的 userDataDir 就是指定了 --user-data-dir 的启动参数。

- `sourceMapPathOverrides`

  代码是经过编译打包然后在浏览器运行的，但调试时却可以直接调试源码，这是通过 sourcemap 做到的。调试工具都支持 sourcemap，并且是默认开启的。当然也可以关掉，Chrome DevTools 里这么关：

  ![ChromeDevTools关闭sourcemap](./image/ChromeDevTools%E5%85%B3%E9%97%ADsourcemap.webp)

  VSCode Debugger 中可以将 `sourceMaps` 设为 false 来关闭。这样调试的就是编译后的代码了。

  在开启 sourcemap 的情况下，用 Chrome DevTools 可以看到，源文件的路径是 /static/js/bundle.js：

  ![源文件路径](./image/%E6%BA%90%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.webp)

  被 sourcemap 到了 /Users/guang/code/test-react-debug/src/index.js：

  ![源码路径](./image/%E6%BA%90%E7%A0%81%E8%B7%AF%E5%BE%84.webp)

  而在 VSCode 里，这个路径是有对应的文件的，所以就会打开对应文件的编辑器，这样就可以边调试边修改代码。但有的时候，sourcemap 到的文件路径在本地里找不到，这时候代码就只读了，因为没有地方保存。这种情况就需要通过 `sourceMapPathOverrides` 对 sourcemap 到的路径再做一次映射：

  ![sourcemap映射](./image/sourcemap%E6%98%A0%E5%B0%84.webp)

  默认有这么三个配置：

  ```json
  {
    "sourceMapPathOverrides": {
      "meteor://💻app/*": "${workspaceFolder}/*",
      "webpack:///./~/*": "${workspaceFolder}/node_modules/*",
      "webpack://?:*/*": "${workspaceFolder}/*"
    }
  }
  ```

  分别是把 meteor、webpack 开头的 path 映射到了本地的目录下。其中 `?:*` 代表匹配任意字符，但不映射，而 `*` 是用于匹配字符并映射的。

- `file`

  除了启动开发服务器然后连上 url 调试之外，也可以直接指定某个文件，VSCode Debugger 会启动静态服务器提供服务：

  ```json
  {
    "name": "Launch Chrome",
    "request": "launch",
    "type": "pwa-chrome",
    "file": "${workspaceFolder}/index.html",
    "webRoot": "${workspaceFolder}"
  }
  ```

  同样，要修改调试的内容需要把 url 映射到本地文件才行，所以有这样一个 `pathMapping` 的配置：

  ```json
  {
    "pathMapping": {
      "/static/js/": "${workspaceFolder}/src/"
    }
  }
  ```

  webRoot 其实就相当于把 `/` 的 url 映射到了 `${workspaceFolder}/`。

## 二. 用 VSCode Debugger 调试 Node.js

## 三. 用 Chrome DevTools 调试网页

## 四. 常用调试工具原理

### 4.1 Chrome DevTools 原理

Chrome DevTools 分为两部分：

- **backend**：backend 和 Chrome 集成，负责把 Chrome 的网页运行时状态通过调试协议暴露出来。backend 可以是 Chromium，也可以是 Node.js 或者 V8，这些 JS 的运行时都支持 CDP 调试协议。

- **frontend**：frontend 是独立的，负责对接调试协议，做 UI 的展示和交互。

两者之间的调试协议叫做 Chrome DevTools Protocol，简称 **CDP**。

传输协议数据的方式叫做**信道**（message channel），有很多种，比如 Chrome DevTools 嵌入在 Chrome 里时，两者通过全局的函数通信；当 Chrome DevTools 远程调试某个目标的代码时，两者通过 WebSocket 通信。

![ChromeDevTools调试原理](./image/ChromeDevTools%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.webp)

### 4.2 VSCode Debugger 原理

VSCode Debugger 的原理和 Chrome DevTools 差不多，也是分为 frontend、backend、调试协议这几部分，只不过它多了一层适配器协议。

![VSCodeDebugger原理](./image/VSCodeDebugger%E5%8E%9F%E7%90%86.webp)

为了能直接用 Chrome DevTools 调试 Node.js 代码，Node.js 6 以上就使用 CDP 作为调试协议了，所以 VSCode Debugger 要调试 Node.js 也是通过这个协议。

因为 VSCode 不是 JS 专用编辑器，它可能用来调试 Python 代码、Rust 代码等等，不能和某一种语言的调试协议深度耦合，所以多了一个适配器层 Debug Adapter Protocol。

![DebugAdapterProtocol](./image/DebugAdapterProtocol.webp)

这样 VSCode Debugger 就可以用同一套 UI 和逻辑来调试各种语言的代码，只要对接不同的 Debug Adapter 做协议转换即可。

这样还有另一个好处，就是别的编辑器也可以用这个 Debug Adapter Protocol 来实现调试，这样就可以直接复用 VSCode 的各种语言的 Debug Adapter 了。

VSCode Debugger 的 UI 的部分算是 frontend，而调试的目标语言算是 backend 部分，中间也是通过 WebSocket 传递调试协议。

整体和 Chrome DevTools 的调试原理差不多，只不过为了支持 frontend 的跨语言复用，多了一层适配器层。

### 4.3 Vue/React DevTools

Vue DevTools 或者 React DevTools 都是以 Chrome 插件（Chrome Extension）的形式存在的，要搞懂它们的原理就得了解 Chrome 插件的机制。

**Chrome 插件机制**
Chrome 插件中可以访问网页的 DOM 的部分叫做 **Content Script**，随页面启动而生效，可以写一些操作 DOM 的逻辑。还有一部分是后台运行的，叫做 **Background**，浏览器启动就生效了，生命周期比较长，可以做一些常驻的逻辑。如果是扩展 DevTools 的 Chrome 插件，那还有一部分 DevTools Page，是在 DevTools 里显示的页面：

![Chrome插件机制](./image/Chrome%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6.webp)

Content Script 部分可以操作 DOM，可以监听 DOM Event。

Background 部分可以访问 extension api，可以和 Content Script 还有 DevTools Page 通信。

DevTools Page 部分可以访问 devtools api，可以向当前 window 注入 JS 执行。

这就是 Chrome 插件的大概架构。Vue DevTools 和 React DevTools 就是基于这个架构来实现的调试功能。

看 [Vue DevTools 的源码目录](https://github.com/vuejs/devtools/tree/main/packages)会发现，它也是分为 backend 和 frontend 的

DevTools Page 可以向页面注入 JS 的，那就可以注入 backend 的代码。backend 的代码拿到 Vue 组件的信息，通过 window message 的方式传递给 Background。Background 可以和 DevTools Page 通信，从而实现消息转发。DevTools Page 根据拿到的数据，渲染组件的信息，实现交互功能。

![backend和frontend的运行与通信](./image/backend%E5%92%8Cfrontend%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E9%80%9A%E4%BF%A1.webp)

### 4.4 调试工具四要素

Chrome DevTools、VSCode Debugger、Vue/React DevTools，都有 backend 部分负责拿到运行时的信息，有 frontend 部分负责渲染和交互，也有调试协议用来规定不同数据的格式，还有不同的信道，比如 WebSocket 、Chrome 插件的 background 转发等。

**frontend、backend、调试协议、信道，这是调试工具的四要素**。

不过，不同的调试工具都会有不同的设计，比如 VSCode Debugger 为了跨语言复用，多了一层 Debugger Adapter，React DevTools 有独立的 electron 应用，用自定义调试协议，可以调试 React Native 代码。

### 4.5 sourcemap 的原理和作用
