# 前端调试

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [前端调试](#前端调试)
  - [一. 用 VSCode 调试网页](#一-用-vscode-调试网页)
    - [1.1 VSCode Chrome Debugger 配置详解](#11-vscode-chrome-debugger-配置详解)
  - [二. 用 VSCode Debugger 调试 Node.js](#二-用-vscode-debugger-调试-nodejs)
  - [三. 用 Chrome DevTools 调试网页](#三-用-chrome-devtools-调试网页)
  - [四. 常用调试工具原理](#四-常用调试工具原理)
    - [4.1 Chrome DevTools 原理](#41-chrome-devtools-原理)
    - [4.2 VSCode Debugger 原理](#42-vscode-debugger-原理)
    - [4.3 Vue/React DevTools](#43-vuereact-devtools)
    - [4.4 调试工具四要素](#44-调试工具四要素)
    - [4.5 sourcemap](#45-sourcemap)
      - [4.5.1 什么是 sourcemap](#451-什么是-sourcemap)
      - [4.5.2 sourcemap 的生成](#452-sourcemap-的生成)
      - [4.5.3 webpack 的 sourcemap 配置](#453-webpack-的-sourcemap-配置)

<!-- /code_chunk_output -->

代码在某个平台运行，把运行时的状态通过某种方式暴露出来，传递给开发工具做 UI 的展示和交互，辅助开发者排查问题、梳理流程、了解代码运行状态等，这个就是调试。

这里的某个平台，可以是浏览器、Node.js、Electron、小程序等任何能执行 JS 代码的平台。

暴露出的运行时状态，可能是调用栈、执行上下文，或者 DOM 的结构，React 组件的状态等。

暴露出这些数据的方式一般是通过基于 WebSocket 的调试协议，当然也会有别的方式。

## 一. 用 VSCode 调试网页

### 1.1 VSCode Chrome Debugger 配置详解

- `launch/attach`

  创建 Chrome Debug 配置有两种方式：launch 和 attach，它们只是 request 的配置不同。

  调试就是把浏览器跑起来，访问目标网页，这时候会有一个 ws 的调试服务，用 frontend 的 ws 客户端连接上这个 ws 服务，就可以进行调试了。

  ![调试原理](./image/%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.webp)

  VSCode 的 Debugger 会多一层适配器协议的转换，但是原理差不多。

  launch 的意思是把 url 对应的网页跑起来，指定调试端口，然后 frontend 自动 attach 到这个端口。但如果已经有一个在调试模式跑的浏览器了，那直接连接上就行，这时候就直接使用 attach。

  [使用 attach 前需要预先安装插件和设置 Chrome](/public_knowledge/VSCode/VisualStudioCode.md#421-web-开发利器)

- `userDataDir`

  user data dir 是保存用户数据的地方，比如浏览记录、cookies、插件、书签、网站的数据等。用户数据目录有个特点，就是只能被一个 Chrome 实例所访问，如果之前启动了 Chrome 用了这个默认的 user data dir，那就不能再启动一个 Chrome 实例用它了。如果用户数据目录已经跑了一个 Chrome 实例，再跑一个就会报错 `Unable to attach to browser`。

  所以用调试模式启动 Chrome 的时候，需要单独指定一下 user data dir 的位置。或者把之前的 Chrome 实例关掉，这样才能用默认的。

  只能在 request 为 launch 模式下配置，默认为 true，代表创建一个临时目录来保存用户数据。也可以设置为 false，使用默认 user data dir 启动 chrome。这样的好处就是登录状态、历史记录都有。也可以指定一个自定义的路径，这样用户数据就会保存在那个目录下。

  更重要的是，安装的 Vue DevTools 等插件都是在默认用户数据目录的，要是用临时数据目录跑调试，这些就都没了。当 `userDataDir` 设置为 true 的时候，Vue DevTools 插件是没有的，需要再安装，userDataDir 设置为 false 的时候，安装过的插件都可以直接用。这个问题可以用下面的配置解决。

- `runtimeExecutable`

  调试网页的 JS，需要先把 Chrome 跑起来，默认跑的是 Google Chrome，其实它还有另外一个版本 Canary。这是给开发者用的每日构建版，能够快速体验新特性，但是不稳定。可以在[官网](https://www.google.com/intl/zh-CN/chrome/canary/)下载。然后指定 `runtimeExecutable` 为 canary，使用默认的用户数据目录启动。这样就可以调试用 canary，平时用 chrome 了，两种不共用同一个数据目录。

  当然，runtimeExecutable 还可以指定用别的浏览器跑，可以是 stable，也就是稳定的 Google Chrome，或者 canary 还可以是 custom，然后用 CHROME_PATH 环境变量指定浏览器的地址。

- `runtimeArgs`

  启动 Chrome 的时候，可以指定启动参数，比如每次打开网页都默认调起 Chrome DevTools，就可以加一个 `--auto-open-devtools-for-tabs` 的启动参数：

  ```json
  {
    "request": "launch",
    "runtimeArgs": ["--auto-open-devtools-for-tabs"]
  }
  ```

  想要无痕模式启动，也就是不加载插件，没有登录状态，就可以加一个 `--incognito` 的启动参数。

  其实设置的 userDataDir 就是指定了 --user-data-dir 的启动参数。

- `sourceMapPathOverrides`

  代码是经过编译打包然后在浏览器运行的，但调试时却可以直接调试源码，这是通过 sourcemap 做到的。调试工具都支持 sourcemap，并且是默认开启的。当然也可以关掉，Chrome DevTools 里这么关：

  ![ChromeDevTools关闭sourcemap](./image/ChromeDevTools%E5%85%B3%E9%97%ADsourcemap.webp)

  VSCode Debugger 中可以将 `sourceMaps` 设为 false 来关闭。这样调试的就是编译后的代码了。

  在开启 sourcemap 的情况下，用 Chrome DevTools 可以看到，源文件的路径是 /static/js/bundle.js：

  ![源文件路径](./image/%E6%BA%90%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.webp)

  被 sourcemap 到了 /Users/guang/code/test-react-debug/src/index.js：

  ![源码路径](./image/%E6%BA%90%E7%A0%81%E8%B7%AF%E5%BE%84.webp)

  而在 VSCode 里，这个路径是有对应的文件的，所以就会打开对应文件的编辑器，这样就可以边调试边修改代码。但有的时候，sourcemap 到的文件路径在本地里找不到，这时候代码就只读了，因为没有地方保存。这种情况就需要通过 `sourceMapPathOverrides` 对 sourcemap 到的路径再做一次映射：

  ![sourcemap映射](./image/sourcemap%E6%98%A0%E5%B0%84.webp)

  默认有这么三个配置：

  ```json
  {
    "sourceMapPathOverrides": {
      "meteor://💻app/*": "${workspaceFolder}/*",
      "webpack:///./~/*": "${workspaceFolder}/node_modules/*",
      "webpack://?:*/*": "${workspaceFolder}/*"
    }
  }
  ```

  分别是把 meteor、webpack 开头的 path 映射到了本地的目录下。其中 `?:*` 代表匹配任意字符，但不映射，而 `*` 是用于匹配字符并映射的。

- `file`

  除了启动开发服务器然后连上 url 调试之外，也可以直接指定某个文件，VSCode Debugger 会启动静态服务器提供服务：

  ```json
  {
    "name": "Launch Chrome",
    "request": "launch",
    "type": "pwa-chrome",
    "file": "${workspaceFolder}/index.html",
    "webRoot": "${workspaceFolder}"
  }
  ```

  同样，要修改调试的内容需要把 url 映射到本地文件才行，所以有这样一个 `pathMapping` 的配置：

  ```json
  {
    "pathMapping": {
      "/static/js/": "${workspaceFolder}/src/"
    }
  }
  ```

  webRoot 其实就相当于把 `/` 的 url 映射到了 `${workspaceFolder}/`。

### 1.2 VSCode Chrome Debugger 断点映射的原理

VSCode 会记录在哪个文件哪行打了个[断点](/public_knowledge/VSCode/VisualStudioCode.md#355-断点的使用)。在 breakpoints 里可以看到。

代码经过编译打包之后，可能会产生一个 bundle.js，网页里运行的就是这个 js 文件。断点最终还是在代码的运行时，也就是网页里断住的，所以在 VSCode 里打的断点会被传递给浏览器，通过 CDP 调试协议。

本地打的断点是一个绝对路径，也就是包含 ${workspaceFolder} 的路径，而网页里根本没有这个路径，可以成功是因为有的文件是关联了 sourcemap，也就是文件末尾的这行注释：

![关联sourcemap](./image/%E5%85%B3%E8%81%94sourcemap.webp)

它会把文件路径映射到源码路径。如果映射到的源码路径直接就是本地的文件路径，那断点就生效了：

![断点映射原理](./image/%E6%96%AD%E7%82%B9%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.webp)

vite 的项目，sourcemap 都是这种绝对路径，所以断点直接就生效了：

![vite的sourcemap](./image/vite%E7%9A%84sourcemap.webp)

但是 webpack 的项目，sourcemap 到的路径不是绝对路径，而是这种：

![webpack4的sourcemap](./image/webpack4%E7%9A%84sourcemap.webp)

或

![webpack5的sourcemap](./image/webpack5%E7%9A%84sourcemap.webp)

所以 VSCode Chrome Debugger 支持了 `sourceMapPathOverrides` 的配置：

```json
{
  "sourceMapPathOverrides": {
    "meteor://💻app/*": "${workspaceFolder}/*",
    "webpack:///./~/*": "${workspaceFolder}/node_modules/*",
    "webpack://?:*/*": "${workspaceFolder}/*"
  }
}
```

默认生成的三个配置，最后一个就是映射 webpack 路径的，其实是把以 `${workspaceFolder}` 开头的本地路径映射成了 webpack:// 开头的路径传给浏览器。

![sourceMapPathOverrides映射](./image/sourceMapPathOverrides%E6%98%A0%E5%B0%84.webp)

这样就和浏览器里的 sourcemap 后的文件路径对上了，那断点也就生效了。

![有sourceMapPathOverrides的映射原理](./image/%E6%9C%89sourceMapPathOverrides%E7%9A%84%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86.webp)

具体怎么配，可以加个 debugger 看看 Chrome DevTools 里是什么路径，然后映射到本地的路径就行。

但上面都是把项目根目录映射到 url 的 / 的，有的时候映射的不是 /，会出现这种情况：

```txt
mobile/js/webpack:/src/pages/user-center/index.tsx
```

这就需要 webRoot 的配置了，默认是 `${workspaceFolder}`，也就是把项目根目录映射到 url 的 /。如果出现上面的情况，说明要把 /mobile/js/ 这个路径映射到项目根目录：

```json
{
  "webRoot": "${workspaceFolder}/mobile/js/"
}
```

综上，**如果 sourcemap 到的文件路径不是本地路径，那就映射不到本地文件，会导致断点打不上，这时候可以配置 sourceMapPathOverrides。如果映射之后路径开头多了几层目录，那就要配置 webRoot**。

## 二. 用 VSCode Debugger 调试 Node.js

## 三. 用 Chrome DevTools 调试网页

## 四. 常用调试工具原理

### 4.1 Chrome DevTools 原理

Chrome DevTools 分为两部分：

- **backend**：backend 和 Chrome 集成，负责把 Chrome 的网页运行时状态通过调试协议暴露出来。backend 可以是 Chromium，也可以是 Node.js 或者 V8，这些 JS 的运行时都支持 CDP 调试协议。

- **frontend**：frontend 是独立的，负责对接调试协议，做 UI 的展示和交互。

两者之间的调试协议叫做 Chrome DevTools Protocol，简称 **CDP**。

传输协议数据的方式叫做**信道**（message channel），有很多种，比如 Chrome DevTools 嵌入在 Chrome 里时，两者通过全局的函数通信；当 Chrome DevTools 远程调试某个目标的代码时，两者通过 WebSocket 通信。

![ChromeDevTools调试原理](./image/ChromeDevTools%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.webp)

### 4.2 VSCode Debugger 原理

VSCode Debugger 的原理和 Chrome DevTools 差不多，也是分为 frontend、backend、调试协议这几部分，只不过它多了一层适配器协议。

![VSCodeDebugger原理](./image/VSCodeDebugger%E5%8E%9F%E7%90%86.webp)

为了能直接用 Chrome DevTools 调试 Node.js 代码，Node.js 6 以上就使用 CDP 作为调试协议了，所以 VSCode Debugger 要调试 Node.js 也是通过这个协议。

因为 VSCode 不是 JS 专用编辑器，它可能用来调试 Python 代码、Rust 代码等等，不能和某一种语言的调试协议深度耦合，所以多了一个适配器层 Debug Adapter Protocol。

![DebugAdapterProtocol](./image/DebugAdapterProtocol.webp)

这样 VSCode Debugger 就可以用同一套 UI 和逻辑来调试各种语言的代码，只要对接不同的 Debug Adapter 做协议转换即可。

这样还有另一个好处，就是别的编辑器也可以用这个 Debug Adapter Protocol 来实现调试，这样就可以直接复用 VSCode 的各种语言的 Debug Adapter 了。

VSCode Debugger 的 UI 的部分算是 frontend，而调试的目标语言算是 backend 部分，中间也是通过 WebSocket 传递调试协议。

整体和 Chrome DevTools 的调试原理差不多，只不过为了支持 frontend 的跨语言复用，多了一层适配器层。

### 4.3 Vue/React DevTools

Vue DevTools 或者 React DevTools 都是以 Chrome 插件（Chrome Extension）的形式存在的，要搞懂它们的原理就得了解 Chrome 插件的机制。

**Chrome 插件机制**
Chrome 插件中可以访问网页的 DOM 的部分叫做 **Content Script**，随页面启动而生效，可以写一些操作 DOM 的逻辑。还有一部分是后台运行的，叫做 **Background**，浏览器启动就生效了，生命周期比较长，可以做一些常驻的逻辑。如果是扩展 DevTools 的 Chrome 插件，那还有一部分 DevTools Page，是在 DevTools 里显示的页面：

![Chrome插件机制](./image/Chrome%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6.webp)

Content Script 部分可以操作 DOM，可以监听 DOM Event。

Background 部分可以访问 extension api，可以和 Content Script 还有 DevTools Page 通信。

DevTools Page 部分可以访问 devtools api，可以向当前 window 注入 JS 执行。

这就是 Chrome 插件的大概架构。Vue DevTools 和 React DevTools 就是基于这个架构来实现的调试功能。

看 [Vue DevTools 的源码目录](https://github.com/vuejs/devtools/tree/main/packages)会发现，它也是分为 backend 和 frontend 的

DevTools Page 可以向页面注入 JS 的，那就可以注入 backend 的代码。backend 的代码拿到 Vue 组件的信息，通过 window message 的方式传递给 Background。Background 可以和 DevTools Page 通信，从而实现消息转发。DevTools Page 根据拿到的数据，渲染组件的信息，实现交互功能。

![backend和frontend的运行与通信](./image/backend%E5%92%8Cfrontend%E7%9A%84%E8%BF%90%E8%A1%8C%E4%B8%8E%E9%80%9A%E4%BF%A1.webp)

### 4.4 调试工具四要素

Chrome DevTools、VSCode Debugger、Vue/React DevTools，都有 backend 部分负责拿到运行时的信息，有 frontend 部分负责渲染和交互，也有调试协议用来规定不同数据的格式，还有不同的信道，比如 WebSocket 、Chrome 插件的 background 转发等。

**frontend、backend、调试协议、信道，这是调试工具的四要素**。

不过，不同的调试工具都会有不同的设计，比如 VSCode Debugger 为了跨语言复用，多了一层 Debugger Adapter，React DevTools 有独立的 electron 应用，用自定义调试协议，可以调试 React Native 代码。

### 4.5 sourcemap

#### 4.5.1 什么是 sourcemap

**sourcemap 是通过一个个行列号的映射，关联编译后的代码和源码的。**。

比如编译后代码的第 3 行第 4 列，对应着源码里的第 8 行第 5 列这种，这叫做一个 **mapping**。sourcemap 的格式如下：

```js
{
　version : 3,
　file: "out.js",
　sourceRoot : "",
　sources: ["foo.js", "bar.js"],
　names: ["a", "b"],
　mappings: "AAgBC,SAAQ,CAAEA;AAAEA",
  sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)']
}
```

file 是文件名，sourceRoot 是源码根目录，names 是转换前的变量名，sources 是源码文件，sourcesContent 是每个 sources 对应的源码的内容，mappings 就是一个个位置映射了。

因为可能编译产物是多个源文件合并的，比如打包，一个 bundle.js 就对应了 n 个 sources 源文件。

**重点是 mappings 部分**：mappings 部分是通过 `;` 和 `,` 分隔的：

```js
mappings: 'AAAAA,BBBBB;CCCCC';
```

一个分号就代表一行，这样就免去了行的映射。然后每一行可能有多个位置的映射，用 `,` 分隔。

上面的 mappings 中有 AAAAA 一共五位，分别有不同的含义：

- 转换后代码的第几列（行数通过分号 ; 来确定）
- 转换前的哪个源码文件，保存在 sources 里的，这里通过下标索引
- 转换前的源码的第几行
- 转换前的源码的第几列
- 转换前的源码的哪个变量名，保存在 names 里的，这里通过下标索引

然后经过编码之后，就成了 AAAAA 这种，这种编码方式叫做 **VLQ 编码**。

各种调试工具一般都支持 sourcemap 的解析，只要在文件末尾加上这样一行：

```js
//@ sourceMappingURL=/path/to/source.js.map
```

除了调试的时候会使用 sourcemap，线上报错定位源码也需要用到。开发时会使用 sourcemap 来调试，但是生产可不会，但是线上报错的时候确实也需要定位到源码，这种情况一般都是单独上传 sourcemap 到错误收集平台。

比如 sentry 就提供了一个 [@sentry/webpack-plugin](https://github.com/getsentry/sentry-webpack-plugin) 支持在打包完成后把 sourcemap 自动上传到 sentry 后台，然后把本地 sourcemap 删掉。还提供了 [@sentry/cli](https://github.com/getsentry/sentry-cli) 让用户可以手动上传。

sourcemap 只是位置的映射，可以用在任何代码上，比如 JS、TS、CSS 等，而且 TS 的类型也支持 sourcemap：

```json
{
  "compilerOptions": {
    "sourceMap": true,
    "outDir": "./out",
    "declaration": true,
    "declarationMap": true
  }
}
```

指定了 declaration 会生成 d.ts 的声明文件，还可以指定 declarationMap 来生成 sourcemap。这样在 VSCode 里就可以直接点击某个类型来跳转到源码里对应的地方了。这也算 sourcemap 应用的另一个场景，_用于生成的类型和源码中定义的关联_。

#### 4.5.2 sourcemap 的生成

编译工具在生成代码的时候也会生成 sourcemap：

![sourcemap 的生成](./image/sourcemap%20%E7%9A%84%E7%94%9F%E6%88%90.webp)

sourcemap 就是由一个个位置的映射组成的，关键就是要知道源码的哪个位置对应到了编译后代码的哪个位置：通过 [astexplorer.net](https://astexplorer.net/#/gist/19042bfa06784d0e1b2dcb2ecd3559d5/50898c658d8129dbe520cc515af169331082036b) 可以看到，AST 中保留了源码中的位置，这是 parser 在 parse 源码的时候记录的。

![AST中的映射](./image/AST%E4%B8%AD%E7%9A%84%E6%98%A0%E5%B0%84.webp)

然后进行 AST 的各种转换之后会打印成目标代码，打印的时候是一行行一列列的拼接字符串，这时候就有了目标代码中的位置。

```ts
export function ConditionaLExpression(node: Object) {
  this.print(node.test, node);
  this.space();
  this.token('?');
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(':');
  this.space();
  this.print(node.alternate, node);
}
```

这两个位置一关联，就是一个 mapping。

![sourcemap的生成过程](./image/sourcemap%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.webp)

这样就生成了 sourcemap。当然 sourcemap 有对应的格式和编码，自己生成还是挺麻烦的，一般会用 [source-map](https://github.com/mozilla/source-map) 这个包：source-map 可以用于生成和解析 sourcemap，它暴露了 SourceMapConsumer、SourceMapGenerator、SourceNode 3 个类，分别用于消费 sourcemap、生成 sourcemap、创建源码节点。

生成 sourcemap 的流程是：

1. 创建一个 SourceMapGenerator 对象
2. 通过 addMapping 方法添加一个映射
3. 通过 toString 转为 sourcemap 字符串

```js
let map = new SourceMapGenerator({
  file: 'source-mapped.js'
});

map.addMapping({
  generated: {
    line: 10,
    column: 35
  },
  source: 'foo.js',
  original: {
    line: 33,
    column: 2
  },
  name: 'christopher'
});

console.log(map.toString());
// '{"version":3,"file":"source-mapped.js",
//   "sources":["foo.js"],"names":["christopher"],"mappings":";;;;;;;;;mCAgCEA"}'
```

消费 sourcemap 用 `SourceMapConsumer` 的 api。可以调用 `originalPositionFor` 和 `generatedPositionFor` 分别用目标代码位置查源码位置和用源码位置查目标代码位置。还可以通过 `eachMapping` 遍历所有 mapping，对每个进行处理。

```js
const rawSourceMap = {
  version: 3,
  file: 'min.js',
  names: ['bar', 'baz', 'n'],
  sources: ['one.js', 'two.js'],
  sourceRoot: 'http://example.com/www/js/',
  mappings: 'CAAC,IAAI,IAAM,SAAUA,GAClB,OAAOC,IAAID;CCDb,IAAI,IAAM,SAAUE,GAClB,OAAOA'
};

const whatever = await SourceMapConsumer.with(rawSourceMap, null, consumer => {
  // 目标代码位置查询源码位置
  consumer.originalPositionFor({
    line: 2,
    column: 28
  });
  // { source: 'http://example.com/www/js/two.js',
  //   line: 2,
  //   column: 10,
  //   name: 'n' }

  // 源码位置查询目标代码位置
  consumer.generatedPositionFor({
    source: 'http://example.com/www/js/two.js',
    line: 2,
    column: 10
  });
  // { line: 2, column: 28 }

  // 遍历 mapping
  consumer.eachMapping(function (m) {
    // ...
  });

  return computeWhatever();
});
```

#### 4.5.3 webpack 的 sourcemap 配置

webpack 对 sourcemap 做了很多封装。比如：

- eval-nosources-cheap-module-source-map
- hidden-source-map

webpack 的配置是有规律的。当配置写错的时候，webpack 会提示一个正则：`^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$`。这个就是配置的规律，是几种基础配置的组合。搞懂了每一种基础配置，比如 eval、nosources、cheap、module，按照规律组合起来，也就搞懂了整体的配置。

- `eval`

  eval() 函数会将传入的字符串当做 JS 代码进行执行。但有个问题，eval 的代码打不了断点。所以浏览器支持了这样一种特性，只要在 eval 代码的最后加上 `//# sourceURL=xxx`，那就会以 xxx 为名字把这段代码加到 sources 里。这就可以打断点了。

  ```js
  eval(`
  function add(a,b){
    return a + b;
  }
  console.log(add(1, 2));
  //# sourceURL=光.js`);
  // 3
  ```

  执行以后，会发现 sources 多了光.js 的文件：

  ![eval()的sourceURL](<./image/eval()的sourceURL.webp>)

  它是可以打断点的，比如在 add 里打个断点，然后再执行 eval。

  除了指定 source 文件外，还可以进一步指定 sourcemap 来映射到源码：

  ```js
  eval(`
  function add(a,b){
    return a + b;
  }
  console.log(add(1, 2));
  //# sourceURL=光.js
  //# sourceMappingURL= xxx`);
  ```

  这样，动态 eval 的代码也能关联到源码，并且能打断点了。

  webpack 就利用了 eval 这个特性来优化的 sourcemap 生成的性能，比如可以指定 `devtool` 为 eval：

  ```js
  module.exports = {
    devtool: 'eval'
  };
  ```

  生成的代码就是每个模块都被 eval 包裹的，并且有 sourceUrl 来指定文件名：

  ![devtool值为eval时生成的代码](./image/devtool%E5%80%BC%E4%B8%BAeval%E6%97%B6%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81.webp)

  这样做比较快，因为只要指定文件名就行，不用生成 sourcemap。sourcemap 的生成还是很慢的，要一个个 mapping 的处理，做编码之类的。

  每个模块的代码都被 eval 包裹，那么执行的时候就会在 sources 里生成对应的文件，这样就可以打断点了。不过这样只是把每个模块的代码分了出去，并没有做源码的关联，如果相关联源码，可以再开启 sourcemap：

  ```js
  module.exports = {
    devtool: 'eval-source-map'
  };
  ```

  会发现生成的代码也是用 eval 包裹的，但除了 sourceUrl 外，还有 sourceMappingUrl：

  ![devtool值为eval-source-map时生成的代码](./image/devtool%E5%80%BC%E4%B8%BAeval-source-map%E6%97%B6%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81.webp)

  再运行的时候除了 eval 的代码会生成文件放在 sources 外，还会做 sourcemap 的映射：

- `source-map`

  source-map 的配置是生成独立的 sourcemap 文件。

  ```js
  module.exports = {
    devtool: 'source-map'
  };
  ```

  ![source-map生成的文件](./image/source-map%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6.webp)

  可以关联，也可以不关联，比如加上 hidden，就是生成 sourcemap 但是不关联：

  ```js
  module.exports = {
    devtool: 'hidden-source-map'
  };
  ```

  生产环境就不需要关联 sourcemap，但是可能要生成 sourcemap 文件，把它上传到错误管理平台之类的，用来映射线上代码报错位置到对应的源码。

  此外，还可以配置成 inline 的：

  ```js
  module.exports = {
    devtool: 'inline-source-map'
  };
  ```

  这个就是通过 dataUrl 的方式内联在打包后的文件里：

  ![inline-source-map生成的文件](./image/inline-source-map%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6.webp)

- `cheap`

  sourcemap 慢主要是处理映射比较慢，很多情况下并不需要映射到源码的行和列，只要精确到行就行，这时候就可以用 cheap。

- `module`

  webpack 中对一个模块会进行多次处理，比如经过 loader A 做一次转换，再用 loader B 做一次转换，之后打包到一起。每次转换都会生成 sourcemap，那也就是有多个 sourcemap：

  ![webpack多次转换](./image/webpack%E5%A4%9A%E6%AC%A1%E8%BD%AC%E6%8D%A2.webp)

  默认 sourcemap 只是能从 bundle 关联到模块的代码，也就是只关联了最后那个 sourcemap。

  ![默认sourcemap关联目标代码](./image/%E9%BB%98%E8%AE%A4sourcemap%E5%85%B3%E8%81%94%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81.webp)

  如果想调试最初的源码，那就把每一次的 loader 的 sourcemap 也关联起来，这就是 module 配置的作用。这样就能一次性映射回最初的源码：

  ![sourcemap的module](./image/sourcemap%E7%9A%84module.webp)

- `nosources`

  sourcemap 里是有 sourceContent 部分的，也就是直接把源码贴在这里，这样的好处是根据文件路径查不到文件也可以映射，但这样会增加 sourcemap 的体积。如果确定根据文件路径能查找到源文件，那不生成 sourceContent 也行。

  比如 devtool 配置为 source-map，生成的 sourcemap 是这样的：

  ![sourcemap生成的文件中有sourceContent](./image/sourcemap%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89sourceContent.webp)

  当加上 nosources 之后，生成的 sourcemap 就没有 sourceContent 部分了：

  ```js
  module.exports = {
    devtool: 'nosources-source-map'
  };
  ```

可以根据上面的基础配置来自由组合，webpack 是按照这个正则来校验 devtool 的：`^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$`。

webpack 有这样一个插件 [SourceMapDevToolPlugin](https://webpack.docschina.org/plugins/source-map-dev-tool-plugin)，它有很多 option，比如 module、columns、noSources 等：

- `module = true (boolean)`：表示 loader 是否生成 source map。
- `columns = true (boolean)`：表示是否应该使用 column mapping。
- `noSources = false (boolean)`：防止源文件的内容被包含在 source map 中。

相当于是 devtool 的另一种配置方式，启用它需要把 devtool 设置为 false。而且它可以控制更多东西，比如修改 sourcemap 的 url 和文件名等：

```js
new webpack.SourceMapDevToolPlugin({
  append: '\n//# sourceMappingURL=https://example.com/sourcemap/[url]',
  filename: '[name].map'
});
```

当需要做更多的 sourcemap 生成方式的控制的时候，可以使用这个 webpack 插件。
