正则表达式 Regular Expression
  一.总论
    1.是什么
      正则表达式是一种描述文本内容组成规律的表示方式。在编程语言中，正则经常被用来简化文本处理的逻辑。
      正则是一个非常强大的文本处理工具，它的应用极其广泛，主要有以下三个方面：
        · 校验数据的有效性: 校验手机号、邮箱等
        · 查找符合要求的文本内容: 查找符合某种规则的号码
        · 对文本进行切割、替换等操作: 对敏感词进行屏蔽
    2.学什么
      · 基本知识: 一些重要的概念和功能
      · 在常见编辑器中使用正则的方法
      · 正则中进阶的内容: 更高阶的正则内容，这部分主要有正则中的断言（包括单词边界、行开始和结束、环视），三种主要流派的区别以及对应的软件实现，正则的工作机制和常见的优化方式等。掌握这些内容可以让我们更好地理解正则， 也可以避过很多坑。比如，为什么在编程语言中能工作的正则，在 Linux 命令 grep 中就不能工作了呢？正则匹配的原理又是什么？如何写出性能更好的正则呢？
    3.怎么用
      使用正则解决问题，大致可以分为四步：
        ① 做分解
          拿到一个问题，先思考：这个问题可以分成几个子问题？每个子问题是否独立？
            例：电子邮件地址匹配，从文本结构来看，它可以分为“username + @ + domain name”这三个独立的部分
        ② 分析各个子问题
          某个位置上可能有多个字符？那就用字符组。某个位置上可能有多个字符串？那就用多选结构。出现的次数不确定？那就用量词。对出现的位置有要求？那就用锚点锁定位置…… ，每个问题都有对应的解法，知道什么时候用字符组，什么时候用多选结构，什么时候用量词，什么时候用锚点，就很容易搭建起完整的概念模型。
        ③ 套皮
          正则真正重要的是字符组、多选结构、量词等等这些概念。概念模型一定要清楚。
        ④ 调试
          正则表达式的麻烦之处在于它像个黑箱子，很难调试，迄今为止仍然没有特别好用的工具。复杂一点的正则表达式不能一次写对，是很正常的。把正则表达式分解来看，明白典型标志限定的到底是正则表达式中的哪一部分。对应要匹配文本中的哪一部分。
    4.注意事项
      正则表达式一定不要乱用，有以下注意事项：
        · 能用普通字符串处理的，一定要用普通字符串处理: 字符串处理的速度不见得差，可读性却好上很多。如果要在大段文本中定位所有的 today 或者 tomorrow，用最简单的字符串查找，直接找两遍，明显比 to(day|morrow) 看起来更清楚。
        · 能写注释的正则表达式，一定要写注释: 正则表达式的语法非常古老，不够直观，为了便于阅读和维护，如今大部分语言里都可以通过 x 打开注释模式。有了注释，复杂正则表达式的结构也能一目了然。
        · 能用多个简单正则表达式解决的，不要苛求用一个复杂的正则表达式: 多个简单正则表达式的可维护性远远强于单个正则表达式，比如输入条件的验证。
    
  二.基础
    1.元字符
      元字符是指在正则表达式中具有特殊意义的专用字符，元字符是构成正则表达式的基本元件。
      元字符可以大致分为以下几类：
        ① 特殊单字符: 
          · .  : 任意字符(换行除外)
          · \d : 任意数字
          · \D : 任意非数字
          · \w : 任意字母数字下划线
          · \W : 任意非字母数字下划线
          · \s : 任意空白字符
          · \S : 任意非空白字符
        ② 空白符: 
          · \s : 任意空白符
          · \r : 回车符
          · \n : 换行符
          · \f : 换页符
          · \t : 制表符
          · \v : 垂直制表符
          平时使用正则，大部分场景使用\s就可以满足需求。
        ③ 量词: 
          · * : 0到多次
          · + : 1到多次
          · ? : 0到1次，例：color?u
          · {m}: 出现m次
          · {m,}: 出现至少m次
          · {m,n}: m到n次
        ④ 范围:
          · | : 用来隔开多个正则，表示满足其中任意一个即可。
            例：ab|cd 既能匹配到ab也能匹配到cd
          · [] : 代表多选一，可以表示里面的任意单字符，中括号中还可以用中划线表示范围，如[a-z]可以表示所有小写字母。如果中括号中第一个是脱字符(^)，那么就表示非，表达的是不能是里面的任何单个元素。
        ⑤ 断言: 
    2.三种模式
      正则中有三种模式，这些模式会改变正则中量词的匹配行为：
        · 贪婪匹配(Greedy): 表示次数的量词默认是贪婪模式，会尽可能多的去匹配。
        · 懒惰匹配(Lazy): 在量词的后面加上(?)变成懒惰模式，找出长度最小且满足要求的。
        · 独占模式: 独占模式和贪婪模式很像，独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯，因此，独占模式性能比较好。具体的方法就是在量词后面加上加号（+）。JS目前不支持。
    3.回溯
      贪婪模式和懒惰模式，都需要发生回溯才能完成相应的功能，回溯在贪婪和懒惰模式下的规则有所不同：
        · 贪婪模式下的回溯: 
          regex = "xy{1,3}z"; text = "xyyz";
          在匹配时，y{1,3}会尽可能长地去匹配，当匹配完 xyy 后，由于 y 要尽可能匹配最长，即三个，但字符串中后面是个 z 就会导致匹配不上，这时候正则就会向前回溯，吐出当前字符 z，接着用正则中的 z 去匹配。
        · 懒惰模式下的回溯: 
          regex = "xy{1,3}?z"; text = “xyyz”;
          由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会向前回溯，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。
    4.分组
      分组就是把由多个元字符组成的某个部分，应该被看成一个整体时，用括号() 括起来表示一个整体。括号起来来还有另一个作用——"复用"。
      (1)子组
        括号在正则中被用于分组，被括号括起来的部分"子表达式"会被保存成一个子组。第几个括号就是第几个子组。
        ① 不保存子组：可以在括号里面使用 ?: 不保存子组
          优点：可以提高正则性能，在子组计算时更不容易出错。
          例：(?:正则) \d{12}(?:\d{3})
        ② 括号嵌套：数左括号（开括号）是第几个，就可以确定是第几个子组。
          例：public_knowledge\regular_expression\示例文件\分组-括号嵌套.png
        ③ 命名分组: 与数字相比更容易辨别，后续改动正则更容易，各个语言提供的命名分组格式不同，使用前查对应文档，JS的格式为 (?<分组名>)
          例：(<?<num>\d+) 
        ④ 分组引用: JS中通过 "$编号" 的方式引用，其他大部分情况下，可以使用 "\ + 编号"
          例：string.replace("^(\d+)\.(\s)"}, "$1")
    5.匹配模式
      匹配模式指的是，正则中一些 改变元字符匹配行为 的方式，JS的匹配模式有六种：
        (1)不区分大小写模式(Case-Insensitive)
          例: /regex/i
        (2)点号通配模式(Dot All)
          让 . 可以匹配包括换行的任意字符
            例: /\d./s
        (3)多行匹配模式(MultiLine)
          通常情况下，^匹配整个字符串的开头，$匹配整个字符串的结尾。多行匹配模式改变的就是^和$的匹配行为，使 ^ 和 $ 能匹配每行的开头和结尾，JS使用修饰符 m 来使用。
            例: /^\w$/m
        (4)全局搜索
          例: /\d?/g
        (5)使用unicode码的模式进行匹配
          例: /\u{hhhh}/u  匹配一个十六进制数表示的Unicode字符
        (6)粘性搜索(Sticky)
          执行"粘性搜索"，匹配从源字符串的 RegExp.prototype.lastIndex 位置开始匹配。
            例：public_knowledge\regular_expression\示例文件\正则表达式示例.html 函数searchSticky
    