正则表达式 Regular Expression
  一.总论
    1.是什么
      正则表达式是一种描述文本内容组成规律的表示方式。在编程语言中，正则经常被用来简化文本处理的逻辑。
      正则是一个非常强大的文本处理工具，它的应用极其广泛，主要有以下三个方面：
        · 校验数据的有效性: 校验手机号、邮箱等
        · 查找符合要求的文本内容: 查找符合某种规则的号码
        · 对文本进行切割、替换等操作: 对敏感词进行屏蔽
    2.学什么
      · 基本知识: 一些重要的概念和功能
      · 在常见编辑器中使用正则的方法
      · 正则中进阶的内容: 更高阶的正则内容，这部分主要有正则中的断言（包括单词边界、行开始和结束、环视），三种主要流派的区别以及对应的软件实现，正则的工作机制和常见的优化方式等。掌握这些内容可以让我们更好地理解正则， 也可以避过很多坑。比如，为什么在编程语言中能工作的正则，在 Linux 命令 grep 中就不能工作了呢？正则匹配的原理又是什么？如何写出性能更好的正则呢？
    3.怎么用
      使用正则解决问题，大致可以分为四步：
        ① 做分解
          拿到一个问题，先思考：这个问题可以分成几个子问题？每个子问题是否独立？
            例：电子邮件地址匹配，从文本结构来看，它可以分为“username + @ + domain name”这三个独立的部分
        ② 分析各个子问题
          某个位置上可能有多个字符？那就用字符组。某个位置上可能有多个字符串？那就用多选结构。出现的次数不确定？那就用量词。对出现的位置有要求？那就用锚点锁定位置…… ，每个问题都有对应的解法，知道什么时候用字符组，什么时候用多选结构，什么时候用量词，什么时候用锚点，就很容易搭建起完整的概念模型。
        ③ 套皮
          正则真正重要的是字符组、多选结构、量词等等这些概念。概念模型一定要清楚。
        ④ 调试
          正则表达式的麻烦之处在于它像个黑箱子，很难调试，迄今为止仍然没有特别好用的工具。复杂一点的正则表达式不能一次写对，是很正常的。把正则表达式分解来看，明白典型标志限定的到底是正则表达式中的哪一部分。对应要匹配文本中的哪一部分。
    4.流派及其特性
      (1)正则表达式简史
        正则表达式的起源，可以追溯到，早期神经系统如何工作的研究。在 20 世纪 40 年代，有两位神经生理学家（Warren McCulloch 和 Walter Pitts），研究出了一种用数学方式来描述神经网络的方法。
        1956 年，一位数学家（Stephen Kleene）发表了一篇标题为《神经网络事件表示法和有穷自动机》的论文。这篇论文描述了一种叫做“正则集合（Regular Sets）”的符号。
        随后，大名鼎鼎的 Unix 之父 Ken Thompson 于 1968 年发表了文章《正则表达式搜索算法》，并且将正则引入了自己开发的编辑器 qed，以及之后的编辑器 ed 中，然后又移植到了大名鼎鼎的文本搜索工具 grep 中。自此，正则表达式被广泛应用到 Unix 系统或类 Unix 系统 (如 macOS、Linux) 的各种工具中。
        随后，由于正则功能强大，非常实用，越来越多的语言和工具都开始支持正则。不过遗憾的是，由于没有尽早确立标准，导致各种语言和工具中的正则虽然功能大致类似，但仍然有不少细微差别。
      (2)流派
        正则表达式目前最主要的两大流派是：
          ① POSIX流派:
            ❶ 诞生
              诞生于 1986 年的 POSIX 开始进行标准化的尝试。POSIX作为一系列规范，定义了 Unix 操作系统应当支持的功能，其中也包括正则表达式的规范。因此，Unix 系统或类 Unix 系统上的大部分工具，如 grep、sed、awk 等，均遵循该标准。我们把这些遵循 POSIX 正则表达式规范的正则表达式，称为 POSIX 流派的正则表达式。
            ❷ 标准
              POSIX 规范定义了正则表达式的两种标准:
                · BRE 标准（Basic Regular Expression 基本正则表达式）: 
                · ERE 标准（Extended Regular Expression 扩展正则表达式）: 
              区别:
                早期 BRE 与 ERE 标准的区别主要在于:
                  · BRE 标准不支持量词问号和加号，也不支持多选分支结构管道符。BRE 标准在使用花括号，圆括号时要转义才能表示特殊含义。
                  · ERE 标准，在使用花括号，圆括号时不需要转义了，还支持了问号、加号 和 多选分支。
                现在使用的 Linux 发行版，大多都集成了 GNU 套件。GNU 在实现 POSIX 标准时，做了一定的扩展，主要有以下三点扩展:
                  · GNU BRE 支持了 +、?，但转义了才表示特殊含义，即需要用\+、\?表示。
                  · GNU BRE 支持管道符多选分支结构，同样需要转义，即用 \|表示。
                  · GNU ERE 也支持使用反引用，和 BRE 一样，使用 \1、\2…\9 表示
              POSIX字符组
                POSIX 流派还有一个特殊的地方，就是有自己的字符组，叫 POSIX 字符组。这个类似于 \d 表示数字，\s 表示空白符等，POSIX 中也定义了一系列的字符组。
          ② PCRE流派: 
            目前大部分常用编程语言都是源于 PCRE 标准，这个流派显著特征是有\d、\w、\s 这类字符组简记方式。
            ❶ 诞生
              在 1987 年 12 月，Larry Wall 发布了 Perl 语言第一版，因其功能强大一票走红，所引入的正则表达式功能大放异彩。之后 Perl 语言中的正则表达式不断改进，影响越来越大。于是在此基础上，1997 年又诞生了PCRE——Perl 兼容正则表达式（Perl Compatible Regular Expressions）。
              PCRE 是一个兼容 Perl 语言正则表达式的解析引擎，是由 Philip Hazel 开发的，为很多现代语言和工具所普遍使用。除了 Unix 上的工具遵循 POSIX 标准，PCRE 现已成为其他大部分语言和工具隐然遵循的标准。
            ❷ 兼容问题
              虽然 PCRE 流派是与 Perl 正则表达式相兼容的流派，但这种兼容在各种语言和工具中还存在程度上的差别，这包括了直接兼容与间接兼容两种情况。
                · 直接兼容: PCRE 流派中与 Perl 正则表达式直接兼容的语言或工具。比如 Perl、PHP preg、PCRE 库等，一般称之为 Perl 系。
                · 间接兼容: 比如 Java 系（包括 Java、Groovy、Scala 等）、Python 系（包括 Python2 和 Python3）、JavaScript 系（包括原生 JavaScript 和扩展库 XRegExp）、.Net 系（包括 C#、VB.Net 等）等。
      (3)在Linux中使用正则
        在遵循 POSIX 规范的 UNIX/LINUX 系统上，按照 BRE 标准 实现的有 grep、sed 和 vi/vim 等，而按照 ERE 标准 实现的有 egrep、awk 等。
        在 Linux 系统中有个 man 命令可以帮助我们。比如，macOS 上执行 man grep ，可以看到选项 -G 是指定使用 BRE 标准（默认），-E 是 ERE 标准，-P 是 PCRE 标准。
    4.注意事项
      正则表达式一定不要乱用，有以下注意事项：
        · 能用普通字符串处理的，一定要用普通字符串处理: 字符串处理的速度不见得差，可读性却好上很多。如果要在大段文本中定位所有的 today 或者 tomorrow，用最简单的字符串查找，直接找两遍，明显比 to(day|morrow) 看起来更清楚。
        · 能写注释的正则表达式，一定要写注释: 正则表达式的语法非常古老，不够直观，为了便于阅读和维护，如今大部分语言里都可以通过 x 打开注释模式。有了注释，复杂正则表达式的结构也能一目了然。
        · 能用多个简单正则表达式解决的，不要苛求用一个复杂的正则表达式: 多个简单正则表达式的可维护性远远强于单个正则表达式，比如输入条件的验证。
    
  二.基础
    1.元字符
      元字符是指在正则表达式中具有特殊意义的专用字符，元字符是构成正则表达式的基本元件。
      元字符可以大致分为以下几类：
        ① 特殊单字符: 
          · .  : 任意字符(换行除外)
          · \d : 任意数字
          · \D : 任意非数字
          · \w : 任意字母数字下划线
          · \W : 任意非字母数字下划线
          · \s : 任意空白字符
          · \S : 任意非空白字符
        ② 空白符: 
          · \s : 任意空白符
          · \r : 回车符
          · \n : 换行符
          · \f : 换页符
          · \t : 制表符
          · \v : 垂直制表符
          平时使用正则，大部分场景使用\s就可以满足需求。
        ③ 量词: 
          · * : 0到多次
          · + : 1到多次
          · ? : 0到1次，例：color?u
          · {m}: 出现m次
          · {m,}: 出现至少m次
          · {m,n}: m到n次
        ④ 范围:
          · | : 用来隔开多个正则，表示满足其中任意一个即可。
            例：ab|cd 既能匹配到ab也能匹配到cd
          · [] : 代表多选一，可以表示里面的任意单字符，中括号中还可以用中划线表示范围，如[a-z]可以表示所有小写字母。如果中括号中第一个是脱字符(^)，那么就表示非，表达的是不能是里面的任何单个元素。
        ⑤ 断言: 
    2.三种模式
      正则中有三种模式，这些模式会改变正则中量词的匹配行为：
        · 贪婪匹配(Greedy): 表示次数的量词默认是贪婪模式，会尽可能多的去匹配。
        · 懒惰匹配(Lazy): 在量词的后面加上(?)变成懒惰模式，找出长度最小且满足要求的。
        · 独占模式: 独占模式和贪婪模式很像，独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯，因此，独占模式性能比较好。具体的方法就是在量词后面加上加号（+）。JS目前不支持。
    3.回溯
      贪婪模式和懒惰模式，都需要发生回溯才能完成相应的功能，回溯在贪婪和懒惰模式下的规则有所不同：
        · 贪婪模式下的回溯: 
          regex = "xy{1,3}z"; text = "xyyz";
          在匹配时，y{1,3}会尽可能长地去匹配，当匹配完 xyy 后，由于 y 要尽可能匹配最长，即三个，但字符串中后面是个 z 就会导致匹配不上，这时候正则就会向前回溯，吐出当前字符 z，接着用正则中的 z 去匹配。
        · 懒惰模式下的回溯: 
          regex = "xy{1,3}?z"; text = “xyyz”;
          由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会向前回溯，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。
    4.分组
      分组就是把由多个元字符组成的某个部分，应该被看成一个整体时，用括号() 括起来表示一个整体。括号起来来还有另一个作用——"复用"。
      (1)子组
        括号在正则中被用于分组，被括号括起来的部分"子表达式"会被保存成一个子组。第几个括号就是第几个子组。
        ① 不保存子组：可以在括号里面使用 ?: 不保存子组
          优点：可以提高正则性能，在子组计算时更不容易出错。
          例：(?:正则) \d{12}(?:\d{3})
        ② 括号嵌套：数左括号（开括号）是第几个，就可以确定是第几个子组。
          例：public_knowledge\regular_expression\示例文件\image\分组-括号嵌套.png
        ③ 命名分组: 与数字相比更容易辨别，后续改动正则更容易，各个语言提供的命名分组格式不同，使用前查对应文档，JS的格式为 (?<分组名>)
          例：(<?<num>\d+) 
        ④ 分组引用: JS在替换时使用 "$编号" 的方式引用，在正则中查找时使用 "\编号"
          例：string.replace("^(\d+)\.(\s)"}, "$1")
              /(a)\1/.test("aa") // true
    5.匹配模式
      匹配模式指的是，正则中一些 改变元字符匹配行为 的方式，JS的匹配模式有六种：
        (1)不区分大小写模式(Case-Insensitive)
          例: /regex/i
        (2)点号通配模式(Dot All)
          让 . 可以匹配包括换行的任意字符
            例: /\d./s
        (3)多行匹配模式(MultiLine)
          通常情况下，^匹配整个字符串的开头，$匹配整个字符串的结尾。多行匹配模式改变的就是^和$的匹配行为，使 ^ 和 $ 能匹配每行的开头和结尾，JS使用修饰符 m 来使用。
            例: /^\w$/m
        (4)全局搜索
          例: /\d?/g
        (5)使用unicode码的模式进行匹配
          例: /\u{61}/u.test("a")  /\w/iu.test('\u017F')
        (6)粘性搜索(Sticky)
          执行"粘性搜索"，匹配从源字符串的 RegExp.prototype.lastIndex 位置开始匹配。
            例：public_knowledge\regular_expression\示例文件\正则表达式示例.html 函数 searchSticky
  
  三.高级
    1.断言
      在有些情况下，对要匹配的文本位置也有一定的要求。为了解决这个问题，正则中提供了一些结构，只用于匹配位置，而不是文本本身，这种结构就是断言。
      常见的断言有三种：
        · 单词边界(Word Boundary): 正则中使用 \b 来表示单词的边界，\w 范围以外的字符。\B 是匹配非单词边界
          例：public_knowledge\regular_expression\示例文件\正则表达式示例.html 函数 wordBoundary
        · 行的开始或结束: 如果要求匹配的内容要出现在一行文本的开头或结尾，可以使用 ^ 和 $ 来进行位置界定。可以在以下方面使用：
          ① 日志起始行判断: 收集日志的时候，通常可以指定日志行的开始规则，比如以时间开头，那些不是以时间开头的可能就是打印的堆栈信息
          ② 输入数据校验: /^\d{6}$/，还可以在使用正则校验前，先判断一下字符串的长度，如果不满足长度要求，那就不需要再用正则去判断了。用正则解决主要的问题，而不是所有问题，使用正则要克制。
        · 环视(Look Around): 环视就是要求匹配部分的前面或后面要满足(或不满足)某种规则，有以下四种：
          ① 向前断言 x(?=y): 右边必须是y，x被y跟随时匹配
            例: /t(?=om)/.test("tom") // true
          ② 向前否定断言 x(?!y): 右边不是y，x没被y跟随时匹配
            例: /t(?!om)/.test("tom") // false
          ③ 向后断言 (?<=y)x: 左边是y，x跟随y时匹配
            例: /(?<=a)s/.test("as") // true
          ④ 向后否定断言 (?<!y)x: 左边不是y，x不跟随y时匹配
            例: /(?<!a)s/.test("as") // false
          注意：环视中虽然有括号，但不会保存成子组。保存成子组的一般是匹配到的文本内容，后续用于替换等操作，而环视是表示对文本左右环境的要求，即环视只匹配位置，不匹配文本内容。
    2.转义
      (1)转义字符
        在计算机科学和远程通信中，当转义字符放在字符序列中，它将对它后续的几个字符进行代替并解释。通常，判定某字符是否为转义字符由上下文确定。转义字符即标志着转义序列开始的那个字符。
        转义序列通常有两种功能：
          · 编码无法用字母表直接表示的特殊数据，用于表示无法直接键盘录入的字符(如回车符)
          · 转义字符自身和后面的字符看成一个整体，用于表示某种含义
            例: "tom is \"cat\"."
      (2)字符串转义和正则转义
        正则中也是使用反斜杠进行转义，一般来说，正则中 \d 代表的是单个数字，但如果我们想表示成 反斜杠和字母 d，这时候就需要进行转义，写成 \\d，这个就表示反斜杠后面紧跟着一个字母 d。
      (3)其他转义
        ① 元字符的转义: 直接在前面加上反斜杠即可
        ② 括号的转义: 在正则中方括号[]和花括号{}只需转义开括号，但圆括号()两个都需要转义，因为，在正则中，圆括号通常用于分组，或者将某个部分看成一个整体如果只转义开括号或闭括号，正则会认为少了另外一半，所以会报错。
        ③ 字符组中的转义，有三种情况：
          · 脱字符在中括号中，且在第一个位置需要转义: [\^ab]
          · 中划线在中括号中，且不在首尾位置: [a\-b]
          · 右中括号在中括号中，且不在首位: [a\]b]
        ④ 字符组中的其他元字符
          要想将元字符（.*+?() 之类）表示成它字面上本来的意思，是需要对其进行转义的，但如果它们出现在字符组中括号里，可以不转义。但如果在中括号中出现 \d 或 \w 等符号时，他们还是元字符本身的含义。

  四.应用
    1.正则处理 Unicode 编码文本
      (1)Unicode 基础知识
        Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字进行了整理、编码。Unicode 使计算机呈现和处理文字变得简单。
        Unicode 至今仍在不断增修，每个新版本都加入更多新的字符。目前 Unicode 最新的版本为 2020 年 3 月 10 日公布的 13.0.0，已经收录超过 14 万个字符。
        现在的 Unicode 字符分为 17 组编排，每组为一个平面（Plane），而每个平面拥有 65536（即 2 的 16 次方）个码值（Code Point）。然而，目前 Unicode 只用了少数平面，我们用到的绝大多数字符都属于第 0 号平面，即 BMP 平面。除了 BMP 平面之外，其它的平面都被称为补充平面。
          图片: public_knowledge\regular_expression\示例文件\image\Unicode平面介绍.png
        Unicode 相当于规定了字符对应的码值，这个码值可以编码成字节的形式去传输和存储。最常见的编码方式是 UTF-8，另外还有 UTF-16，UTF-32 等。UTF-8 之所以能够流行起来，是因为其编码比较巧妙，采用的是变长的方法。也就是一个 Unicode 字符，在使用 UTF-8 编码表示时占用 1 到 4 个字节不等。最重要的是 Unicode 兼容 ASCII 编码，在表示纯英文时，并不会占用更多存储空间。而汉字，在 UTF-8 中，通常是用三个字节来表示。
      (2)Unicode中的正则可能遇到的问题
        ① 点号匹配: 点号可以匹配除了换行符以外的任何字符，但在 Unicode 中，点号匹配上 Unicode 字符情况比较复杂，不同语言支持的也不太一样，具体的可以通过测试来得到答案。
        ② 字符组匹配: 也需要通过测试来验证支持情况。
      (3)Unicode 属性
        在正则中使用 Unicode，还可能会用到 Unicode 的一些属性。这些属性把 Unicode 字符集划分成不同的字符小集合。在正则中常用的有三种:
          · 按功能划分的 Unicode Categories（有的也叫 Unicode Property）: 比如标点符号，数字符号，JS目前支持这个，\p{P}标点符号，\p{N}数字字符
            例: /\p{P}/u.test("-+.")  /\p{N}/u.test("123")
          · 按连续区间划分的 Unicode Blocks: 比如只是中日韩字符，在不同的语言中记法有差异，比如 Java 需要加上 In 前缀，类似于 \p{InBopomofo} 表示注音字符。
          · 按书写系统划分的 Unicode Scripts: 比如汉语中文字符。
      (4)表情符号
        表情符号其实是"图片字符"，在 2020 年 3 月 10 日公布的 Unicode 标准 13.0.0 中，新增了 55 个新的 emoji 表情，完整的表情列表你可以在这里查看：http://www.unicode.org/emoji/charts/full-emoji-list.html
        这些表情符号有以下特点：
          · 许多表情不在 BMP 内，码值超过了 FFFF。使用 UTF-8 编码时，普通的 ASCII 是 1 个字节，中文是 3 个字节，而有一些表情需要 4 个字节来编码。
          · 这些表情分散在 BMP 和各个补充平面中，要想用一个正则来表示所有的表情符号非常麻烦，即便使用编程语言处理也同样很麻烦。
          · 一些表情现在支持使用颜色修饰（Fitzpatrick modifiers），可以在 5 种色调之间进行选择。这样一个表情其实就是 8 个字节了。
        注意: 在处理表情符号时，不建议使用正则来处理。可以使用专门的库，这样做一方面代码可读性更好，另一方面是表情在不断增加，使用正则的话不好维护，而使用专门的库可以通过升级版本来解决这个问题。
    2.文本处理
      在进行文本处理时，正则解决的问题大概分成四类:
        (1)校验文本内容
          通常在网页上输入的手机号、邮箱、日期等，都需要校验。校验的特点在于，整个文本的内容要符合正则。
            例: /\d{4}-\d{2}-\d{2}/.test("2020-12-01")
        (2)提取文本内容
          内容提取，就是从大段的文本中抽取出我们关心的内容。比较常见的例子是网页爬虫，或者说从页面上提取邮箱、抓取需要的内容等。在 JavaScript 中，想要提取文本中所有符合要求的内容，正则必须使用 g 模式，否则找到第一个结果后，正则就不会继续向后查找了。
            例: "2020-06 2020-07".match(/\d{4}-\d{2}/g)
        (3)替换文本内容
          文本内容替换，替换通常用于对原来的文本内容进行一些调整。在 JavaScript 中替换和查找类似，需要指定 g 模式，否则只会替换第一个。
            例: "02-20-2020 05-21-2020".replace(/(\d{2})-(\d{2})-(\d{4})/g, "$3年$1月$2日") // 2020年02月20日 2020年05月21日
        (4)切割文本内容
          文本内容切割，通常切割用于变长的空白符号，多变的标点符号等。在 JavaScript 中，正则的切割 split 当第二个参数是 2 的时候，表示切割成 2 个部分，而不是切2刀，且是全部切割后的前两个。
            例: "apple, pear! orange; tea".split(/\W+/)  "apple, pear! orange; tea".split(/\W+/, 2)
    3.正则的匹配原理以及优化原则
      (1)匹配原理
        ① 有穷状态自动机（finite automaton）
          概念
            有穷状态是指一个系统具有有穷个状态，不同的状态代表不同的意义。自动机是指系统可以根据相应的条件，在不同的状态下进行转移。从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）。正则之所以能够处理复杂文本，就是因为采用了有穷状态自动机。
            有穷自动机的具体实现称为正则引擎，主要有 DFA 和 NFA 两种，其中 NFA 又分为传统的 NFA 和 POSIX NFA。NFA 和 DFA 是可以相互转化的。
        ② 正则的匹配过程
          在编程语言中，正则表达式通常会先"编译"一下，来提升效率，这个编译过程，其实就是生成自动机的过程，正则引擎会拿着这个自动机去和字符串进行匹配。