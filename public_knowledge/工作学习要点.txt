工作学习要点
  一.工作
    1.技术变现
      (1)关注有价值的东西
        价值是受供需关系影响的，供大于求，就没什么价值，供不应求，就有价值。不仅要看到市场，还要看到技术的趋势，能够分辨出什么是主流技术，什么是过渡式的技术。
          · 市场需求: 要看清市场，就需要看看各个公司都在做什么，他们的难题是什么。
          · 技术趋势: 了解技术发展轨迹是一件很重要的事。要看一个新的技术是否顺应技术发展趋势，你需要将一些老技术的本质吃得很透。另外，还有一个简单的判断方法，如果一个新的技术顺应技术发展趋势，那么在这个新的技术出现时，后面一定会有大型的商业公司支持，这类公司支持得越多，就说明你越需要关注。
      (2)动手能力很重要
        因为在解决任何一个具体问题的时候，有没有动手能力就成为了关键。代码里全是细节，细节是魔鬼，只有了解了细节，才能提出更好或是更靠谱、可以落地的解决方案。而不是一些笼统和模糊的东西。这太重要了。
      (3)找到能体现价值的地方
        在一家高速发展的公司中，技术人员的价值可以达到最大化。
      (4)关注技术付费点
        技术付费点基本体现在两个地方，一个是，能帮别人"挣钱"的地方；另一个是，能帮别人"省钱"的地方。
      (4)找到有价值的信息源
        信息社会，如果你比别人有更好的信息源，那么你就可以比别人成长得更快。用google搜索，而用好这个更好的信息源需要你的英文能力，因此不断提升英文能力很关键。
    2.时间管理
      只有将使用时间的主动权掌握在自己手上，才能更好地利用时间，才能更为高效率的工作，这才是时间管理的关键点。
      (1)主动管理
        ① 告诉大家，我什么时间段在做什么事，请大家不要打扰我。
        ② 要求你的同事，重要的事，不要发微信，而是要发邮件，邮件可以通过邮件标题聚合，还可以设置很多规则来自动化分类邮件，还可以设置自动化回复。
        ③ 做好信息管理，将信息做好分类，才方便检索，方便通过优先级来处理信息
        ④ 开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。
      (2)学会说不
        ① 当面对做不到的需求时:   不要说这个需求做不到，而是在思考后给出另一个你可以做到的方案，而不是把对方的方案直接回绝掉。
        ② 当面对过于复杂的需求时: 我不说我不能完全满足你，但我说我可以部分满足你。
        ③ 当面对时间完全不够的需求时: 给回三个选择：a. 我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。b. 我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？c. 我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？我不能说不，但是我要有条件地说是。而且，我要把你给我的压力再反过来还给你，看似我给了需求方选择，实际上，我掌握了主动。
          学会在"积极主动的态度下对于不合理的事讨价还价"。只有学会了说"不"，才能够控制好的时间。
      (3)如何利用时间
        要学会规划行动计划，不是短期的，而是一个中长期的。建议是按季度来规划，这个季度做什么，达到什么目标，一年往前走四步，而不是只考虑眼下。
        ① 投资时间
          · 花时间学习基础知识，花时间读文档: 系统地学习一门技术是非常关键的，所以这个时间是值得投资的。
          · 花时间在解放自己生产力的事上: 在自动化、可配置、可重用、可扩展上要多花时间。
          · 花时间在让自己成长的事上: 能让自己有更强的竞争力，能让自己有更大的视野，能让自己有更多可能性的事情上。这样的时间投资才是有价值的。
          · 花时间在建立高效的环境上
        ② 规划时间
          · 定义好优先级: 要有自己的待办事项列表，要知道什么事是重要的，什么事是紧急的，什么事重要但不紧急，什么事又重要又紧急。这有利于你划分优先级。
          · 最短作业优先: 对于相同优先级的事，"最短作业优先"。
          · 想清楚再做
          · 关注长期利益规划
        ③ 用好时间
          · 专心做一件事
          · 形成习惯
          · 反思和举一反三
    3.团队协同工作
      本质
        · 不同的团队能够尽可能地并行开发。
        · 不同软件版本和代码的一致性。
        · 不同环境和代码的一致性。
        · 代码总是会在稳定和不稳定间交替。希望生产线上的代码总是能对应到稳定的代码上来。

  二.学习
    1.要点
      (1)在学习技术的过程一定要多问自己两个问题
        · 这个技术解决什么问题？为什么别的同类技术做不到？
        · 为什么是这样解决的？有没有更好的方式？
      (2)好书
        《算法导论》《设计模式》《代码整洁之道》《Effective C++》/《More Effective C++》《Unix 编程艺术》、《Unix 高级环境编程》
    2.技术领导力
      什么是
        · 尊重技术，追求核心基础技术。
        · 追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。
        · 解放生产力，追逐人效的提高。
        · 开发抽象和高质量的可以重用的技术组件。
        · 坚持高于社会主流的技术标准和要求
      是什么
        · 发现问题: 能够发现现有方案的问题。
        · 能够提供解决问题的思路和方案，并能比较这些方案的优缺点: 能够做出正确的技术决定。用什么样的技术、什么解决方案、怎样实现来完成一个项目。
        · 能够用更优雅，更简单，更容易的方式来解决问题。
        · 能够提高代码或软件的扩展性、重用性和可维护性。
        · 能够用正确的方式管理团队: 
          ① 让正确的人做正确的事，并发挥每个人的潜力
          ② 可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。
        · 创新能力: 能够使用新的方法新的方式解决问题，追逐新的工具和技术。
      如何有
        ① 扎实的基础技术
          基础技术是各种上层技术共同的基础。吃透基础技术是为了更好地理解程序的运行原理，并基于这些基础技术做出更优化的产品。
          基础技术，可以分成两种:
            编程部分:
              · C语言: C 语言更接近底层。在具备跨平台能力的前提下，它可以比较容易地被人工翻译成相应的汇编代码。它的内存管理更为直接，可以让我们直接和内存地址打交道。
                好处: 能掌握程序的运行情况，并能进行应用程序和操作系统编程（操作系统一般是汇编和 C 语言）
              · 编程范式: 各种编程语言都有它们各自的编程范式，用于解决各种问题。
                好处: 学好编程范式，有助于培养抽象思维，同时也可以提高编程效率，提高程序的结构合理性、可读性和可维护性，降低代码的冗余度，进而提高代码的运行效率。还可以多了解各种程序设计语言的功能特性。
              · 算法和数据结构: 算法（及其相应的数据结构）是程序设计的有力支撑。适当地应用算法，可以有效地抽象问题，提高程序的合理性和执行效率。算法是编程中最最重要的东西，也是计算机科学中最重要的基础。学习算法不仅是为了写出运转更为高效的代码，而且更是为了能够写出可以覆盖更多场景的正确代码。
            系统部分:
              · 计算机系统原理: CPU 的体系结构（指令集 [CISC/RISC]、分支预测、缓存结构、总线、DMA、中断、陷阱、多任务、虚拟内存、虚拟化等），内存的原理与性能特点（SRAM、DRAM、DDR-SDRAM 等），磁盘的原理（机械硬盘 [盘面、磁头臂、磁头、启停区、寻道等]、固态硬盘 [页映射、块的合并与回收算法、TRIM 指令等]），GPU 的原理等。
                好处: 能够了解计算机的原理之外，还能举一反三地反推出高维度的分布式架构和高并发高可用的架构设计。
              · 操作系统原理和基础: 进程、进程管理、线程、线程调度、多核的缓存一致性、信号量、物理内存管理、虚拟内存管理、内存分配、文件系统、磁盘管理等。
                好处: 理解程序是怎样被管理的，操作系统对应用程序提供了怎样的支持，抽象出怎样的编程接口（比如 POSIX/Win32 API），性能特性如何（比如控制合理的上下文切换次数），怎样进行进程间通信（如管道、套接字、内存映射等），以便让不同的软件配合一起运行等。
                了解操作系统的原理，可以让你更能从本质理解各种语言或是技术的底层原理。一眼看透本质可以让你更容易地掌握和使用高阶技术。
              · 网络基础: 计算机网络是现代计算机不可或缺的一部分。需要了解基本的网络层次结构（ISO/OSI 模型、TCP/IP 协议栈），包括物理层、数据链路层（包含错误重发机制）、网络层（包含路由机制）、传输层（包含连接保持机制）、会话层、表示层、应用层（在 TCP/IP 协议栈里，这三层可以并为一层）。
                好处: 可以为高维分布式架构中的一些技术问题提供很多的技术方案。比如 TCP 的滑动窗口限流，完全可以用于分布式服务中的限流方案。
              · 数据库原理: 数据库管理系统是管理数据库的利器。通常操作系统提供文件系统来管理文件数据，而文件比较适合保存连续的信息，如一篇文章、一个图片等。但有时需要保存一个名字等较短的信息。如果单个文件只保存名字这样的几个字节的信息的话，就会浪费大量的磁盘空间，而且无法方便地查询（除非使用索引服务）。但数据库则更适合保存这种短的数据，而且可以方便地按字段进行查询。现代流行的数据库管理系统有两大类：SQL（基于 B+ 树，强一致性）和 NoSQL（较弱的一致性，较高的存取效率，基于哈希表或其他技术）。
                好处: 了解数据库访问性能调优的要点，以及保证并发情况下数据操作原子性的方法。
              · 分布式技术架构: 包括负载均衡、DNS 解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、Map/Reduce 操作、分布式 SQL 数据库一致性（以 Google Cloud Spanner 为代表）等知识点。
                好处: 数据库和应用程序服务器在应对互联网上数以亿计的访问量的时候，需要能进行横向扩展，这样才能提供足够高的性能。
        ② 提高学习能力。所谓学习能力，就是能够很快地学习新技术，又能在关键技术上深入的能力
          · 学习的信息源: 信息源很重要，有好的信息源就可以更快速地获取有价值的信息，并提升学习效率。常见的信息源有 Google 等搜索引擎，Stack Overflow、Quora 等社区，图书，API 文档，论文和博客等。
          · 与高手交流: 程序员可以通过技术社区以及参加技术会议与高手交流，也可以通过参加开源项目来和高手切磋。常闻"听君一席话，胜读十年书"便是如此。与高手交流对程序员的学习和成长很有益处，不仅有助于了解热门的技术方向及关键的技术点，更可以通过观察和学习高手的技术思维及解决问题的方式，提高自己的技术前瞻性和技术决策力。
          · 举一反三的思考: 比如，了解了操作系统的缓存和网页缓存以后，你要思考其相同点和不同点。了解了 C++ 语言的面向对象特性以后，思考 Java 面向对象的相同点和不同点。遇到故障的时候，举一反三，把同类问题一次性地处理掉。
          · 开放的心态: 实现一个目的通常有多种办法。带有开放的心态，不拘泥于一个平台、一种语言，往往能带来更多思考，也能得到更好的结果。而且，能在不同的方法和方案间做比较，比较它们的优缺点，也会知道在什么样的场景下用什么样的方案，就会比一般人能够有更全面和更完整的思路。
        ③ 坚持做正确的事
          · 提高效率的事: 要学习和掌握良好的时间管理方式，管理好自己的时间，能显著提高效率。
          · 自动化的事:   程序员要充分利用自己的职业特质，当看见有可以自动化的步骤时，编写程序来自动化操作，可以显著提高效率。
          · 掌握前沿技术的事
          · 知识密集型的事
          · 技术驱动的事: 不仅是指用程序驱动的事，而且还包括一切技术改变生活的事。
        ④ 不断提高对自己的要求标准
          · 敏锐的技术嗅觉: 这是一个相对综合的能力，需要充分利用信息源，GET 到新的技术动态，并通过参与技术社区的讨论，丰富自己了解技术的角度。思考一下是否是自己感兴趣的，能解决哪些实际问题，以及其背后的原因。
          · 强调实践，学以致用
          · Lead by Example: 永远在编程。不写代码，就对技术细节不敏感，无法做出可以实践的技术决策和方案。

  三.技术
    1.编程语言
      (1)Go
        优点: 
          · 语言简单，上手快。
          · 并行和异步编程几乎无痛点。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。
          · 常用库齐全: Go 语言的 lib 库中基本上有绝大多数常用的库。
          · C 语言的理念和 Python 的姿态: C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且对底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。而 Go 语言是想要把 C 和 Python 统一起来。
    2.技术要素
      重要:
        · 有没有一个比较好的社区。
        · 有没有一个工业化的标准。
        · 有没有一个或多个杀手级应用。 
      次要
        · 学习难度是否低，上手是否快。
        · 有没有一个不错的提高开发效率的开发框架。
        · 是否有一个或多个巨型的技术公司作为后盾。
        · 有没有解决软件开发中的痛点。
      (1)有价值的技术
        一项有价值的技术，并不在于这项技术是否有技术含量，而是在于:
          · 能否低成本高效率地解决实际问题: 低成本高效率地解决实际问题的技术，一定是自动化的技术。软件天生就是用来完成重复劳动的，天生就是用来做自动化的。而未来的 AI 和 IoT 也是在拼命数字化和自动化还没有自动化的领域
          · 是不是众多产品的基础技术: 基础技术总是枯燥和有价值的。数学、算法、网络、存储等基础技术吃得越透，就越容易服务上层的各种衍生技术或产品。
          · 是不是可以支持规模化的技术: 支持规模化的技术也是很有价值的。在软件行业中，也就是 PaaS 的相关技术。
    3.异常捕捉处理
      try-catch-finally 的异常处理方式有以下好处:
        · 函数接口在 input（参数）和 output（返回值）以及错误处理的语义是比较清楚的。
        · 正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。
        · 异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）。
        · 在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。
        · 与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。比如：int x = add(a, div(b,c)); 或 Pizza p = PizzaBuilder().SetSize(sz) .SetPrice(p)...
      影响
        · 异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着 return 了。而程序在执行时需要处理函数栈的上下文，这会导致性能变得很慢，尤其是函数栈比较深的时候。
        · 但从另一方面来说，异常的抛出基本上表明程序的错误。程序在绝大多数情况下，应该是在没有异常的情况下运行的，所以，有异常的情况应该是少数的情况，不会影响正常处理的性能问题。
      异步编程错误处理问题
        · 无法使用返回码。因为函数在"被"异步运行中，所谓的返回只是把处理权交给下一条指令，而不是把函数运行完的结果返回。所以，函数返回的语义完全变了，返回码也没有用了。
        · 无法使用抛异常的方式。因为除了上述的函数立马返回的原因之外，抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的，所以主线程的 catch 完全看不到另外一个线程中的异常。
        解决方式: 使用 Promise 模式来处理。
      错误处理的实践
        · 统一分类的错误字典: 无论是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。      
        · 同类错误的定义最好是可以扩展的: 这一点非常重要，而对于这一点，通过面向对象的继承或是像 Go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。
        · 定义错误的严重程度: 比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足，Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息，Debug 表示这是给内部开发人员用于调试程序的。
        · 错误日志的输出最好使用错误码，而不是错误信息: 打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。
        · 忽略错误最好有日志。
        · 于同一个地方不停的报错，最好不要都打到日志里: 不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。
        · 不要用错误处理逻辑来处理业务逻辑。
        · 对于同类的错误处理，用一样的模式
        · 尽可能在错误发生的地方处理错误: 因为这样会让调用者变得更简单。
        · 向上尽可能地返回原始的错误。
        · 处理错误时，总是要清理已分配的资源。
        · 不推荐在循环体里处理错误。
        · 不要把大量的代码都放在一个 try 语句块内。
        · 为你的错误定义提供清楚的文档以及每种错误的代码示例。
        · 对于异步的方式，推荐使用 Promise 模式处理错误。
        · 对于分布式的系统，推荐使用 APM 相关的软件。
    4.故障处理
      (1)故障发生时
        需要做什么
          最重要的是快速恢复故障。而快速恢复故障的前提是快速定位故障源。因为在很多分布式系统中，一旦发生故障就会出现"多米诺骨牌效应"。也就是说，系统会随着一个故障开始一点一点地波及到其它系统，而且这个过程可能会很快。一旦很多系统都在报警，要想快速定位到故障源就不是一件简单的事了。
        通常会有以下几种手段来恢复系统
          · 重启和限流: 重启和限流主要解决的是可用性的问题，不是功能性的问题。重启还好说，但是限流这个事就需要相关的流控中间件了。
          · 回滚操作:   回滚操作一般来说是解决新代码的 bug，把代码回滚到之前的版本是快速的方式。
          · 降级操作:   并不是所有的代码变更都是能够回滚的，如果无法回滚，就需要降级功能了。也就是说，需要挂一个停止服务的故障公告，主要是不要把事态扩大。
          · 紧急更新: 紧急更新是常用的手段，这个需要强大的自动化系统，尤其是自动化测试和自动化发布系统。假如你要紧急更新 1000 多台服务器，没有一个强大的自动化发布系统是很难做到的。
        最重要的不是 debug 故障，而是尽可能地减少故障的影响范围，并尽可能快地修复问题。
      (2)故障前的准备工作
        为了能够在面临故障时做得有条不紊，需要做一些前期的准备工作:
          · 以用户功能为索引的服务和资源的全视图: 首先，需要一个系统来记录前端用户操作界面和后端服务，以及服务使用到的硬件资源之间的关联关系。这个系统有点像 CMDB（配置管理数据库），但是比 CMDB 要大得多，是以用户端的功能来做索引的。然后，把后端的服务、服务的调用关系，以及服务使用到的资源都关联起来做成一个视图。
          · 为地图中的各个服务制定关键指标，以及一套运维流程和工具，包括应急方案: 以用户功能为索引，为每个用户功能的服务都制定一个服务故障的检测、处理和恢复手册，以及相关的检测、查错或是恢复的运维工具。对于基础层和一些通用的中间件，也需要有相应的最佳实践的方法。
          · 设定故障的等级: 制定故障等级，主要是为了确定该故障要牵扯进多大规模的人员来处理。故障级别越高，牵扯进来的人就越多，参与进来的管理层级别也就越高。
          · 灰度发布系统
      (3)故障复盘过程
        对于故障，复盘是一件非常重要的事情，因为我们的成长基本上就是从故障中总结各种经验教训，从而可以获得最大的提升。
        故障复盘过程基本上是以下几方面:
          · 故障处理的整个过程: 就像一个 log 一样，需要详细地记录几点几分干了什么事，把故障从发生到解决的所有细节过程都记录下来。
          · 故障原因分析: 需要说明故障的原因和分析报告
          · Ask 5 Whys: 需要反思并反问至少 5 个为什么，并为这些"为什么"找到答案
          · 故障后续整改计划: 需要针对上述的"Ask 5 Whys"说明后续如何举一反三地从根本上解决所有的问题
      (4)故障整改
        故障整改原则:
          · 举一反三解决当下的故障。为自己赢得更多的时间。
          · 简化复杂、不合理的技术架构、流程和组织。不可能在一个复杂的环境下根本地解决问题。
          · 全面改善和优化整个系统，包括组织。解决问题的根本方法是改善和调整整体结构。而只有简单优雅的东西才有被改善和优化的可能。
    5.分布式系统架构
      (1)优缺点
        优点:
          · 系统容量大: 业务量越来越大，而要能应对越来越大的业务量，一台机器的性能已经无法满足了，需要多台机器才能应对大规模的应用场景。所以，需要垂直或是水平拆分业务系统，让其变成一个分布式的架构。
          · 系统可用性强: 业务越来越关键，需要提高整个系统架构的可用性，这就意味着架构中不能存在单点故障。这样，整个系统不会因为一台机器出故障而导致整体不可用。所以，需要通过分布式架构来冗余系统以消除单点故障，从而提高系统的可用性。
          · 因为模块化，所以系统模块重用度更高
          · 因为软件服务模块被拆分，开发和发布速度可以并行而变得更快
          · 系统扩展性更高
          · 团队协作流程也会得到改善
        缺点:
          · 架构设计变得复杂（尤其是其中的分布式事务）。
          · 部署单个服务会比较快，但是如果一次部署需要多个服务，流程会变得复杂。
          · 系统的吞吐量会变大，但是响应时间会变长。
          · 运维复杂度会因为服务变多而变得很复杂。
          · 架构复杂导致学习曲线变大。
          · 测试和查错的复杂度增大。
          · 技术多元化，这会带来维护和运维的复杂度。
          · 管理分布式系统中的服务和调度变得困难和复杂。
          · 一个线上故障的工单会在不同的服务和不同的团队中转过来转过去。
          · 每个团队都可能成为一个潜在的 DDoS 攻击者，除非每个服务都要做好配额和限流。
          · 监控和查错变得更为复杂。除非有非常强大的监控手段。
          · 服务发现和服务治理也变得非常复杂。
        难点: 
          分布式系统架构的难点在于系统设计，以及管理和运维。所以，分布式架构解决了"单点"和"性能容量"的问题，但却新增了一堆问题。而对于这些新增的问题，还会衍生出更多的子问题，这就需要不断地用各式各样的技术和手段来解决这些问题。
      (2)运维管理解决方案:
        · 分布式服务的架构需要分布式的团队架构: 一个服务由一个小团队负责，从前端到数据，从需求分析到上线运维。这是良性的分工策略——按职责分工，而不是按技能分工。
        · 分布式服务查错不容易: 一旦出现比较严重的故障，需要整体查错。出现一个 S2 的故障，就可以看到每个团队的人都会上线。在工单系统里能看到，在故障发生的一开始，大家都在签到并自查自己的系统。如果没问题，也要在线待命（standby），等问题解决。
        · 没有专职的测试人员，也没有专职的运维人员，开发人员做所有的事情: 自己写的代码自己维护自己养，会让开发人员明白，写代码容易维护代码复杂。这样，开发人员在接需求、做设计、写代码、做工具时都会考虑到软件的长期维护性。
        · 运维优先，崇尚简化和自动化
        · 内部服务和外部服务一致: 无论是从安全方面，还是接口设计方面，无论是从运维方面，还是故障处理的流程方面，内部系统都和外部系统一样对待。这样做的好处是，内部系统的服务随时都可以开放出来。而且，从第一天开始，服务提供方就有对外服务的能力。
      (3)需要注意的问题:
        ① 异构系统的不标准问题
          · 软件和应用不标准。
          · 通讯协议不标准。
          · 数据格式不标准。
          · 开发和运维的过程和方法不标准。
        ②
        ③
        ④